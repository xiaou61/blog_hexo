<!DOCTYPE html><html class="hide-aside" lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>JVM系列-第10章-垃圾回收概述和相关算法 | 小u的博客</title><meta name="keywords" content="JVM，虚拟机。"><meta name="author" content="小u"><meta name="copyright" content="小u"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JVM系列-第10章-垃圾回收概述和相关算法"><meta name="application-name" content="JVM系列-第10章-垃圾回收概述和相关算法"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="JVM系列-第10章-垃圾回收概述和相关算法"><meta property="og:url" content="http://example.com/2023/10/01/codenotes/Java/jvm/10/index.html"><meta property="og:site_name" content="小u的博客"><meta property="og:description" content="JVM系列-第10章-垃圾回收概述和相关算法。"><meta property="og:locale" content="en"><meta property="og:image" content="https://npm.elemecdn.com/lql_static@latest/logo/jvm.png"><meta property="article:author" content="小u"><meta property="article:tag" content="Java,java,springboot,mysql,redis,教程,git,软件,编程,开发,互联网,Java 基础,Java 教程,Java程序员进阶之路,Java 入门,Vue,前端,算法"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://npm.elemecdn.com/lql_static@latest/logo/jvm.png"><meta name="description" content="JVM系列-第10章-垃圾回收概述和相关算法。"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2023/10/01/codenotes/Java/jvm/10/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//hm.baidu.com"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1433b93d16cca6b366bdf23126c0c200";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"tianli","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"784b999ee9b2f0689c5a","Referer":"https://mydocs-1305448902.cos-website.ap-nanjing.myqcloud.com/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: 小u","link":"Link: ","source":"Source: 小u的博客","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小u的博客',
  title: 'JVM系列-第10章-垃圾回收概述和相关算法',
  postAI: '',
  pageFillDescription: '垃圾回收概述, 大厂面试题, 蚂蚁金服, 百度, 天猫, 滴滴, 京东, 阿里, 字节跳动, 什么是垃圾？, 为什么需要GC？, 早期垃圾回收, Java 垃圾回收机制, 自动内存管理, 应该关心哪些区域的回收？, 垃圾回收相关算法, 标记阶段：引用计数算法, 标记阶段的目的, 引用计数算法, 循环引用, 证明：java使用的不是引用计数算法, 小结, 标记阶段：可达性分析算法, 可达性分析实现思路, GC Roots可以是哪些元素？, 注意, 对象的 finalization 机制, finalize() 方法机制, 生存还是死亡？, 具体过程, 代码演示 finalize() 方法可复活对象, MAT与JProfiler的GC Roots溯源, MAT 介绍, 获取 dump 文件方式, 捕捉 dump 示例, 使用JVisualVM捕捉 heap dump, 使用 MAT 查看堆内存快照, JProfiler GC Roots 溯源, JProfiler 分析 OOM, 清除阶段：标记-清除算法, 清除阶段：复制算法, 清除阶段：标记-压缩算法, 垃圾回收算法小结, 分代收集算法, 增量收集算法和分区算法, 增量收集算法, 分区算法, 写在最后垃圾回收概述和语言的区别就在于垃圾收集技术和内存动态分配上语言没有垃圾收集技术需要程序员手动的收集垃圾收集不是语言的伴生产物早在年第一门开始使用内存动态分配和垃圾收集技术的语言诞生关于垃圾收集有三个经典问题哪些内存需要回收什么时候回收如何回收垃圾收集机制是的招牌能力极大地提高了开发效率如今垃圾收集几乎成为现代语言的标配即使经过如此长时间的发展的垃圾收集机制仍然在不断的演进中不同大小的设备不同特征的应用场景对垃圾收集提出了新的挑战这当然也是面试的热点大厂面试题蚂蚁金服你知道哪几种垃圾回收器各自的优缺点重点讲一下和算法有哪些目前的版本采用什么回收算法回收器讲下回收过程是什么为什么要有的两种判定方法收集器与收集器的特点百度说一下算法分代回收说下垃圾收集策略和算法天猫原理怎么回收内存特点垃圾回收算法有哪些各自的优缺点他们共同的缺点是什么滴滴的垃圾回收器都有哪些说下的应用场景平时你是如何搭配使用垃圾回收器的京东你知道哪几种垃圾收集器各自的优缺点重点讲下和包括原理流程优缺点垃圾回收算法的实现原理阿里讲一讲垃圾回收算法什么情况下触发垃圾回收如何选择合适的垃圾收集算法有哪三种垃圾回收器字节跳动常见的垃圾回收器算法有哪些各有什么优劣和会做什么事情机制有哪些对象的回收方式回收算法和了解么解决什么问题说一下回收的过程回收停顿了几次为什么要停顿两次什么是垃圾垃圾是指在运行程序中没有任何指针指向的对象这个对象就是需要被回收的垃圾外文如果不及时对内存中的垃圾进行清理那么这些垃圾对象所占的内存空间会一直保留到应用程序结束被保留的空间无法被其他对象使用甚至可能导致内存溢出十几年前磁盘碎片整理的日子为什么需要想要学习首先需要理解为什么需要对于高级语言来说一个基本认知是如果不进行垃圾回收内存迟早都会被消耗完因为不断地分配内存空间而不进行回收就好像不停地生产生活垃圾而从来不打扫一样除了释放没用的对象垃圾回收也可以清除内存里的记录碎片碎片整理将所占用的堆内存移到堆的一端以便将整理出的内存分配给新的对象随着应用程序所应付的业务越来越庞大复杂用户越来越多没有就不能保证应用程序的正常进行而经常造成的又跟不上实际的需求所以才会不断地尝试对进行优化早期垃圾回收在早期的时代垃圾回收基本上是手工进行的开发人员可以使用关键字进行内存申请并使用关键字进行内存释放比如以下代码如果注册失败使用释放该对象所占内存区域这种方式可以灵活控制内存释放的时间但是会给开发人员带来频繁申请和释放内存的管理负担倘若有一处内存区间由于程序员编码的问题忘记被回收那么就会产生内存泄漏垃圾对象永远无法被清除随着系统运行时间的不断增长垃圾对象所耗内存可能持续上升直到出现内存溢出并造成应用程序崩溃有了垃圾回收机制后上述代码极有可能变成这样现在除了以外等语言都使用了自动垃圾回收的思想也是未来发展趋势可以说这种自动化的内存分配和来及回收方式已经成为了现代开发语言必备的标准垃圾回收机制自动内存管理官网介绍自动内存管理的优点自动内存管理无需开发人员手动参与内存的分配与回收这样降低内存泄漏和内存溢出的风险没有垃圾回收器也会和一样各种悬垂指针野指针泄露问题让你头疼不已自动内存管理机制将程序员从繁重的内存管理中释放出来可以更专心地专注于业务开发关于自动内存管理的担忧对于开发人员而言自动内存管理就像是一个黑匣子如果过度依赖于自动那么这将会是一场灾难最严重的就会弱化开发人员在程序出现内存溢出时定位问题和解决问题的能力此时了解的自动内存分配和内存回收原理就显得非常重要只有在真正了解是如何管理内存后我们才能够在遇见时快速地根据错误异常日志定位问题和解决问题当需要排查各种内存溢出内存泄漏问题时当垃圾收集成为系统达到更高并发量的瓶颈时我们就必须对这些自动化的技术实施必要的监控和调节应该关心哪些区域的回收垃圾收集器可以对年轻代回收也可以对老年代回收甚至是全栈和方法区的回收其中堆是垃圾收集器的工作重点从次数上讲频繁收集区较少收集区基本不收集区元空间垃圾回收相关算法标记阶段引用计数算法标记阶段的目的垃圾标记阶段主要是为了判断对象是否存活在堆里存放着几乎所有的对象实例在执行垃圾回收之前首先需要区分出内存中哪些是存活对象哪些是已经死亡的对象只有被标记为己经死亡的对象才会在执行垃圾回收时释放掉其所占用的内存空间因此这个过程我们可以称为垃圾标记阶段那么在中究竟是如何标记一个死亡对象呢简单来说当一个对象已经不再被任何的存活对象继续引用时就可以宣判为已经死亡判断对象存活一般有两种方式引用计数算法和可达性分析算法引用计数算法引用计数算法比较简单对每个对象保存一个整型的引用计数器属性用于记录对象被引用的情况对于一个对象只要有任何一个对象引用了则的引用计数器就加当引用失效时引用计数器就减只要对象的引用计数器的值为即表示对象不可能再被使用可进行回收优点实现简单垃圾对象便于辨识判定效率高回收没有延迟性缺点它需要单独的字段存储计数器这样的做法增加了存储空间的开销每次赋值都需要更新计数器伴随着加法和减法操作这增加了时间开销引用计数器有一个严重的问题即无法处理循环引用的情况这是一条致命缺陷导致在的垃圾回收器中没有使用这类算法循环引用当的指针断开的时候内部的引用形成一个循环计数器都还算无法被回收这就是循环引用从而造成内存泄漏证明使用的不是引用计数算法证明使用的不是引用计数算法这个成员属性唯一的作用就是占用一点内存显式的执行垃圾回收行为这里发生和能否被回收如果不小心直接把和置为则在堆中的两块内存依然保持着互相引用无法被回收没有进行时把下面的几行代码注释掉让它来不及把这行代码注释掉进行打开那行代码的注释从打印日志就可以明显看出来已经进行了如果使用引用计数算法那么这两个对象将会无法回收而现在两个对象被回收了说明使用的不是引用计数算法来进行标记的小结引用计数算法是很多语言的资源回收选择例如因人工智能而更加火热的它更是同时支持引用计数和垃圾收集机制具体哪种最优是要看场景的业界有大规模实践中仅保留引用计数机制以提高吞吐量的尝试并没有选择引用计数是因为其存在一个基本的难题也就是很难处理循环引用关系如何解决循环引用手动解除很好理解就是在合适的时机解除引用关系使用弱引用是提供的标准库旨在解决循环引用标记阶段可达性分析算法可达性分析算法也可以称为根搜索算法追踪性垃圾收集相对于引用计数算法而言可达性分析算法不仅同样具备实现简单和执行高效等特点更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题防止内存泄漏的发生相较于引用计数算法这里的可达性分析就是选择的这种类型的垃圾收集通常也叫作追踪性垃圾收集可达性分析实现思路所谓根集合就是一组必须活跃的引用其基本思路如下可达性分析算法是以根对象集合为起始点按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达使用可达性分析算法后内存中的存活对象都会被根对象集合直接或间接连接着搜索所走过的路径称为引用链如果目标对象没有任何引用链相连则是不可达的就意味着该对象己经死亡可以标记为垃圾对象在可达性分析算法中只有能够被根对象集合直接或者间接连接的对象才是存活对象可以是哪些元素虚拟机栈中引用的对象比如各个线程被调用的方法中使用到的参数局部变量等本地方法栈内通常说的本地方法引用的对象方法区中类静态属性引用的对象比如类的引用类型静态变量方法区中常量引用的对象比如字符串常量池里的引用所有被同步锁持有的对象虚拟机内部的引用基本数据类型对应的对象一些常驻的异常对象如系统类加载器反映虚拟机内部情况的中注册的回调本地代码缓存等总结一句话就是除了堆空间的周边比如虚拟机栈本地方法栈方法区字符串常量池等地方对堆空间进行引用的都可以作为进行可达性分析除了这些固定的集合以外根据用户所选用的垃圾收集器以及当前回收的内存区域不同还可以有其他对象临时性地加入共同构成完整集合比如分代收集和局部回收如果只针对堆中的某一块区域进行垃圾回收比如典型的只针对新生代必须考虑到内存区域是虚拟机自己的实现细节更不是孤立封闭的这个区域的对象完全有可能被其他区域的对象所引用这时候就需要一并将关联的区域对象也加入集合中去考虑才能保证可达性分析的准确性小技巧由于采用栈方式存放变量和指针所以如果一个指针它保存了堆内存里面的对象但是自己又不存放在堆内存里面那它就是一个注意如果要使用可达性分析算法来判断内存是否可回收那么分析工作必须在一个能保障一致性的快照中进行这点不满足的话分析结果的准确性就无法保证这点也是导致进行时必须的一个重要原因即使是号称几乎不会发生停顿的收集器中枚举根节点时也是必须要停顿的对象的机制方法机制对象销毁前的回调函数语言提供了对象终止机制来允许开发人员提供对象被销毁之前的自定义处理逻辑当垃圾回收器发现没有引用指向一个对象即垃圾回收此对象之前总会先调用这个对象的方法方法允许在子类中被重写用于在对象被回收时进行资源释放通常在这个方法中进行一些资源释放和清理的工作比如关闭文件套接字和数据库连接等类中源码等待被重写永远不要主动调用某个对象的方法应该交给垃圾回收机制调用理由包括下面三点在时可能会导致对象复活方法的执行时间是没有保障的它完全由线程决定极端情况下若不发生则方法将没有执行机会一个糟糕的会严重影响的性能比如是个死循环从功能上来说方法与中的析构函数比较相似但是采用的是基于垃圾回收器的自动内存管理机制所以方法在本质上不同于中的析构函数方法对应了一个线程因为优先级比较低即使主动调用该方法也不会因此就直接进行回收生存还是死亡由于方法的存在虚拟机中的对象一般处于三种可能的状态如果从所有的根节点都无法访问到某个对象说明对象己经不再使用了一般来说此对象需要被回收但事实上也并非是非死不可的这时候它们暂时处于缓刑阶段一个无法触及的对象有可能在某一个条件下复活自己如果这样那么对它立即进行回收就是不合理的为此定义虚拟机中的对象可能的三种状态如下可触及的从根节点开始可以到达这个对象可复活的对象的所有引用都被释放但是对象有可能在中复活不可触及的对象的被调用并且没有复活那么就会进入不可触及状态不可触及的对象不可能被复活因为只会被调用一次以上种状态中是由于方法的存在进行的区分只有在对象不可触及时才可以被回收具体过程判定一个对象是否可回收至少要经历两次标记过程如果对象到没有引用链则进行第一次标记进行筛选判断此对象是否有必要执行方法如果对象没有重写方法或者方法已经被虚拟机调用过则虚拟机视为没有必要执行被判定为不可触及的如果对象重写了方法且还未执行过那么会被插入到队列中由一个虚拟机自动创建的低优先级的线程触发其方法执行方法是对象逃脱死亡的最后机会稍后会对队列中的对象进行第二次标记如果在方法中与引用链上的任何一个对象建立了联系那么在第二次标记时会被移出即将回收集合之后对象会再次出现没有引用存在的情况在这个情况下方法不会被再次调用对象会直接变成不可触及的状态也就是说一个对象的方法只会被调用一次通过查看线程代码演示方法可复活对象我们重写类的方法在调用其方法时将指向当前类对象测试类中方法即对象的机制类变量属于此方法只能被调用一次调用当前类重写的方法当前待回收的对象在方法中与引用链上的一个对象建立了联系对象第一次成功拯救自己调用垃圾回收器第次因为线程优先级很低暂停秒以等待它第次下面这段代码与上面的完全相同但是这次自救却失败了因为线程优先级很低暂停秒以等待它如果注释掉方法此方法只能被调用一次调用当前类重写的方法当前待回收的对象在方法中与引用链上的一个对象建立了联系输出结果第次第次放开方法输出结果第次调用当前类重写的方法第次第一次自救成功但由于方法只会执行一次所以第二次自救失败与的溯源介绍是的简称它是一款功能强大的堆内存分析器用于查找内存泄漏以及查看内存消耗情况是基于开发的是一款免费的性能分析工具大家可以在下载并使用虽然很强大但是在内存分析方面还是更好用一些此小节主要是为了实时分析是哪些东西中间需要用到一个的文件获取文件方式方式一命令行使用方式二使用捕获的文件是一个临时文件关闭后自动删除若要保留需要将其另存为文件可通过以下方法捕获操作步骤下面演示捕捉示例使用捕捉代码和在第一次捕捉内存快照的时候为之后和置为对应的引用对象被回收在第二次捕捉内存快照的时候就不再是数据添加完毕请操作已置空请操作结束如何捕捉堆内存快照先执行第一步然后停下来去生成此步骤文件点击堆右键另存为即可输入命令继续执行程序我们接着捕获第二张堆内存快照使用查看堆内存快照打开选择打开刚刚的两个文件我们先打开第一个文件点击也行选择第一次捕捉堆内存快照时中包含我们定义的两个局部变量类型分别为和打开第二个文件第二次捕获内存快照时由于两个局部变量引用的对象被释放所以这两个局部变量不再作为从也可以看出少了两个溯源在实际开发中我们很少会查看所有的一般都是查看某一个或几个对象的是哪个这个过程叫溯源下面我们使用使用进行溯源演示依然用下面这个代码数据添加完毕请操作已置空请操作结束可以发现颜色变绿了可以动态的看变化右击对象选择单独的查看某个对象选择表示追寻的源头点击在弹出界面中选择默认设置即可分析这里是简单的讲一下后面篇章会详解这个参数的意思是当程序出现的时候就会在当前工程目录生成一个文件程序输出日志打开这个文件看这个超大对象揪出线程中出问题的代码清除阶段标记清除算法垃圾清除阶段当成功区分出内存中存活对象和死亡对象后接下来的任务就是执行垃圾回收释放掉无用对象所占用的内存空间以便有足够的可用内存空间为新对象分配内存目前在中比较常见的三种垃圾收集算法是标记清除算法复制算法标记压缩算法背景标记清除算法是一种非常基础和常见的垃圾收集算法该算法被等人在年提出并并应用于语言执行过程当堆中的有效内存空间被耗尽的时候就会停止整个程序也被称为然后进行两项工作第一项则是标记第二项则是清除标记从引用根节点开始遍历标记所有被引用的对象一般是在对象的中记录为可达对象注意标记的是被引用的对象也就是可达对象并非标记的是即将被清除的垃圾对象清除对堆内存从头到尾进行线性的遍历如果发现某个对象在其中没有标记为可达对象则将其回收标记清除算法的缺点标记清除算法的效率不算高在进行的时候需要停止整个应用程序用户体验较差这种方式清理出来的空闲内存是不连续的产生内碎片需要维护一个空闲列表注意何为清除这里所谓的清除并不是真的置空而是把需要清除的对象地址保存在空闲的地址列表里下次有新对象需要加载时判断垃圾的位置空间是否够如果够就存放也就是覆盖原有的地址关于空闲列表是在为对象分配内存的时候提过如果内存规整采用指针碰撞的方式进行内存分配如果内存不规整虚拟机需要维护一个空闲列表采用空闲列表分配内存清除阶段复制算法背景为了解决标记清除算法在垃圾收集效率方面的缺陷于年发表了著名的论文使用双存储区的语言垃圾收集器在该论文中描述的算法被人们称为复制算法它也被本人成功地引入到了语言的一个实现版本中核心思想将活着的内存空间分为两块每次只使用其中一块在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中之后清除正在使用的内存块中的所有对象交换两个内存的角色最后完成垃圾回收新生代里面就用到了复制算法区和区存活对象整体复制到区复制算法的优缺点优点没有标记和清除过程实现简单运行高效复制过去以后保证空间的连续性不会出现碎片问题缺点此算法的缺点也是很明显的就是需要两倍的内存空间对于这种分拆成为大量的复制而不是移动意味着需要维护之间对象引用关系不管是内存占用或者时间开销也不小复制算法的应用场景如果系统中的垃圾对象很多复制算法需要复制的存活对象数量并不会太大效率较高老年代大量的对象存活那么复制的对象将会有很多效率会很低在新生代对常规应用的垃圾回收一次通常可以回收的内存空间回收性价比很高所以现在的商业虚拟机都是用这种收集算法回收新生代清除阶段标记压缩算法标记压缩或标记整理算法背景复制算法的高效性是建立在存活对象少垃圾对象多的前提下的这种情况在新生代经常发生但是在老年代更常见的情况是大部分对象都是存活对象如果依然使用复制算法由于存活对象较多复制的成本也将很高因此基于老年代垃圾回收的特性需要使用其他的算法标记清除算法的确可以应用在老年代中但是该算法不仅执行效率低下而且在执行完内存回收后还会产生内存碎片所以的设计者需要在此基础之上进行改进标记压缩算法由此诞生年前后和等研究者发布标记压缩算法在许多现代的垃圾收集器中人们都使用了标记压缩算法或其改进版本执行过程第一阶段和标记清除算法一样从根节点开始标记所有被引用对象第二阶段将所有的存活对象压缩到内存的一端按顺序排放之后清理边界外所有的空间标记压缩算法与标记清除算法的比较标记压缩算法的最终效果等同于标记清除算法执行完成后再进行一次内存碎片整理因此也可以把它称为标记清除压缩算法二者的本质差异在于标记清除算法是一种非移动式的回收算法标记压缩是移动式的是否移动回收后的存活对象是一项优缺点并存的风险决策可以看到标记的存活对象将会被整理按照内存地址依次排列而未被标记的内存会被清理掉如此一来当我们需要给新对象分配内存时只需要持有一个内存的起始地址即可这比维护一个空闲列表显然少了许多开销标记压缩算法的优缺点优点消除了标记清除算法当中内存区域分散的缺点我们需要给新对象分配内存时只需要持有一个内存的起始地址即可消除了复制算法当中内存减半的高额代价缺点从效率上来说标记整理算法要低于复制算法移动对象的同时如果对象被其他对象引用则还需要调整引用的地址因为虚拟机采用的不是句柄池的方式而是直接指针移动过程中需要全程暂停用户应用程序即垃圾回收算法小结对比三种清除阶段的算法效率上来说复制算法是当之无愧的老大但是却浪费了太多内存而为了尽量兼顾上面提到的三个指标标记整理算法相对来说更平滑一些但是效率上不尽如人意它比复制算法多了一个标记的阶段比标记清除多了一个整理内存的阶段标记清除标记整理复制速率中等最慢最快空间开销少但会堆积碎片少不堆积碎片通常需要活对象的倍空间不堆积碎片移动对象否是是分代收集算法难道就没有一种最优的算法吗无没有最好的算法只有最合适的算法为什么要使用分代收集算法前面所有这些算法中并没有一种算法可以完全替代其他算法它们都具有自己独特的优势和特点分代收集算法应运而生分代收集算法是基于这样一个事实不同的对象的生命周期是不一样的因此不同生命周期的对象可以采取不同的收集方式以便提高回收效率一般是把堆分为新生代和老年代这样就可以根据各个年代的特点使用不同的回收算法以提高垃圾回收的效率在程序运行的过程中会产生大量的对象其中有些对象是与业务信息相关比如请求中的对象线程连接这类对象跟业务直接挂钩因此生命周期比较长但是还有一些对象主要是程序运行过程中生成的临时变量这些对象生命周期会比较短比如对象由于其不变类的特性系统会产生大量的这些对象有些对象甚至只用一次即可回收目前几乎所有的都采用分代手机算法执行垃圾回收的在中基于分代的概念所使用的内存回收算法必须结合年轻代和老年代各自的特点年轻代年轻代特点区域相对老年代较小对象生命周期短存活率低回收频繁这种情况复制算法的回收整理速度是最快的复制算法的效率只和当前存活对象大小有关因此很适用于年轻代的回收而复制算法内存利用率不高的问题通过中的两个的设计得到缓解老年代老年代特点区域较大对象生命周期长存活率高回收不及年轻代频繁这种情况存在大量存活率高的对象复制算法明显变得不合适一般是由标记清除或者是标记清除与标记整理的混合实现阶段的开销与存活对象的数量成正比阶段的开销与所管理区域的大小成正相关阶段的开销与存活对象的数据成正比以中的回收器为例是基于实现的对于对象的回收效率很高对于碎片问题采用基于算法的回收器作为补偿措施当内存回收不佳碎片导致的时将采用执行以达到对老年代内存的整理分代的思想被现有的虚拟机广泛使用几乎所有的垃圾回收器都区分新生代和老年代增量收集算法和分区算法增量收集算法上述现有的算法在垃圾回收过程中应用软件将处于一种的状态在状态下应用程序所有的线程都会挂起暂停一切正常的工作等待垃圾回收的完成如果垃圾回收时间过长应用程序会被挂起很久将严重影响用户体验或者系统的稳定性为了解决这个问题即对实时垃圾收集算法的研究直接导致了增量收集算法的诞生增量收集算法基本思想如果一次性将所有的垃圾进行处理需要造成系统长时间的停顿那么就可以让垃圾收集线程和应用程序线程交替执行每次垃圾收集线程只收集一小片区域的内存空间接着切换到应用程序线程依次反复直到垃圾收集完成总的来说增量收集算法的基础仍是传统的标记清除和复制算法增量收集算法通过对线程间冲突的妥善处理允许垃圾收集线程以分阶段的方式完成标记清理或复制工作增量收集算法的缺点使用这种方式由于在垃圾回收过程中间断性地还执行了应用程序代码所以能减少系统的停顿时间但是因为线程切换和上下文转换的消耗会使得垃圾回收的总体成本上升造成系统吞吐量的下降分区算法主要针对收集器来说的一般来说在相同条件下堆空间越大一次时所需要的时间就越长有关产生的停顿也越长为了更好地控制产生的停顿时间将一块大的内存区域分割成多个小块根据目标的停顿时间每次合理地回收若干个小区间而不是整个堆空间从而减少一次所产生的停顿分代算法将按照对象的生命周期长短划分成两个部分分区算法将整个堆空间划分成连续的不同小区间每一个小区间都独立使用独立回收这种算法的好处是可以控制一次回收多少个小区间写在最后注意这些只是基本的算法思路实际实现过程要复杂的多目前还在发展中的前沿都是复合算法并且并行和并发兼备',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-02 18:28:49',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://mydocs.guoyaxue.top/" title="旧版博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="旧版博客"/><span class="back-menu-item-text">旧版博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://pan.xiaou61.top/#/" title="免费网盘"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="免费网盘"/><span class="back-menu-item-text">免费网盘</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://cloud.xiaou61.top/" title="云盘(自用)"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="云盘(自用)"/><span class="back-menu-item-text">云盘(自用)</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://wpzc.xiaou61.top/" title="云盘转存"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="云盘转存"/><span class="back-menu-item-text">云盘转存</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://love.xiaou61.top/#/" title="关于我们(My girlFriend)"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="关于我们(My girlFriend)"/><span class="back-menu-item-text">关于我们(My girlFriend)</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">娱乐项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://fxq.xiaou61.top/#/" title="飞行棋"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="飞行棋"/><span class="back-menu-item-text">飞行棋</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/game/sqnwmai803/" title="谁去拿外卖"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="谁去拿外卖"/><span class="back-menu-item-text">谁去拿外卖</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/desktop.html" title="win12网页版"><img class="back-menu-item-icon" src="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/icon/logo.svg" alt="win12网页版"/><span class="back-menu-item-text">win12网页版</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://game.xiaou61.top/" title="在线游戏"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="在线游戏"/><span class="back-menu-item-text">在线游戏</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">小u的博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 开往</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><span> 开往</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>3</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JVM/" style="font-size: 1.05rem;">JVM<sup>22</sup></a><a href="/tags/Nginx/" style="font-size: 1.05rem;">Nginx<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>1</sup></a><a href="/tags/Ts/" style="font-size: 1.05rem;">Ts<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size: 1.05rem;">TypeScript<sup>1</sup></a><a href="/tags/WebApi/" style="font-size: 1.05rem;">WebApi<sup>1</sup></a><a href="/tags/coder1v5/" style="font-size: 1.05rem;">coder1v5<sup>2</sup></a><a href="/tags/css/" style="font-size: 1.05rem;">css<sup>3</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>12</sup></a><a href="/tags/javaSE/" style="font-size: 1.05rem;">javaSE<sup>3</sup></a><a href="/tags/javaWeb/" style="font-size: 1.05rem;">javaWeb<sup>2</sup></a><a href="/tags/js%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">js逆向<sup>1</sup></a><a href="/tags/leetcode/" style="font-size: 1.05rem;">leetcode<sup>3</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>8</sup></a><a href="/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/" style="font-size: 1.05rem;">书籍推荐<sup>2</sup></a><a href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%90%AC%E8%BF%90/" style="font-size: 1.05rem;">公众号搬运<sup>35</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 1.05rem;">前端<sup>10</sup></a><a href="/tags/%E5%8A%9E%E5%85%AC/" style="font-size: 1.05rem;">办公<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 1.05rem;">后端<sup>8</sup></a><a href="/tags/%E5%A4%A9%E6%B6%AF%E8%AE%BA%E5%9D%9B/" style="font-size: 1.05rem;">天涯论坛<sup>1</sup></a><a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 1.05rem;">导航<sup>1</sup></a><a href="/tags/%E5%B0%B1%E4%B8%9A/" style="font-size: 1.05rem;">就业<sup>16</sup></a><a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 1.05rem;">微信<sup>1</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/" style="font-size: 1.05rem;">技术杂谈<sup>51</sup></a><a href="/tags/%E6%8E%98%E9%87%91/" style="font-size: 1.05rem;">掘金<sup>14</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 1.05rem;">杂项<sup>1</sup></a><a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 1.05rem;">测试<sup>1</sup></a><a href="/tags/%E6%B8%A1%E4%B8%80%E5%A4%A7%E5%B8%88%E8%AF%BE/" style="font-size: 1.05rem;">渡一大师课<sup>3</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 1.05rem;">爬虫<sup>1</sup></a><a href="/tags/%E7%9B%AE%E5%BD%95/" style="font-size: 1.05rem;">目录<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>4</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 1.05rem;">虚拟机<sup>12</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>6</sup></a><a href="/tags/%E8%B7%AF%E9%A3%9E%E5%AD%A6%E9%99%A2/" style="font-size: 1.05rem;">路飞学院<sup>3</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">面向对象<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>51</sup></a><a href="/tags/%E9%A3%9E%E8%A1%8C%E6%A3%8B/" style="font-size: 1.05rem;">飞行棋<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">234</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">September 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">May 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/" itemprop="url">JVM</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/1-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/" itemprop="url">1.内存与垃圾回收篇</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/JVM/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JVM</span></a><a class="article-meta__tags" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>虚拟机</span></a></span></div></div><h1 class="post-title" itemprop="name headline">JVM系列-第10章-垃圾回收概述和相关算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-09-30T23:34:06.018Z" title="Created 2023-10-01 07:34:06">2023-10-01</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-08-02T10:28:49.228Z" title="Updated 2023-08-02 18:28:49">2023-08-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为邯郸"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>邯郸</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://npm.elemecdn.com/lql_static@latest/logo/jvm.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2023/10/01/codenotes/Java/jvm/10/"><header><a class="post-meta-categories" href="/categories/JVM/" itemprop="url">JVM</a><a class="post-meta-categories" href="/categories/JVM/1-%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/" itemprop="url">1.内存与垃圾回收篇</a><a href="/tags/JVM/" tabindex="-1" itemprop="url">JVM</a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" tabindex="-1" itemprop="url">虚拟机</a><h1 id="CrawlerTitle" itemprop="name headline">JVM系列-第10章-垃圾回收概述和相关算法</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小u</span><time itemprop="dateCreated datePublished" datetime="2023-09-30T23:34:06.018Z" title="Created 2023-10-01 07:34:06">2023-10-01</time><time itemprop="dateCreated datePublished" datetime="2023-08-02T10:28:49.228Z" title="Updated 2023-08-02 18:28:49">2023-08-02</time></header><h1 id="垃圾回收概述"><a href="#垃圾回收概述" class="headerlink" title="垃圾回收概述"></a>垃圾回收概述</h1><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0001.png">

<ol>
<li><p>Java 和 C++语言的区别，就在于垃圾收集技术和内存动态分配上，C++语言没有垃圾收集技术，需要程序员手动的收集。</p>
</li>
<li><p>垃圾收集，不是Java语言的伴生产物。早在1960年，第一门开始使用内存动态分配和垃圾收集技术的Lisp语言诞生。</p>
</li>
<li><p>关于垃圾收集有三个经典问题：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
</li>
<li><p>垃圾收集机制是Java的招牌能力，极大地提高了开发效率。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p>
</li>
</ol>
<h2 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h2><h3 id="蚂蚁金服"><a href="#蚂蚁金服" class="headerlink" title="蚂蚁金服"></a>蚂蚁金服</h3><ol>
<li>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下CMS和G1？</li>
<li>JVM GC算法有哪些，目前的JDK版本采用什么回收算法？</li>
<li>G1回收器讲下回收过程GC是什么？为什么要有GC？</li>
<li>GC的两种判定方法？CMS收集器与G1收集器的特点</li>
</ol>
<h3 id="百度"><a href="#百度" class="headerlink" title="百度"></a>百度</h3><ol>
<li>说一下GC算法，分代回收说下</li>
<li>垃圾收集策略和算法</li>
</ol>
<h3 id="天猫"><a href="#天猫" class="headerlink" title="天猫"></a>天猫</h3><ol>
<li>JVM GC原理，JVM怎么回收内存</li>
<li>CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</li>
</ol>
<h3 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h3><ol>
<li>Java的垃圾回收器都有哪些，说下G1的应用场景，平时你是如何搭配使用垃圾回收器的</li>
</ol>
<h3 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h3><ol>
<li>你知道哪几种垃圾收集器，各自的优缺点，重点讲下CMS和G1，</li>
<li>包括原理，流程，优缺点。垃圾回收算法的实现原理</li>
</ol>
<h3 id="阿里"><a href="#阿里" class="headerlink" title="阿里"></a>阿里</h3><ol>
<li>讲一讲垃圾回收算法。</li>
<li>什么情况下触发垃圾回收？</li>
<li>如何选择合适的垃圾收集算法？</li>
<li>JVM有哪三种垃圾回收器？</li>
</ol>
<h3 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h3><ol>
<li>常见的垃圾回收器算法有哪些，各有什么优劣？</li>
<li>System.gc()和Runtime.gc()会做什么事情？</li>
<li>Java GC机制？GC Roots有哪些？</li>
<li>Java对象的回收方式，回收算法。</li>
<li>CMS和G1了解么，CMS解决什么问题，说一下回收的过程。</li>
<li>CMS回收停顿了几次，为什么要停顿两次?</li>
</ol>
<h2 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h2><ol>
<li>垃圾是指<strong>在运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾。</li>
<li>外文：An object is considered garbage when it can no longer be reached from any pointer in the running program.</li>
<li>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</li>
</ol>
<p><strong>十几年前磁盘碎片整理的日子</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0002.jpg">



<h2 id="为什么需要GC？"><a href="#为什么需要GC？" class="headerlink" title="为什么需要GC？"></a>为什么需要GC？</h2><p><strong>想要学习GC，首先需要理解为什么需要GC？</strong></p>
<ol>
<li><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p>
</li>
<li><p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，<strong>以便JVM将整理出的内存分配给新的对象</strong>。</p>
</li>
<li><p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行</strong>。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</p>
</li>
</ol>
<h2 id="早期垃圾回收"><a href="#早期垃圾回收" class="headerlink" title="早期垃圾回收"></a>早期垃圾回收</h2><ol>
<li>在早期的C&#x2F;C++时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码：</li>
</ol>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge= <span class="keyword">new</span> cmBaseGroupBridge（）；</span><br><span class="line"><span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span>（pBridge-&gt;Register（kDestroy）！=NO ERROR）</span><br><span class="line">	<span class="keyword">delete</span> pBridge；</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<strong>应用程序崩溃</strong>。</p>
</li>
<li><p>有了垃圾回收机制后，上述代码极有可能变成这样</p>
</li>
</ol>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge=<span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>(); </span><br><span class="line">pBridge-&gt;<span class="built_in">Register</span>(kDestroy);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>现在，除了Java以外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了现代开发语言必备的标准。</li>
</ol>
<h2 id="Java-垃圾回收机制"><a href="#Java-垃圾回收机制" class="headerlink" title="Java 垃圾回收机制"></a>Java 垃圾回收机制</h2><h3 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h3><blockquote>
<p><strong>官网介绍</strong>：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p>
</blockquote>
<p><strong>自动内存管理的优点</strong></p>
<ol>
<li><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险</p>
</li>
<li><p>没有垃圾回收器，java也会和cpp一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</p>
</li>
<li><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</p>
</li>
</ol>
<p><strong>关于自动内存管理的担忧</strong></p>
<ol>
<li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力</strong>。</li>
<li>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutofMemoryError时，快速地根据错误异常日志定位问题和解决问题。</li>
<li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<strong>实施必要的监控和调节</strong>。</li>
</ol>
<h3 id="应该关心哪些区域的回收？"><a href="#应该关心哪些区域的回收？" class="headerlink" title="应该关心哪些区域的回收？"></a>应该关心哪些区域的回收？</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0003.png">

<ol>
<li><p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收，</p>
</li>
<li><p>其中，<strong>Java堆是垃圾收集器的工作重点</strong></p>
</li>
<li><p>从次数上讲：</p>
<ol>
<li>频繁收集Young区</li>
<li>较少收集Old区</li>
<li>基本不收集Perm区（元空间）</li>
</ol>
</li>
</ol>
<h1 id="垃圾回收相关算法"><a href="#垃圾回收相关算法" class="headerlink" title="垃圾回收相关算法"></a>垃圾回收相关算法</h1><h2 id="标记阶段：引用计数算法"><a href="#标记阶段：引用计数算法" class="headerlink" title="标记阶段：引用计数算法"></a>标记阶段：引用计数算法</h2><h3 id="标记阶段的目的"><a href="#标记阶段的目的" class="headerlink" title="标记阶段的目的"></a>标记阶段的目的</h3><p><strong>垃圾标记阶段：主要是为了判断对象是否存活</strong></p>
<ol>
<li>在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先<strong>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。</strong>只有被标记为己经死亡的对象，GC才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程我们可以称为<strong>垃圾标记阶段</strong>。</li>
<li>那么在JVM中究竟是如何标记一个死亡对象呢？简单来说，当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</li>
<li>判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong>。</li>
</ol>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><ol>
<li>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。</li>
<li>对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。</li>
<li>优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</li>
<li>缺点：<ol>
<li>它需要单独的字段存储计数器，这样的做法增加了<strong>存储空间的开销</strong>。</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<strong>时间开销</strong>。</li>
<li>引用计数器有一个严重的问题，即<strong>无法处理循环引用</strong>的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。</li>
</ol>
</li>
</ol>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0004.png">

<p>当p的指针断开的时候，内部的引用形成一个循环，计数器都还算1，无法被回收，这就是循环引用，从而造成内存泄漏</p>
<h3 id="证明：java使用的不是引用计数算法"><a href="#证明：java使用的不是引用计数算法" class="headerlink" title="证明：java使用的不是引用计数算法"></a>证明：java使用的不是引用计数算法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * 证明：java使用的不是引用计数算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefCountGC</span> &#123;</span><br><span class="line">    <span class="comment">//这个成员属性唯一的作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//5MB</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line"></span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line"></span><br><span class="line">        obj1 = <span class="literal">null</span>;</span><br><span class="line">        obj2 = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//显式的执行垃圾回收行为</span></span><br><span class="line">        <span class="comment">//这里发生GC，obj1和obj2能否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0005.png">

<ul>
<li>如果不小心直接把<code>obj1.reference</code>和<code>obj2.reference</code>置为null。则在Java堆中的两块内存依然保持着互相引用，无法被回收</li>
</ul>
<p><strong>没有进行GC时</strong></p>
<p>把下面的几行代码注释掉，让它来不及</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.gc();<span class="comment">//把这行代码注释掉</span></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 38400K, used 14234K [0x00000000d5f80000, 0x00000000d8a00000, 0x0000000100000000)</span><br><span class="line">  eden space 33280K, 42% used [0x00000000d5f80000,0x00000000d6d66be8,0x00000000d8000000)</span><br><span class="line">  from space 5120K, 0% used [0x00000000d8500000,0x00000000d8500000,0x00000000d8a00000)</span><br><span class="line">  to   space 5120K, 0% used [0x00000000d8000000,0x00000000d8000000,0x00000000d8500000)</span><br><span class="line"> ParOldGen       total 87552K, used 0K [0x0000000081e00000, 0x0000000087380000, 0x00000000d5f80000)</span><br><span class="line">  object space 87552K, 0% used [0x0000000081e00000,0x0000000081e00000,0x0000000087380000)</span><br><span class="line"> Metaspace       used 3496K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 387K, capacity 390K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>



<p><strong>进行GC</strong></p>
<p>打开那行代码的注释</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 13569K-&gt;808K(38400K)] 13569K-&gt;816K(125952K), <span class="number">0.0012717</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(System.gc()</span>) [PSYoungGen: 808K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;670K(87552K)] 816K-&gt;670K(125952K), [Metaspace: 3491K-&gt;3491K(1056768K)], <span class="number">0.0051769</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 38400K, used 333K [<span class="number">0x00000000d5f80000</span>, <span class="number">0x00000000d8a00000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">  eden space 33280K, <span class="number">1</span>% used [<span class="number">0x00000000d5f80000</span>,<span class="number">0x00000000d5fd34a8</span>,<span class="number">0x00000000d8000000</span>)</span><br><span class="line">  from space 5120K, <span class="number">0</span>% used [<span class="number">0x00000000d8000000</span>,<span class="number">0x00000000d8000000</span>,<span class="number">0x00000000d8500000</span>)</span><br><span class="line">  to   space 5120K, <span class="number">0</span>% used [<span class="number">0x00000000d8500000</span>,<span class="number">0x00000000d8500000</span>,<span class="number">0x00000000d8a00000</span>)</span><br><span class="line"> ParOldGen       total 87552K, used 670K [<span class="number">0x0000000081e00000</span>, <span class="number">0x0000000087380000</span>, <span class="number">0x00000000d5f80000</span>)</span><br><span class="line">  object space 87552K, <span class="number">0</span>% used [<span class="number">0x0000000081e00000</span>,<span class="number">0x0000000081ea7990</span>,<span class="number">0x0000000087380000</span>)</span><br><span class="line"> Metaspace       used 3498K, capacity 4498K, committed 4864K, reserved 1056768K</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">space</span>    used 387K, capacity 390K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>



<p>1、从打印日志就可以明显看出来，已经进行了GC</p>
<p>2、如果使用引用计数算法，那么这两个对象将会无法回收。而现在两个对象被回收了，说明Java使用的不是引用计数算法来进行标记的。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。</li>
<li>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</li>
<li>Java并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理循环引用关系。</li>
<li>Python如何解决循环引用？<ul>
<li>手动解除：很好理解，就是在合适的时机，解除引用关系。</li>
<li>使用弱引用weakref，weakref是Python提供的标准库，旨在解决循环引用。</li>
</ul>
</li>
</ol>
<h2 id="标记阶段：可达性分析算法"><a href="#标记阶段：可达性分析算法" class="headerlink" title="标记阶段：可达性分析算法"></a>标记阶段：可达性分析算法</h2><p><strong>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</strong></p>
<ol>
<li>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<strong>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</strong>。</li>
<li>相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作<strong>追踪性垃圾收集</strong>（Tracing Garbage Collection）</li>
</ol>
<h3 id="可达性分析实现思路"><a href="#可达性分析实现思路" class="headerlink" title="可达性分析实现思路"></a>可达性分析实现思路</h3><ul>
<li><p>所谓”GCRoots”根集合就是一组必须活跃的引用</p>
</li>
<li><p>其基本思路如下：</p>
</li>
</ul>
<ol>
<li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式<strong>搜索被根对象集合所连接的目标对象是否可达。</strong></li>
<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong>（Reference Chain）</li>
<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li>
<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0006.png">



<h3 id="GC-Roots可以是哪些元素？"><a href="#GC-Roots可以是哪些元素？" class="headerlink" title="GC Roots可以是哪些元素？"></a>GC Roots可以是哪些元素？</h3><ol>
<li>虚拟机栈中引用的对象<ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
</li>
<li>本地方法栈内JNI（通常说的本地方法）引用的对象</li>
<li>方法区中类静态属性引用的对象<ul>
<li>比如：Java类的引用类型静态变量</li>
</ul>
</li>
<li>方法区中常量引用的对象<ul>
<li>比如：字符串常量池（StringTable）里的引用</li>
</ul>
</li>
<li>所有被同步锁synchronized持有的对象</li>
<li>Java虚拟机内部的引用。<ul>
<li>基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器。</li>
</ul>
</li>
<li>反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0007.png">



<ol>
<li>总结一句话就是，除了堆空间的周边，比如：虚拟机栈、本地方法栈、方法区、字符串常量池等地方对堆空间进行引用的，都可以作为GC Roots进行可达性分析</li>
<li>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：<strong>分代收集</strong>和局部回收（PartialGC）。<ul>
<li>如果只针对Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性。</li>
</ul>
</li>
</ol>
<p><strong>小技巧</strong></p>
<p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root。</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。</li>
<li>这点也是导致GC进行时必须“Stop The World”的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，<strong>枚举根节点时也是必须要停顿的</strong>。</li>
</ol>
<h2 id="对象的-finalization-机制"><a href="#对象的-finalization-机制" class="headerlink" title="对象的 finalization 机制"></a>对象的 finalization 机制</h2><h3 id="finalize-方法机制"><a href="#finalize-方法机制" class="headerlink" title="finalize() 方法机制"></a>finalize() 方法机制</h3><p><strong>对象销毁前的回调函数：finalize()</strong></p>
<ol>
<li><p>Java语言提供了对象终止（finalization）机制来允许开发人员提供<strong>对象被销毁之前的自定义处理逻辑</strong>。</p>
</li>
<li><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。</p>
</li>
<li><p>finalize() 方法允许在子类中被重写，<strong>用于在对象被回收时进行资源释放</strong>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</p>
</li>
</ol>
<p>Object 类中 finalize() 源码</p>
<pre><code>// 等待被重写
protected void finalize() throws Throwable &#123; &#125;
</code></pre>
<ol>
<li>永远不要主动调用某个对象的finalize()方法，应该交给垃圾回收机制调用。理由包括下面三点：<ol>
<li>在finalize()时可能会导致对象复活。</li>
<li>finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。</li>
<li>一个糟糕的finalize()会严重影响GC的性能。比如finalize是个死循环</li>
</ol>
</li>
<li>从功能上来说，finalize()方法与C++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在<strong>本质上不同于C++中的析构函数</strong>。</li>
<li>finalize()方法对应了一个finalize线程，因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li>
</ol>
<h3 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h3><p>由于finalize()方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态。</strong></p>
<ol>
<li>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<strong>一个无法触及的对象有可能在某一个条件下“复活”自己</strong>，如果这样，那么对它立即进行回收就是不合理的。为此，定义虚拟机中的对象可能的三种状态。如下：<ol>
<li>可触及的：从根节点开始，可以到达这个对象。</li>
<li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。</li>
<li>不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，<strong>因为finalize()只会被调用一次</strong>。</li>
</ol>
</li>
<li>以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</li>
</ol>
<h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><p>判定一个对象objA是否可回收，至少要经历两次标记过程：</p>
<ol>
<li>如果对象objA到GC Roots没有引用链，则进行第一次标记。</li>
<li>进行筛选，判断此对象是否有必要执行finalize()方法<ol>
<li>如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。</li>
<li>如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。</li>
<li>finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize()方法只会被调用一次。</li>
</ol>
</li>
</ol>
<p><strong>通过 JVisual VM 查看 Finalizer 线程</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0008.png">



<h3 id="代码演示-finalize-方法可复活对象"><a href="#代码演示-finalize-方法可复活对象" class="headerlink" title="代码演示 finalize() 方法可复活对象"></a>代码演示 finalize() 方法可复活对象</h3><p>我们重写 CanReliveObj 类的 finalize()方法，在调用其 finalize()方法时，将 obj 指向当前类对象 this</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试Object类中finalize()方法，即对象的finalization机制。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanReliveObj</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj obj;<span class="comment">//类变量，属于 GC Root</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法只能被调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);</span><br><span class="line">        obj = <span class="built_in">this</span>;<span class="comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            obj = <span class="keyword">new</span> <span class="title class_">CanReliveObj</span>();</span><br><span class="line">            <span class="comment">// 对象第一次成功拯救自己</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();<span class="comment">//调用垃圾回收器</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第1次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第2次 gc&quot;</span>);</span><br><span class="line">            <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">            obj = <span class="literal">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">            <span class="comment">// 因为Finalizer线程优先级很低，暂停2秒，以等待它</span></span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is dead&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;obj is still alive&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>如果注释掉finalize()方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此方法只能被调用一次</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">       <span class="built_in">super</span>.finalize();</span><br><span class="line">       System.out.println(<span class="string">&quot;调用当前类重写的finalize()方法&quot;</span>);</span><br><span class="line">       obj = <span class="built_in">this</span>;<span class="comment">//当前待回收的对象在finalize()方法中与引用链上的一个对象obj建立了联系</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">1</span>次 gc</span><br><span class="line">obj is dead</span><br><span class="line">第<span class="number">2</span>次 gc</span><br><span class="line">obj is dead</span><br></pre></td></tr></table></figure>





<p><strong>放开finalize()方法</strong></p>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第<span class="number">1</span>次 gc</span><br><span class="line">调用当前类重写的finalize()方法</span><br><span class="line">obj is still alive</span><br><span class="line">第<span class="number">2</span>次 gc</span><br><span class="line">obj is dead</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第一次自救成功，但由于 finalize() 方法只会执行一次，所以第二次自救失败</p>
<h2 id="MAT与JProfiler的GC-Roots溯源"><a href="#MAT与JProfiler的GC-Roots溯源" class="headerlink" title="MAT与JProfiler的GC Roots溯源"></a>MAT与JProfiler的GC Roots溯源</h2><h3 id="MAT-介绍"><a href="#MAT-介绍" class="headerlink" title="MAT 介绍"></a>MAT 介绍</h3><ol>
<li>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</li>
<li>MAT是基于Eclipse开发的，是一款免费的性能分析工具。</li>
<li>大家可以在<a target="_blank" rel="noopener" href="http://www.eclipse.org/mat/%E4%B8%8B%E8%BD%BD%E5%B9%B6%E4%BD%BF%E7%94%A8MAT">http://www.eclipse.org/mat/下载并使用MAT</a></li>
</ol>
<blockquote>
<p>1、虽然Jvisualvm很强大，但是在内存分析方面，还是MAT更好用一些</p>
<p>2、此小节主要是为了实时分析GC Roots是哪些东西，中间需要用到一个dump的文件</p>
</blockquote>
<h3 id="获取-dump-文件方式"><a href="#获取-dump-文件方式" class="headerlink" title="获取 dump 文件方式"></a>获取 dump 文件方式</h3><p><strong>方式一：命令行使用 jmap</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0009.png">



<p><strong>方式二：使用JVisualVM</strong></p>
<ol>
<li>捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。可通过以下方法捕获heap dump：</li>
<li>操作步骤下面演示</li>
</ol>
<h3 id="捕捉-dump-示例"><a href="#捕捉-dump-示例" class="headerlink" title="捕捉 dump 示例"></a>捕捉 dump 示例</h3><h4 id="使用JVisualVM捕捉-heap-dump"><a href="#使用JVisualVM捕捉-heap-dump" class="headerlink" title="使用JVisualVM捕捉 heap dump"></a>使用JVisualVM捕捉 heap dump</h4><p>代码：</p>
<ul>
<li>numList 和 birth 在第一次捕捉内存快照的时候，为 GC Roots</li>
<li>之后 numList 和 birth 置为 null ，对应的引用对象被回收，在第二次捕捉内存快照的时候，就不再是 GC Roots</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCRootsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            numList.add(String.valueOf(i));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;数据添加完毕，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line">        numList = <span class="literal">null</span>;</span><br><span class="line">        birth = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;numList、birth已置空，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>如何捕捉堆内存快照</strong></p>
<p>1、先执行第一步，然后停下来，去生成此步骤dump文件</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0010.png">

<p>2、 点击【堆 Dump】</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0011.png">

<p>3、右键 –&gt; 另存为即可</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0012.jpg">

<p>4、输入命令，继续执行程序</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0013.png">

<p>5、我们接着捕获第二张堆内存快照</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0014.jpg">



<h4 id="使用-MAT-查看堆内存快照"><a href="#使用-MAT-查看堆内存快照" class="headerlink" title="使用 MAT 查看堆内存快照"></a>使用 MAT 查看堆内存快照</h4><p>1、打开 MAT ，选择File –&gt; Open File，打开刚刚的两个dump文件，<strong>我们先打开第一个dump文件</strong></p>
<blockquote>
<p>点击Open Heap Dump也行</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0015.png">

<p>2、选择Java Basics –&gt; GC Roots</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0016.png">

<p>3、第一次捕捉堆内存快照时，GC Roots 中包含我们定义的两个局部变量，类型分别为 ArrayList 和 Date，Total:21</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0017.jpg">

<p>4、打开第二个dump文件，第二次捕获内存快照时，由于两个局部变量引用的对象被释放，所以这两个局部变量不再作为 GC Roots ，从 Total Entries &#x3D; 19 也可以看出（少了两个 GC Roots）</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0018.jpg">



<h3 id="JProfiler-GC-Roots-溯源"><a href="#JProfiler-GC-Roots-溯源" class="headerlink" title="JProfiler GC Roots 溯源"></a>JProfiler GC Roots 溯源</h3><p>1、在实际开发中，我们很少会查看所有的GC Roots。一般都是查看某一个或几个对象的GC Root是哪个，这个过程叫<strong>GC Roots 溯源</strong></p>
<p>2、下面我们使用使用 JProfiler 进行 GC Roots 溯源演示</p>
<p>依然用下面这个代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GCRootsTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">birth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            numList.add(String.valueOf(i));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;数据添加完毕，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line">        numList = <span class="literal">null</span>;</span><br><span class="line">        birth = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;numList、birth已置空，请操作：&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>1、</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0019.jpg">

<p>2、</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0020.png">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0021.jpg">

<p>可以发现颜色变绿了，可以动态的看变化</p>
<p>3、右击对象，选择 Show Selection In Heap Walker，单独的查看某个对象</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0022.png">



<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0023.png">



<p>4、选择Incoming References，表示追寻 GC Roots 的源头</p>
<p>点击Show Paths To GC Roots，在弹出界面中选择默认设置即可</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0024.jpg">

<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0025.png">



<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0026.png">

<h3 id="JProfiler-分析-OOM"><a href="#JProfiler-分析-OOM" class="headerlink" title="JProfiler 分析 OOM"></a>JProfiler 分析 OOM</h3><blockquote>
<p>这里是简单的讲一下，后面篇章会详解</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * -Xms8m -Xmx8m </span></span><br><span class="line"><span class="comment"> * -XX:+HeapDumpOnOutOfMemoryError  这个参数的意思是当程序出现OOM的时候就会在当前工程目录生成一个dump文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapOOM</span> &#123;</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//1MB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;HeapOOM&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">HeapOOM</span>());</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;count = &quot;</span> + count);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>程序输出日志</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">com.atguigu.java.HeapOOM</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid14608.hprof ...</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.atguigu.java.HeapOOM.&lt;init&gt;(HeapOOM.java:<span class="number">12</span>)</span><br><span class="line">	at com.atguigu.java.HeapOOM.main(HeapOOM.java:<span class="number">20</span>)</span><br><span class="line">Heap dump file created [<span class="number">7797849</span> bytes in <span class="number">0.010</span> secs]</span><br><span class="line">count = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>打开这个dump文件</p>
<p>1、看这个超大对象</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0027.png">

<p>2、揪出 main() 线程中出问题的代码</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0028.png">



<h2 id="清除阶段：标记-清除算法"><a href="#清除阶段：标记-清除算法" class="headerlink" title="清除阶段：标记-清除算法"></a>清除阶段：标记-清除算法</h2><p><strong>垃圾清除阶段</strong></p>
<ul>
<li>当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法是</li>
</ul>
<ol>
<li>标记-清除算法（Mark-Sweep）</li>
<li>复制算法（Copying）</li>
<li>标记-压缩算法（Mark-Compact）</li>
</ol>
<p><strong>背景</strong></p>
<p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并并应用于Lisp语言。</p>
<p><strong>执行过程</strong></p>
<p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p>
<ol>
<li>标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。<ul>
<li>注意：标记的是被引用的对象，也就是可达对象，并非标记的是即将被清除的垃圾对象</li>
</ul>
</li>
<li>清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0029.png">



<p><strong>标记-清除算法的缺点</strong></p>
<ol>
<li>标记清除算法的效率不算高</li>
<li>在进行GC的时候，需要停止整个应用程序，用户体验较差</li>
<li>这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表</li>
</ol>
<p><strong>注意：何为清除？</strong></p>
<p>这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放（也就是覆盖原有的地址）。</p>
<p>关于空闲列表是在为对象分配内存的时候提过：</p>
<ol>
<li>如果内存规整<ul>
<li>采用指针碰撞的方式进行内存分配</li>
</ul>
</li>
<li>如果内存不规整<ul>
<li>虚拟机需要维护一个空闲列表</li>
<li>采用空闲列表分配内存</li>
</ul>
</li>
</ol>
<h2 id="清除阶段：复制算法"><a href="#清除阶段：复制算法" class="headerlink" title="清除阶段：复制算法"></a>清除阶段：复制算法</h2><p><strong>背景</strong></p>
<ol>
<li>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky于1963年发表了著名的论文，“使用双存储区的Lisp语言垃圾收集器CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky在该论文中描述的算法被人们称为复制（Copying）算法，它也被M.L.Minsky本人成功地引入到了Lisp语言的一个实现版本中。</li>
</ol>
<p><strong>核心思想</strong></p>
<p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0030.png">

<p>新生代里面就用到了复制算法，Eden区和S0区存活对象整体复制到S1区</p>
<p><strong>复制算法的优缺点</strong></p>
<p><strong>优点</strong></p>
<ol>
<li>没有标记和清除过程，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>
<li>对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小</li>
</ol>
<p><strong>复制算法的应用场景</strong></p>
<ol>
<li>如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，效率较高</li>
<li>老年代大量的对象存活，那么复制的对象将会有很多，效率会很低</li>
<li>在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0031.png">



<h2 id="清除阶段：标记-压缩算法"><a href="#清除阶段：标记-压缩算法" class="headerlink" title="清除阶段：标记-压缩算法"></a>清除阶段：标记-压缩算法</h2><p><strong>标记-压缩（或标记-整理、Mark - Compact）算法</strong></p>
<p><strong>背景</strong></p>
<ol>
<li><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，<strong>基于老年代垃圾回收的特性，需要使用其他的算法。</strong></p>
</li>
<li><p>标记-清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p>
</li>
<li><p>1970年前后，G.L.Steele、C.J.Chene和D.s.Wise等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p>
</li>
</ol>
<p><strong>执行过程</strong></p>
<ol>
<li><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p>
</li>
<li><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。</p>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0032.png">



<p><strong>标记-压缩算法与标记-清除算法的比较</strong></p>
<ol>
<li><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。</p>
</li>
<li><p>二者的本质差异在于标记-清除算法是一种<strong>非移动式的回收算法</strong>，标记-压缩是<strong>移动式的</strong>。是否移动回收后的存活对象是一项优缺点并存的风险决策。</p>
</li>
<li><p>可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</p>
</li>
</ol>
<p><strong>标记-压缩算法的优缺点</strong></p>
<p><strong>优点</strong></p>
<ol>
<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法当中，内存减半的高额代价。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>从效率上来说，标记-整理算法要低于复制算法。</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址（因为HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）</li>
<li>移动过程中，需要全程暂停用户应用程序。即：STW</li>
</ol>
<h2 id="垃圾回收算法小结"><a href="#垃圾回收算法小结" class="headerlink" title="垃圾回收算法小结"></a>垃圾回收算法小结</h2><blockquote>
<p><strong>对比三种清除阶段的算法</strong></p>
</blockquote>
<ol>
<li><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p>
</li>
<li><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>标记清除</th>
<th>标记整理</th>
<th>复制</th>
</tr>
</thead>
<tbody><tr>
<td><strong>速率</strong></td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td><strong>空间开销</strong></td>
<td>少（但会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要活对象的2倍空间（不堆积碎片）</td>
</tr>
<tr>
<td><strong>移动对象</strong></td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody></table>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>Q：难道就没有一种最优的算法吗？</p>
<p>A：无，没有最好的算法，只有最合适的算法</p>
<p><strong>为什么要使用分代收集算法</strong></p>
<ol>
<li><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p>
</li>
<li><p>分代收集算法，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。</strong>一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
</li>
<li><p>在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关:</p>
<ul>
<li>比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。</li>
<li>但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</li>
</ul>
</li>
</ol>
<p><strong>目前几乎所有的GC都采用分代手机算法执行垃圾回收的</strong></p>
<p>在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点。</p>
<ol>
<li><p>年轻代（Young Gen）</p>
<ul>
<li>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</li>
<li>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。</li>
</ul>
</li>
<li><p>老年代（Tenured Gen）</p>
<ul>
<li>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。</li>
<li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。<ul>
<li><p>Mark阶段的开销与存活对象的数量成正比。</p>
</li>
<li><p>Sweep阶段的开销与所管理区域的大小成正相关。</p>
</li>
<li><p>Compact阶段的开销与存活对象的数据成正比。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。</p>
</li>
<li><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p>
</li>
</ol>
<h2 id="增量收集算法和分区算法"><a href="#增量收集算法和分区算法" class="headerlink" title="增量收集算法和分区算法"></a>增量收集算法和分区算法</h2><h3 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h3><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种Stop the World的状态。在<strong>Stop the World</strong>状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p>
<p><strong>增量收集算法基本思想</strong></p>
<ol>
<li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。<strong>每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。</strong></li>
<li>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过<strong>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</strong></li>
</ol>
<p><strong>增量收集算法的缺点</strong></p>
<p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<strong>造成系统吞吐量的下降</strong>。</p>
<h3 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h3><blockquote>
<p>主要针对G1收集器来说的</p>
</blockquote>
<ol>
<li>一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。</li>
<li>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/youthlql@1.0.8/JVM/chapter_010/0033.png">



<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>注意，这些只是基本的算法思路，实际GC实现过程要复杂的多，目前还在发展中的前沿GC都是复合算法，并且并行和并发兼备。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">小u</div><div class="post-copyright__author_desc">热爱可抵岁月漫长</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2023/10/01/codenotes/Java/jvm/10/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2023/10/01/codenotes/Java/jvm/10/')">JVM系列-第10章-垃圾回收概述和相关算法</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2023/10/01/codenotes/Java/jvm/10/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=JVM系列-第10章-垃圾回收概述和相关算法&amp;url=http://example.com/2023/10/01/codenotes/Java/jvm/10/&amp;pic=https://npm.elemecdn.com/lql_static@latest/logo/jvm.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/JVM/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JVM<span class="tagsPageCount">22</span></a><a class="post-meta__box__tags" href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>虚拟机<span class="tagsPageCount">12</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/01/codenotes/Java/jvm/11/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/lql_static@latest/logo/jvm.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">JVM系列-第11章-垃圾回收相关概念</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/01/codenotes/Java/jvm/12/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/lql_static@latest/logo/jvm.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">JVM系列-第12章-垃圾回收器</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/10/01/codenotes/Java/jvm/1/" title="JVM系列-第1章-JVM与Java体系结构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/lql_static@latest/logo/jvm.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">JVM系列-第1章-JVM与Java体系结构</div></div></a></div><div><a href="/2023/10/01/codenotes/Java/jvm/12/" title="JVM系列-第12章-垃圾回收器"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/lql_static@latest/logo/jvm.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">JVM系列-第12章-垃圾回收器</div></div></a></div><div><a href="/2023/10/01/codenotes/Java/jvm/11/" title="JVM系列-第11章-垃圾回收相关概念"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/lql_static@latest/logo/jvm.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">JVM系列-第11章-垃圾回收相关概念</div></div></a></div><div><a href="/2023/10/01/codenotes/Java/jvm/2/" title="JVM系列-第2章-类加载子系统"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/lql_static@latest/logo/jvm.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">JVM系列-第2章-类加载子系统</div></div></a></div><div><a href="/2023/10/01/codenotes/Java/jvm/3/" title="JVM系列-第3章-运行时数据区"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/lql_static@latest/logo/jvm.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">JVM系列-第3章-运行时数据区</div></div></a></div><div><a href="/2023/10/01/codenotes/Java/jvm/5/" title="JVM系列-第5章-堆"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/lql_static@latest/logo/jvm.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">JVM系列-第5章-堆</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" ait="status"/></div></div><div class="author-info__description">Java,java,springboot,mysql,redis,教程,git,软件,编程,开发,互联网,Java 基础,Java 教程,Java程序员进阶之路,Java 入门,Vue,前端,算法</div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎来看我的博客 博客主地址：http://blog.xiaou61.top/  备用地址：https://newblog.guoyaxue.top/</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">垃圾回收概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">大厂面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%9A%82%E8%9A%81%E9%87%91%E6%9C%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">蚂蚁金服</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BE%E5%BA%A6"><span class="toc-number">1.1.2.</span> <span class="toc-text">百度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A9%E7%8C%AB"><span class="toc-number">1.1.3.</span> <span class="toc-text">天猫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%B4%E6%BB%B4"><span class="toc-number">1.1.4.</span> <span class="toc-text">滴滴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%AC%E4%B8%9C"><span class="toc-number">1.1.5.</span> <span class="toc-text">京东</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BF%E9%87%8C"><span class="toc-number">1.1.6.</span> <span class="toc-text">阿里</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8"><span class="toc-number">1.1.7.</span> <span class="toc-text">字节跳动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">什么是垃圾？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81GC%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">为什么需要GC？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A9%E6%9C%9F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.4.</span> <span class="toc-text">早期垃圾回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">Java 垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.1.</span> <span class="toc-text">自动内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E8%AF%A5%E5%85%B3%E5%BF%83%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">1.5.2.</span> <span class="toc-text">应该关心哪些区域的回收？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">垃圾回收相关算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">标记阶段：引用计数算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">2.1.1.</span> <span class="toc-text">标记阶段的目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">引用计数算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-number">2.1.3.</span> <span class="toc-text">循环引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%81%E6%98%8E%EF%BC%9Ajava%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%8D%E6%98%AF%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.4.</span> <span class="toc-text">证明：java使用的不是引用计数算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.1.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">标记阶段：可达性分析算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-number">2.2.1.</span> <span class="toc-text">可达性分析实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-Roots%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%93%AA%E4%BA%9B%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="toc-number">2.2.2.</span> <span class="toc-text">GC Roots可以是哪些元素？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">2.2.3.</span> <span class="toc-text">注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84-finalization-%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">对象的 finalization 机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#finalize-%E6%96%B9%E6%B3%95%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.1.</span> <span class="toc-text">finalize() 方法机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%AD%98%E8%BF%98%E6%98%AF%E6%AD%BB%E4%BA%A1%EF%BC%9F"><span class="toc-number">2.3.2.</span> <span class="toc-text">生存还是死亡？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.3.</span> <span class="toc-text">具体过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA-finalize-%E6%96%B9%E6%B3%95%E5%8F%AF%E5%A4%8D%E6%B4%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.4.</span> <span class="toc-text">代码演示 finalize() 方法可复活对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MAT%E4%B8%8EJProfiler%E7%9A%84GC-Roots%E6%BA%AF%E6%BA%90"><span class="toc-number">2.4.</span> <span class="toc-text">MAT与JProfiler的GC Roots溯源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MAT-%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.4.1.</span> <span class="toc-text">MAT 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-dump-%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.2.</span> <span class="toc-text">获取 dump 文件方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%95%E6%8D%89-dump-%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.4.3.</span> <span class="toc-text">捕捉 dump 示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8JVisualVM%E6%8D%95%E6%8D%89-heap-dump"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">使用JVisualVM捕捉 heap dump</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-MAT-%E6%9F%A5%E7%9C%8B%E5%A0%86%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">使用 MAT 查看堆内存快照</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JProfiler-GC-Roots-%E6%BA%AF%E6%BA%90"><span class="toc-number">2.4.4.</span> <span class="toc-text">JProfiler GC Roots 溯源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JProfiler-%E5%88%86%E6%9E%90-OOM"><span class="toc-number">2.4.5.</span> <span class="toc-text">JProfiler 分析 OOM</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">2.5.</span> <span class="toc-text">清除阶段：标记-清除算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">2.6.</span> <span class="toc-text">清除阶段：复制算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E9%98%B6%E6%AE%B5%EF%BC%9A%E6%A0%87%E8%AE%B0-%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95"><span class="toc-number">2.7.</span> <span class="toc-text">清除阶段：标记-压缩算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93"><span class="toc-number">2.8.</span> <span class="toc-text">垃圾回收算法小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.9.</span> <span class="toc-text">分代收集算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E5%92%8C%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="toc-number">2.10.</span> <span class="toc-text">增量收集算法和分区算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.10.1.</span> <span class="toc-text">增量收集算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E7%AE%97%E6%B3%95"><span class="toc-number">2.10.2.</span> <span class="toc-text">分区算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="toc-number">2.11.</span> <span class="toc-text">写在最后</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/27/" title="再见 MyBatis-Plus ！">再见 MyBatis-Plus ！</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/26/" title="“人尽皆知”的单例模式">“人尽皆知”的单例模式</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/29/" title="阿里的同事，写的代码真 TMD 优雅！">阿里的同事，写的代码真 TMD 优雅！</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/28/" title="别再用 BeanUtils 了，这款 PO VO DTO 转换神器不香么？">别再用 BeanUtils 了，这款 PO VO DTO 转换神器不香么？</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/30/" title="MyBatis过时了吗？">MyBatis过时了吗？</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="小u" target="_blank">小u</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">238</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">39</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">50</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://mydocs.guoyaxue.top/" title="旧版博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="旧版博客"/><span class="back-menu-item-text">旧版博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://pan.xiaou61.top/#/" title="免费网盘"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="免费网盘"/><span class="back-menu-item-text">免费网盘</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://cloud.xiaou61.top/" title="云盘(自用)"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="云盘(自用)"/><span class="back-menu-item-text">云盘(自用)</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://wpzc.xiaou61.top/" title="云盘转存"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="云盘转存"/><span class="back-menu-item-text">云盘转存</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://love.xiaou61.top/#/" title="关于我们(My girlFriend)"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="关于我们(My girlFriend)"/><span class="back-menu-item-text">关于我们(My girlFriend)</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">娱乐项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://fxq.xiaou61.top/#/" title="飞行棋"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="飞行棋"/><span class="back-menu-item-text">飞行棋</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/game/sqnwmai803/" title="谁去拿外卖"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="谁去拿外卖"/><span class="back-menu-item-text">谁去拿外卖</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/desktop.html" title="win12网页版"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/icon/logo.svg" alt="win12网页版"/><span class="back-menu-item-text">win12网页版</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://game.xiaou61.top/" title="在线游戏"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="在线游戏"/><span class="back-menu-item-text">在线游戏</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 开往</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><span> 开往</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>3</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JVM/" style="font-size: 0.88rem;">JVM<sup>22</sup></a><a href="/tags/Nginx/" style="font-size: 0.88rem;">Nginx<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>1</sup></a><a href="/tags/Ts/" style="font-size: 0.88rem;">Ts<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size: 0.88rem;">TypeScript<sup>1</sup></a><a href="/tags/WebApi/" style="font-size: 0.88rem;">WebApi<sup>1</sup></a><a href="/tags/coder1v5/" style="font-size: 0.88rem;">coder1v5<sup>2</sup></a><a href="/tags/css/" style="font-size: 0.88rem;">css<sup>3</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>12</sup></a><a href="/tags/javaSE/" style="font-size: 0.88rem;">javaSE<sup>3</sup></a><a href="/tags/javaWeb/" style="font-size: 0.88rem;">javaWeb<sup>2</sup></a><a href="/tags/js%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">js逆向<sup>1</sup></a><a href="/tags/leetcode/" style="font-size: 0.88rem;">leetcode<sup>3</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>8</sup></a><a href="/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/" style="font-size: 0.88rem;">书籍推荐<sup>2</sup></a><a href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%90%AC%E8%BF%90/" style="font-size: 0.88rem;">公众号搬运<sup>35</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 0.88rem;">前端<sup>10</sup></a><a href="/tags/%E5%8A%9E%E5%85%AC/" style="font-size: 0.88rem;">办公<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 0.88rem;">后端<sup>8</sup></a><a href="/tags/%E5%A4%A9%E6%B6%AF%E8%AE%BA%E5%9D%9B/" style="font-size: 0.88rem;">天涯论坛<sup>1</sup></a><a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 0.88rem;">导航<sup>1</sup></a><a href="/tags/%E5%B0%B1%E4%B8%9A/" style="font-size: 0.88rem;">就业<sup>16</sup></a><a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 0.88rem;">微信<sup>1</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/" style="font-size: 0.88rem;">技术杂谈<sup>51</sup></a><a href="/tags/%E6%8E%98%E9%87%91/" style="font-size: 0.88rem;">掘金<sup>14</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 0.88rem;">杂项<sup>1</sup></a><a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 0.88rem;">测试<sup>1</sup></a><a href="/tags/%E6%B8%A1%E4%B8%80%E5%A4%A7%E5%B8%88%E8%AF%BE/" style="font-size: 0.88rem;">渡一大师课<sup>3</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 0.88rem;">爬虫<sup>1</sup></a><a href="/tags/%E7%9B%AE%E5%BD%95/" style="font-size: 0.88rem;">目录<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>4</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 0.88rem;">虚拟机<sup>12</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>6</sup></a><a href="/tags/%E8%B7%AF%E9%A3%9E%E5%AD%A6%E9%99%A2/" style="font-size: 0.88rem;">路飞学院<sup>3</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">面向对象<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>51</sup></a><a href="/tags/%E9%A3%9E%E8%A1%8C%E6%A3%8B/" style="font-size: 0.88rem;">飞行棋<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="7409599794" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>