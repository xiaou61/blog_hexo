<!DOCTYPE html><html class="hide-aside" lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>【全文8W字】我是怎样从0开始学会🚀TypeScript🚀的 | 小u的博客</title><meta name="keywords" content="掘金"><meta name="author" content="小u"><meta name="copyright" content="小u"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="【全文8W字】我是怎样从0开始学会🚀TypeScript🚀的"><meta name="application-name" content="【全文8W字】我是怎样从0开始学会🚀TypeScript🚀的"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="【全文8W字】我是怎样从0开始学会🚀TypeScript🚀的"><meta property="og:url" content="http://example.com/2023/10/01/%E6%8E%98%E9%87%91%E6%94%B6%E8%97%8F/8/index.html"><meta property="og:site_name" content="小u的博客"><meta property="og:description" content="【全文8W字】我是怎样从0开始学会🚀TypeScript🚀的一边学习，一边记录，前前后后花了至少2个月的时间，算是把TS大部分都搞明白了。 这篇文章的篇幅有点长，是我本人学习过程中的一些记录，参考了很多优秀博主的一些文章，以及在B站看了一些TS的视频，把几乎所有TS涵盖到的基础知识点都总结了下来"><meta property="og:locale" content="en"><meta property="og:image" content="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png"><meta property="article:author" content="小u"><meta property="article:tag" content="Java,java,springboot,mysql,redis,教程,git,软件,编程,开发,互联网,Java 基础,Java 教程,Java程序员进阶之路,Java 入门,Vue,前端,算法"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png"><meta name="description" content="【全文8W字】我是怎样从0开始学会🚀TypeScript🚀的一边学习，一边记录，前前后后花了至少2个月的时间，算是把TS大部分都搞明白了。 这篇文章的篇幅有点长，是我本人学习过程中的一些记录，参考了很多优秀博主的一些文章，以及在B站看了一些TS的视频，把几乎所有TS涵盖到的基础知识点都总结了下来"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2023/10/01/%E6%8E%98%E9%87%91%E6%94%B6%E8%97%8F/8/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//hm.baidu.com"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1433b93d16cca6b366bdf23126c0c200";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"tianli","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"784b999ee9b2f0689c5a","Referer":"https://mydocs-1305448902.cos-website.ap-nanjing.myqcloud.com/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: 小u","link":"Link: ","source":"Source: 小u的博客","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小u的博客',
  title: '【全文8W字】我是怎样从0开始学会🚀TypeScript🚀的',
  postAI: 'true',
  pageFillDescription: '【全文8W字】我是怎样从0开始学会🚀TypeScript🚀的, 一、了解TypeScript, 1. 什么是TypeScript, 2. 为什么需要TypeScript, 3. TypeScript的特点, 4. TypeScript和JavaScript的区别, 二、TypeScript环境搭建, 1. 安装编译TS的工具包, 2. 验证TS是否安装成功, 3. TypeScript初体验, 4. 简化运行TS的步骤, 5. 运行TS文件的另一种方法, 6. TypeScript Playground线上环境, 三、TypeScript类型注解, 1. 类型注解作用, 2. 类型注解用途, 3. 类型注解注意事项, 四、TypeScript类型, 1. TS中常用的基础类型, 1.1. 数值（number）, 1.2. 布尔值（boolean）, 1.3. 字符串（string）, 1.4. null 和 undefined, 1.5. symbol, 1.6. bigint, 1.7. 区别, 1.7.1. null 和 undefined 的区别, 1.7.2. bigint 和 number 的区别, 1.8. 对象类型, 1.8.1. 数组（Array）类型, 1.8.2. 函数类型, 1.8.2.1. 单独指定参数、返回值的类型, 1.8.2.2. 同时指定参数、返回值的类型, 1.8.2.3. 函数没有返回值, 1.8.2.4. 可选参数, 1.8.2.5. 参数默认值, 1.8.2.6. 剩余参数, 1.8.2.7. 函数重载, 1.8.3. 对象类型, 1.8.3.1. 定义对象类型, 1.8.3.2. 对象可选属性, 1.8.3.3. 对象只读属性, 2. 元组（Tuple）, 2.1. 元组的定义, 2.2. 元组的特点, 2.3. 元组类型的解构赋值, 2.4. 元组类型的可选元素, 2.5. 元组类型的剩余元素, 2.6. 只读的元组类型, 3. 字面量类型, 3.1. 字符串字面量类型, 3.2. 数字字面量类型, 3.3. 布尔字面量类型, 3.4. 符号字面量类型, 3.5. 函数参数中的字面量类型, 3.6. 函数返回值中的字面量类型, 3.7. 对象属性中的字面量类型, 3.8. let 和 const 分析, 3.8.1 let 声明的字面量类型, 3.8.2 const 声明的字面量类型, 4. 枚举（Enum）, 4.1. 基本枚举, 4.2. 数字枚举, 4.2.1. 默认递增的数字枚举, 4.2.2. 手动赋值的数字枚举, 4.2.3. 计算成员的数字枚举, 4.3. 常量枚举, 4.3.1. 常量枚举的定义, 4.3.2. 常量枚举的使用, 4.3.3. 常量枚举会在编译阶段被删除, 4.4. 字符串枚举, 4.5. 外部枚举, 4.6. 异构枚举, 4.7. 反向映射, 4.8. 运行时的枚举, 4.9. 联合枚举, 5. any类型, 五、接口（interface）, 1. 什么是接口, 2. 定义接口, 3. 接口（interface）和类型别名（type）的区别, 4. 接口继承（extends）, 5. 接口的可选属性, 6. 接口的只读属性, 7. 额外的属性检查, 8. 接口的任意属性, 9. 函数类型, 10. 可索引类型, 11. 类类型实现接口, 12. 继承接口, 13. 接口继承类, 六、类型别名, 七、类型推论, 1. 定义, 2. 基本类型推论, 3. 上下文类型推论, 4. 最佳通用类型推论, 5. 声明变量但没有赋值的情况, 八、类型断言, 1. 定义, 2. 语法, 3. 任何类型可以断言为 any 类型, 4. any 类型可以断言为任何类型, 5. 联合类型的类型断言, 6. 类型断言的限制, 6.1. 类型断言不会改变变量的实际类型, 6.2. 类型断言不能用于基本类型之间的转换, 6.3. 类型断言不能覆盖类型检查, 6.4. 类型断言不能将 null 或 undefined 断言为其他类型, 6.5. 联合类型的类型断言存在类型互相排斥的限制, 7. 双重断言, 8. 类型断言VS类型转换, 9. 类型断言VS类型声明, 10. 类型断言和泛型, 九、类（class）, 1. 类的定义, 2. 类的基本使用, 3. 类的构造函数, 3.1. 构造函数的基本语法, 3.2. 使用构造函数初始化成员变量, 3.3. 创建类的实例并调用构造函数, 3.4. 构造函数的可选参数和默认值, 3.5 .调用其他构造函数（构造函数重载）, 4. 类的实例方法, 4.1. 定义实例方法, 4.2. 访问实例属性, 4.3. 调用实例方法, 5. 类的继承, 5.1. extends（继承父类）, 5.1.1. 定义父类和子类, 5.1.2. 继承父类的属性和方法, 5.1.3. 调用继承的属性和方法, 5.2. implements（实现接口）, 5.2.1. 定义接口, 5.2.2. 使用 implements 实现接口, 5.2.3. 实现接口的属性和方法, 6. 类的修饰符, 6.1. public, 6.2. private, 6.3. protected, 6.4. readonly, 6.5. 参数属性, 7. 抽象类, 7.1. 语法, 7.2. 抽象方法, 7.3. 抽象类不能被实例化只能被继承, 7.4. 特点, 十、类型兼容性, 1. 基本类型的兼容性, 1.1. 相同的基本类型可以互相赋值, 1.2. 数字字面量类型可以赋值给数值类型, 1.3. 枚举类型可以赋值给数字类型, 2. 对象类型的兼容性, 2.1. 成员个数的兼容性, 2.2. 成员类型的兼容性, 2.3. 可选属性的兼容性, 3. 函数类型兼容性, 3.1. 参数个数, 3.2. 参数类型, 3.3. 返回值类型, 4. 类类型兼容性, 5. 泛型类型兼容性, 十一、交叉类型（Intersection Types）, 1. 组合对象类型, 2. 合并函数类型, 3. 交叉类型VS接口继承, 4. 注意, 十二、泛型（Generics）, 1. 什么是泛型, 2. 一个简单的例子, 3. 泛型语法, 4. 简化调用泛型函数, 5. 多个类型参数, 6. 泛型类, 7. 泛型接口, 8. 泛型参数的默认类型, 9. 泛型约束, 十三、TS中的关键字, 1. keyof, 2. typeof, 2.1. typeof获取变量的声明类型, 2.2. typeof与对象结合使用, 2.3. typeof与接口结合使用, 2.4. typeof与keyof结合使用, 3. in, 3.1. 遍历枚举类型, 3.2. 遍历联合类型, 4. extends, 4.1. 用于泛型函数, 4.2. 用于泛型类, 4.3. 用于类继承, 4.4. 用于继承接口, 4.5. 用于类型约束, 4.6. 用于条件类型, 十四、泛型工具类型, 十五、总结全文字我是怎样从开始学会的一边学习一边记录前前后后花了至少个月的时间算是把大部分都搞明白了这篇文章的篇幅有点长是我本人学习过程中的一些记录参考了很多优秀博主的一些文章以及在站看了一些的视频把几乎所有涵盖到的基础知识点都总结了下来所以对于想学习的小伙伴下来一定一定要认认真真把这篇文章看完万多字的教程不敢说是全网最好但可以说是全网最详细对于新手入门来说是一篇非常不错的宝藏文章几乎每个的知识点都有详细的讲到并且附上一些简单的示例通俗易懂希望可以给想学习的小伙伴带来动力一了解什么是是由微软开发的一门开源的编程语言简称是的超集以为基础构建的语言有的都有在基础之上为添加了类型支持可以在任何支持的平台中执行为什么需要我们都知道是弱类型的编程语言很多的错误只有在运行的时候才会被发现而在代码编译的时候代码执行前就可以发现错误的特点支持最新的语法在代码编译阶段就能发现错误在基础上增加了类型支持和的区别编译期发现错误运行时发现错误强类型语言支持静态和动态类型弱类型语言没有静态类型选项支持模块泛型和接口不支持模块泛型和接口代码运行时会被编译成代码浏览器才能识别可以直接在浏览器使用二环境搭建安装编译的工具包验证是否安装成功初体验创建一个文件注意文件的后缀名为并输入以下的内容复制代码将文件编译为文件在终端中输入命令此时在同级目录中会出现一个同名的文件复制代码执行代码在终端中输入命令终端会输出复制代码简化运行的步骤每次修改代码后都要重复执行两个命令才能运行代码我们可以直接使用工具包直接在中执行代码安装命令使用方式运行文件的另一种方法在中安装扩展插件在需要运行的文件中按鼠标右键选择快捷键线上环境对于刚入门的小伙伴来说我们可以不用安装本地的运行环境而是直接使用线上的我们就可以在浏览器中学习和编写代码通过配置的可以设置不同的编译目标从而编译生成不同的目标代码三类型注解类型注解作用类型注解的作用是为变量函数类等添加类型信息用于在静态类型检查阶段检查代码的类型正确性类型注解用途提供类型提示类型注解使得开发人员可以清晰地知道变量的类型编辑器能够根据类型注解给出相应的代码提示提高代码的可读性和可维护性静态类型检查通过给变量添加类型注解在编译阶段可以对代码进行静态类型检查它会检查变量的类型是否符合预期的类型并发现潜在的类型错误函数参数类型检查类型注解可以帮助开发人员在编写函数时明确参数的类型并在调用函数时进行参数类型检查这样可以避免因参数类型不匹配引发的潜在错误对象属性类型约束通过类型注解可以约束对象的属性类型确保对象的属性符合特定的类型要求例如上述代码中的就是类型注解约定变量的类型为数值类型类型注解注意事项约定了什么类型就只能给变量赋值该类型的值否则就会报错例如我们将变量的值重新赋值为字符串的此时我们就可以看到编辑器的错误提示不能将类型分配给类型类型注解只在编译阶段起作用并不会影响运行时的行为在编译后的代码中类型注解会被编译器忽略四类型中常用的基础类型我们可以将中常用的基础类型分为两类已有的类型新增的类型已有的类型我们又可以分为两类原始数据类型中的新类型中的新类型对象类型包括数组对象函数等对象新增的类型自定义类型类型别名联合类型接口元组字面量类型枚举等数值和一样里的所有数字都是浮点数这些浮点数的类型是除了支持十进制和十六进制字面量还支持中引入的二进制和八进制字面量在中使用来定义数值类型复制代码十进制十六进制二进制八进制编译结果复制代码十进制十六进制二进制八进制布尔值在中使用来定义布尔值类型复制代码编译结果复制代码字符串在中使用来定义字符串类型在中字符串的表现形式主要有以下三种方式使用单引号使用双引号使用模板字符串它可以定义多行文本和内嵌表达式这种字符串是被反引号包围并且以这种形式嵌入表达式复制代码模板字符串上面定义的的语句与下面定义的语句的效果相同编译结果复制代码模板字符串上面定义的的语句与下面定义的语句的效果相同和和是所有类型的子类型默认情况下可以把和赋值给其他类型注意如果你将文件中的选项设置为下面这种操作不会报错不过尽量不要这么做复制代码将和赋值给类型哈哈哈将和赋值给类型将和赋值给类型将和赋值给类型将和赋值给类型将和赋值给类型编译结果复制代码将和赋值给类型哈哈哈将和赋值给类型将和赋值给类型将和赋值给类型将和赋值给类型将和赋值给类型注意如果你在文件中指定了和只能赋值给和它们各自的类型下面这种情况会报错是新增的一种基本数据类型函数会返回类型的值每个从函数返回的的值都是唯一的复制代码上面的代码创建了三个新的类型但是注意的是每个从函数返回的值都是唯一的此时如果我们在控制台打印下面的代码两者并不相等复制代码是新增的一种基本数据类型在中可以用表示的最大整数为可以写为如果超过了这个界限那么就可以用来表示它可以表示任意大的整数在一个整数字面量后面加的方式定义一个或者调用函数复制代码区别和的区别在中表示什么都没有而是一个没有设置值的变量用检测返回一个没有值的变量会返回是一个只有一个值的特殊类型表示一个空对象的引用和是其它任何类型包括的子类型可以赋值给其它类型如数字类型此时赋值后的类型会变成或而在中启用严格的空校验特性就可以使得和只能被赋值给或本身对应的类型和的区别和都可以表示数字但是两者不能进行相互转换仅在值大于时才使用否则尽量使用用检测对象时返回用检测返回复制代码对象类型数组类型数组类型的写法有两种在类型后面加上例如复制代码使用数组泛型例如复制代码推荐使用第一种写法注意如果我们定义了一个类型的数组此时数组的项中就不能出现其它的类型如果我们希望数组中既有类型又有类型此时我们可以用联合类型来写关于联合类型后面会详细讲到复制代码上面的代码表示的是定义一个数组这个数组中可以出现或者类型的元素复制代码上面的代码和都表示即可以是类型又可以是加了小括号和不加小括号含义不同函数类型函数类型实际上指的是函数参数和返回值的类型为函数指定类型的两种方式单独指定参数返回值的类型同时指定参数返回值的类型在中有两种常见的定义函数的方式函数声明函数表达式单独指定参数返回值的类型复制代码函数声明写法函数表达式写法同时指定参数返回值的类型复制代码注意不要把中的和中的混淆了在中叫做箭头函数而在的类型定义中用来表示函数的定义左边是输入类型需要用括号括起来右边是输出类型函数没有返回值如果函数没有返回值那么函数返回值类型为复制代码可选参数使用函数实现某个功能时参数可以传也可以不传这种情况下在给函数参数指定类型时就用到可选参数了可选参数使用问号标记表示该参数可以省略复制代码上面的代码中我们在第二个参数的后面加了个问号表示在调用函数时该参数可传可不传注意可选参数只能出现在参数列表的最后面也就是说可选参数后面不能再出现必选参数错误演示下面代码中我们把第一个参数改为可选的第二个参数改为必选的然后将鼠标移到必选参数上面可以看到错误提示必选参数不能位于可选参数后参数默认值在中允许给函数的参数添加默认值而会将添加了默认值的参数识别为可选参数默认参数使用等号赋予默认值复制代码注意与可选参数不同的是带默认值的参数不需要放在必选参数的后面如果带默认值的参数出现在必选参数的前面我们在调用函数时必须明确的传入值来获得默认值复制代码报错未提供自变量剩余参数使用三个点前缀和参数名来定义剩余参数剩余参数允许我们将不确定数量的参数表示为一个数组复制代码注意剩余参数必须是函数参数列表中的最后一个参数函数重载函数重载允许我们为同一个函数提供多个函数类型定义以便在不同的参数类型或返回值类型下进行不同的处理例如我们现在需要实现一个函数需求是输入数字输出反转的数字输入字符串输出反转的字符串利用联合类型我们可以这么实现复制代码然后这样会有一个问题就是输出的类型不能准确的知道我们想输入为数字的时候输出的类型应该也为数值类型输入为字符串的时候输出类型应该也为字符串类型这时我们可以用重载定义多个的函数类型复制代码上述代码中第行是函数定义第行是函数实现第行代码我们调用函数并传入数值使用检测类型为第行代码我们调用函数并传入字符串使用检测类型为这样我们利用函数重载就实现了输入为什么类型输出应该也是什么类型对象类型中的对象是由属性和方法构成的而中对象的类型就是在描述对象的结构有什么类型的属性和方法定义对象类型使用花括号来定义对象类型属性采用属性名类型的形式方法采用方法名返回值类型的形式如果方法有参数就在方法名后面的小括号中指定参数类型比如在一行代码中指定对象的多个属性类型时使用分号来分隔如果一行代码只指定一个属性类型通过换行来分隔多个属性类型可以去掉分号方法的类型也可以使用箭头函数形式比如复制代码上面的代码也可以写成下面这种形式复制代码对象可选属性对象类型中的属性或方法可以是可选的使用问号标记可选属性表示该属性可以存在也可以不存在比如我们在使用时如果发送请求属性就可以省略复制代码对象只读属性对象的属性也可以是只读的使用关键字标记只读属性表示该属性的值在创建后就不能被修改复制代码元组元组的定义在中元组是一种特殊的数组类型它允许存储具有固定数量和特定类型顺序的元素声明一个元组的语法是在类型注解中使用方括号并使用逗号分隔元素的类型例如下面是一个包含两个元素的元组复制代码在上述示例中我们声明了一个名为的变量它被注解为一个元组类型我们可以将一个包含两个元素的数组赋值给其中第一个元素是一个字符串第二个元素是一个数字元组的特点元组可以包含多个不同类型的元素但每个元素的类型和顺序是固定的元组的长度是固定的在创建元组时必须指定元素的数量可以通过索引访问元组中的元素索引从开始元组中的每个元素可以具有不同的类型注解当访问元组中的元素时会根据其类型注解提供相关的类型检查和智能提示下面是一些操作元组的示例复制代码声明一个变量它的类型注解为然后把一个包含个元素的数组赋值给其中数组的第一个元素为字符串类型第二个元素为数值类型第三个元素为布尔值类型通过索引访问元组中的元素索引从开始输出输出输出可以通过索引重新赋值赋值的类型需要跟类型注解中的固定位置的类型一样输出下面的代码会报错不能将类型分配给类型源具有个元素但目标仅允许个下面的代码也会报错因为元组的第一个元素类型要求为字符串类型不能将类型分配给类型注意当访问元组中的元素以及进行元素的赋值时要确保索引和类型注解的一致性否则可能会导致类型错误元组类型的解构赋值在中可以使用解构赋值语法来从元组中提取和赋值元素下面是一个简单的示例展示了如何使用解构赋值从元组中获取各个元素复制代码输出输出在上述示例中我们首先声明了一个元组其中包含一个字符串类型的元素和一个数值类型的元素接着我们使用解构赋值语法将元组中的元素分别赋值给变量和通过解构赋值我们可以直接使用对应位置的变量来获取元组中的元素值而不需要通过索引访问这样可以以一种简洁语义明确的方式从元组中解构得到各个元素解构赋值还支持忽略某些元素或者只提取部分元素例如如果只想获取元组中的第一个元素可以使用以下方式复制代码输出在上述示例中我们只声明了一个变量而忽略了后面的元素通过解构赋值只获取所需元素可以简化代码并提高可读性另外解构赋值还支持使用默认值当从元组中解构一个不存在的元素时可以提供一个默认值作为备选值例如复制代码输出输出在上述示例中我们声明了一个带有可选的数字元素的元组但是没有给出对应的数字值在解构赋值时如果元组中缺少对应的元素就会使用默认值这里我们将默认值设置为总而言之使用解构赋值可以轻松地从元组中提取和赋值元素使得代码更加简洁和可读它是一种方便的语法特别适用于处理具有固定结构的数据注意在解构赋值时如果解构数组元素的个数超过元组中元素的个数会出现错误复制代码在上述示例中我们解构时新增了一个变量但元组的长度为在索引处没有元素元组类型的可选元素在中可以使用问号来将元素定义为可选的以表示元组中某些位置的元素是可选的复制代码输出输出在上述示例中我们定义了一个元组该元组有两个元素第一个是一个字符串类型的元素而第二个是一个可选的数值类型的元素当我们只提供第一个元素时第二个元素会被默认设置为然后我们更新了元组的值提供了第二个元素的值此时元组中的两个元素都有具体的值注意当一个元组中包含一个可选元素时该元素可以存在或不存在但是顺序必须与元组类型定义一致在解构赋值时可以使用默认值来处理可选元素的缺失情况复制代码输出输出在上述示例中我们使用解构赋值将元组中的元素分别赋值给变量和由于元组只提供了一个元素没有提供可选的第二个元素所以的值将使用默认值通过使用可选元素可以更灵活地定义元组类型允许元组中特定位置的元素是可选的这样我们可以在处理数据时更好地适应不完整或可变的情况元组类型的剩余元素在中可以使用剩余元素来表示元组中剩余的元素即将剩余的元素放入一个数组中复制代码输出在上述示例中我们定义了一个元组包含一个字符串元素一个数字元素以及剩余元素使用剩余元素语法定义的布尔类型数组在创建元组时我们提供了多个布尔类型的元素它们会被放入一个数组并作为剩余元素这样元组中除了前两个元素以外的其他元素都会被放入数组中并以数组的形式表示复制代码输出输出输出在上述示例中我们使用解构赋值从元组中提取出各个元素通过使用我们将剩余的布尔类型元素提取到名为的数组中使用剩余元素可以处理元组中数量不确定的元素可以更灵活地处理和操作这些元素它提供了一种方便的方式来处理由不固定数量的元素组成的结构数据只读的元组类型在中可以使用修饰符来创建只读的元组类型即元组中的元素不可被修改复制代码输出编译错误无法为赋值因为它是只读属性编译错误类型上不存在在上述示例中我们使用修饰符将声明为只读的元组类型这意味着在运行时我们无法修改元组中的元素的值尝试对进行赋值或调用修改元素的方法如时编译器会报错因为元组被声明为只读无法被修改只读的元组类型在某些场景下非常有用特别是当希望确保元组中的数据不会被意外修改时它提供了一种强制保护元组数据不可变性的机制字面量类型当我们在中使用字面量类型我们可以明确指定变量只能取特定的字面量值而不是其他可能性这样可以在编译时捕获潜在的错误并提供更好的类型推断和类型检查支持在中可以使用多种类型的字面量进行类型定义包括字符串字面量类型数字字面量类型布尔字面量类型和符号字面量类型字符串字面量类型使用字符串字面量表示的类型只能取特定的字符串值复制代码合法错误只能取值为数字字面量类型使用数字字面量表示的类型只能取特定的数字值复制代码合法错误只能取值为或布尔字面量类型使用布尔字面量表示的类型只能取特定的布尔值复制代码合法合法错误只能取值为或符号字面量类型使用符号字面量表示的类型只能取特定的符号值复制代码合法合法错误只能取预定义的或字面量类型不仅可以用于变量的定义还可以用于函数的参数返回值对象属性等地方通过使用字面量类型我们可以在编写代码时明确指定特定的取值范围提高代码的可读性和可维护性需要注意的是字面量类型具有一个特殊的用途即与联合类型结合使用以实现更精确的类型约束例如联合类型表示可以是字符串或数字类型的值而字面量类型表示只能是字符串或它们可以一起使用来实现更精确的类型定义复制代码合法合法错误只能取值为或类型函数参数中的字面量类型复制代码合法合法错误只能取值为或或或在上述示例中函数的参数的类型被指定为这意味着参数只能接受这四个特定的值函数返回值中的字面量类型复制代码在上述示例中函数的返回值被指定为这表示函数的返回值只能是这四个特定的值之一对象属性中的字面量类型复制代码在上述示例中接口中的属性的类型被指定为属性的类型被指定为这意味着对象的属性只能是其中一个值属性也只能是其中一个值和分析声明的字面量类型复制代码合法错误只能取值为在上述示例中我们使用关键字声明了变量并将其类型指定为因此只能取值为或或或这四个特定值中的其中一个声明的字面量类型复制代码在上述示例中我们使用关键字声明了常量并将其类型指定为由于使用了是一个只读的常量且初始值为因此的值将永远是不能被重新赋值使用和关键字来声明变量和常量时可以配合字面量类型提供更具体和可靠的类型约束注意声明的常量在声明时必须被初始化并且一旦初始化后其值将不能被修改而声明的变量可以在后续代码中被重新赋值枚举枚举是一种用于定义一组命名常量的数据结构基本枚举复制代码输出在上述示例中我们定义了一个名为的枚举其中列出了和四个枚举成员默认情况下枚举成员的值从开始自动递增因此的值为我们可以使用枚举成员来声明变量并进行比较打印等操作数字枚举在默认情况下数字枚举的成员从开始自动递增默认递增的数字枚举复制代码输出输出输出输出在上述示例中我们定义了一个名为的枚举其中列出了和四个枚举成员默认情况下枚举成员的值从开始自动递增因此的值是的值是的值是的值是手动赋值的数字枚举在手动赋值的数字枚举中可以为每个枚举成员手动指定一个特定的值手动赋值的数字枚举可以使用任意合法的数字作为成员的值复制代码输出输出输出输出在上述示例中被赋值为被赋值为被赋值为被赋值为计算成员的数字枚举在数字枚举中可以使用计算表达式作为成员的值复制代码输出输出输出输出在上述示例中我们使用加法减法乘法和除法运算符来计算成员的值在编译时这些计算表达式会被求值为结果值并成为实际的枚举成员的值常量枚举常量枚举是一种特殊类型的枚举它在编译时被删除并且只保留枚举成员的值作为常量常量枚举提供了一种更轻量级的方式来使用枚举可以用于在编译期间替换枚举成员的值常量枚举的定义在定义常量枚举时需要使用关键字和关键字的组合常量枚举不能有计算成员复制代码常量枚举的使用复制代码输出输出输出输出常量枚举会在编译阶段被删除字符串枚举在中字符串枚举是一种特殊类型的枚举其中每个成员都用字符串字面量进行初始化复制代码输出输出输出输出在上述示例中我们定义了一个名为的字符串枚举其中的成员使用字符串字面量进行初始化成员使用字符串字面量进行初始化成员使用字符串字面量进行初始化成员使用字符串字面量进行初始化我们可以通过直接访问枚举成员来获得其对应的字符串值字符串枚举的特点明确的字符串值每个字符串枚举成员都具有明确的字符串值可更好地描述其含义和用途代码可读性由于成员的值直接使用字符串字面量因此代码更加清晰易读保留字符串字面量使用字符串枚举可以在编译后保留字符串字面量而不是转换为数值或其他类型可用于反向映射字符串枚举可以支持从枚举值到枚举名的反向映射外部枚举外部枚举是一种定义在外部代码如声明文件中的枚举外部枚举通常用于描述已存在的枚举类型的形状而不是为了创建一个具体的对象外部枚举的定义不会在编译时生成任何实际的代码它只用于类型检查复制代码输出输出输出自动递增输出在上述示例中我们使用关键字来定义了一个外部枚举它描述了一些常见的状态码其中的成员和和指定了具体的数值分别为和成员没有显式指定值它会根据前一个成员的值自动递增因此值为在使用外部枚举时我们可以像使用普通枚举一样访问它的成员并获得相应的值在上述示例中我们将赋值给变量然后将变量的值打印出来得到的结果是注意当使用外部枚举时我们必须使用来声明它以告诉编译器这是一个外部定义的枚举此外外部枚举的定义通常是在一个声明文件中以结尾以便在与现有库或框架进行交互时提供类型信息总结起来外部枚举是中一种在外部代码中定义的枚举用于描述已存在的枚举类型的形状外部枚举的定义通常只用于类型检查并不会生成实际的代码它在与现有库或框架进行交互时提供类型信息异构枚举异构枚举是一种允许枚举成员的值具有不同类型的枚举通常情况下枚举中的成员的值应该是相同类型的但是异构枚举允许在同一个枚举中使用不同类型的值包括字符串数字和其他类型复制代码输出输出自动递增输出输出在上述示例中我们定义了一个名为的异构枚举其中的成员的值是一个数字值为成员没有显式指定值它的值会根据前一个成员的值自动递增因此值为成员的值是一个字符串值为成员的值是一个字符串值为在访问异构枚举的成员时将得到其对应的值在上述示例中我们分别打印了每个异构枚举成员的值并相应地获得了不同类型的结果异构枚举的优势在于允许在一组相关的枚举中使用不同类型的值这在某些特定情况下可能很有用例如需要表示不同种类的状态或类型时注意在异构枚举中具有数字字面量值的成员会根据前一个成员的值自动递增而具有字符串字面量值的成员不会自动递增同时在异构枚举中没有初始化值的成员会根据前一个成员的值自动递增反向映射反向映射是指枚举成员不仅可以通过名称访问值而且可以通过值访问名称这意味着可以根据枚举的值获取到对应的枚举成员名称复制代码输出输出在上述示例中我们定义了一个名为的枚举其中的成员分别使用数字进行初始化我们将的值赋给变量然后使用获取到对应的枚举成员名称将结果赋给变量在打印出变量和的值后我们得到的结果是和这就是反向映射的效果根据枚举的值可以获取到对应的枚举成员名称注意反向映射只在数字枚举中有效而不适用于字符串枚举字符串枚举的成员值虽然可以是字符串字面量但在中无法实现反向映射运行时的枚举运行时的枚举是指在运行时可访问和操作的枚举编译器在编译过程中会将枚举类型转换为实际的对象这些对象在运行时仍然保留了枚举的结构和值以便能够通过它们来进行运行时的枚举操作复制代码输出输出输出在上述示例中我们定义了一个名为的枚举其中包含了三个成员和然后我们定义了一个函数它接受一个类型的参数根据传入的枚举值返回对应的水果名称通过运行函数并传入不同的枚举值我们可以在控制台上看到输出的结果它们是根据传入的枚举值返回的相应水果名称注意当使用运行时枚举时由于枚举的成员值实际上是数字默认从开始递增因此进行比较时需要使用严格相等运算符联合枚举联合枚举是指一个枚举类型可以包含多个不同的枚举成员的组合每个成员可以具有不同的值和类型复制代码画一个圆形画一个矩形画一个三角形颜色为红色颜色为绿色颜色为蓝色输出画一个圆形输出颜色为蓝色在上述示例中我们定义了两个枚举和枚举表示不同的形状枚举表示不同的颜色然后我们定义了一个类型别名它是枚举成员和枚举成员的联合接着我们定义了一个函数它接受一个类型的参数根据传入的参数值进行不同的分支逻辑处理并输出相应的消息通过调用函数并传入不同的值我们可以根据传入的参数值来绘制不同的形状或填充不同的颜色联合枚举使得我们能够在一个类型中组合多个不同的枚举成员以表示更复杂的类型这可以让的类型系统提供更精确的类型检查和推断以确保代码的正确性注意联合枚举的使用是通过定义类型别名或接口来实现的通过将不同枚举成员组合在一起可以创建复合类型提供更灵活的数据表示类型在中类型表示一个动态类型它可以接受任何类型的值使用类型时编译器将不会对值进行类型检查允许你在编译期绕过类型系统的限制如果是一个普通类型在赋值过程中改变类型是不被允许的如果是类型则允许被赋值为任意类型复制代码以下两种情况隐式具有类型声明变量不提供类型也不提供默认值函数参数不加类型注意在开发过程中应尽量避免过度使用类型以充分利用的类型系统来提供更好的类型安全性和代码可维护性五接口什么是接口在中接口是一种用来定义对象的结构和行为的类型通过接口我们可以定义对象应该有哪些属性属性的类型以及方法接口提供了一种约束和规范使得我们可以在代码中定义和使用特定的数据结构定义接口使用关键字来定义接口声明接口后直接使用接口名称作为变量的类型方法的定义和函数的定义类似包括参数和返回值类型接口一般首字母大写有的编程语言中建议接口的名称加上前缀复制代码上面的代码中我们定义了一个接口接着定义了一个变量它的类型是这样我们就约束了的形状必须和接口一致注意定义的变量比接口少了一些属性不允许的下面是一段错误的代码演示我们定义了一个接口里面有个属性以及方法接着定义了一个变量它的类型是但是我们只给属性和赋值所以会报错当然定义的变量比接口多了一些属性也是不允许的也就是说在赋值的时候变量的形状必须和接口的形状保持一致接口和类型别名的区别相同点都可以用于定义对象的结构和类型不同点接口更适合用于描述真实存在的对象而类型别名更适合用于定义复杂的类型接口可以被其他对象实现而类型别名只是给类型起了一个别名复制代码接口继承在中接口是可以相互继承的也就是说一个接口可以从另一个接口中继承属性和方法的定义通过继承实现复用接口的继承可以通过使用关键字实现接口继承的语法格式如下通过继承子接口可以获得父接口中定义的属性和方法并可以在自身接口中添加新的属性和方法下面是一个简单的例子展示了接口继承的用法复制代码在上面的例子中使用关键字实现了接口继承继承后就有了中的属性以及自身的属性以及方法接口的可选属性带有可选属性的接口与普通的接口定义差不多只是在可选属性名字定义的后面加一个符号复制代码可选属性上面的例子中接口中的属性是可选的我们定义了和两个对象类型都是其中对象中没有属性而对象中包含了属性可选属性的好处有个可以对可能存在的属性进行预定义可以捕获引用了不存在的属性时的错误例如我们故意将对象中的属性名写错就会得到一个错误的提示接口的只读属性有时候我们希望某些属性在对象创建后不能被修改可以将这些属性声明为只读属性通过在属性名称前面加上关键字就可以将属性设置为只读例如下面的例子中声明了一个名称为的接口接口中的属性和都是只读的然后创建了一个对象类型为此时我们不能再给对象中的和重新赋值会报错因为它们都是只读属性此外还提供了类型它与相似只是把所有可变方法去掉了因此可以确保数组创建后再也不能被修改复制代码额外的属性检查接口用于定义对象的结构当我们使用对象字面量赋值给接口类型时会自动进行额外的属性检查这意味着赋值的对象不能包含接口中未定义的额外属性否则会导致编译错误复制代码编译错误额外的属性检查在上述例子中对象包含了额外的属性但是接口中并未定义该属性所以会导致编译错误注意如果我们确定对象会包含额外的属性可以使用类型断言来绕过额外属性检查接口的任意属性有时候我们希望一个接口中除了包含必选和可选属性之外还允许有其他的任意属性这时我们可以使用索引签名的形式来满足上述要求复制代码上述代码中我们使用定义了任意属性取类型的值注意一旦定义了任意属性那么必选属性和可选属性的类型都必须是它的类型的子集复制代码上述例子中任意属性的值允许是但是可选属性的值却是不是的子属性所以报错了注意一个接口中只能定义一个任意属性如果接口中有多个类型的属性则可以在任意属性中使用联合类型复制代码这里真实的类型应该为函数类型接口可以描述函数类型为了使用接口表示函数类型我们需要给接口定义一个调用签名它就像是一个只有参数列表和返回值类型的函数定义参数列表里的每个参数都需要名字和类型复制代码在上述例子中是一个接口它表示一个接收两个参数和参数类型都为并且返回值为类型的函数这样定义后我们可以像使用其它接口一样使用这个函数类型的接口下面的例子展示了如何创建一个函数类型的变量并将一个同类型的函数赋值给这个变量复制代码注意对于函数类型的类型检查来说函数的参数名不需要与接口里定义的名字相匹配例如我们使用下面的代码重写上面的例子复制代码函数的参数会逐个进行检查要求对应位置上的参数类型是兼容的如果你不想指定类型的类型系统会推断出参数类型因为函数直接赋值给了类型变量函数的返回值类型是通过其返回值推断出来的此例是和复制代码如果让这个函数返回数字或字符串类型检查器会警告我们函数的返回值类型与接口中的定义不匹配可索引类型接口可以描述具有索引签名的对象这样我们就可以通过索引来访问对象的属性复制代码上述的例子中我们定义了接口它具有索引签名这个索引签名表示了当用去索引时会得到类型的返回值支持两种索引签名字符串和数字可以同时使用两种类型的索引但是数字索引的返回值必须是字符串索引返回值类型的子类型这是因为当使用来索引时会将它转换成然后再去索引对象也就是说用一个去索引等同于使用一个去索引因此两者需要保持一致类类型实现接口接口可以被类实现称为类类型类可以通过关键字来实现接口并必须实现接口中定义的所有属性和方法复制代码在上述例子中类实现了接口并实现了接口中定义的方法继承接口和类一样接口也可以相互继承这让我们能够从一个接口里复制成员到另一个接口里可以更灵活地将接口分割到可重用的模块里复制代码一个接口可以继承多个接口创建出多个接口的合成接口复制代码接口继承类当接口继承了一个类类型时它会继承类的成员但不包括其实现就好像接口声明了所有类中存在的成员但并没有提供具体实现一样接口同样会继承到类的和成员这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时这个接口类型只能被这个类或其子类所实现复制代码输出输出在以上示例中我们定义了一个类它有一个属性和一个方法然后我们定义了一个接口它继承自类并添加了一个和方法接着我们创建了一个类来实现接口并在类中实现了和方法在最后的代码中我们使用接口来声明一个对象并将其实例化为类的对象这样我们可以通过调用对象的和方法来验证接口继承类的实现接口继承类的主要作用在于类型标注和约束通过接口继承类我们可以定义更具体的接口类型使得类和接口之间的关系更加清晰同时在使用接口类型的变量或参数时可以享受到类成员的类型检查和智能提示的功能这对于代码的可读性可维护性和可扩展性都有很大的帮助六类型别名作用在中类型别名主要用于为已有的类型创建别名以便在代码中更方便地引用和重用这些类型用法使用关键字可以为任何类型定义别名包括基本类型复杂类型函数类型等创建类型别名后直接使用该类型别名作为变量的类型注解即可解释类型别名是为已有类型提供另一个名称而不是创建新的类型类型别名可以用于简化复杂类型的表达提高可读性和可维护性类型别名可以用于定义联合类型或交叉类型的别名注意尽量选择有意义的别名能够准确描述类型的用途提高代码的可读性避免过度使用类型别名过多的别名可能导致代码的可维护性变差注意避免循环引用的情况即在类型别名中引用自身这会导致编译错误类型别名并不创建新的类型所以它无法被继承或实现复制代码未使用类型别名使用类型别名七类型推论定义在中类型推论是指编译器在没有明确指定类型的情况下根据变量的值推断出该变量的类型通过类型推论可以在代码中自动推断出变量的类型而无需显式地将其指定为特定类型基本类型推论当声明一个变量时如果没有显式指定类型并且在声明的同时进行了赋值操作将根据赋值的值推断出变量的类型复制代码推断为类型推断为类型推断为类型以上的代码等价于下面的下吗上下文类型推论当变量的类型与其所处的上下文相关时可以根据上下文进行类型推断复制代码推断为类型在上述示例中函数接收两个参数并返回它们的和当我们调用时根据函数返回值的类型推断出变量的类型为最佳通用类型推论当需要推断出数组或对象类型时会根据元素或属性的类型推断出一个最佳通用类型复制代码推断为类型推断为在上述示例中数组中的所有元素都是数字因此推断出的类型为而数组中的元素类型不同数字字符串和布尔值所以推断出的类型为表示该数组可以存储数字字符串或布尔值类型的元素声明变量但没有赋值的情况如果声明变量的时候没有赋值不管之后有没有赋值都会被推断成类型而完全不被类型检查复制代码在上述示例中变量的类型推断为类型因为它没有明确的初始值此时我们就可以把任意类型的值赋值给需要注意的是虽然可以根据赋值来推断类型但如果变量的初始值为或类型推论仍然会将其推断为类型为了避免使用类型我们可以显式指定变量的类型或为变量提供一个初始值来触发类型推论八类型断言定义类型断言是中的一种表达式它可以用来告诉编译器一个值的确切类型通过类型断言我们可以在一些情况下主动指定变量的类型以满足特定的需求语法类型断言有种语法形式尖括号语法使用尖括号将值包裹并在尖括号内指定目标类型类型值复制代码输出在上面的示例中我们将变量的类型断言为类型然后使用属性获取字符串的长度语法使用关键字在值后面跟上目标类型值类型复制代码输出在上面的示例中我们使用关键字将变量的类型断言为类型并用属性获取字符串的长度以上两种语法虽说没有太大的区别但是我们更推荐使用语法因为尖括号格式会与中产生语法冲突任何类型可以断言为类型由于类型可以接收任何值因此任何类型都可以断言为类型这样的断言并不提供更多的类型检查因此在使用类型断言时需要谨慎上面的例子中数字类型的变量上是没有属性的故给出了相应的错误提示这种错误提示显然是非常有用的但有的时候我们非常确定这段代码不会出错比如下面这个例子上面的示例中我们需要将上添加一个属性但编译时会报错提示我们上不存在属性此时我们可以使用临时将断言为类型复制代码类型可以断言为任何类型与上述情况相反由于类型可以接收任何值它可以被断言为任何类型这样的断言会跳过类型检查因此潜在的类型错误可能发生复制代码将类型断言为类型联合类型的类型断言当变量具有联合类型时我们可以通过类型断言将其断言为其中的一个类型但是必须确保断言的类型是变量实际上可以具备的类型复制代码类型断言为类型类型断言的限制类型断言不会改变变量的实际类型类型断言只是告诉编译器将一个值视为特定类型并不会改变该值的实际类型在运行时类型断言不会影响变量的值或行为它只是在编译时起作用类型断言不能用于基本类型之间的转换的类型断言不能用于将基本类型如相互转换因为基本类型具有明确的类型判断和行为不能将一个基本类型断言为另一个基本类型复制代码错误不能将类型断言为类型类型断言不能覆盖类型检查类型断言可以绕过编译器的类型检查但并不意味着我们可以随意断言任何类型如果发生类型断言与变量的实际类型不匹配的情况可能会导致运行时错误类型断言不能将或断言为其他类型因为和可以被赋值给任何类型将它们断言为其他类型是没有意义的复制代码错误不能将断言为类型联合类型的类型断言存在类型互相排斥的限制如果将一个变量断言为联合类型中某个类型那么它必须是该联合类型中的实际类型之一复制代码正确因为的实际类型可以为错误的实际类型不是双重断言双重断言也被称为双重类型断言或连续类型断言是一种在中连续使用类型断言的技术它是将一个值断言为多个类型的一种尝试尽管这种用法并不被官方鼓励使用因为它可能产生不可预测的结果双重断言的形式是使用连续的类型断言操作符或尖括号来表示复制代码在上述示例中我们连续使用了两次类型断言将值先断言为类型然后再将其断言为类型并使用属性获取字符串的长度但是需要注意的是尽管代码通过了编译但是这种双重断言的方法并不安全因为它可以导致类型错误和运行时错误使用双重断言可能会隐藏类型错误因为类型断言是编译时的操作而不是运行时在运行时双重断言可能会导致意外的类型转换错误并且编译器无法为此提供任何保护所以在实际开发中应尽量避免使用双重断言如果需要使用多个类型而无法使用更安全的方法来表示可以考虑重构代码使用更合适的类型来处理多种情况或者使用类型守卫和类型判断等提供的更安全的技术来处理复杂的类型转换或条件判断类型断言类型转换在中类型断言是一种在编译时告诉编译器一个值的确切类型的方式它只是一种类型的声明不会对变量进行真正的类型转换与类型断言相对的是类型转换它是将一个值从一种类型转换为另一种类型的实际操作而不仅仅是告诉编译器某个值的类型类型转换通常需要在运行时进行并涉及对值的实际修改复制代码类型断言类型转换在上述示例中是一种类型断言告诉编译器将变量视为字符串类型而是一种类型转换将字符串类型的转换为整数类型需要注意的是类型断言只会在编译时起作用不会对变量进行实际的类型转换而类型转换涉及到对变量值的修改通常发生在运行时尽管类型断言和类型转换在某种程度上可以实现相似的效果但它们的机制和目的不同类型断言是为了辅助编译器进行类型推断和类型检查的工具而类型转换是为了实际修改变量的类型以满足特定需求因此在使用类型转换时需要注意潜在的类型错误和运行时错误并谨慎处理类型转换的结果类型断言类型声明在中类型断言是一种在编译时告诉编译器一个值的确切类型的方式它是开发者主动指定一个变量的类型并告诉编译器遵循这个类型进行类型检查通过类型断言我们可以在某些情况下绕过编译器的类型检查但这需要开发者对类型的准确性负责并且存在潜在的类型错误的风险复制代码在上述示例中是一种类型断言将变量的类型断言为字符串类型从而可以安全地访问字符串的属性类型声明是一种为变量参数返回值等明确指定类型的语法它是用来定义变量的类型并告诉编译器如何对变量进行类型推断和类型检查类型声明通常出现在变量声明函数声明函数参数函数返回值等地方例如复制代码在上述示例中是对变量进行类型声明指定其类型为字符串而是对函数参数进行类型声明指定其类型为字符串这样可以确保编译器在类型检查时能够发现潜在的类型错误类型声明是中一种重要的类型系统的特性它提供了对变量类型的明确说明使开发者能够编写更加安全和可维护的代码与类型断言相比类型声明更加强制能够更好地帮助开发者在编译时发现类型错误并提供更好的类型推断和类型检查支持类型断言和泛型在中类型断言是一种在编译时告诉编译器一个值的确切类型的方式它是开发者主动指定一个变量的类型并告诉编译器遵循这个类型进行类型检查通过类型断言我们可以在某些情况下绕过编译器的类型检查但这需要开发者对类型的准确性负责并且存在潜在的类型错误的风险复制代码在上述示例中是一种类型断言将变量的类型断言为字符串类型以便可以安全地访问字符串的属性泛型是一种在定义函数类或接口时使用类型参数来表示灵活的类型的方式通过泛型我们可以在定义时不指定具体类型而是在使用时根据上下文传入具体的类型它可以增加代码的重用性和灵活性例如复制代码在上述示例中是一个泛型函数使用类型参数来表示数组中的元素类型通过传入具体的类型我们可以创建一个字符串类型的数组类型断言和泛型实际上可以一起使用当我们在处理泛型类型时有时可能需要对类型进行断言以满足特定的需求例如复制代码在上述示例中通过连续使用类型断言我们将泛型类型先断言为类型然后再断言为字符串类型将参数转换为字符串类型并返回需要注意的是在使用类型断言和泛型时我们要确保类型的安全性和正确性并避免潜在的类型错误类型断言可以帮助我们处理一些特殊情况但要谨慎使用并确保断言的类型与变量的实际类型相符泛型则是一种更加灵活和通用的方式来处理不特定类型的代码逻辑九类类的定义在中可以使用关键字来定义类类的定义通常包括成员变量构造函数方法等类的基本使用类的基本使用主要有以下几个步骤定义类及成员变量使用关键字定义一个类并在类中声明成员变量构造函数使用方法定义构造函数用于在创建类的实例时初始化对象的属性方法在类中定义方法可通过类的实例调用创建类的实例使用关键字创建类的实例并传递构造函数所需的参数访问成员变量和调用方法通过实例对象访问成员变量和调用方法复制代码输出输出输出在上述示例中我们使用关键字定义一个名为的类并在类中声明了两个成员变量和接着我们使用方法定义一个构造函数用于在创建类的实例时初始化对象的属性构造函数参数和分别用于接收传入的和值并将其赋给对应的成员变量然后定义了一个名为的方法用于打印一个问候语并使用成员变量和接着我们使用关键字创建一个实例然后打印出和的值以及调用方法类的构造函数在类中构造函数是一种特殊的方法用于在创建类的实例时进行初始化操作构造函数使用关键字来定义可以接收参数并在创建对象时调用构造函数的基本语法复制代码书写构造函数的逻辑在上面的代码中是类的名称等表示构造函数的参数名等表示参数的类型使用构造函数初始化成员变量构造函数可以用来初始化类中的成员变量通过接收构造函数的参数并将其赋给对应的成员变量成员变量的声明通常放在类的顶部而初始化则在构造函数中进行复制代码在上述示例中构造函数接收和作为参数并将参数的值分别赋给类中的和成员变量创建类的实例并调用构造函数使用关键字创建类的实例时构造函数会被自动调用让我们可以在创建实例的同时进行初始化操作复制代码在上述代码中我们创建了一个类的实例并传递了和作为构造函数的参数构造函数会将这些参数的值分别赋给实例的和成员变量构造函数的可选参数和默认值构造函数的参数可以设置为可选的并且可以为参数提供默认值可选参数使用问号修饰符进行标记而默认值则使用等号进行赋值复制代码创建实例但不传递和参数输出输出创建实例只传递参数输出输出创建实例同时传递和参数输出输出在上述示例中参数具有一个默认值而参数则是可选的如果在创建实例时不传和参数那么会输出默认值而会被设置为如果在创建实例时只传递了参数而没有传递参数那么也会被设置为调用其他构造函数构造函数重载在一个类中可以定义多个构造函数并通过不同的参数配置来进行重载重载的构造函数之间可以相互调用使用关键字来引用当前类的实例构造函数重载需要定义多个具有不同参数类型和数量的构造函数签名构造函数签名是指构造函数名称和参数列表通过这些不同的签名来区分不同的构造函数复制代码书写构造函数实现的逻辑在上面的示例中我们定义了三个构造函数签名每个签名有不同的参数类型和数量以提供不同的构造函数选项复制代码输出输出在上述示例中我们定义了两个构造函数签名第一个构造函数接收一个参数第二个构造函数接收一个和一个参数在构造函数的实现中根据传递的参数情况决定是否给成员变量赋值接着我们创建了两个实例和第一次实例化传递了一个参数调用了第一个构造函数第二次实例化传递了一个参数和一个参数调用了第二个构造函数注意成员初始化比如后才可以通过来访问实例成员需要为构造函数指定类型注解否则会被隐式推断为类型构造函数不需要返回值类型类的实例方法在类中实例方法是定义在类中的成员方法用于操作和访问类的实例属性并执行特定的操作实例方法可以通过类的实例来调用用于对特定实例进行特定操作定义实例方法实例方法是通过在类中定义普通函数来创建的语法格式如下复制代码书写方法的实现逻辑在上面的示例中是实例方法的名称和是方法的参数和是参数的类型是方法的返回类型访问实例属性实例方法可以通过使用关键字直接访问类的实例属性复制代码在上述示例中是一个实例方法它访问了类的和属性并在控制台打印出相应的消息调用实例方法实例方法必须通过类的实例来调用复制代码输出在上述示例中我们首先创建了一个类的实例然后使用实例来调用方法类的继承类的继承有种方式继承父类实现接口说明中只有而是提供的继承父类当一个类继承另一个类时它会继承父类的属性和方法并可以通过重载或添加新的属性和方法来扩展父类继承使用关键字来建立类之间的关系定义父类和子类父类是被继承的类子类是继承父类的类复制代码书写父类的属性和方法书写子类特有的属性和方法在上面的示例中是父类是子类继承了的属性和方法继承父类的属性和方法使用关键字来建立子类对父类的继承关系子类会继承父类的公共成员属性和方法子类可以直接访问和使用继承来的属性和方法复制代码在上述示例中是父类其中包含了属性和方法是子类使用建立了继承关系继承了的属性和方法并且定义了自己的方法调用继承的属性和方法子类可以直接调用继承来的父类属性和方法也可以访问自己定义的属性和方法复制代码调用继承来自父类的方法输出调用子类自己定义的方法输出在上述示例中我们首先创建了一个类的实例我们可以通过实例调用继承自父类的方法也可以调用子类自己定义的方法实现接口接口的实现是以类为基础的类可以通过关键字实现一个或多个接口通过实现接口类必须提供接口中定义的所有属性和方法的具体实现定义接口接口是一种抽象的类型定义了一组属性和方法的规范接口在定义时不包含具体的实现而是描述了类应具备的特定行为和功能复制代码书写接口的属性和方法在上面的示例中是一个接口用于定义属性和方法的规范使用实现接口使用关键字来实现接口使得类能够满足接口定义的规范通过实现接口类必须提供接口中定义的所有属性和方法的具体实现复制代码书写类的属性和方法的具体实现在上述示例中是一个类通过实现了接口从而满足了接口定义的规范实现接口的属性和方法实现接口的类必须包含接口中定义的所有属性和方法并提供它们的具体实现复制代码输出在上面的示例中是一个接口定义了属性和方法类通过实现了接口并提供了接口中定义的属性和方法的具体实现类的修饰符在中类的修饰符用于控制类的成员属性和方法的可见性和访问权限类的修饰符包括公有的可以在任何地方被访问到默认所有的属性和方法都是的私有的不能在声明它的类的外部访问受保护的和类似区别是它在子类中也是允许被访问的关键字是默认的访问修饰符如果不指定修饰符默认为公共成员在类的内部和外部都是可见的并且可以随时访问复制代码输出输出输出在上述示例中和都是公共成员可以在类的内部和外部进行访问关键字修饰符限制成员的访问范围仅在类的内部私有成员在类的外部不可见只能在类的内部进行访问复制代码输出报错属性为私有属性只能在类中访问在上述示例中成员是私有成员只能在类的内部进行访问外部访问会报错注意使用修饰的属性或方法在子类中也是不允许访问的复制代码报错属性为私有属性只能在类中访问注意当构造函数修饰为时该类不允许被继承或者实例化复制代码报错无法扩展类类构造函数标记为私有报错类的构造函数是私有的仅可在类声明中访问关键字修饰符限制成员的访问范围在类的内部及其派生类中受保护成员在类的外部不可见但可以在类的内部和派生类中进行访问复制代码输出注意当构造函数修饰为时该类只允许被继承复制代码报错类的构造函数是受保护的仅可在类声明中访问是一个只读属性关键字只允许出现在属性声明或索引签名或构造函数中复制代码输出报错无法为赋值因为它是只读属性注意如果和其他访问修饰符同时存在的话需要写在其后面复制代码只读属性特点只读属性必须在声明时或索引签名或构造函数内进行初始化赋值只读属性不能被重新赋值或修改否则会报错只能修饰属性不能修饰方法只读属性和常量的区别只读属性是提供的一种语法用于将类的属性标记为只读并且只有在类的内部可以修改其值常量通常是通过关键字声明的在任何地方都无法修改其值包括类的内部参数属性参数属性是一种简化代码的语法糖用于在构造函数中同时声明和初始化类的成员属性使用参数属性可以在一个地方完成属性的声明和赋值减少了重复的代码复制代码输出报错属性为私有属性只能在类中访问报错属性受保护只能在类及其子类中访问输出在上述示例中定义了一个名为的类类里面定义了一个构造方法其中参数是公共属性可以在类的内部和外部访问参数是私有属性只能在类中访问参数是受保护属性只能在类及其子类中访问参数是只读属性类的外部无法修改其值抽象类使用关键字用于定义抽象类和其中的抽象方法抽象类是一种不能直接实例化的类它主要用作其他类的基类抽象类可以包含抽象方法和具体方法的定义供子类继承和实现语法复制代码抽象方法具体方法在上述示例中是一个抽象类它包含了一个抽象方法和一个具体方法抽象方法抽象方法是在抽象类中声明但没有具体实现的方法它只包含方法的签名没有方法体子类必须实现抽象方法复制代码输出在上述示例中抽象类中的是一个抽象方法子类继承了父类并实现了抽象方法抽象类不能被实例化只能被继承抽象类不能被实例化只能被继承复制代码报错无法创建抽象类的实例特点抽象类不能被实例化只能被继承抽象类可以包含抽象方法和具体方法的定义子类必须实现抽象类中的所有抽象方法否则子类也必须声明为抽象类如果一个类继承了一个抽象类那么它必须实现抽象类中的抽象方法除非它自身也声明为抽象类抽象类可以作为其他类的基类用于提供共享的属性和方法定义十类型兼容性类型兼容性是指在中如何判断一个类型是否能够赋值给另一个类型基本类型的兼容性相同的基本类型可以互相赋值当你声明一个变量并为其赋予一个特定类型的值时会根据类型注解进行类型检查和推断如果变量的类型与给定的值的类型完全匹配那么它们可以互相赋值复制代码输出在上述示例中变量被声明为类型并且被赋值为然后将变量赋值给变量因为和的类型相同都是所以赋值是允许的数字字面量类型可以赋值给数值类型当你声明一个变量并为其指定为数字字面量类型时会将该变量视为一个特定的数字值而不仅仅是一般的数值类型复制代码输出在这个示例中变量被声明为数字字面量类型它只能具有值而不能是其它的值然后将变量赋值给变量因为的类型是而是数字字面量类型数字字面量类型是数字类型的子类型所以赋值是允许的需要注意的是只有字面量类型才可以赋值给相应的数值类型普通数值类型不能赋值给字面量类型除非两者完全匹配枚举类型可以赋值给数字类型枚举类型在中被编译成了一个具有反向映射的对象默认情况下枚举类型的成员值是从开始递增的数字由于枚举成员值是数字类型所以它们可以被赋值给数字类型复制代码输出在上述示例中将赋值给了枚举类型的变量然后又将赋值给了数字类型的变量此时的值为与对应的枚举成员值相同需要注意的是枚举类型不仅可以赋值给数字类型也可以赋值给字面量类型或其他兼容的类型这主要是由于在类型系统中对枚举类型进行了特殊处理使得枚举成员值可以被当作相应的字面量值使用对象类型的兼容性对象类型包括接口类字面量对象等记住这句话成员多的可以赋值给成员少的成员个数的兼容性对象类型能够赋值给对象类型需要满足的条件是中的成员个数要大于等于中的成员个数也就是说可以拥有中的所有成员但可能还有额外的成员复制代码正确类拥有类中的所有成员错误类型中缺少属性但类型中需要该属性在上述示例中类具有和成员类比类多了一个成员根据兼容性规则可以赋值给因为类拥有类中的所有成员成员类型的兼容性对象类型能够赋值给对象类型需要满足的条件是中的每个成员的类型都能够赋值给中对应成员的类型这个规则适用于成员变量和成员函数复制代码正确的成员类型包含的成员类型错误类型中缺少属性但类型中需要该属性可选属性的兼容性对象类型能够赋值给对象类型如果中定义了可选属性且中没有对应的属性则仍然可以进行赋值复制代码可选属性正确虽然类型中没有属性但类型中属性是可选的错误类型中缺少属性但类型中需要该属性函数类型兼容性函数之间的兼容性会比较复杂需要考虑以下几个方面参数个数参数类型返回值类型参数个数源函数的参数个数要小于等于目标函数的参数个数也就是说源函数可以接受更少的参数或与目标函数相同数量的参数多余的参数是允许的因为在函数调用时可以忽略它们记住这句话参数少的可以赋值给参数多的复制代码正确的参数个数少于的参数个数错误的参数个数多于的参数个数在上述示例中我们定义了两个类型和分别表示加法函数和计算函数根据函数兼容性规则可以赋值给因为的参数个数个少于的参数个数个但是相反的赋值会导致兼容性错误因为的参数个数个要多于的参数个数个参数类型复制代码正确错误在上述示例中函数的参数只有一个类型为函数的参数有两个和类型分别为和可以赋值给是因为的每个参数都能在里找到对应类型的参数注意的是参数的名字相同与否无所谓只看它们的类型而不能赋值给因为有个必需的第二个参数但是并没有所以不允许赋值返回值类型如果返回值类型是普通类型此时函数的返回值类型要相同复制代码正确正确如果返回值类型是对象类型此时成员多的可以赋值给成员少的复制代码正确错误类类型兼容性类与对象字面量和接口差不多但有一点不同类有静态部分和实例部分的类型比较两个类类型的对象时只有实例的成员会被比较静态成员和构造函数不在比较的范围内复制代码正确正确私有的和受保护的成员必须来自于相同的类或者父类的派生类复制代码正确正确错误错误泛型类型兼容性当泛型类型没有明确指定类型参数时它被认为是一种特殊的兼容性形式称为类型参数的默认即泛型函数或泛型类在没有传递类型参数的情况下它们的类型参数会被推导为此时泛型类型可以兼容任意类型也能赋值给其他泛型类型复制代码正确类型参数的默认能兼容任意类型正确指定的类型参数是也能赋值给类型参数的默认当泛型类型明确指定了类型参数时要求类型参数具有兼容的类型这意味着泛型类型在传递不同类型参数时需要确保它们之间满足兼容性规则复制代码报错不能将类型分配给类型报错不能将类型分配给类型十一交叉类型交叉类型类似于接口继承是将多个类型合并为一个类型也就是说我们可以把现有的多种类型叠加到一起成为一种类型它包含了所需的所有类型的特性使用符号来定义交叉类型组合对象类型复制代码在上述示例中我们定义了和两个类型然后使用交叉类型将连接起来创建了一个新的类型该类型包含了和类型的所有成员接着我们定义了一个变量该变量同时具有和类型的属性和方法合并函数类型复制代码输出输出在上述示例中我们定义了两个函数类型和里面定义了函数里面定义了函数并使用交叉类型将连接起来创建了一个新的类型此时变量同时拥有和两个方法交叉类型接口继承相同点都可以实现对象类型的组合不同点两种方式实现类型组合时对于同名属性之间处理类型冲突的方式不同下面是接口继承的示例接口继承接口两个接口都定义了方法返回值都是类型但是参数的类型不同一个一个由于参数的类型不兼容所以接口不能继承接口复制代码下面是交叉类型的示例我们定义了和两个接口然后使用交叉类型将连接起来创建了一个新的类型接着我们定义了一个变量类型为变量调用方法此时参数的类型我们可以传数字类型或者字符串类型复制代码正确正确注意如果合并的多个接口类型存在同名属性会是什么效果呢复制代码错误不能将类型分配给类型错误不能将类型分配给类型在上面示例中定义了两个类型和其中类型中有和属性类型中有和属性两个类型都有同名的属性但类型不同一个是一个是合并后属性的类型就是和两个原子类型的交叉类型即此时我们如果赋予任意类型的属性值都会提示类型错误而如果我们不设置属性又会提示一个缺少必选的属性的错误在这种情况下就意味着上述代码中交叉出来的类型是一个无用类型如果同名属性的类型兼容比如一个是另一个是的子类型数字字面量类型合并后属性的类型就是两者中的子类型复制代码正确错误不能将类型分配给类型在上面示例中属性的类型就是数字字面量类型因此我们不能把任何非之外的值赋予属性如果交叉类型中的某个成员是对象类型那么交叉后的类型将拥有这些对象类型的所有属性复制代码输出十二泛型什么是泛型泛型是中一种允许我们在定义函数类或接口时使用参数化类型的机制泛型可以看作是类型参数类似于函数中的参数但是用于表示类型而不是值它允许我们在定义函数类或接口时使用占位符表示类型并在实际使用时指定具体的类型一个简单的例子现在我们有个需求实现一个函数传入的函数参数是什么类型的返回值的类型也要跟函数参数的类型相同并且函数只能接收一个参数你会怎么做复制代码输出类型是上面的示例中我们创建了一个函数参数值和返回值类型都为调用函数传入一个数字会返回数字本身但是该函数只能接收数值类型如果我调用函数的时候传入字符串或者布尔值类型的值此时就会报错复制代码报错类型的参数不能赋值给类型的参数为了让函数能够接收任意类型可以将参数类型改为但是这样就失去了的类型保护类型不安全复制代码输出输出输出输出输出为了解决上面的这些问题我们使用泛型对上面的代码进行重构泛型在保证类型安全不丢失类型信息的同时可以让函数等于多钟不同的类型一起工作灵活可复用复制代码输出输出输出上面示例中我们在函数名后添加了其中代表在定义泛型时通常用作第一个类型变量名称但实际上可以用任何有效名称代替在调用函数时在中指定类型此时参数和返回值类型也都为泛型语法在函数名称的后面添加尖括号尖括号中添加类型变量比如下图中的其中代表可以是任意合法的变量名称类型变量是一种特殊类型的变量它用于处理类型而不是值该类型变量相当于一个类型容器能够捕获用户提供的类型具体是什么类型由用户调用该函数时指定因为是类型因此可以将其作为函数参数和返回值的类型表示参数和返回值具有相同的类型复制代码在下面的示例中调用泛型函数当传入类型后这个类型就会被函数声明时指定的类型变量捕获到此时的类型就是所以函数的参数和返回值的类型也都是简化调用泛型函数在调用泛型函数时可以省略类型来简化泛型函数的调用此时内部会采用一种叫做类型参数推断的机制来根据传入的实参自动推断出类型变量的类型当编译器无法推断类型或者推断的类型不准确时就需要显示地传入类型参数比如传入实参会自动推断出变量的类型并作为的类型复制代码多个类型参数定义泛型的时候可以一次定义多个类型参数复制代码上述示例中我们定义了一个函数用来交换输入的元组泛型类泛型类是指在定义类时使用泛型类型参数的类它允许我们在类的属性方法构造函数以及实例化时使用泛型在名称后面添加类型变量这个类就变成了泛型类在创建实例时在类名后面通过类型来指定明确的类型下面是一个简单的泛型类的示例复制代码实例化一个泛型类指定类型参数为输出泛型接口在接口名称的后面添加类型变量那么这个接口就变成了泛型接口接口的类型变量对接口中所有其它成员可见也就是接口中所有成员都可以使用类型变量使用泛型接口时需要显示指定具体的类型下面是一个简单的泛型接口的示例复制代码泛型参数的默认类型在以后我们可以为泛型中的类型参数指定默认类型当使用泛型时没有在代码中直接指定类型参数从实际值参数中也无法推测出时这个默认类型就会起作用复制代码泛型约束默认情况下泛型函数的类型参数理论上是可以是任何类型的不同于你不管使用它的什么属性或者方法都会报错除非这个属性和方法是所有集合共有的比如下面的示例中我想打印出参数的属性如果不进行泛型约束是会报错的类型上不存在属性报错的原因很明显如果要解决这个问题我们就可以通过给泛型类型变量添加约束下面我们通过关键字进行类型约束复制代码正确因为数组有属性正确因为字符串有属性正确因为传入的参数有舒心报错类型不能赋值给类型的参数因为数字不具有属性在上述示例中我们定义了一个接口具有属性在泛型函数中使用进行约束该约束表示传入的类型必须具有属性十三中的关键字内置了一些常用的工具类型来简化中一些常见的操作它们都是基于泛型实现的并且是内置的所以可以直接使用在学习工具类型之前我们先学习一些关键字和基础知识以便我们可以更好的去学习后面的内置工具类型在中操作符主要用途是用于获取类型中所有键的关键字它用于泛型中通常与索引类型结合使用其返回类型是联合类型下面示例中我们定义了一个接口包含和三个键然后使用来获取接口的所有键这样类型就是一个由构成的联合字面量类型复制代码下面示例中我们创建一个函数来获取对象中属性的值复制代码输出输出输出在中是一种泛型约束方式用于限制一个泛型类型参数的范围关键字表示限制的取值只能是类型中已有的属性名可以理解为只能是所有键中的任意一个或者说只能访问对象中存在的属性在上面的例子中函数接收两个参数一个泛型类型参数代表输入对象的类型一个泛型类型参数代表属性名的类型实际上获取的是对象所有键的联合字面量类型也就是当我们调用调用函数传入一个不存在的属性名例如会引发编译错误在中操作符的主要用途是在类型上下文中获取变量或者属性的类型获取变量的声明类型在中可以用来返回一个变量的声明类型如果不存在则获取该类型的推论类型复制代码等同于等同于等同于等同于需要注意的是作为类型操作符后面只能跟变量复制代码正确错误如果变量没有声明类型返回变量的推断类型如果变量没有明确声明类型将返回变量的推断类型此时关键字声明的变量可以被重新赋值复制代码等同于可以被重新赋值正确报错不能将类型分配给类型有时候我们希望变量是常量不允许被重新赋值关键字可以解决这个问题此时基于类型推断返回类型是等号右边的字面量类型例如下面示例中返回的是字面量类型不是字符串复制代码等同于报错无法分配到因为它是常数在中引入了一种新的字面量构造方式断言在断言作用下即使是声明也可以限制类型扩展变量不能被重新赋值例如下面示例中返回的是字面量类型不是字符串复制代码等同于报错无法分配到分配给类型当我们使用断言构造新的字面量表达式时应注意以下几点表达式中的任何字面量类型都不应该被扩展对象字面量的属性将使用修饰数组字面量将变成元组复制代码等同于等同于等同于如果变量明确声明了类型推断类型不受影响返回的声明类型而不是字面量类型但是变量依然不能被重新赋值复制代码等同于报错无法分配到因为它是常数与对象结合使用与对象结合使用可以用来获取对象的结构类型以及使用该类型来声明新的变量或函数参数等获取对象的类型复制代码相当于在上述示例中返回的是对象的类型即声明新变量的类型为对象的类型复制代码输出在上述示例中我们使用将的类型声明为并赋予了新的值在函数参数中使用对象的类型复制代码输出在上述示例中函数接收一个参数其类型为即接收与对象相同类型的参数需要注意的是运算符用于获取对象类型是在静态类型检查阶段进行的而不是在运行时期执行的因此它只提供了类型信息而不会直接访问对象的值与接口结合使用与接口结合使用可以用于创建新类型该类型的属性和方法将与给定对象类型保持一致复制代码在上述实例中定义了一个名为的接口然后创建一个对象类型为接着使用来创建一个新的类型该类型的属性和方法将与接口中定义的属性和方法保持一致这样我们就可以基于来创建新的对象需要注意的是运算符与接口结合使用通常适用于已存在的对象它提取已知对象的类型用于创建新的类型它不会用于动态创建对象或实例化类与结合使用主要用于获取类型的所有属性键可以与结合使用获取某个类型的键集合复制代码等同于在中操作符的主要用于遍历目标类型的属性值类似一般结合一起使用遍历枚举类型复制代码遍历联合类型复制代码用于泛型函数复制代码必须是或类型正确正确错误布尔类型不符合约束条件用于泛型类复制代码必须是具有属性的类型正确输出错误数字类型没有属性用于类继承复制代码调用继承来自父类的方法输出调用子类自己定义的方法输出用于继承接口复制代码用于类型约束复制代码正确因为数组有属性正确因为字符串有属性正确因为传入的参数有舒心报错类型不能赋值给类型的参数因为数字不具有属性用于条件类型引入了条件类型表达式类似于三元运算符复制代码如果泛型参数为或那么取否则直接返回是类型因为不是的子集是类型因为是的子集条件类型也支持嵌套复制代码十四泛型工具类型泛型工具类型这一章节相关的内容我想放到其它文章中来讲因为这里涉及到的知识点有点多一时半会写不完大家可以持续关注我精力有限尽量做到每周更十五总结如果文章有什么错误欢迎大家在评论区指正如果觉得本文对您有帮助的话欢迎点赞收藏哦',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-01 11:36:41',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://mydocs.guoyaxue.top/" title="旧版博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="旧版博客"/><span class="back-menu-item-text">旧版博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://pan.xiaou61.top/#/" title="免费网盘"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="免费网盘"/><span class="back-menu-item-text">免费网盘</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://cloud.xiaou61.top/" title="云盘(自用)"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="云盘(自用)"/><span class="back-menu-item-text">云盘(自用)</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://wpzc.xiaou61.top/" title="云盘转存"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="云盘转存"/><span class="back-menu-item-text">云盘转存</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://love.xiaou61.top/#/" title="关于我们(My girlFriend)"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="关于我们(My girlFriend)"/><span class="back-menu-item-text">关于我们(My girlFriend)</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">娱乐项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://fxq.xiaou61.top/#/" title="飞行棋"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="飞行棋"/><span class="back-menu-item-text">飞行棋</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/game/sqnwmai803/" title="谁去拿外卖"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="谁去拿外卖"/><span class="back-menu-item-text">谁去拿外卖</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/desktop.html" title="win12网页版"><img class="back-menu-item-icon" src="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/icon/logo.svg" alt="win12网页版"/><span class="back-menu-item-text">win12网页版</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://game.xiaou61.top/" title="在线游戏"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="在线游戏"/><span class="back-menu-item-text">在线游戏</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">小u的博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 开往</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><span> 开往</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>3</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JVM/" style="font-size: 1.05rem;">JVM<sup>22</sup></a><a href="/tags/Nginx/" style="font-size: 1.05rem;">Nginx<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>1</sup></a><a href="/tags/Ts/" style="font-size: 1.05rem;">Ts<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size: 1.05rem;">TypeScript<sup>1</sup></a><a href="/tags/WebApi/" style="font-size: 1.05rem;">WebApi<sup>1</sup></a><a href="/tags/coder1v5/" style="font-size: 1.05rem;">coder1v5<sup>2</sup></a><a href="/tags/css/" style="font-size: 1.05rem;">css<sup>3</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>12</sup></a><a href="/tags/javaSE/" style="font-size: 1.05rem;">javaSE<sup>3</sup></a><a href="/tags/javaWeb/" style="font-size: 1.05rem;">javaWeb<sup>2</sup></a><a href="/tags/js%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">js逆向<sup>1</sup></a><a href="/tags/leetcode/" style="font-size: 1.05rem;">leetcode<sup>3</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>8</sup></a><a href="/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/" style="font-size: 1.05rem;">书籍推荐<sup>2</sup></a><a href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%90%AC%E8%BF%90/" style="font-size: 1.05rem;">公众号搬运<sup>35</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 1.05rem;">前端<sup>10</sup></a><a href="/tags/%E5%8A%9E%E5%85%AC/" style="font-size: 1.05rem;">办公<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 1.05rem;">后端<sup>8</sup></a><a href="/tags/%E5%A4%A9%E6%B6%AF%E8%AE%BA%E5%9D%9B/" style="font-size: 1.05rem;">天涯论坛<sup>1</sup></a><a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 1.05rem;">导航<sup>1</sup></a><a href="/tags/%E5%B0%B1%E4%B8%9A/" style="font-size: 1.05rem;">就业<sup>16</sup></a><a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 1.05rem;">微信<sup>1</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/" style="font-size: 1.05rem;">技术杂谈<sup>51</sup></a><a href="/tags/%E6%8E%98%E9%87%91/" style="font-size: 1.05rem;">掘金<sup>14</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 1.05rem;">杂项<sup>1</sup></a><a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 1.05rem;">测试<sup>1</sup></a><a href="/tags/%E6%B8%A1%E4%B8%80%E5%A4%A7%E5%B8%88%E8%AF%BE/" style="font-size: 1.05rem;">渡一大师课<sup>3</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 1.05rem;">爬虫<sup>1</sup></a><a href="/tags/%E7%9B%AE%E5%BD%95/" style="font-size: 1.05rem;">目录<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>4</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 1.05rem;">虚拟机<sup>12</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>6</sup></a><a href="/tags/%E8%B7%AF%E9%A3%9E%E5%AD%A6%E9%99%A2/" style="font-size: 1.05rem;">路飞学院<sup>3</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">面向对象<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>51</sup></a><a href="/tags/%E9%A3%9E%E8%A1%8C%E6%A3%8B/" style="font-size: 1.05rem;">飞行棋<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">234</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">September 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">May 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8E%98%E9%87%91/" itemprop="url">掘金</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E6%8E%98%E9%87%91/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>掘金</span></a></span></div></div><h1 class="post-title" itemprop="name headline">【全文8W字】我是怎样从0开始学会🚀TypeScript🚀的</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-10-01T03:28:14.000Z" title="Created 2023-10-01 11:28:14">2023-10-01</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-10-01T03:36:41.717Z" title="Updated 2023-10-01 11:36:41">2023-10-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为邯郸"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>邯郸</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><div class="post-ai-description"><div class="ai-title"><i class="anzhiyufont anzhiyu-icon-bilibili"></i><div class="ai-title-text">AI-摘要</div><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i><i class="anzhiyufont anzhiyu-icon-circle-dot" title="朗读摘要"></i><div id="ai-tag">Tianli GPT</div></div><div class="ai-explanation">AI初始化中...</div><div class="ai-btn-box"><div class="ai-btn-item">介绍自己 🙈</div><div class="ai-btn-item">生成本文简介 👋</div><div class="ai-btn-item">推荐相关文章 📖</div><div class="ai-btn-item">前往主页 🏠</div><div class="ai-btn-item" id="go-tianli-blog">前往爱发电购买</div></div><script data-pjax src="/js/anzhiyu/ai_abstract.js"></script></div><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2023/10/01/%E6%8E%98%E9%87%91%E6%94%B6%E8%97%8F/8/"><header><a class="post-meta-categories" href="/categories/%E6%8E%98%E9%87%91/" itemprop="url">掘金</a><a href="/tags/%E6%8E%98%E9%87%91/" tabindex="-1" itemprop="url">掘金</a><h1 id="CrawlerTitle" itemprop="name headline">【全文8W字】我是怎样从0开始学会🚀TypeScript🚀的</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小u</span><time itemprop="dateCreated datePublished" datetime="2023-10-01T03:28:14.000Z" title="Created 2023-10-01 11:28:14">2023-10-01</time><time itemprop="dateCreated datePublished" datetime="2023-10-01T03:36:41.717Z" title="Updated 2023-10-01 11:36:41">2023-10-01</time></header><h1 id="【全文8W字】我是怎样从0开始学会🚀TypeScript🚀的"><a href="#【全文8W字】我是怎样从0开始学会🚀TypeScript🚀的" class="headerlink" title="【全文8W字】我是怎样从0开始学会🚀TypeScript🚀的"></a>【全文8W字】我是怎样从0开始学会🚀TypeScript🚀的</h1><p>一边学习，一边记录，前前后后花了至少2个月的时间，算是把TS大部分都搞明白了。</p>
<p>这篇文章的篇幅有点长，是我本人学习过程中的一些记录，参考了很多优秀博主的一些文章，以及在B站看了一些TS的视频，把几乎所有TS涵盖到的基础知识点都总结了下来，所以，对于想学习TS的小伙伴下来，一定一定要认认真真把这篇文章看完。</p>
<p><strong>8万多字的教程，不敢说是全网最好，但可以说是全网最详细。</strong></p>
<p>对于新手入门来说是一篇非常不错的宝藏文章，几乎每个 TypeScript 的知识点都有详细的讲到，并且附上一些简单的示例，通俗易懂，希望可以给想学习 TS 的小伙伴带来动力！</p>
<h1 id="一、了解TypeScript"><a href="#一、了解TypeScript" class="headerlink" title="一、了解TypeScript"></a>一、了解TypeScript</h1><h2 id="1-什么是TypeScript"><a href="#1-什么是TypeScript" class="headerlink" title="1. 什么是TypeScript"></a>1. 什么是TypeScript</h2><ul>
<li>TypeScript是由微软开发的一门开源的编程语言。</li>
<li>TypeScript，简称TS，是JavaScript的超集（以JavaScript为基础构建的语言，JS有的TS都有）。</li>
<li>Typescript &#x3D; Type + JavaScript（在JS基础之上，为JS添加了类型支持）。</li>
<li>可以在任何支持JavaScript的平台中执行。</li>
</ul>
<h2 id="2-为什么需要TypeScript"><a href="#2-为什么需要TypeScript" class="headerlink" title="2. 为什么需要TypeScript"></a>2. 为什么需要TypeScript</h2><p>我们都知道，JavaScript是弱类型的编程语言，很多的错误只有在运行的时候才会被发现，而TS在代码编译的时候（代码执行前）就可以发现错误。</p>
<h2 id="3-TypeScript的特点"><a href="#3-TypeScript的特点" class="headerlink" title="3. TypeScript的特点"></a>3. TypeScript的特点</h2><ul>
<li>支持最新的ECMAScript语法</li>
<li>在代码编译阶段就能发现错误</li>
<li>在JS基础上增加了类型支持</li>
</ul>
<h2 id="4-TypeScript和JavaScript的区别"><a href="#4-TypeScript和JavaScript的区别" class="headerlink" title="4. TypeScript和JavaScript的区别"></a>4. TypeScript和JavaScript的区别</h2><table>
<thead>
<tr>
<th><strong>TypeScript</strong></th>
<th><strong>JavaScript</strong></th>
</tr>
</thead>
<tbody><tr>
<td>编译期发现错误</td>
<td>运行时发现错误</td>
</tr>
<tr>
<td>强类型语言，支持静态和动态类型</td>
<td>弱类型语言，没有静态类型选项</td>
</tr>
<tr>
<td>支持模块、泛型和接口</td>
<td>不支持模块、泛型和接口</td>
</tr>
<tr>
<td>代码运行时会被编译成JavaScript代码，浏览器才能识别</td>
<td>可以直接在浏览器使用</td>
</tr>
</tbody></table>
<h1 id="二、TypeScript环境搭建"><a href="#二、TypeScript环境搭建" class="headerlink" title="二、TypeScript环境搭建"></a>二、TypeScript环境搭建</h1><h2 id="1-安装编译TS的工具包"><a href="#1-安装编译TS的工具包" class="headerlink" title="1. 安装编译TS的工具包"></a>1. 安装编译TS的工具包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g typescript</span><br></pre></td></tr></table></figure>

<h2 id="2-验证TS是否安装成功"><a href="#2-验证TS是否安装成功" class="headerlink" title="2. 验证TS是否安装成功"></a>2. 验证TS是否安装成功</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc -v</span><br></pre></td></tr></table></figure>

<h2 id="3-TypeScript初体验"><a href="#3-TypeScript初体验" class="headerlink" title="3. TypeScript初体验"></a>3. TypeScript初体验</h2><ol>
<li>创建一个TS文件，hello.ts（注意：TS文件的后缀名为 <strong>.ts</strong>），并输入以下的内容</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`hello, <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="string">&quot;Echo&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greet</span>(<span class="string">&quot;Echo&quot;</span>))</span><br></pre></td></tr></table></figure>

<ol>
<li>将TS文件编译为JS文件，在终端中输入命令：<strong>tsc hello.ts，</strong> （此时，在同级目录中会出现一个同名的JS文件）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="string">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span>.<span class="title function_">concat</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="string">&quot;Echo&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greet</span>(user));</span><br></pre></td></tr></table></figure>

<ol>
<li>执行JS代码：在终端中输入命令，<strong>node hello.js</strong>，终端会输出 hello, Echo。</li>
</ol>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arduino</span><br><span class="line">复制代码<span class="string">&quot;hello, Echo&quot;</span> </span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132467.webp" alt="img"></p>
<h2 id="4-简化运行TS的步骤"><a href="#4-简化运行TS的步骤" class="headerlink" title="4. 简化运行TS的步骤"></a>4. 简化运行TS的步骤</h2><p>每次修改代码后，都要重复执行两个命令，才能运行TS代码，我们可以直接使用<strong>ts-node</strong>工具包，直接在node.js中执行TS代码。</p>
<p>安装命令：<strong>npm i -g ts-node</strong></p>
<p>使用方式：<strong>ts-node hello.ts</strong></p>
<h2 id="5-运行TS文件的另一种方法"><a href="#5-运行TS文件的另一种方法" class="headerlink" title="5. 运行TS文件的另一种方法"></a>5. 运行TS文件的另一种方法</h2><p>在VSCode中安装<strong>Code Runner</strong>扩展插件，在需要运行的ts文件中按鼠标右键，选择<strong>Run Code</strong>(快捷键：<strong>Ctrl+Alt+N</strong>)。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132463.webp" alt="img"></p>
<h2 id="6-TypeScript-Playground线上环境"><a href="#6-TypeScript-Playground线上环境" class="headerlink" title="6. TypeScript Playground线上环境"></a>6. TypeScript Playground线上环境</h2><p>对于刚入门TypeScript的小伙伴来说，我们可以不用安装本地的运行环境，而是直接使用线上的 <a href="https://link.juejin.cn/?target=https://www.typescriptlang.org/play?%23code/GYVwdgxgLglg9mABAcwKZQGIgDbYHICGAtqgBTAwBOAzlISQFyK2UxjIA0i2Bt9qTFm2QBKQVFbtEAbwCwAKESJK6EJSQUadYqkQBqRACIA+of3de2kgoC+ChRAS1EoXP0QBeFOixudpQwBRCAALOEMuQwAFVHZDEQcnOGxUADpsOGRyHHwdESA">TypeScript Playground</a>，我们就可以在浏览器中学习和编写TypeScript代码，通过配置TS Config的Target，可以设置不同的编译目标，从而编译生成不同的目标代码。</p>
<h1 id="三、TypeScript类型注解"><a href="#三、TypeScript类型注解" class="headerlink" title="三、TypeScript类型注解"></a>三、TypeScript类型注解</h1><h2 id="1-类型注解作用"><a href="#1-类型注解作用" class="headerlink" title="1. 类型注解作用"></a>1. 类型注解作用</h2><p><strong>TS类型注解的作用是为变量、函数、类等添加类型信息，用于在静态类型检查阶段检查代码的类型正确性。</strong></p>
<h2 id="2-类型注解用途"><a href="#2-类型注解用途" class="headerlink" title="2. 类型注解用途"></a>2. 类型注解用途</h2><ol>
<li>提供类型提示：类型注解使得开发人员可以清晰地知道变量的类型，编辑器能够根据类型注解给出相应的代码提示，提高代码的可读性和可维护性。</li>
<li>静态类型检查：通过给变量添加类型注解，在编译阶段可以对代码进行静态类型检查。它会检查变量的类型是否符合预期的类型，并发现潜在的类型错误。</li>
<li>函数参数类型检查：类型注解可以帮助开发人员在编写函数时明确参数的类型，并在调用函数时进行参数类型检查。这样可以避免因参数类型不匹配引发的潜在错误。</li>
<li>对象属性类型约束：通过类型注解，可以约束对象的属性类型，确保对象的属性符合特定的类型要求。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132391.webp" alt="img"></p>
<p>例如，上述代码中的 <strong>: number</strong> 就是<strong>类型注解。</strong> 约定变量num的类型为number（数值类型）。</p>
<h2 id="3-类型注解注意事项"><a href="#3-类型注解注意事项" class="headerlink" title="3. 类型注解注意事项"></a>3. 类型注解注意事项</h2><ol>
<li><strong>约定了什么类型，就只能给变量赋值该类型的值</strong>，否则，就会报错。</li>
</ol>
<p>例如，我们将变量num的值123，重新赋值为字符串的“456”，此时我们就可以看到编辑器的错误提示：不能将类型“string”分配给类型“number”。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132412.webp" alt="img"></p>
<ol>
<li><strong>类型注解只在编译阶段起作用，并不会影响运行时的行为。</strong> 在编译后的 JavaScript 代码中，类型注解会被编译器忽略。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132393.webp" alt="img"></p>
<h1 id="四、TypeScript类型"><a href="#四、TypeScript类型" class="headerlink" title="四、TypeScript类型"></a>四、TypeScript类型</h1><h2 id="1-TS中常用的基础类型"><a href="#1-TS中常用的基础类型" class="headerlink" title="1. TS中常用的基础类型"></a>1. TS中常用的基础类型</h2><p>我们可以将TS中常用的基础类型分为两类：</p>
<ol>
<li>JS已有的类型</li>
<li>TS新增的类型</li>
</ol>
<p>JS已有的类型，我们又可以分为两类：</p>
<ol>
<li>原始数据类型：<strong>number、string、boolean、null、undefined、symbol（ES6中的新类型）、bigint（ES10中的新类型）。</strong></li>
<li>对象类型：<strong>object（包括数组、对象、函数等对象）。</strong></li>
</ol>
<p>TS新增的类型：<strong>any、void、自定义类型（类型别名）、联合类型、接口、元组、字面量类型、枚举等。</strong></p>
<h3 id="1-1-数值（number）"><a href="#1-1-数值（number）" class="headerlink" title="1.1. 数值（number）"></a>1.1. 数值（number）</h3><p>和JS一样，TS里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TS还支持ECMAScript 2015中引入的二进制和八进制字面量。</p>
<p>在TS中，使用 <strong>number</strong> ****来定义数值类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">decLiteral</span>: <span class="built_in">number</span> = <span class="number">6</span></span><br><span class="line"><span class="comment">// 十六进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">hexLiteral</span>: <span class="built_in">number</span> = <span class="number">0xf00d</span></span><br><span class="line"><span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">binaryLiteral</span>: <span class="built_in">number</span> = <span class="number">0b1010</span></span><br><span class="line"><span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">octalLiteral</span>: <span class="built_in">number</span> = <span class="number">0o744</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">notANumber</span>: <span class="built_in">number</span> = <span class="title class_">NaN</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">infinityNumber</span>: <span class="built_in">number</span> = <span class="title class_">Infinity</span></span><br></pre></td></tr></table></figure>

<p>编译结果：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码// 十进制</span><br><span class="line">var <span class="attr">decLiteral</span> = <span class="number">6</span><span class="comment">;</span></span><br><span class="line">// 十六进制</span><br><span class="line">var <span class="attr">hexLiteral</span> = <span class="number">0</span>xf00d<span class="comment">;</span></span><br><span class="line">// 二进制</span><br><span class="line">var <span class="attr">binaryLiteral</span> = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">// 八进制</span><br><span class="line">var <span class="attr">octalLiteral</span> = <span class="number">484</span><span class="comment">;</span></span><br><span class="line">var <span class="attr">notANumber</span> = NaN<span class="comment">;</span></span><br><span class="line">var <span class="attr">infinityNumber</span> = Infinity<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-布尔值（boolean）"><a href="#1-2-布尔值（boolean）" class="headerlink" title="1.2. 布尔值（boolean）"></a>1.2. 布尔值（boolean）</h3><p>在TS中，使用 <strong>boolean</strong> 来定义布尔值类型：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini</span><br><span class="line">复制代码let flag: <span class="attr">boolean</span> = <span class="literal">false</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>编译结果：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini</span><br><span class="line">复制代码var <span class="attr">flag</span> = <span class="literal">false</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-字符串（string）"><a href="#1-3-字符串（string）" class="headerlink" title="1.3. 字符串（string）"></a>1.3. 字符串（string）</h3><p>在TS中，使用 <strong>string</strong> 来定义字符串类型：</p>
<p>在TS中，字符串的表现形式主要有以下三种方式：</p>
<ol>
<li>使用单引号（ <strong>‘</strong> ）</li>
<li>使用双引号（ <strong>“</strong> ）</li>
<li>使用模板字符串，它可以定义多行文本和内嵌表达式。这种字符串是被反引号包围（ <strong>&#96;</strong> ），并且以 <strong>${ expr }</strong> 这种形式嵌入表达式</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">myName</span>: <span class="built_in">string</span> = <span class="string">&quot;Echo&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">sentence</span>: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123; myName &#125;</span>. I&#x27;ll be <span class="subst">$&#123; age + <span class="number">1</span>&#125;</span> years old next month.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面定义的sentence的语句与下面定义的sentence1语句的效果相同</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">sentence1</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello, my name is &quot;</span> + myName + <span class="string">&quot;. I&#x27;ll be &quot;</span> + ( age + <span class="number">1</span>) +<span class="string">&quot; years old next month.&quot;</span></span><br></pre></td></tr></table></figure>

<p>编译结果：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码var <span class="attr">myName</span> = <span class="string">&quot;Echo&quot;</span><span class="comment">;</span></span><br><span class="line">var <span class="attr">age</span> = <span class="number">25</span><span class="comment">;</span></span><br><span class="line">// 模板字符串</span><br><span class="line">var <span class="attr">sentence</span> = <span class="string">&quot;Hello, my name is &quot;</span>.concat(myName, <span class="string">&quot;. I&#x27;ll be &quot;</span>).concat(age + <span class="number">1</span>, <span class="string">&quot; years old next month.&quot;</span>)<span class="comment">;</span></span><br><span class="line">// 上面定义的sentence的语句与下面定义的sentence1语句的效果相同</span><br><span class="line">var <span class="attr">sentence1</span> = <span class="string">&quot;Hello, my name is &quot;</span> + myName + <span class="string">&quot;. I&#x27;ll be &quot;</span> + (age + <span class="number">1</span>) + <span class="string">&quot; years old next month.&quot;</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-null-和-undefined"><a href="#1-4-null-和-undefined" class="headerlink" title="1.4. null 和 undefined"></a>1.4. null 和 undefined</h3><p>null 和 undefined 是所有类型的子类型，默认情况下，可以把null 和 undefined赋值给其他类型。</p>
<p>注意：如果你将 tsconfig.json 文件中的 <strong>strictNullChecks</strong> 选项设置为 <strong>false</strong>，下面这种操作不会报错，不过尽量不要这么做。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码// 将 null 和 undefined 赋值给 string 类型</span><br><span class="line">let str: <span class="attr">string</span> = <span class="string">&quot;哈哈哈&quot;</span></span><br><span class="line"><span class="attr">str</span> = null</span><br><span class="line"><span class="attr">str</span> = undefined</span><br><span class="line"></span><br><span class="line">// 将 null 和 undefined 赋值给 number 类型</span><br><span class="line">let num: <span class="attr">number</span> = <span class="number">123</span></span><br><span class="line"><span class="attr">num</span> = null</span><br><span class="line"><span class="attr">num</span> = undefined</span><br><span class="line"></span><br><span class="line">// 将 null 和 undefined 赋值给 object 类型</span><br><span class="line">let obj: <span class="attr">object</span> = &#123;&#125;</span><br><span class="line"><span class="attr">obj</span> = null</span><br><span class="line"><span class="attr">obj</span> = undefined</span><br><span class="line"></span><br><span class="line">// 将 null 和 undefined 赋值给 boolean 类型</span><br><span class="line">let flag: <span class="attr">boolean</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">flag</span> = null</span><br><span class="line"><span class="attr">flag</span> = undefined</span><br><span class="line"></span><br><span class="line">// 将 null 和 undefined 赋值给 symbol 类型</span><br><span class="line">let sym: <span class="attr">symbol</span> = Symbol(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="attr">sym</span> = null</span><br><span class="line"><span class="attr">sym</span> = undefined</span><br><span class="line"></span><br><span class="line">// 将 null 和 undefined 赋值给 bigint 类型</span><br><span class="line">let big: <span class="attr">bigint</span> =  <span class="number">10</span>n<span class="comment">;</span></span><br><span class="line"><span class="attr">big</span> = null</span><br><span class="line"><span class="attr">big</span> = undefined</span><br></pre></td></tr></table></figure>

<p>编译结果：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码// 将 null 和 undefined 赋值给 string 类型</span><br><span class="line">var <span class="attr">str</span> = <span class="string">&quot;哈哈哈&quot;</span><span class="comment">;</span></span><br><span class="line"><span class="attr">str</span> = null<span class="comment">;</span></span><br><span class="line"><span class="attr">str</span> = undefined<span class="comment">;</span></span><br><span class="line">// 将 null 和 undefined 赋值给 number 类型</span><br><span class="line">var <span class="attr">num</span> = <span class="number">123</span><span class="comment">;</span></span><br><span class="line"><span class="attr">num</span> = null<span class="comment">;</span></span><br><span class="line"><span class="attr">num</span> = undefined<span class="comment">;</span></span><br><span class="line">// 将 null 和 undefined 赋值给 object 类型</span><br><span class="line">var <span class="attr">obj</span> = &#123;&#125;<span class="comment">;</span></span><br><span class="line"><span class="attr">obj</span> = null<span class="comment">;</span></span><br><span class="line"><span class="attr">obj</span> = undefined<span class="comment">;</span></span><br><span class="line">// 将 null 和 undefined 赋值给 boolean 类型</span><br><span class="line">var <span class="attr">flag</span> = <span class="literal">false</span><span class="comment">;</span></span><br><span class="line"><span class="attr">flag</span> = null<span class="comment">;</span></span><br><span class="line"><span class="attr">flag</span> = undefined<span class="comment">;</span></span><br><span class="line">// 将 null 和 undefined 赋值给 symbol 类型</span><br><span class="line">var <span class="attr">sym</span> = Symbol(<span class="string">&quot;abc&quot;</span>)<span class="comment">;</span></span><br><span class="line"><span class="attr">sym</span> = null<span class="comment">;</span></span><br><span class="line"><span class="attr">sym</span> = undefined<span class="comment">;</span></span><br><span class="line">// 将 null 和 undefined 赋值给 bigint 类型</span><br><span class="line">var <span class="attr">big</span> = <span class="number">10</span>n<span class="comment">;</span></span><br><span class="line"><span class="attr">big</span> = null<span class="comment">;</span></span><br><span class="line"><span class="attr">big</span> = undefined<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>注意：如果你在 <strong>tsconfig.json</strong> 文件中指定了“<strong>strictNullChecks：true</strong>”，null 和 undefined 只能赋值给 <strong>void</strong> 和它们各自的类型。</p>
<p>下面这种情况会报错：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132452.webp" alt="img"></p>
<h3 id="1-5-symbol"><a href="#1-5-symbol" class="headerlink" title="1.5. symbol"></a>1.5. symbol</h3><p><strong>symbol</strong> 是ES6新增的一种基本数据类型，<strong>Symbol()函数</strong> 会返回 <strong>symbol</strong> 类型的值，<strong>每个从 Symbol()函数 返回的 symbol 的值都是唯一的。</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">const</span> <span class="attr">sym1</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="attr">sym2</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;temp&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="attr">sym3</span>: <span class="built_in">symbol</span> = <span class="title class_">Symbol</span>(<span class="string">&#x27;temp&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>上面的代码创建了三个新的 symbol 类型，但是注意的是，每个从 Symbol()函数 返回的值都是唯一的。</p>
<p>此时，如果我们在控制台打印下面的代码，两者并不相等。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini</span><br><span class="line">复制代码console.log(<span class="attr">sym2</span> === sym3) // <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="1-6-bigint"><a href="#1-6-bigint" class="headerlink" title="1.6. bigint"></a>1.6. bigint</h3><p><strong>bigint</strong> 是ES10新增的一种基本数据类型，在JS中，可以用 Number 表示的最大整数为 2^53 - 1，可以写为 Number.MAX_SAFE_INTEGER。如果超过了这个界限，那么就可以用 BigInt 来表示，它可以表示任意大的整数。</p>
<p>在一个整数字面量后面加 n 的方式定义一个 bigint，或者调用函数 BigInt()。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码let big1: <span class="attr">bigint</span> = <span class="number">10</span>n</span><br><span class="line">let big2: <span class="attr">bigint</span> = BigInt(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">console.log(<span class="attr">big1</span> === big2) // <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="1-7-区别"><a href="#1-7-区别" class="headerlink" title="1.7. 区别"></a>1.7. 区别</h3><h4 id="1-7-1-null-和-undefined-的区别"><a href="#1-7-1-null-和-undefined-的区别" class="headerlink" title="1.7.1. null 和 undefined 的区别"></a>1.7.1. null 和 undefined 的区别</h4><ol>
<li>在JS中，null 表示“什么都没有”，而 undefined 是一个没有设置值的变量</li>
<li>用 typeof 检测 null，返回 object；typeof 一个没有值的变量会返回 undefined</li>
<li>null 是一个只有一个值的特殊类型，表示一个空对象的引用</li>
<li>null 和 undefined 是其它任何类型（包括void）的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined。而在TS中启用严格的空校验（strictNullChecks）特性，就可以使得 null 和 undefined 只能被赋值给 void 或本身对应的类型</li>
</ol>
<h4 id="1-7-2-bigint-和-number-的区别"><a href="#1-7-2-bigint-和-number-的区别" class="headerlink" title="1.7.2. bigint 和 number 的区别"></a>1.7.2. bigint 和 number 的区别</h4><ol>
<li>number 和 bigint 都可以表示数字，但是两者不能进行相互转换</li>
<li>仅在值大于 2^53 - 1时，才使用 bigint，否则尽量使用 number</li>
<li>用 typeof 检测 bigint 对象时，返回 bigint，用 typeof 检测 number，返回 number</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">10</span>) <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Number</span>(<span class="number">10</span>)) <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">10n</span>) <span class="comment">// bigint</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">BigInt</span>(<span class="number">10</span>)) <span class="comment">// bigint</span></span><br></pre></td></tr></table></figure>

<h3 id="1-8-对象类型"><a href="#1-8-对象类型" class="headerlink" title="1.8. 对象类型"></a>1.8. 对象类型</h3><h4 id="1-8-1-数组（Array）类型"><a href="#1-8-1-数组（Array）类型" class="headerlink" title="1.8.1. 数组（Array）类型"></a>1.8.1. 数组（Array）类型</h4><p>数组类型的写法有两种：</p>
<ol>
<li>在类型后面加上 []，例如 <strong>number[]</strong></li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini</span><br><span class="line">复制代码let num: number<span class="section">[]</span> = <span class="section">[1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<ol>
<li>使用数组泛型 &lt;&gt;，例如 <strong>Array</strong></li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typescript</span><br><span class="line">复制代码<span class="keyword">let</span> <span class="attr">num</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>推荐使用第一种写法。</p>
<p><strong>注意：</strong></p>
<ol>
<li>如果我们定义了一个number类型的数组，此时数组的项中就不能出现其它的类型。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132233.webp" alt="img"></p>
<ol>
<li>如果我们希望数组中既有number类型，又有string类型，此时我们可以用联合类型来写（关于联合类型，后面会详细讲到）。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typescript</span><br><span class="line">复制代码<span class="keyword">let</span> <span class="attr">arr</span>: (<span class="built_in">number</span> | <span class="built_in">string</span>)[] = [<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>上面的代码，表示的是，定义一个arr数组，这个数组中可以出现 number 或者 string 类型的元素。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">arr1</span>: <span class="built_in">number</span> | <span class="built_in">string</span>[] = <span class="number">123</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: <span class="built_in">number</span> | <span class="built_in">string</span>[] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>上面的代码，arr1 和 arr2 都表示即可以是number类型，又可以是string[]，加了小括号和不加小括号，含义不同。</p>
<h4 id="1-8-2-函数类型"><a href="#1-8-2-函数类型" class="headerlink" title="1.8.2. 函数类型"></a>1.8.2. 函数类型</h4><p>函数类型实际上指的是：<strong>函数参数和返回值的类型</strong>。</p>
<p>为函数指定类型的两种方式：</p>
<ol>
<li>单独指定参数、返回值的类型</li>
<li>同时指定参数、返回值的类型</li>
</ol>
<p>在JS中，有两种常见的定义函数的方式：</p>
<ol>
<li>函数声明</li>
<li>函数表达式</li>
</ol>
<h5 id="1-8-2-1-单独指定参数、返回值的类型"><a href="#1-8-2-1-单独指定参数、返回值的类型" class="headerlink" title="1.8.2.1. 单独指定参数、返回值的类型"></a>1.8.2.1. 单独指定参数、返回值的类型</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="comment">// 函数声明写法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数表达式写法</span></span><br><span class="line"><span class="keyword">const</span> sum1 = (<span class="attr">num1</span>: <span class="built_in">number</span>, <span class="attr">num2</span>: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">20</span>))  <span class="comment">// 30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum1</span>(<span class="number">10</span>, <span class="number">20</span>)) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<h5 id="1-8-2-2-同时指定参数、返回值的类型"><a href="#1-8-2-2-同时指定参数、返回值的类型" class="headerlink" title="1.8.2.2. 同时指定参数、返回值的类型"></a>1.8.2.2. 同时指定参数、返回值的类型</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">const</span> <span class="attr">sum</span>: <span class="function">(<span class="params">num1: <span class="built_in">number</span>, num2: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">20</span>)) <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>注意：不要把ES6中的 &#x3D;&gt; 和 TypeScript 中的 &#x3D;&gt;混淆了。</p>
<p>在ES6中，&#x3D;&gt;叫做箭头函数。而在 TypeScript 的类型定义中，&#x3D;&gt;用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p>
<h5 id="1-8-2-3-函数没有返回值"><a href="#1-8-2-3-函数没有返回值" class="headerlink" title="1.8.2.3. 函数没有返回值"></a>1.8.2.3. 函数没有返回值</h5><p>如果函数没有返回值，那么，函数返回值类型为：<strong>void</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c复制代码function <span class="title function_">greet</span><span class="params">(name: <span class="built_in">string</span>)</span>: <span class="type">void</span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">&quot;Hello, &quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;Echo&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="1-8-2-4-可选参数"><a href="#1-8-2-4-可选参数" class="headerlink" title="1.8.2.4. 可选参数"></a>1.8.2.4. 可选参数</h5><p>使用函数实现某个功能时，参数可以传也可以不传，这种情况下，在给函数参数指定类型时，就用到<strong>可选参数</strong>了。</p>
<p>可选参数使用问号（ <strong>?</strong> ）标记，表示该参数可以省略。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">string</span>, greeting?: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (greeting) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;greeting&#125;</span>, <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>!`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greet</span>(<span class="string">&quot;Echo&quot;</span>)) <span class="comment">// &quot;Hello, Echo!&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greet</span>(<span class="string">&quot;Echo&quot;</span>, <span class="string">&quot;Hi&quot;</span>)) <span class="comment">// &quot;Hi, Echo!&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们在第二个参数 greeting 的后面加了个问号，表示在调用 greet() 函数时，该参数可传可不传。</p>
<p>注意：<strong>可选参数只能出现在参数列表的最后面，也就是说，可选参数后面不能再出现必选参数。</strong></p>
<p>错误演示：下面代码中，我们把第一个参数改为可选的，第二个参数改为必选的，然后将鼠标移到必选参数上面，可以看到错误提示：“必选参数不能位于可选参数后”。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132247.webp" alt="img"></p>
<h5 id="1-8-2-5-参数默认值"><a href="#1-8-2-5-参数默认值" class="headerlink" title="1.8.2.5. 参数默认值"></a>1.8.2.5. 参数默认值</h5><p>在ES6中，允许给函数的参数添加默认值，而TypeScript会将添加了默认值的参数识别为可选参数。</p>
<p>默认参数使用等号（**&#x3D;**）赋予默认值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c复制代码function <span class="title function_">buildName</span><span class="params">(firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span> = <span class="string">&#x27;Cat&#x27;</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(buildName(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>)) <span class="comment">// Tom Cat</span></span><br><span class="line">console.<span class="built_in">log</span>(buildName(<span class="string">&#x27;Tom&#x27;</span>)) <span class="comment">// Tom Cat</span></span><br></pre></td></tr></table></figure>

<p>注意：与可选参数不同的是，<strong>带默认值的参数不需要放在必选参数的后面</strong>。如果带默认值的参数出现在必选参数的前面，我们在调用函数时，必须明确的传入 <strong>undefined</strong> 值来获得默认值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> <span class="title function_">buildName</span>(<span class="params">firstName = <span class="string">&quot;Echo&quot;</span>, lastName: string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&quot; &quot;</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">buildName</span>(<span class="string">&quot;james&quot;</span>))           <span class="comment">// 报错，未提供“lastName”自变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">buildName</span>(<span class="string">&quot;Jerk&quot;</span>, <span class="string">&quot;Lose&quot;</span>))    <span class="comment">// Jerk Lose</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">buildName</span>(<span class="literal">undefined</span>, <span class="string">&quot;Deno&quot;</span>)) <span class="comment">// Echo Deno</span></span><br></pre></td></tr></table></figure>

<h5 id="1-8-2-6-剩余参数"><a href="#1-8-2-6-剩余参数" class="headerlink" title="1.8.2.6. 剩余参数"></a>1.8.2.6. 剩余参数</h5><p>使用三个点（ <strong>…</strong> ）前缀和参数名来定义剩余参数。</p>
<p>剩余参数允许我们将不确定数量的参数表示为一个数组。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x: <span class="built_in">number</span>, ...rest: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = x;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> rest) &#123;</span><br><span class="line">    result += num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)) <span class="comment">// 15</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))       <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>剩余参数必须是函数参数列表中的最后一个参数</strong>。</p>
<h5 id="1-8-2-7-函数重载"><a href="#1-8-2-7-函数重载" class="headerlink" title="1.8.2.7. 函数重载"></a>1.8.2.7. 函数重载</h5><p>函数重载允许我们为同一个函数提供多个函数类型定义，以便在不同的参数类型或返回值类型下进行不同的处理。</p>
<p>例如，我们现在需要实现一个函数，需求是：输入数字123，输出反转的数字321，输入字符串”hello”，输出反转的字符串”olleh”。</p>
<p>利用联合类型，我们可以这么实现：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="built_in">number</span> | <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Number</span>(x.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reverse</span>(<span class="number">123</span>))     <span class="comment">// 321</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reverse</span>(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// olleh</span></span><br></pre></td></tr></table></figure>

<p>然后这样会有一个问题，就是输出的类型不能准确的知道，我们想输入为数字的时候，输出的类型应该也为数值类型，输入为字符串的时候，输出类型应该也为字符串类型。</p>
<p>这时，我们可以用<strong>重载</strong>定义多个reserve的函数类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="built_in">number</span> | <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Number</span>(x.<span class="title function_">toString</span>().<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>().<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reverse</span>(<span class="number">123</span>), <span class="keyword">typeof</span> <span class="title function_">reverse</span>(<span class="number">123</span>))     <span class="comment">// 321 number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reverse</span>(<span class="string">&quot;hello&quot;</span>), <span class="keyword">typeof</span> <span class="title function_">reverse</span>(<span class="string">&quot;hello&quot;</span>)) <span class="comment">// olleh string</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，第1-2行是函数定义，第3-9行是函数实现。第11行代码，我们调用reverse函数，并传入数值123，使用typeof检测类型为number，第12行代码，我们调用reverse函数，并传入字符串”hello”，使用typeof检测类型为string，这样我们利用函数重载就实现了输入为什么类型，输出应该也是什么类型。</p>
<h4 id="1-8-3-对象类型"><a href="#1-8-3-对象类型" class="headerlink" title="1.8.3. 对象类型"></a>1.8.3. 对象类型</h4><p>JS中的对象是由属性和方法构成的，而TS中对象的类型就是在描述对象的结构（有什么类型的属性和方法）。</p>
<h5 id="1-8-3-1-定义对象类型"><a href="#1-8-3-1-定义对象类型" class="headerlink" title="1.8.3.1. 定义对象类型"></a>1.8.3.1. 定义对象类型</h5><ul>
<li>使用花括号（ <strong>{}</strong> ）来定义对象类型，属性采用 <strong>属性名: 类型</strong> 的形式；方法采用 <strong>方法名(): 返回值类型</strong> 的形式。</li>
<li>如果方法有参数，就在方法名后面的小括号中指定参数类型（比如：greet(name: string): void）。</li>
<li>在一行代码中指定对象的多个属性类型时，使用分号（ <strong>;</strong> ）来分隔。</li>
<li>如果一行代码只指定一个属性类型（通过换行来分隔多个属性类型），可以去掉分号（ <strong>;</strong> ）。</li>
<li>方法的类型也可以使用箭头函数形式，比如：{ sayHi: () &#x3D;&gt; void }。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">person</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span>; <span class="title function_">sayHi</span>(): <span class="built_in">void</span>; <span class="title function_">greet</span>(<span class="attr">name</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#125; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params">name</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码，也可以写成下面这种形式：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">person</span>: &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="comment">// sayHi(): void</span></span><br><span class="line">  <span class="attr">sayHi</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">	<span class="comment">// greet(name: string): void</span></span><br><span class="line">  <span class="attr">greet</span>: <span class="function">(<span class="params">name: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125; = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">greet</span>(<span class="params">name</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-8-3-2-对象可选属性"><a href="#1-8-3-2-对象可选属性" class="headerlink" title="1.8.3.2. 对象可选属性"></a>1.8.3.2. 对象可选属性</h5><p>对象类型中的属性或方法可以是可选的，使用问号（ <strong>?</strong> ）标记。</p>
<p>可选属性表示该属性可以存在，也可以不存在。</p>
<p>比如，我们在使用axios({…})时，如果发送GET请求，method属性就可以省略。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">php复制代码<span class="function"><span class="keyword">function</span> <span class="title">myAxios</span>(<span class="params">config: &#123; url: <span class="keyword">string</span>; method?: <span class="keyword">string</span>&#125;</span>) </span>&#123;</span><br><span class="line">  console.<span class="title function_ invoke__">log</span>(config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">myAxios</span>(&#123; <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure>

<h5 id="1-8-3-3-对象只读属性"><a href="#1-8-3-3-对象只读属性" class="headerlink" title="1.8.3.3. 对象只读属性"></a>1.8.3.3. 对象只读属性</h5><p>对象的属性也可以是只读的，使用 <strong>readonly</strong> 关键字标记。</p>
<p>只读属性表示该属性的值在创建后就不能被修改。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">yaml复制代码let</span> <span class="attr">person:</span> &#123;</span><br><span class="line">  <span class="attr">name:</span> <span class="string">string</span></span><br><span class="line">  <span class="attr">age:</span> <span class="string">number</span></span><br><span class="line">	<span class="attr">readonly id:</span> <span class="string">number</span></span><br><span class="line">&#125; <span class="string">=</span> &#123;</span><br><span class="line">  <span class="attr">name:</span> <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age:</span> <span class="number">25</span>,</span><br><span class="line">	<span class="attr">id:</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-元组（Tuple）"><a href="#2-元组（Tuple）" class="headerlink" title="2. 元组（Tuple）"></a>2. 元组（Tuple）</h2><h3 id="2-1-元组的定义"><a href="#2-1-元组的定义" class="headerlink" title="2.1. 元组的定义"></a>2.1. 元组的定义</h3><p>在 TypeScript 中，<strong>元组（Tuple）是一种特殊的数组类型，它允许</strong> <strong>存储具有固定数量和特定类型顺序的元素。</strong></p>
<p>声明一个元组的语法是在类型注解中使用方括号 <strong>[]</strong> ，并使用逗号分隔元素的类型。</p>
<p>例如，下面是一个包含两个元素的元组：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码let tuple: <span class="section">[string, number]</span><span class="comment">;</span></span><br><span class="line"><span class="attr">tuple</span> = [<span class="string">&quot;Echo&quot;</span>, <span class="number">26</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们声明了一个名为 tuple 的变量，它被注解为一个元组类型 [string, number]。我们可以将一个包含两个元素的数组赋值给 tuple，其中第一个元素是一个字符串，第二个元素是一个数字。</p>
<h3 id="2-2-元组的特点"><a href="#2-2-元组的特点" class="headerlink" title="2.2. 元组的特点"></a>2.2. 元组的特点</h3><ol>
<li>元组可以包含多个不同类型的元素，但每个元素的类型和顺序是固定的。</li>
<li>元组的长度是固定的，在创建元组时必须指定元素的数量。</li>
<li>可以通过索引访问元组中的元素，索引从 0 开始。</li>
<li>元组中的每个元素可以具有不同的类型注解。</li>
<li>当访问元组中的元素时，会根据其类型注解提供相关的类型检查和智能提示。</li>
</ol>
<p>下面是一些操作元组的示例：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">arduino复制代码<span class="comment">// 声明一个 tuple 变量，它的类型注解为：[string, number, boolean]，然后把一个包含3个元素的数组赋值给 tuple，其中，数组的第一个元素为字符串类型，第二个元素为数值类型，第三个元素为布尔值类型</span></span><br><span class="line">let tuple: [string, number, <span class="type">boolean</span>] = [<span class="string">&quot;Echo&quot;</span>, <span class="number">26</span>, <span class="literal">true</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过索引访问元组中的元素，索引从 0 开始</span></span><br><span class="line">console.<span class="built_in">log</span>(tuple[<span class="number">0</span>]); <span class="comment">// 输出：Echo</span></span><br><span class="line">console.<span class="built_in">log</span>(tuple[<span class="number">1</span>]); <span class="comment">// 输出：26</span></span><br><span class="line">console.<span class="built_in">log</span>(tuple[<span class="number">2</span>]); <span class="comment">// 输出：true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过索引重新赋值，赋值的类型需要跟类型注解中的固定位置的类型一样</span></span><br><span class="line">tuple[<span class="number">0</span>] = <span class="string">&quot;june&quot;</span>;</span><br><span class="line">tuple[<span class="number">1</span>] = <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(tuple); <span class="comment">// 输出：[&quot;june&quot;, 28, true]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码会报错：不能将类型 &quot;[string, number, boolean, string]&quot; 分配给类型 &quot;[string, number, boolean]&quot;，源具有 4 个元素，但目标仅允许3个</span></span><br><span class="line">tuple = [<span class="string">&quot;Echo&quot;</span>, <span class="number">26</span>, <span class="literal">true</span>, <span class="string">&quot;hhhh&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码也会报错，因为元组的第一个元素类型要求为字符串类型，不能将 number 类型分配给 string 类型。</span></span><br><span class="line">tuple = [<span class="number">1</span>, <span class="number">28</span>, <span class="literal">true</span>]</span><br></pre></td></tr></table></figure>

<p>注意：<strong>当访问元组中的元素以及进行元素的赋值时，要确保索引和类型注解的一致性，否则可能会导致类型错误。</strong></p>
<h3 id="2-3-元组类型的解构赋值"><a href="#2-3-元组类型的解构赋值" class="headerlink" title="2.3. 元组类型的解构赋值"></a>2.3. 元组类型的解构赋值</h3><p>在 TypeScript 中，可以使用解构赋值语法来从元组中提取和赋值元素。</p>
<p>下面是一个简单的示例，展示了如何使用解构赋值从元组中获取各个元素：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">tuple</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&quot;Echo&quot;</span>, <span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [str, num] = tuple;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">// 输出：Echo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 输出：26</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先声明了一个元组 tuple，其中包含一个字符串类型的元素和一个数值类型的元素。接着，我们使用解构赋值语法将元组中的元素分别赋值给变量 str 和 num。</p>
<p>通过解构赋值，我们可以直接使用对应位置的变量来获取元组中的元素值，而不需要通过索引访问。这样可以以一种简洁、语义明确的方式从元组中解构得到各个元素。</p>
<p><strong>解构赋值还支持忽略某些元素，或者只提取部分元素。</strong></p>
<p>例如，如果只想获取元组中的第一个元素，可以使用以下方式：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">tuple</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&quot;Echo&quot;</span>, <span class="number">26</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [str] = tuple;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">// 输出：Echo</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们只声明了一个变量 str，而忽略了后面的元素。通过解构赋值只获取所需元素，可以简化代码并提高可读性。</p>
<p>另外，<strong>解构赋值还支持使用默认值。</strong></p>
<p>当从元组中解构一个不存在的元素时，可以提供一个默认值作为备选值。例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">tuple</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>?] = [<span class="string">&quot;Echo&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [str, num = <span class="number">26</span>] = tuple;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">// 输出：Echo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 输出：26</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们声明了一个带有可选的数字元素的元组 tuple，但是没有给出对应的数字值。在解构赋值时，如果元组中缺少对应的元素，就会使用默认值 undefined，这里我们将默认值设置为 26。</p>
<p>总而言之，使用解构赋值可以轻松地从元组中提取和赋值元素，使得代码更加简洁和可读。它是一种方便的语法，特别适用于处理具有固定结构的数据。</p>
<p>注意：<strong>在解构赋值时，如果解构数组元素的个数超过元组中元素的个数，会出现错误。</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码let tuple: <span class="section">[string, number]</span> = <span class="section">[&quot;Echo&quot;, 26]</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let <span class="section">[str, num, sex]</span> = tuple<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们解构时新增了一个 sex 变量，但元组的长度为 2，在索引 “2” 处没有元素。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132297.webp" alt="img"></p>
<h3 id="2-4-元组类型的可选元素"><a href="#2-4-元组类型的可选元素" class="headerlink" title="2.4. 元组类型的可选元素"></a>2.4. 元组类型的可选元素</h3><p>在 TypeScript 中，可以使用问号 <strong>?</strong> 来将元素定义为可选的，以表示元组中某些位置的元素是可选的。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arduino复制代码let tuple: [string, number?] = [<span class="string">&quot;Echo&quot;</span>];</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(tuple);   <span class="comment">// 输出 [ &#x27;Echo&#x27;, undefined ]</span></span><br><span class="line"></span><br><span class="line">tuple = [<span class="string">&quot;june&quot;</span>, <span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(tuple);  <span class="comment">// 输出 [ &#x27;june&#x27;, 26 ]</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个元组 tuple，该元组有两个元素，第一个是一个字符串类型的元素，而第二个是一个可选的数值类型的元素。当我们只提供第一个元素时，第二个元素会被默认设置为 undefined。然后，我们更新了元组的值，提供了第二个元素的值。此时，元组中的两个元素都有具体的值。</p>
<p>注意，<strong>当一个元组中包含一个可选元素时，该元素可以存在或不存在，但是顺序必须与元组类型定义一致。在解构赋值时，可以使用默认值来处理可选元素的缺失情况。</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">tuple</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>?] = [<span class="string">&quot;Echo&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [str, num = <span class="number">26</span>] = tuple;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str); <span class="comment">// 输出：Echo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 输出：26</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用解构赋值将元组中的元素分别赋值给变量 str 和 num。由于元组只提供了一个元素，没有提供可选的第二个元素，所以 num 的值将使用默认值 26。</p>
<p>通过使用可选元素，可以更灵活地定义元组类型，允许元组中特定位置的元素是可选的。这样，我们可以在处理数据时更好地适应不完整或可变的情况。</p>
<h3 id="2-5-元组类型的剩余元素"><a href="#2-5-元组类型的剩余元素" class="headerlink" title="2.5. 元组类型的剩余元素"></a>2.5. 元组类型的剩余元素</h3><p>在 TypeScript 中，可以使用剩余元素（Rest Elements）来表示元组中剩余的元素，即将剩余的元素放入一个数组中。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lua复制代码let tuple: [<span class="built_in">string</span>, number, ...boolean[]] = [<span class="string">&quot;Echo&quot;</span>, <span class="number">26</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(tuple); // 输出：[ <span class="string">&#x27;Echo&#x27;</span>, <span class="number">26</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span> ]</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个元组 tuple，包含一个字符串元素、一个数字元素，以及剩余元素使用剩余元素语法 <strong>…</strong> 定义的布尔类型数组。在创建元组时，我们提供了多个布尔类型的元素，它们会被放入一个数组并作为剩余元素。这样，元组中除了前两个元素以外的其他元素都会被放入数组中，并以数组的形式表示。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">tuple</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="built_in">boolean</span>[]] = [<span class="string">&quot;Echo&quot;</span>, <span class="number">26</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [str, num, ...boolArr] = tuple;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str);      <span class="comment">// 输出：Echo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num);      <span class="comment">// 输出：26</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(boolArr);  <span class="comment">// 输出：[true, true, false]</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用解构赋值从元组中提取出各个元素。通过使用 …boolArr，我们将剩余的布尔类型元素提取到名为 boolArr 的数组中。</p>
<p>使用剩余元素可以处理元组中数量不确定的元素，可以更灵活地处理和操作这些元素。它提供了一种方便的方式来处理由不固定数量的元素组成的结构数据。</p>
<h3 id="2-6-只读的元组类型"><a href="#2-6-只读的元组类型" class="headerlink" title="2.6. 只读的元组类型"></a>2.6. 只读的元组类型</h3><p>在 TypeScript 中，可以使用 <strong>readonly</strong> 修饰符来创建只读的元组类型，即元组中的元素不可被修改。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arduino复制代码let tuple: readonly [string, number] = [<span class="string">&quot;Echo&quot;</span>, <span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(tuple);    <span class="comment">// 输出：[ &#x27;Echo&#x27;, 26 ]</span></span><br><span class="line"></span><br><span class="line">tuple[<span class="number">0</span>] = <span class="string">&quot;world&quot;</span>;    <span class="comment">// 编译错误：无法为“0”赋值，因为它是只读属性</span></span><br><span class="line">tuple.<span class="built_in">push</span>(<span class="string">&#x27;abc&#x27;</span>);     <span class="comment">// 编译错误：类型 &quot;readonly [string, number]&quot; 上不存在 &quot;push&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 readonly 修饰符将 tuple 声明为只读的元组类型。这意味着在运行时，我们无法修改元组中的元素的值。</p>
<p>尝试对 tuple 进行赋值或调用修改元素的方法（如 push）时，TypeScript 编译器会报错，因为元组被声明为只读，无法被修改。</p>
<p>只读的元组类型在某些场景下非常有用，特别是当希望确保元组中的数据不会被意外修改时。它提供了一种强制保护元组数据不可变性的机制。</p>
<h2 id="3-字面量类型"><a href="#3-字面量类型" class="headerlink" title="3. 字面量类型"></a>3. 字面量类型</h2><p>当我们在 TypeScript 中使用字面量类型，我们可以明确指定变量只能取特定的字面量值，而不是其他可能性。这样可以在编译时捕获潜在的错误，并提供更好的类型推断和类型检查支持。</p>
<p>在 TypeScript 中，可以使用多种类型的字面量进行类型定义，包括字符串字面量类型、数字字面量类型、布尔字面量类型和符号字面量类型。</p>
<h3 id="3-1-字符串字面量类型"><a href="#3-1-字符串字面量类型" class="headerlink" title="3.1. 字符串字面量类型"></a>3.1. 字符串字面量类型</h3><p>使用字符串字面量表示的类型，只能取特定的字符串值。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">css复制代码let <span class="attribute">direction</span>: <span class="string">&quot;Up&quot;</span> | <span class="string">&quot;Right&quot;</span> | <span class="string">&quot;Down&quot;</span> | <span class="string">&quot;Left&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">direction</span> = &quot;<span class="attribute">Right</span>&quot;;   // 合法</span><br><span class="line"><span class="attribute">direction</span> = &quot;<span class="attribute">none</span>&quot;;    // 错误，只能取值为 &quot;Up&quot; | &quot;<span class="attribute">Right</span>&quot; | &quot;Down&quot; | &quot;<span class="attribute">Left</span>&quot;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-数字字面量类型"><a href="#3-2-数字字面量类型" class="headerlink" title="3.2. 数字字面量类型"></a>3.2. 数字字面量类型</h3><p>使用数字字面量表示的类型，只能取特定的数字值。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码let num: 1 | 2 | 3<span class="comment">;</span></span><br><span class="line"><span class="attr">num</span> = <span class="number">2</span><span class="comment">; // 合法</span></span><br><span class="line"><span class="attr">num</span> = <span class="number">4</span><span class="comment">; // 错误，只能取值为 1、2 或 3</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-布尔字面量类型"><a href="#3-3-布尔字面量类型" class="headerlink" title="3.3. 布尔字面量类型"></a>3.3. 布尔字面量类型</h3><p>使用布尔字面量表示的类型，只能取特定的布尔值。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码let isShow: true | false<span class="comment">;</span></span><br><span class="line"><span class="attr">isShow</span> = <span class="literal">true</span><span class="comment">;  // 合法</span></span><br><span class="line"><span class="attr">isShow</span> = <span class="literal">false</span><span class="comment">; // 合法</span></span><br><span class="line"><span class="attr">isShow</span> = <span class="number">1</span><span class="comment">;     // 错误，只能取值为 true 或 false</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-符号字面量类型"><a href="#3-4-符号字面量类型" class="headerlink" title="3.4. 符号字面量类型"></a>3.4. 符号字面量类型</h3><p>使用符号字面量表示的类型，只能取特定的符号值。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码const apple: unique <span class="attr">symbol</span> = Symbol(<span class="string">&quot;apple&quot;</span>)<span class="comment">;</span></span><br><span class="line">const orange: unique <span class="attr">symbol</span> = Symbol(<span class="string">&quot;orange&quot;</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let fruit: typeof apple | typeof orange<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">fruit</span> = apple<span class="comment">;           // 合法</span></span><br><span class="line"><span class="attr">fruit</span> = orange<span class="comment">;          // 合法</span></span><br><span class="line"><span class="attr">fruit</span> = Symbol(<span class="string">&quot;apple&quot;</span>)<span class="comment">; // 错误，只能取预定义的 apple 或 orange</span></span><br></pre></td></tr></table></figure>

<p>字面量类型不仅可以用于变量的定义，还可以用于<strong>函数的参数、返回值、对象属性</strong>等地方。通过使用字面量类型，我们可以在编写代码时明确指定特定的取值范围，提高代码的可读性和可维护性。</p>
<p>需要注意的是，字面量类型具有一个特殊的用途，即与联合类型结合使用，以实现更精确的类型约束。例如，联合类型 string | number 表示可以是字符串或数字类型的值，而字面量类型 “success” | “error” 表示只能是字符串 “success” 或 “error”，它们可以一起使用来实现更精确的类型定义。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码let result: &quot;success&quot; | &quot;error&quot; | number<span class="comment">;</span></span><br><span class="line"><span class="attr">result</span> = <span class="string">&quot;success&quot;</span><span class="comment">; // 合法</span></span><br><span class="line"><span class="attr">result</span> = <span class="number">42</span><span class="comment">;        // 合法</span></span><br><span class="line"><span class="attr">result</span> = <span class="literal">true</span><span class="comment">;      // 错误，只能取值为 &quot;success&quot;、&quot;error&quot; 或 number 类型</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-函数参数中的字面量类型"><a href="#3-5-函数参数中的字面量类型" class="headerlink" title="3.5. 函数参数中的字面量类型"></a>3.5. 函数参数中的字面量类型</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arduino复制代码<span class="function">function <span class="title">move</span><span class="params">(direction: <span class="string">&quot;up&quot;</span> | <span class="string">&quot;right&quot;</span> | <span class="string">&quot;down&quot;</span> | <span class="string">&quot;left&quot;</span>)</span>: void &#123;</span></span><br><span class="line">  console.<span class="built_in">log</span>(direction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">move</span>(<span class="string">&quot;up&quot;</span>);    <span class="comment">// 合法</span></span><br><span class="line"><span class="built_in">move</span>(<span class="string">&quot;left&quot;</span>);  <span class="comment">// 合法</span></span><br><span class="line"><span class="built_in">move</span>(<span class="number">10</span>);      <span class="comment">// 错误，只能取值为 &quot;up&quot; 或 &quot;right&quot; 或 &quot;down&quot; 或 &quot;left&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，函数 move 的参数 direction 的类型被指定为 “up” | “right” | “down” | “left”，这意味着参数 direction 只能接受这四个特定的值。</p>
<h3 id="3-6-函数返回值中的字面量类型"><a href="#3-6-函数返回值中的字面量类型" class="headerlink" title="3.6. 函数返回值中的字面量类型"></a>3.6. 函数返回值中的字面量类型</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制代码function getMove(direction: string): <span class="string">&quot;up&quot;</span> | <span class="string">&quot;right&quot;</span> | <span class="string">&quot;down&quot;</span> | <span class="string">&quot;left&quot;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (direction === <span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;up&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction === <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;right&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (direction === <span class="string">&#x27;S&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;down&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;left&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，函数 getMove 的返回值被指定为 “up” | “right” | “down” | “left”，这表示函数的返回值只能是这四个特定的值之一。</p>
<h3 id="3-7-对象属性中的字面量类型"><a href="#3-7-对象属性中的字面量类型" class="headerlink" title="3.7. 对象属性中的字面量类型"></a>3.7. 对象属性中的字面量类型</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">css复制代码interface Options &#123;</span><br><span class="line">  mode: <span class="string">&quot;light&quot;</span> | <span class="string">&quot;dark&quot;</span>;</span><br><span class="line">  size: <span class="string">&quot;small&quot;</span> | <span class="string">&quot;medium&quot;</span> | <span class="string">&quot;large&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let config: Options = &#123;</span><br><span class="line">  mode: <span class="string">&quot;light&quot;</span>,</span><br><span class="line">  size: <span class="string">&quot;medium&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，Options 接口中的 mode 属性的类型被指定为 “light” | “dark”，size 属性的类型被指定为 “small” | “medium” | “large”，这意味着对象 config 的 mode 属性只能是其中一个值，size 属性也只能是其中一个值。</p>
<h3 id="3-8-let-和-const-分析"><a href="#3-8-let-和-const-分析" class="headerlink" title="3.8. let 和 const 分析"></a>3.8. let 和 const 分析</h3><h4 id="3-8-1-let-声明的字面量类型"><a href="#3-8-1-let-声明的字面量类型" class="headerlink" title="3.8.1 let 声明的字面量类型"></a>3.8.1 let 声明的字面量类型</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">css复制代码let <span class="attribute">direction</span>: <span class="string">&quot;Up&quot;</span> | <span class="string">&quot;Right&quot;</span> | <span class="string">&quot;Down&quot;</span> | <span class="string">&quot;Left&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">direction</span> = &quot;<span class="attribute">Right</span>&quot;;   // 合法</span><br><span class="line"><span class="attribute">direction</span> = &quot;<span class="attribute">none</span>&quot;;    // 错误，只能取值为 &quot;Up&quot; | &quot;<span class="attribute">Right</span>&quot; | &quot;Down&quot; | &quot;<span class="attribute">Left</span>&quot;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 let 关键字声明了变量 direction，并将其类型指定为 “Up” | “Right” | “Down” | “Left”，因此 direction 只能取值为 “Up” 或 “Right” 或 “Down” 或 “Left” 这四个特定值中的其中一个。</p>
<h4 id="3-8-2-const-声明的字面量类型"><a href="#3-8-2-const-声明的字面量类型" class="headerlink" title="3.8.2 const 声明的字面量类型"></a>3.8.2 const 声明的字面量类型</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arduino</span><br><span class="line">复制代码<span class="type">const</span> size: <span class="string">&quot;small&quot;</span> | <span class="string">&quot;medium&quot;</span> | <span class="string">&quot;large&quot;</span> = <span class="string">&quot;medium&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 const 关键字声明了常量 size，并将其类型指定为 “small” | “medium” | “large”。由于使用了 const，size 是一个只读的常量，且初始值为 “medium”。因此，size 的值将永远是 “medium”，不能被重新赋值。</p>
<p>使用 let 和 const 关键字来声明变量和常量时，可以配合字面量类型提供更具体和可靠的类型约束。</p>
<p>注意：<strong>const 声明的常量在声明时必须被初始化，并且一旦初始化后，其值将不能被修改。而 let 声明的变量可以在后续代码中被重新赋值。</strong></p>
<h2 id="4-枚举（Enum）"><a href="#4-枚举（Enum）" class="headerlink" title="4. 枚举（Enum）"></a>4. 枚举（Enum）</h2><p>枚举（Enum）是一种用于定义一组命名常量的数据结构。</p>
<h3 id="4-1-基本枚举"><a href="#4-1-基本枚举" class="headerlink" title="4.1. 基本枚举"></a>4.1. 基本枚举</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scss复制代码enum <span class="attribute">Direction</span> &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  <span class="attribute">Left</span>,</span><br><span class="line">  <span class="attribute">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dir: Direction = Direction.Up;</span><br><span class="line">console<span class="selector-class">.log</span>(dir); <span class="comment">// 输出: 0</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个名为 Direction 的枚举，其中列出了 Up、Down、Left 和 Right 四个枚举成员。默认情况下，枚举成员的值从 0 开始自动递增，因此 Direction.Up 的值为 0。我们可以使用枚举成员来声明变量，并进行比较、打印等操作。</p>
<h3 id="4-2-数字枚举"><a href="#4-2-数字枚举" class="headerlink" title="4.2. 数字枚举"></a>4.2. 数字枚举</h3><p>在默认情况下，数字枚举的成员从 0 开始自动递增。</p>
<h4 id="4-2-1-默认递增的数字枚举"><a href="#4-2-1-默认递增的数字枚举" class="headerlink" title="4.2.1. 默认递增的数字枚举"></a>4.2.1. 默认递增的数字枚举</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scss复制代码enum <span class="attribute">Direction</span> &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  <span class="attribute">Left</span>,</span><br><span class="line">  <span class="attribute">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console<span class="selector-class">.log</span>(Direction.Up);     <span class="comment">// 输出: 0</span></span><br><span class="line">console<span class="selector-class">.log</span>(Direction.Down);   <span class="comment">// 输出: 1</span></span><br><span class="line">console<span class="selector-class">.log</span>(Direction.Left);   <span class="comment">// 输出: 2</span></span><br><span class="line">console<span class="selector-class">.log</span>(Direction.Right);  <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个名为 Direction 的枚举，其中列出了 Up、Down、Left 和 Right 四个枚举成员。默认情况下，枚举成员的值从 0 开始自动递增，因此 Direction.Up 的值是 0，Direction.Down 的值是 1，Direction.Left 的值是 2，Direction.Right 的值是 3。</p>
<h4 id="4-2-2-手动赋值的数字枚举"><a href="#4-2-2-手动赋值的数字枚举" class="headerlink" title="4.2.2. 手动赋值的数字枚举"></a>4.2.2. 手动赋值的数字枚举</h4><p>在手动赋值的数字枚举中，可以为每个枚举成员手动指定一个特定的值。手动赋值的数字枚举可以使用任意合法的数字作为成员的值。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码enum Direction &#123;</span><br><span class="line">  <span class="attr">Up</span> = <span class="number">2</span>,</span><br><span class="line">  <span class="attr">Down</span> = <span class="number">4</span>,</span><br><span class="line">  <span class="attr">Left</span> = <span class="number">6</span>,</span><br><span class="line">  <span class="attr">Right</span> = <span class="number">8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Direction.Up)<span class="comment">;     // 输出: 2</span></span><br><span class="line">console.log(Direction.Down)<span class="comment">;   // 输出: 4</span></span><br><span class="line">console.log(Direction.Left)<span class="comment">;   // 输出: 6</span></span><br><span class="line">console.log(Direction.Right)<span class="comment">;  // 输出: 8</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，Direction.Up 被赋值为 2，Direction.Down 被赋值为 4，Direction.Left 被赋值为 6，Direction.Right 被赋值为 8。</p>
<h4 id="4-2-3-计算成员的数字枚举"><a href="#4-2-3-计算成员的数字枚举" class="headerlink" title="4.2.3. 计算成员的数字枚举"></a>4.2.3. 计算成员的数字枚举</h4><p>在数字枚举中，可以使用计算表达式作为成员的值。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码enum Calculation &#123;</span><br><span class="line">  <span class="attr">Addition</span> = <span class="number">2</span> + <span class="number">3</span>,</span><br><span class="line">  <span class="attr">Subtraction</span> = <span class="number">10</span> - <span class="number">5</span>,</span><br><span class="line">  <span class="attr">Multiplication</span> = <span class="number">6</span> * <span class="number">2</span>,</span><br><span class="line">  <span class="attr">Division</span> = <span class="number">20</span> / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Calculation.Addition)<span class="comment">;        // 输出: 5</span></span><br><span class="line">console.log(Calculation.Subtraction)<span class="comment">;     // 输出: 5</span></span><br><span class="line">console.log(Calculation.Multiplication)<span class="comment">;  // 输出: 12</span></span><br><span class="line">console.log(Calculation.Division)<span class="comment">;        // 输出: 5</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用加法、减法、乘法和除法运算符来计算成员的值。在编译时，这些计算表达式会被求值为结果值并成为实际的枚举成员的值。</p>
<h3 id="4-3-常量枚举"><a href="#4-3-常量枚举" class="headerlink" title="4.3. 常量枚举"></a>4.3. 常量枚举</h3><p>常量枚举（const enum）是一种特殊类型的枚举，它在编译时被删除，并且只保留枚举成员的值作为常量。常量枚举提供了一种更轻量级的方式来使用枚举，可以用于在编译期间替换枚举成员的值。</p>
<h4 id="4-3-1-常量枚举的定义"><a href="#4-3-1-常量枚举的定义" class="headerlink" title="4.3.1. 常量枚举的定义"></a>4.3.1. 常量枚举的定义</h4><p>在定义常量枚举时，需要使用 <strong>const</strong> 关键字和 <strong>enum</strong> 关键字的组合。<strong>常量枚举不能有计算成员。</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">css复制代码const enum <span class="attribute">Direction</span> &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  <span class="attribute">Left</span>,</span><br><span class="line">  <span class="attribute">Right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2-常量枚举的使用"><a href="#4-3-2-常量枚举的使用" class="headerlink" title="4.3.2. 常量枚举的使用"></a>4.3.2. 常量枚举的使用</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scss复制代码const enum <span class="attribute">Direction</span> &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Down,</span><br><span class="line">  <span class="attribute">Left</span>,</span><br><span class="line">  <span class="attribute">Right</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console<span class="selector-class">.log</span>(Direction.Up);     <span class="comment">// 输出: 0</span></span><br><span class="line">console<span class="selector-class">.log</span>(Direction.Down);   <span class="comment">// 输出: 1</span></span><br><span class="line">console<span class="selector-class">.log</span>(Direction.Left);   <span class="comment">// 输出: 2</span></span><br><span class="line">console<span class="selector-class">.log</span>(Direction.Right);  <span class="comment">// 输出: 3</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-3-常量枚举会在编译阶段被删除"><a href="#4-3-3-常量枚举会在编译阶段被删除" class="headerlink" title="4.3.3. 常量枚举会在编译阶段被删除"></a>4.3.3. 常量枚举会在编译阶段被删除</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132381.webp" alt="img"></p>
<h3 id="4-4-字符串枚举"><a href="#4-4-字符串枚举" class="headerlink" title="4.4. 字符串枚举"></a>4.4. 字符串枚举</h3><p>在 TypeScript 中，字符串枚举是一种特殊类型的枚举，其中每个成员都用字符串字面量进行初始化。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">arduino复制代码<span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">  Up = <span class="string">&quot;UP&quot;</span>,</span><br><span class="line">  Down = <span class="string">&quot;DOWN&quot;</span>,</span><br><span class="line">  Left = <span class="string">&quot;LEFT&quot;</span>,</span><br><span class="line">  Right = <span class="string">&quot;RIGHT&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(Direction.Up)     <span class="comment">// 输出 UP</span></span><br><span class="line">console.<span class="built_in">log</span>(Direction.Down)   <span class="comment">// 输出 DOWN</span></span><br><span class="line">console.<span class="built_in">log</span>(Direction.Left)   <span class="comment">// 输出 LEFT</span></span><br><span class="line">console.<span class="built_in">log</span>(Direction.Right)  <span class="comment">// 输出 RIGHT</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个名为 Direction 的字符串枚举。其中的成员 Up 使用字符串字面量 “UP” 进行初始化，成员 Down 使用字符串字面量 “DOWN” 进行初始化，成员 Left 使用字符串字面量 “LEFT” 进行初始化，成员 Right 使用字符串字面量 “RIGHT” 进行初始化。我们可以通过直接访问枚举成员来获得其对应的字符串值。</p>
<p>字符串枚举的特点：</p>
<ul>
<li>明确的字符串值：每个字符串枚举成员都具有明确的字符串值，可更好地描述其含义和用途。</li>
<li>代码可读性：由于成员的值直接使用字符串字面量，因此代码更加清晰、易读。</li>
<li>保留字符串字面量：使用字符串枚举可以在编译后保留字符串字面量，而不是转换为数值或其他类型。</li>
<li>可用于反向映射：字符串枚举可以支持从枚举值到枚举名的反向映射。</li>
</ul>
<h3 id="4-5-外部枚举"><a href="#4-5-外部枚举" class="headerlink" title="4.5. 外部枚举"></a>4.5. 外部枚举</h3><p>外部枚举（ambient enum）是一种定义在外部代码（如声明文件）中的枚举。外部枚举通常用于描述已存在的枚举类型的形状，而不是为了创建一个具体的 JavaScript 对象。</p>
<p><strong>外部枚举的定义不会在编译时生成任何实际的 JavaScript 代码，它只用于类型检查。</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码declare enum HttpStatusCode &#123;</span><br><span class="line">  <span class="attr">OK</span> = <span class="number">200</span>,</span><br><span class="line">  <span class="attr">BadRequest</span> = <span class="number">400</span>,</span><br><span class="line">  Unauthorized,</span><br><span class="line">  <span class="attr">NotFound</span> = <span class="number">404</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let code: <span class="attr">HttpStatusCode</span> = HttpStatusCode.OK<span class="comment">;</span></span><br><span class="line">console.log(code)<span class="comment">;                        // 输出: 200</span></span><br><span class="line">console.log(HttpStatusCode.BadRequest)<span class="comment">;   // 输出: 400</span></span><br><span class="line">console.log(HttpStatusCode.Unauthorized)<span class="comment">; // 输出: 401 (自动递增)</span></span><br><span class="line">console.log(HttpStatusCode.NotFound)<span class="comment">;     // 输出: 404</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 declare 关键字来定义了一个外部枚举 HttpStatusCode。它描述了一些常见的 HTTP 状态码。其中的成员 OK 和 BadRequest 和 NotFound 指定了具体的数值，分别为 200，400 和 404，成员 Unauthorized 没有显式指定值，它会根据前一个成员的值自动递增，因此值为 401。</p>
<p>在使用外部枚举时，我们可以像使用普通枚举一样，访问它的成员并获得相应的值。在上述示例中，我们将 HttpStatusCode.OK 赋值给变量 code，然后将变量 code 的值打印出来，得到的结果是 200。</p>
<p>注意：当使用外部枚举时，我们必须使用 <strong>declare</strong> 来声明它，以告诉 TypeScript 编译器这是一个外部定义的枚举。此外，外部枚举的定义通常是在一个声明文件中（以 .d.ts 结尾），以便在与现有 JavaScript 库或框架进行交互时提供类型信息。</p>
<p>总结起来，外部枚举是 TypeScript 中一种在外部代码中定义的枚举，用于描述已存在的枚举类型的形状。外部枚举的定义通常只用于类型检查，并不会生成实际的 JavaScript 代码。它在与现有 JavaScript 库或框架进行交互时提供类型信息。</p>
<h3 id="4-6-异构枚举"><a href="#4-6-异构枚举" class="headerlink" title="4.6. 异构枚举"></a>4.6. 异构枚举</h3><p>异构枚举（heterogeneous enum）是一种允许枚举成员的值具有不同类型的枚举。</p>
<p>通常情况下，枚举中的成员的值应该是相同类型的。但是异构枚举允许在同一个枚举中使用不同类型的值，包括字符串、数字和其他类型。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码enum Status &#123;</span><br><span class="line">  <span class="attr">Active</span> = <span class="number">1</span>,</span><br><span class="line">  Pending,</span><br><span class="line">  <span class="attr">Inactive</span> = <span class="string">&quot;inactive&quot;</span>,</span><br><span class="line">  <span class="attr">OnHold</span> = <span class="string">&quot;on hold&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Status.Active)<span class="comment">;   // 输出: 1</span></span><br><span class="line">console.log(Status.Pending)<span class="comment">;  // 输出: 2 (自动递增)</span></span><br><span class="line">console.log(Status.Inactive)<span class="comment">; // 输出: &quot;inactive&quot;</span></span><br><span class="line">console.log(Status.OnHold)<span class="comment">;   // 输出: &quot;on hold&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个名为 Status 的异构枚举。其中的成员 Active 的值是一个数字，值为 1。成员 Pending 没有显式指定值，它的值会根据前一个成员的值自动递增，因此值为 2。成员 Inactive 的值是一个字符串，值为 “inactive”。成员 OnHold 的值是一个字符串，值为 “on hold”。</p>
<p>在访问异构枚举的成员时，将得到其对应的值。在上述示例中，我们分别打印了每个异构枚举成员的值，并相应地获得了不同类型的结果。</p>
<p>异构枚举的优势在于允许在一组相关的枚举中使用不同类型的值。这在某些特定情况下可能很有用，例如需要表示不同种类的状态或类型时。</p>
<p>注意：<strong>在异构枚举中，具有数字字面量值的成员会根据前一个成员的值自动递增，而具有字符串字面量值的成员不会自动递增。同时，在异构枚举中，没有初始化值的成员会根据前一个成员的值自动递增。</strong></p>
<h3 id="4-7-反向映射"><a href="#4-7-反向映射" class="headerlink" title="4.7. 反向映射"></a>4.7. 反向映射</h3><p>反向映射（reverse mapping）是指<strong>枚举成员不仅可以通过名称访问值，而且可以通过值访问名称。</strong> 这意味着可以根据枚举的值获取到对应的枚举成员名称。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码enum Direction &#123;</span><br><span class="line">  <span class="attr">Up</span> = <span class="number">1</span>,</span><br><span class="line">  Down,</span><br><span class="line">  Left,</span><br><span class="line">  Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let <span class="attr">rightValue</span> = Direction.Right<span class="comment">;</span></span><br><span class="line">let <span class="attr">rightName</span> = Direction[rightValue]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">console.log(rightValue)<span class="comment">;  // 输出: 4</span></span><br><span class="line">console.log(rightName)<span class="comment">;   // 输出: Right</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个名为 Direction 的枚举，其中的成员分别使用数字进行初始化。我们将 Direction.Right 的值赋给变量 rightValue，然后使用 Direction[rightValue] 获取到对应的枚举成员名称，将结果赋给变量 rightName。</p>
<p>在打印出变量 rightValue 和 rightName 的值后，我们得到的结果是 4 和 Right。这就是反向映射的效果，根据枚举的值可以获取到对应的枚举成员名称。</p>
<p>注意：<strong>反向映射只在数字枚举中有效，而不适用于字符串枚举。</strong> 字符串枚举的成员值虽然可以是字符串字面量，但在 JavaScript 中无法实现反向映射。</p>
<h3 id="4-8-运行时的枚举"><a href="#4-8-运行时的枚举" class="headerlink" title="4.8. 运行时的枚举"></a>4.8. 运行时的枚举</h3><p>运行时的枚举（runtime enum）是指在 JavaScript 运行时可访问和操作的枚举。</p>
<p>TypeScript 编译器在编译过程中，会将枚举类型转换为实际的 JavaScript 对象。这些对象在运行时仍然保留了枚举的结构和值，以便能够通过它们来进行运行时的枚举操作。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">arduino复制代码<span class="keyword">enum</span> <span class="title class_">Fruit</span> &#123;</span><br><span class="line">  Apple,</span><br><span class="line">  Orange,</span><br><span class="line">  Banana</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">getFruitName</span><span class="params">(fruit: Fruit)</span>: string &#123;</span></span><br><span class="line">  <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">    <span class="keyword">case</span> Fruit.Apple:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> Fruit.Orange:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Orange&quot;</span>;</span><br><span class="line">    <span class="keyword">case</span> Fruit.Banana:</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;Banana&quot;</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;Invalid fruit&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">getFruitName</span>(Fruit.Apple));  <span class="comment">// 输出: Apple</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">getFruitName</span>(Fruit.Orange)); <span class="comment">// 输出: Orange</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">getFruitName</span>(Fruit.Banana)); <span class="comment">// 输出: Banana</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个名为 Fruit 的枚举，其中包含了三个成员 Apple、Orange 和 Banana。然后我们定义了一个函数 getFruitName，它接受一个 Fruit 类型的参数，根据传入的枚举值返回对应的水果名称。</p>
<p>通过运行 getFruitName 函数并传入不同的枚举值，我们可以在控制台上看到输出的结果，它们是根据传入的枚举值返回的相应水果名称。</p>
<p>注意：<strong>当使用运行时枚举时，由于枚举的成员值实际上是数字（默认从 0 开始递增），因此进行比较时需要使用严格相等运算符 &#x3D;&#x3D;&#x3D;。</strong></p>
<h3 id="4-9-联合枚举"><a href="#4-9-联合枚举" class="headerlink" title="4.9. 联合枚举"></a>4.9. 联合枚举</h3><p>联合枚举（union enum）是指一个枚举类型可以包含多个不同的枚举成员的组合。每个成员可以具有不同的值和类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">enum</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="title class_">Circle</span> = <span class="string">&quot;circle&quot;</span>,</span><br><span class="line">  <span class="title class_">Rectangle</span> = <span class="string">&quot;rectangle&quot;</span>,</span><br><span class="line">  <span class="title class_">Triangle</span> = <span class="string">&quot;triangle&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;</span><br><span class="line">  <span class="title class_">Red</span> = <span class="string">&quot;red&quot;</span>,</span><br><span class="line">  <span class="title class_">Green</span> = <span class="string">&quot;green&quot;</span>,</span><br><span class="line">  <span class="title class_">Blue</span> = <span class="string">&quot;blue&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ShapeColor</span> = <span class="title class_">Shape</span>.<span class="property">Circle</span> | <span class="title class_">Shape</span>.<span class="property">Rectangle</span> | <span class="title class_">Shape</span>.<span class="property">Triangle</span> | <span class="title class_">Color</span>.<span class="property">Red</span> | <span class="title class_">Color</span>.<span class="property">Green</span> | <span class="title class_">Color</span>.<span class="property">Blue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">drawShape</span>(<span class="params">shape: ShapeColor</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (shape) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Shape</span>.<span class="property">Circle</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;画一个圆形&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Shape</span>.<span class="property">Rectangle</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;画一个矩形&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Shape</span>.<span class="property">Triangle</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;画一个三角形&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Color</span>.<span class="property">Red</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;颜色为红色&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Color</span>.<span class="property">Green</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;颜色为绿色&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">Color</span>.<span class="property">Blue</span>:</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;颜色为蓝色&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Invalid shape or color&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">drawShape</span>(<span class="title class_">Shape</span>.<span class="property">Circle</span>); <span class="comment">// 输出: 画一个圆形</span></span><br><span class="line"><span class="title function_">drawShape</span>(<span class="title class_">Color</span>.<span class="property">Blue</span>);   <span class="comment">// 输出: 颜色为蓝色</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了两个枚举 Shape 和 Color。Shape 枚举表示不同的形状，Color 枚举表示不同的颜色。然后我们定义了一个类型别名 ShapeColor，它是 Shape 枚举成员和 Color 枚举成员的联合。接着，我们定义了一个函数 drawShape，它接受一个 ShapeColor 类型的参数 shape。根据传入的参数值进行不同的分支逻辑处理，并输出相应的消息。通过调用 drawShape 函数并传入不同的值，我们可以根据传入的参数值来绘制不同的形状或填充不同的颜色。</p>
<p>联合枚举使得我们能够在一个类型中组合多个不同的枚举成员，以表示更复杂的类型。这可以让 TypeScript 的类型系统提供更精确的类型检查和推断，以确保代码的正确性。</p>
<p>注意：<strong>联合枚举的使用是通过定义类型别名或接口来实现的。</strong> 通过将不同枚举成员组合在一起，可以创建复合类型，提供更灵活的数据表示。</p>
<h2 id="5-any类型"><a href="#5-any类型" class="headerlink" title="5. any类型"></a>5. any类型</h2><p>在 TypeScript 中，any 类型表示一个动态类型，它可以接受任何类型的值。使用 any 类型时，TypeScript 编译器将不会对值进行类型检查，允许你在编译期绕过类型系统的限制。</p>
<p>如果是一个普通类型，在赋值过程中改变类型是不被允许的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132536.webp" alt="img"></p>
<p>如果是 any 类型，则允许被赋值为任意类型。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码let x: <span class="attr">any</span> = <span class="number">26</span><span class="comment">;</span></span><br><span class="line"><span class="attr">x</span> = <span class="string">&quot;Echo&quot;</span><span class="comment">;</span></span><br><span class="line"><span class="attr">x</span> = <span class="literal">true</span><span class="comment">;</span></span><br><span class="line"><span class="attr">x</span> = undefined</span><br><span class="line"><span class="attr">x</span> = null</span><br><span class="line"><span class="attr">x</span> = []</span><br><span class="line"><span class="attr">x</span> = &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>以下两种情况，隐式具有 any 类型：</p>
<ul>
<li>声明变量不提供类型也不提供默认值。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132681.webp" alt="img"></p>
<ul>
<li>函数参数不加类型。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132045.webp" alt="img"></p>
<p>注意：在开发过程中应尽量避免过度使用 any 类型，以充分利用 TypeScript 的类型系统来提供更好的类型安全性和代码可维护性。</p>
<h1 id="五、接口（interface）"><a href="#五、接口（interface）" class="headerlink" title="五、接口（interface）"></a>五、接口（interface）</h1><h2 id="1-什么是接口"><a href="#1-什么是接口" class="headerlink" title="1. 什么是接口"></a>1. 什么是接口</h2><p>在 TypeScript 中，接口（Interface）是一种用来定义对象的结构和行为的类型。通过接口，我们可以定义对象应该有哪些属性、属性的类型以及方法。</p>
<p>接口提供了一种约束和规范，使得我们可以在代码中定义和使用特定的数据结构。</p>
<h2 id="2-定义接口"><a href="#2-定义接口" class="headerlink" title="2. 定义接口"></a>2. 定义接口</h2><ul>
<li>使用关键字 <strong>interface</strong> 来定义接口。</li>
<li>声明接口后，直接使用接口名称作为变量的类型。</li>
<li>方法的定义和函数的定义类似，包括参数和返回值类型。</li>
<li>接口一般首字母大写。<strong>有的编程语言中建议接口的名称加上前缀</strong> <strong>I</strong> <strong>。</strong></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="title function_">sayHi</span>(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">jerry</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们定义了一个接口 Person，接着定义了一个变量 jerry，它的类型是 Person。这样，我们就约束了 jerry 的形状必须和接口 Person 一致。</p>
<p>注意：<strong>定义的变量比接口少了一些属性不允许的</strong>。</p>
<p>下面是一段错误的代码演示：我们定义了一个接口 Person，里面有name，age2个属性，以及sayHi方法，接着定义了一个变量 jerry，它的类型是 Person，但是我们只给属性name和age赋值，所以会报错。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132051.webp" alt="img"></p>
<p>当然，<strong>定义的变量比接口多了一些属性也是不允许的。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132230.webp" alt="img"></p>
<p>也就是说，<strong>在赋值的时候，变量的形状必须和接口的形状保持一致</strong>。</p>
<h2 id="3-接口（interface）和类型别名（type）的区别"><a href="#3-接口（interface）和类型别名（type）的区别" class="headerlink" title="3. 接口（interface）和类型别名（type）的区别"></a>3. 接口（interface）和类型别名（type）的区别</h2><ol>
<li><p>相同点：都可以用于定义对象的结构和类型。</p>
</li>
<li><p>不同点：</p>
</li>
<li><ol>
<li>接口更适合用于描述真实存在的对象，而类型别名更适合用于定义复杂的类型。</li>
<li>接口可以被其他对象实现，而类型别名只是给类型起了一个别名。</li>
</ol>
</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">csharp复制代码<span class="keyword">interface</span> <span class="title">Person</span> &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="function">number</span></span><br><span class="line"><span class="function">  <span class="title">sayHi</span>(): <span class="keyword">void</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">type IPerson</span> = &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="function">number</span></span><br><span class="line"><span class="function">  <span class="title">sayHi</span>(): <span class="keyword">void</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-接口继承（extends）"><a href="#4-接口继承（extends）" class="headerlink" title="4. 接口继承（extends）"></a>4. 接口继承（extends）</h2><p>在 TypeScript 中，接口是可以相互继承的，也就是说：<strong>一个接口可以从另一个接口中继承属性和方法的定义（通过继承实现复用）。</strong> 接口的继承可以通过使用关键字 <strong>extends</strong> ****实现。</p>
<p>接口继承的语法格式如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132342.webp" alt="img"></p>
<p>通过继承，子接口可以获得父接口中定义的属性和方法，并可以在自身接口中添加新的属性和方法。</p>
<p>下面是一个简单的例子，展示了接口继承的用法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="title function_">getArea</span>(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">circle</span>: <span class="title class_">Circle</span> = &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">  <span class="attr">radius</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="title function_">getArea</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="variable language_">this</span>.<span class="property">radius</span> * <span class="variable language_">this</span>.<span class="property">radius</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，使用 extends 关键字实现了接口 Circle 继承 Shape。继承后，Circle 就有了 Shape 中的 color 属性，以及自身的 radius 属性以及 getArea() 方法。</p>
<h2 id="5-接口的可选属性"><a href="#5-接口的可选属性" class="headerlink" title="5. 接口的可选属性"></a>5. 接口的可选属性</h2><p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个 <strong>?</strong> 符号。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码interface Person &#123;</span><br><span class="line">  name: string<span class="comment">;</span></span><br><span class="line">  age?: number<span class="comment">; // 可选属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person1: <span class="attr">Person</span> = &#123; name: <span class="string">&quot;Alice&quot;</span> &#125;<span class="comment">;</span></span><br><span class="line">const person2: <span class="attr">Person</span> = &#123; name: <span class="string">&quot;Bob&quot;</span>, age: <span class="number">25</span> &#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，Person 接口中的 age 属性是可选的，我们定义了 person1 和 person2 两个对象，类型都是Person，其中，person1 对象中没有 age 属性，而 person2 对象中包含了 age 属性。</p>
<p>可选属性的好处有2个：</p>
<ol>
<li>可以对可能存在的属性进行预定义</li>
<li>可以捕获引用了不存在的属性时的错误</li>
</ol>
<p>例如，我们故意将 person2 对象中的 age 属性名写错，就会得到一个错误的提示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132462.webp" alt="img"></p>
<h2 id="6-接口的只读属性"><a href="#6-接口的只读属性" class="headerlink" title="6. 接口的只读属性"></a>6. 接口的只读属性</h2><p>有时候我们希望某些属性在对象创建后不能被修改，可以将这些属性声明为<strong>只读属性</strong>。</p>
<p>通过在属性名称前面加上 <strong>readonly</strong> 关键字，就可以将属性设置为只读。</p>
<p>例如，下面的例子中，声明了一个名称为 Point2D 的接口，接口中的属性 x 和 y 都是只读的，然后创建了一个 point 对象，类型为 Point2D，此时，我们不能再给对象中的 x 和 y 重新赋值，会报错，因为它们都是只读属性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132798.webp" alt="img"></p>
<p>此外 TypeScript 还提供了 <strong>ReadonlyArray</strong> 类型，它与 <strong>Array</strong> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">less</span>复制代码<span class="selector-tag">let</span> <span class="selector-tag">a</span>: <span class="selector-tag">number</span><span class="selector-attr">[]</span> = <span class="selector-attr">[1, 2, 3, 4]</span></span><br><span class="line"><span class="selector-tag">let</span> <span class="selector-tag">ro</span>: <span class="selector-tag">ReadonlyArray</span>&lt;<span class="selector-tag">number</span>&gt; = <span class="selector-tag">a</span></span><br><span class="line"><span class="selector-tag">ro</span><span class="selector-attr">[0]</span> = <span class="number">12</span>      <span class="comment">// error!</span></span><br><span class="line"><span class="selector-tag">ro</span><span class="selector-class">.push</span>(<span class="number">5</span>)      <span class="comment">// error!</span></span><br><span class="line"><span class="selector-tag">ro</span><span class="selector-class">.length</span> = <span class="number">100</span> <span class="comment">// error!</span></span><br><span class="line"><span class="selector-tag">a</span> = <span class="selector-tag">ro</span>          <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<h2 id="7-额外的属性检查"><a href="#7-额外的属性检查" class="headerlink" title="7. 额外的属性检查"></a>7. 额外的属性检查</h2><p>接口用于定义对象的结构，当我们使用<strong>对象字面量</strong>赋值给接口类型时，TypeScript 会自动进行额外的属性检查。这意味着<strong>赋值的对象不能包含接口中未定义的额外属性，否则会导致编译错误。</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">css复制代码interface Rectangle &#123;</span><br><span class="line">  <span class="attribute">width</span>: number;</span><br><span class="line">  <span class="attribute">height</span>: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const rect1: Rectangle = &#123; <span class="attribute">width</span>: <span class="number">10</span>, height: <span class="number">20</span> &#125;</span><br><span class="line">const rect2: Rectangle = &#123; <span class="attribute">width</span>: <span class="number">10</span>, height: <span class="number">20</span>, color: <span class="string">&quot;red&quot;</span> &#125; // 编译错误，额外的属性检查</span><br></pre></td></tr></table></figure>

<p>在上述例子中，rect2 对象包含了额外的 color 属性，但是接口 Rectangle 中并未定义该属性，所以会导致编译错误。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132883.webp" alt="img"></p>
<p>注意：<strong>如果我们确定对象会包含额外的属性，可以使用类型断言（Type Assertion）来绕过额外属性检查。</strong></p>
<h2 id="8-接口的任意属性"><a href="#8-接口的任意属性" class="headerlink" title="8. 接口的任意属性"></a>8. 接口的任意属性</h2><p>有时候我们希望一个接口中除了包含必选和可选属性之外，还允许有其他的任意属性，这时我们可以使用 <strong>索引签名</strong> 的形式来满足上述要求。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">css复制代码interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age?: number;</span><br><span class="line">  <span class="selector-attr">[propName: string]</span>: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person: Person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Echo&#x27;</span>,</span><br><span class="line">  gender: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，我们使用 <strong>[propName: string]</strong> 定义了任意属性取 <strong>string</strong> 类型的值。</p>
<p>注意：<strong>一旦定义了任意属性，那么必选属性和可选属性的类型都必须是它的类型的子集：</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">css复制代码interface Person &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age?: number;</span><br><span class="line">  <span class="selector-attr">[propName: string]</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person: Person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Echo&#x27;</span>,</span><br><span class="line">  age: <span class="number">25</span>,</span><br><span class="line">  gender: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述例子中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132952.webp" alt="img"></p>
<p>注意：<strong>一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型。</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  age?: <span class="built_in">number</span>; <span class="comment">// 这里age真实的类型应该为：number | undefined</span></span><br><span class="line">  [<span class="attr">propName</span>: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Echo&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-函数类型"><a href="#9-函数类型" class="headerlink" title="9. 函数类型"></a>9. 函数类型</h2><p>接口可以描述函数类型。</p>
<p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义，参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">php复制代码<span class="class"><span class="keyword">interface</span> <span class="title">SearchFunc</span> </span>&#123;</span><br><span class="line">  (source: <span class="keyword">string</span>, subString: <span class="keyword">string</span>): <span class="keyword">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，SearchFunc 是一个接口，它表示一个接收两个参数 source 和 subString，参数类型都为 string，并且返回值为 number 类型的函数。</p>
<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。</p>
<p>下面的例子展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">interface</span> <span class="title class_">SearchFunc</span> &#123;</span><br><span class="line">  (<span class="attr">source</span>: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">mySearch</span>: <span class="title class_">SearchFunc</span>;</span><br><span class="line">mySearch = <span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = source.<span class="title function_">search</span>(subString);</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<strong>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。</strong></p>
<p>例如，我们使用下面的代码重写上面的例子：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">perl复制代码interface SearchFunc &#123;</span><br><span class="line">  (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(src: string, <span class="function"><span class="keyword">sub</span>: <span class="title">string</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  let result = src.search(<span class="function"><span class="keyword">sub</span>)</span>;</span><br><span class="line">  <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。</p>
<p>如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc 类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">perl复制代码interface SearchFunc &#123;</span><br><span class="line">  (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(src, <span class="function"><span class="keyword">sub</span>) </span>&#123;</span><br><span class="line">    let result = src.search(<span class="function"><span class="keyword">sub</span>)</span>;</span><br><span class="line">    <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc 接口中的定义不匹配。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132220.webp" alt="img"></p>
<h2 id="10-可索引类型"><a href="#10-可索引类型" class="headerlink" title="10. 可索引类型"></a>10. 可索引类型</h2><p>接口可以描述具有索引签名的对象，这样我们就可以通过索引来访问对象的属性。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码interface StringArray &#123;</span><br><span class="line">  <span class="section">[index: number]</span>: string<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myArray: StringArray<span class="comment">;</span></span><br><span class="line"><span class="attr">myArray</span> = [<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Fred&quot;</span>]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let myStr: <span class="attr">string</span> = myArray[<span class="number">0</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>上述的例子中，我们定义了 StringArray 接口，它具有索引签名。这个索引签名表示了当用 number 去索引StringArray 时会得到 string 类型的返回值。</p>
<p>TypeScript 支持两种索引签名：<strong>字符串和数字。可以同时使用两种类型的索引，但是</strong>数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number 来索引时，JavaScript 会将它转换成 string 然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。</p>
<h2 id="11-类类型实现接口"><a href="#11-类类型实现接口" class="headerlink" title="11. 类类型实现接口"></a>11. 类类型实现接口</h2><p>接口可以被类实现，称为<strong>类类型</strong>。</p>
<p>类可以通过 <strong>implements</strong> 关键字来实现接口，并必须实现接口中定义的所有属性和方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">interface</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line">  <span class="title function_">print</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Document</span> <span class="keyword">implements</span> <span class="title class_">Printable</span> &#123;</span><br><span class="line">  <span class="title function_">print</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Printing document...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，Document 类实现了 Printable 接口，并实现了接口中定义的 print 方法。</p>
<h2 id="12-继承接口"><a href="#12-继承接口" class="headerlink" title="12. 继承接口"></a>12. 继承接口</h2><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码interface Shape &#123;</span><br><span class="line">    color: string<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Square extends Shape &#123;</span><br><span class="line">    sideLength: number<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let <span class="attr">square</span> = &lt;Square&gt;&#123;&#125;<span class="comment">;</span></span><br><span class="line"><span class="attr">square.color</span> = <span class="string">&quot;blue&quot;</span><span class="comment">;</span></span><br><span class="line"><span class="attr">square.sideLength</span> = <span class="number">10</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码interface Shape &#123;</span><br><span class="line">    color: string<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface PenStroke &#123;</span><br><span class="line">    penWidth: number<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Square extends Shape, PenStroke &#123;</span><br><span class="line">    sideLength: number<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let <span class="attr">square</span> = &lt;Square&gt;&#123;&#125;<span class="comment">;</span></span><br><span class="line"><span class="attr">square.color</span> = <span class="string">&quot;blue&quot;</span><span class="comment">;</span></span><br><span class="line"><span class="attr">square.sideLength</span> = <span class="number">10</span><span class="comment">;</span></span><br><span class="line"><span class="attr">square.penWidth</span> = <span class="number">5.0</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h2 id="13-接口继承类"><a href="#13-接口继承类" class="headerlink" title="13. 接口继承类"></a>13. 接口继承类</h2><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 private 和 protected 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; is eating.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CanRun</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">run</span>(): <span class="built_in">void</span>;</span><br><span class="line">  <span class="title function_">eat</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">CanRun</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; is running.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; is eating.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">dog</span>: <span class="title class_">CanRun</span> = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Buddy&quot;</span>);</span><br><span class="line">dog.<span class="title function_">eat</span>(); <span class="comment">// 输出：Buddy is eating.</span></span><br><span class="line">dog.<span class="title function_">run</span>(); <span class="comment">// 输出：Buddy is running.</span></span><br></pre></td></tr></table></figure>

<p>在以上示例中，我们定义了一个 Animal 类，它有一个 name 属性和一个 eat 方法。然后，我们定义了一个接口 CanRun，它继承自 Animal 类，并添加了一个 run 和 eat 方法。接着，我们创建了一个 Dog 类来实现 CanRun 接口，并在 Dog 类中实现了 run 和 eat 方法。</p>
<p>在最后的代码中，我们使用 CanRun 接口来声明一个 dog 对象，并将其实例化为 Dog 类的对象。这样，我们可以通过调用 dog 对象的 eat 和 run 方法来验证接口继承类的实现。</p>
<p><strong>接口继承类的主要作用在于类型标注和约束。</strong> 通过接口继承类，我们可以定义更具体的接口类型，使得类和接口之间的关系更加清晰。同时，在使用接口类型的变量或参数时，可以享受到类成员的类型检查和智能提示的功能。这对于代码的可读性、可维护性和可扩展性都有很大的帮助。</p>
<h1 id="六、类型别名"><a href="#六、类型别名" class="headerlink" title="六、类型别名"></a>六、类型别名</h1><p>作用：</p>
<p>在 TS 中，类型别名主要用于为已有的类型创建别名，以便在代码中更方便地引用和重用这些类型。</p>
<p>用法：</p>
<ol>
<li>使用 <strong>type</strong> 关键字可以为任何类型定义别名，包括基本类型、复杂类型、函数类型等。</li>
<li>创建类型别名后，直接使用该类型别名作为变量的类型注解即可。</li>
</ol>
<p>解释：</p>
<ol>
<li>类型别名是为已有类型提供另一个名称，而不是创建新的类型。</li>
<li>类型别名可以用于简化复杂类型的表达，提高可读性和可维护性。</li>
<li>类型别名可以用于定义联合类型或交叉类型的别名。</li>
</ol>
<p>注意：</p>
<ol>
<li>尽量选择有意义的别名，能够准确描述类型的用途，提高代码的可读性。</li>
<li>避免过度使用类型别名，过多的别名可能导致代码的可维护性变差。</li>
<li>注意避免循环引用的情况，即在类型别名中引用自身，这会导致编译错误。</li>
<li>类型别名并不创建新的类型，所以它无法被继承或实现。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="comment">// 未使用类型别名</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: (<span class="built_in">number</span> | <span class="built_in">string</span>)[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr1</span>: (<span class="built_in">number</span> | <span class="built_in">string</span>)[] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型别名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CustomArray</span> = (<span class="built_in">number</span> | <span class="built_in">string</span>)[]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: <span class="title class_">CustomArray</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr3</span>: <span class="title class_">CustomArray</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr4</span>: <span class="title class_">CustomArray</span> = [<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>, <span class="string">&#x27;c&#x27;</span>]</span><br></pre></td></tr></table></figure>

<h1 id="七、类型推论"><a href="#七、类型推论" class="headerlink" title="七、类型推论"></a>七、类型推论</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>在 TypeScript 中，类型推论（Type Inference）是指<strong>编译器在没有明确指定类型的情况下，根据变量的值推断出该变量的类型。</strong> 通过类型推论，TypeScript 可以在代码中自动推断出变量的类型，而无需显式地将其指定为特定类型。</p>
<h2 id="2-基本类型推论"><a href="#2-基本类型推论" class="headerlink" title="2. 基本类型推论"></a>2. 基本类型推论</h2><p>当声明一个变量时，如果没有显式指定类型，并且在声明的同时进行了赋值操作，TypeScript 将根据赋值的值推断出变量的类型。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码let <span class="attr">age</span> = <span class="number">26</span><span class="comment">;         // 推断为 number 类型</span></span><br><span class="line">let <span class="attr">str</span> = <span class="string">&quot;Echo&quot;</span><span class="comment">;    // 推断为 string 类型</span></span><br><span class="line">let <span class="attr">isActive</span> = <span class="literal">true</span><span class="comment">; // 推断为 boolean 类型</span></span><br><span class="line"></span><br><span class="line">// 以上的代码等价于下面的下吗</span><br><span class="line">let age: <span class="attr">number</span> = <span class="number">26</span><span class="comment">;</span></span><br><span class="line">let str: <span class="attr">string</span> = <span class="string">&quot;Echo&quot;</span><span class="comment">;</span></span><br><span class="line">let isActive: <span class="attr">boolean</span> = <span class="literal">true</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132289.webp" alt="img"></p>
<h2 id="3-上下文类型推论"><a href="#3-上下文类型推论" class="headerlink" title="3. 上下文类型推论"></a>3. 上下文类型推论</h2><p>当变量的类型与其所处的上下文相关时，TypeScript 可以根据上下文进行类型推断。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>复制代码<span class="keyword">function</span> <span class="keyword">add</span>(x: number, y: number) &#123;</span><br><span class="line">  <span class="keyword">return</span> x <span class="operator">+</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let <span class="keyword">result</span> <span class="operator">=</span> <span class="keyword">add</span>(<span class="number">5</span>, <span class="number">10</span>); <span class="operator">/</span><span class="operator">/</span> 推断 <span class="keyword">result</span> 为 number 类型</span><br></pre></td></tr></table></figure>

<p>在上述示例中，函数 add 接收两个参数，并返回它们的和。当我们调用 add(5, 10) 时，TypeScript 根据函数返回值的类型推断出 result 变量的类型为 number。</p>
<h2 id="4-最佳通用类型推论"><a href="#4-最佳通用类型推论" class="headerlink" title="4. 最佳通用类型推论"></a>4. 最佳通用类型推论</h2><p>当需要推断出数组或对象类型时，TypeScript 会根据元素或属性的类型推断出一个“最佳通用类型”。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码let <span class="attr">numbers</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]<span class="comment">; // 推断为 number[] 类型</span></span><br><span class="line"></span><br><span class="line">let <span class="attr">mixed</span> = [<span class="number">26</span>, <span class="string">&quot;Echo&quot;</span>, <span class="literal">true</span>]<span class="comment">; // 推断为 (number | string | boolean)[]</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，数组 numbers 中的所有元素都是数字，因此 TypeScript 推断出 numbers 的类型为 number[]。而数组 mixed 中的元素类型不同（数字、字符串和布尔值），所以 TypeScript 推断出 mixed 的类型为 (number | string | boolean)[]，表示该数组可以存储数字、字符串或布尔值类型的元素。</p>
<h2 id="5-声明变量但没有赋值的情况"><a href="#5-声明变量但没有赋值的情况" class="headerlink" title="5. 声明变量但没有赋值的情况"></a>5. 声明变量但没有赋值的情况</h2><p>如果声明变量的时候没有赋值，不管之后有没有赋值，都会被推断成 <strong>any</strong> 类型而完全不被类型检查。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码let str</span><br><span class="line"></span><br><span class="line"><span class="attr">str</span> = <span class="string">&quot;Echo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str</span> = <span class="number">26</span></span><br><span class="line"></span><br><span class="line"><span class="attr">str</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，变量 str 的类型推断为 any 类型，因为它没有明确的初始值。此时我们就可以把任意类型的值赋值给 str。</p>
<p>需要注意的是，虽然 TypeScript 可以根据赋值来推断类型，但如果变量的初始值为 null 或 undefined，类型推论仍然会将其推断为 any 类型。</p>
<p><strong>为了避免使用 any 类型，我们可以显式指定变量的类型或为变量提供一个初始值来触发类型推论。</strong></p>
<h1 id="八、类型断言"><a href="#八、类型断言" class="headerlink" title="八、类型断言"></a>八、类型断言</h1><h2 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>类型断言（Type Assertion）是 TypeScript 中的一种表达式，它可以用来告诉编译器一个值的确切类型。通过类型断言，我们可以在一些情况下主动指定变量的类型，以满足特定的需求。</p>
<h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h2><p>类型断言有2种语法形式：</p>
<ol>
<li><strong>尖括号语法：</strong> 使用尖括号 &lt;&gt; 将值包裹，并在尖括号内指定目标类型。 <strong>&lt;类型&gt;值</strong></li>
</ol>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码let value: <span class="attr">any</span> = <span class="string">&quot;Hello&quot;</span><span class="comment">;</span></span><br><span class="line">let len: <span class="attr">number</span> = (&lt;string&gt;value).length<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">console.log(len)<span class="comment">; // 输出: 5</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们将变量 value 的类型断言为 string 类型，然后使用 .length 属性获取字符串的长度。</p>
<ol>
<li><strong>as 语法：</strong> 使用 as 关键字，在值后面跟上目标类型。<strong>值 as 类型</strong></li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">value</span>: <span class="built_in">any</span> = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">len</span>: <span class="built_in">number</span> = (value <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(len); <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用 as 关键字将变量 value 的类型断言为 string 类型，并用 length 属性获取字符串的长度。</p>
<p>以上两种语法虽说没有太大的区别，但是我们<strong>更推荐使用 as 语法</strong>。因为尖括号格式会与 react 中 JSX 产生语法冲突。</p>
<h2 id="3-任何类型可以断言为-any-类型"><a href="#3-任何类型可以断言为-any-类型" class="headerlink" title="3. 任何类型可以断言为 any 类型"></a>3. 任何类型可以断言为 any 类型</h2><p>由于 any 类型可以接收任何值，因此任何类型都可以断言为 any 类型。这样的断言并不提供更多的类型检查，因此在使用类型断言时需要谨慎。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132353.webp" alt="img"></p>
<p>上面的例子中，数字类型的变量 foo 上是没有 length 属性的，故 TypeScript 给出了相应的错误提示。</p>
<p>这种错误提示显然是非常有用的。</p>
<p>但有的时候，我们非常确定这段代码不会出错，比如下面这个例子：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132642.webp" alt="img"></p>
<p>上面的示例中，我们需要将 window 上添加一个属性 bar，但 TypeScript 编译时会报错，提示我们 window 上不存在 属性 bar。</p>
<p>此时我们可以使用 as any 临时将 window 断言为 any 类型：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini</span><br><span class="line">复制代码(window as any).<span class="attr">bar</span> = <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h2 id="4-any-类型可以断言为任何类型"><a href="#4-any-类型可以断言为任何类型" class="headerlink" title="4. any 类型可以断言为任何类型"></a>4. any 类型可以断言为任何类型</h2><p>与上述情况相反，由于 any 类型可以接收任何值，它可以被断言为任何类型。这样的断言会跳过类型检查，因此潜在的类型错误可能发生。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">any</span> = <span class="string">&quot;Echo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: <span class="built_in">number</span> = x <span class="keyword">as</span> <span class="built_in">number</span>; <span class="comment">// 将 any 类型断言为 number 类型</span></span><br></pre></td></tr></table></figure>

<h2 id="5-联合类型的类型断言"><a href="#5-联合类型的类型断言" class="headerlink" title="5. 联合类型的类型断言"></a>5. 联合类型的类型断言</h2><p>当变量具有联合类型时，我们可以通过类型断言将其断言为其中的一个类型，但是必须确保断言的类型是变量实际上可以具备的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">value</span>: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="string">&quot;Echo&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">length</span>: <span class="built_in">number</span> = (value <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>; <span class="comment">// 类型断言为 string 类型</span></span><br></pre></td></tr></table></figure>

<h2 id="6-类型断言的限制"><a href="#6-类型断言的限制" class="headerlink" title="6. 类型断言的限制"></a>6. 类型断言的限制</h2><h3 id="6-1-类型断言不会改变变量的实际类型"><a href="#6-1-类型断言不会改变变量的实际类型" class="headerlink" title="6.1. 类型断言不会改变变量的实际类型"></a>6.1. 类型断言不会改变变量的实际类型</h3><p>类型断言只是告诉编译器将一个值视为特定类型，并不会改变该值的实际类型。在运行时，类型断言不会影响变量的值或行为，它只是在编译时起作用。</p>
<h3 id="6-2-类型断言不能用于基本类型之间的转换"><a href="#6-2-类型断言不能用于基本类型之间的转换" class="headerlink" title="6.2. 类型断言不能用于基本类型之间的转换"></a>6.2. 类型断言不能用于基本类型之间的转换</h3><p>TypeScript 的类型断言不能用于将基本类型（如 number、string、boolean）相互转换。因为基本类型具有明确的类型判断和行为，不能将一个基本类型断言为另一个基本类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: <span class="built_in">string</span> = x <span class="keyword">as</span> <span class="built_in">string</span>; <span class="comment">// 错误，不能将 number 类型断言为 string 类型</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-类型断言不能覆盖类型检查"><a href="#6-3-类型断言不能覆盖类型检查" class="headerlink" title="6.3. 类型断言不能覆盖类型检查"></a>6.3. 类型断言不能覆盖类型检查</h3><p>类型断言可以绕过编译器的类型检查，但并不意味着我们可以随意断言任何类型。如果发生类型断言与变量的实际类型不匹配的情况，可能会导致运行时错误。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132706.webp" alt="img"></p>
<h3 id="6-4-类型断言不能将-null-或-undefined-断言为其他类型"><a href="#6-4-类型断言不能将-null-或-undefined-断言为其他类型" class="headerlink" title="6.4. 类型断言不能将 null 或 undefined 断言为其他类型"></a>6.4. 类型断言不能将 null 或 undefined 断言为其他类型</h3><p>因为 null 和 undefined 可以被赋值给任何类型，将它们断言为其他类型是没有意义的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">x</span>: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: <span class="built_in">number</span> = x <span class="keyword">as</span> <span class="built_in">number</span>; <span class="comment">// 错误，不能将 null 断言为 number 类型</span></span><br></pre></td></tr></table></figure>

<h3 id="6-5-联合类型的类型断言存在类型互相排斥的限制"><a href="#6-5-联合类型的类型断言存在类型互相排斥的限制" class="headerlink" title="6.5. 联合类型的类型断言存在类型互相排斥的限制"></a>6.5. 联合类型的类型断言存在类型互相排斥的限制</h3><p>如果将一个变量断言为联合类型中某个类型，那么它必须是该联合类型中的实际类型之一。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">value</span>: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="string">&quot;Echo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">len</span>: <span class="built_in">number</span> = (value <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>; <span class="comment">// 正确，因为 value 的实际类型可以为 string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">size</span>: <span class="built_in">number</span> = (value <span class="keyword">as</span> <span class="built_in">number</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>); <span class="comment">// 错误，value 的实际类型不是 number</span></span><br></pre></td></tr></table></figure>

<h2 id="7-双重断言"><a href="#7-双重断言" class="headerlink" title="7. 双重断言"></a>7. 双重断言</h2><p>双重断言（Double Assertion），也被称为双重类型断言或连续类型断言，是一种在 TypeScript 中连续使用类型断言的技术。它是将一个值断言为多个类型的一种尝试，尽管这种用法并不被 TypeScript 官方鼓励使用，因为它可能产生不可预测的结果。</p>
<p>双重断言的形式是使用连续的类型断言操作符 <strong>as</strong> 或尖括号 <strong>&lt;&gt;</strong> 来表示：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">value</span>: <span class="built_in">any</span> = <span class="string">&quot;Echo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">len</span>: <span class="built_in">number</span> = (value <span class="keyword">as</span> <span class="built_in">any</span> <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们连续使用了两次类型断言，将值 value 先断言为 any 类型，然后再将其断言为 string 类型，并使用 length 属性获取字符串的长度。但是需要注意的是，尽管代码通过了编译，但是这种双重断言的方法并不安全，因为它可以导致类型错误和运行时错误。</p>
<p>使用双重断言可能会隐藏类型错误，因为类型断言是编译时的操作，而不是运行时。在运行时，双重断言可能会导致意外的类型转换错误，并且编译器无法为此提供任何保护。</p>
<p>所以，在实际开发中，应尽量避免使用双重断言。如果需要使用多个类型，而无法使用更安全的方法来表示，可以考虑重构代码，使用更合适的类型来处理多种情况，或者使用类型守卫和类型判断等 TypeScript 提供的更安全的技术来处理复杂的类型转换或条件判断。</p>
<h2 id="8-类型断言VS类型转换"><a href="#8-类型断言VS类型转换" class="headerlink" title="8. 类型断言VS类型转换"></a>8. 类型断言VS类型转换</h2><p>在 TypeScript 中，<strong>类型断言（Type Assertion）</strong> 是一种在编译时告诉编译器一个值的确切类型的方式，它只是一种类型的声明，不会对变量进行真正的类型转换。</p>
<p>与类型断言相对的是<strong>类型转换（Type Casting）</strong> ，它是将一个值从一种类型转换为另一种类型的实际操作，而不仅仅是告诉编译器某个值的类型。类型转换通常需要在运行时进行，并涉及对值的实际修改。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="comment">// 类型断言</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">value</span>: <span class="built_in">any</span> = <span class="string">&quot;Echo&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">len</span>: <span class="built_in">number</span> = (value <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型转换</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">numberValue</span>: <span class="built_in">any</span> = <span class="string">&quot;26&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">intValue</span>: <span class="built_in">number</span> = <span class="built_in">parseInt</span>(numberValue);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，(value as string) 是一种类型断言，告诉编译器将变量 value 视为字符串类型。而 parseInt 是一种类型转换，将字符串类型的 numberValue 转换为整数类型。</p>
<p>需要注意的是，<strong>类型断言只会在编译时起作用，不会对变量进行实际的类型转换。而类型转换涉及到对变量值的修改，通常发生在运行时。</strong></p>
<p>尽管类型断言和类型转换在某种程度上可以实现相似的效果，但它们的机制和目的不同。类型断言是为了辅助编译器进行类型推断和类型检查的工具，而类型转换是为了实际修改变量的类型以满足特定需求。因此，在使用类型转换时，需要注意潜在的类型错误和运行时错误，并谨慎处理类型转换的结果。</p>
<h2 id="9-类型断言VS类型声明"><a href="#9-类型断言VS类型声明" class="headerlink" title="9. 类型断言VS类型声明"></a>9. 类型断言VS类型声明</h2><p>在 TypeScript 中，<strong>类型断言（Type Assertion）</strong> 是一种在编译时告诉编译器一个值的确切类型的方式，它是开发者主动指定一个变量的类型，并告诉编译器遵循这个类型进行类型检查。通过类型断言，我们可以在某些情况下绕过编译器的类型检查，但这需要开发者对类型的准确性负责，并且存在潜在的类型错误的风险。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码let value: <span class="attr">any</span> = <span class="string">&quot;Echo&quot;</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let len: <span class="attr">number</span> = (value as string).length<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，(value as string) 是一种类型断言，将变量 value 的类型断言为字符串类型，从而可以安全地访问字符串的 length 属性。</p>
<p><strong>类型声明（Type Declaration）</strong> 是一种为变量、参数、返回值等明确指定类型的语法，它是用来定义变量的类型，并告诉编译器如何对变量进行类型推断和类型检查。类型声明通常出现在变量声明、函数声明、函数参数、函数返回值等地方，例如：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">value</span>: <span class="built_in">string</span> = <span class="string">&quot;Echo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，value: string 是对变量 value 进行类型声明，指定其类型为字符串。而 name: string 是对函数参数 name 进行类型声明，指定其类型为字符串。这样可以确保编译器在类型检查时能够发现潜在的类型错误。</p>
<p>类型声明是 TypeScript 中一种重要的类型系统的特性，它提供了对变量类型的明确说明，使开发者能够编写更加安全和可维护的代码。与类型断言相比，类型声明更加强制，能够更好地帮助开发者在编译时发现类型错误，并提供更好的类型推断和类型检查支持。</p>
<h2 id="10-类型断言和泛型"><a href="#10-类型断言和泛型" class="headerlink" title="10. 类型断言和泛型"></a>10. 类型断言和泛型</h2><p>在 TypeScript 中，<strong>类型断言（Type Assertion）</strong> 是一种在编译时告诉编译器一个值的确切类型的方式，它是开发者主动指定一个变量的类型，并告诉编译器遵循这个类型进行类型检查。通过类型断言，我们可以在某些情况下绕过编译器的类型检查，但这需要开发者对类型的准确性负责，并且存在潜在的类型错误的风险。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码let value: <span class="attr">any</span> = <span class="string">&quot;Echo&quot;</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let len: <span class="attr">number</span> = (value as string).length<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，(value as string) 是一种类型断言，将变量 value 的类型断言为字符串类型，以便可以安全地访问字符串的 length 属性。</p>
<p>泛型是一种在定义函数、类或接口时使用类型参数来表示灵活的类型的方式。通过泛型，我们可以在定义时不指定具体类型，而是在使用时根据上下文传入具体的类型。它可以增加代码的重用性和灵活性。例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">csharp复制代码<span class="function">function <span class="title">toArray</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">value</span>: T</span>): T[]</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">value</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array: <span class="built_in">string</span>[] = toArray(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，toArray 是一个泛型函数，使用类型参数 T 来表示数组中的元素类型。通过传入具体的类型 “Hello”，我们可以创建一个字符串类型的数组。</p>
<p>类型断言和泛型实际上可以一起使用。当我们在处理泛型类型时，有时可能需要对类型进行断言以满足特定的需求。例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">csharp复制代码<span class="function">function <span class="title">convertToString</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">value</span>: T</span>): <span class="built_in">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">value</span> <span class="keyword">as</span> unknown <span class="keyword">as</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，通过连续使用类型断言，我们将泛型类型 T 先断言为 unknown 类型，然后再断言为字符串类型，将参数 value 转换为字符串类型并返回。</p>
<p>需要注意的是，在使用类型断言和泛型时，我们要确保类型的安全性和正确性，并避免潜在的类型错误。类型断言可以帮助我们处理一些特殊情况，但要谨慎使用，并确保断言的类型与变量的实际类型相符。泛型则是一种更加灵活和通用的方式来处理不特定类型的代码逻辑。</p>
<h1 id="九、类（class）"><a href="#九、类（class）" class="headerlink" title="九、类（class）"></a>九、类（class）</h1><h2 id="1-类的定义"><a href="#1-类的定义" class="headerlink" title="1. 类的定义"></a>1. 类的定义</h2><p>在 TypeScript 中，可以使用 <strong>class</strong> 关键字来定义类。类的定义通常包括成员变量、构造函数、方法等。</p>
<h2 id="2-类的基本使用"><a href="#2-类的基本使用" class="headerlink" title="2. 类的基本使用"></a>2. 类的基本使用</h2><p>类的基本使用主要有以下几个步骤：</p>
<ol>
<li><strong>定义类及成员变量：</strong> 使用 <strong>class</strong> 关键字定义一个类，并在类中声明成员变量。</li>
<li><strong>构造函数：</strong> 使用 <strong>constructor</strong> 方法定义构造函数，用于在创建类的实例时初始化对象的属性。</li>
<li><strong>方法：</strong> 在类中定义方法，可通过类的实例调用。</li>
<li><strong>创建类的实例：</strong> 使用 <strong>new</strong> 关键字创建类的实例，并传递构造函数所需的参数。</li>
<li><strong>访问成员变量和调用方法：</strong> 通过实例对象访问成员变量和调用方法。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHello</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Echo&quot;</span>, <span class="number">26</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>); <span class="comment">// 输出：Echo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">age</span>);  <span class="comment">// 输出：26</span></span><br><span class="line">p.<span class="title function_">sayHello</span>();        <span class="comment">// 输出：Hello, my name is Echo and I&#x27;m 26 years old.</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中：我们使用 class 关键字定义一个名为 Person 的类，并在 Person 类中声明了两个成员变量：name 和 age。接着，我们使用 constructor 方法定义一个构造函数，用于在创建类的实例时初始化对象的属性，构造函数参数 name 和 age 分别用于接收传入的 name 和 age 值，并将其赋给对应的成员变量。然后定义了一个名为 sayHello 的方法，用于打印一个问候语，并使用成员变量 name 和 age。接着，我们使用 new 关键字创建一个 Person 实例 p，然后打印出 name 和 age 的值以及调用 sayHello 方法。</p>
<h2 id="3-类的构造函数"><a href="#3-类的构造函数" class="headerlink" title="3. 类的构造函数"></a>3. 类的构造函数</h2><p>在 TypeScript 类中，构造函数是一种特殊的方法，用于在创建类的实例时进行初始化操作。构造函数使用 <strong>constructor</strong> 关键字来定义，可以接收参数，并在创建对象时调用。</p>
<h3 id="3-1-构造函数的基本语法"><a href="#3-1-构造函数的基本语法" class="headerlink" title="3.1. 构造函数的基本语法"></a>3.1. 构造函数的基本语法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">class</span> <span class="title class_">ClassName</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">parameter1: Type1, parameter2: Type2, ...</span>) &#123;</span><br><span class="line">    <span class="comment">// 书写构造函数的逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，ClassName 是类的名称，parameter1、parameter2 等表示构造函数的参数名，Type1、Type2 等表示参数的类型。</p>
<h3 id="3-2-使用构造函数初始化成员变量"><a href="#3-2-使用构造函数初始化成员变量" class="headerlink" title="3.2. 使用构造函数初始化成员变量"></a>3.2. 使用构造函数初始化成员变量</h3><p>构造函数可以用来初始化类中的成员变量，通过接收构造函数的参数，并将其赋给对应的成员变量。成员变量的声明通常放在类的顶部，而初始化则在构造函数中进行。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，构造函数接收 name 和 age 作为参数，并将参数的值分别赋给类中的 name 和 age 成员变量。</p>
<h3 id="3-3-创建类的实例并调用构造函数"><a href="#3-3-创建类的实例并调用构造函数" class="headerlink" title="3.3. 创建类的实例并调用构造函数"></a>3.3. 创建类的实例并调用构造函数</h3><p>使用 new 关键字创建类的实例时，构造函数会被自动调用，让我们可以在创建实例的同时进行初始化操作。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini</span><br><span class="line">复制代码const <span class="attr">person</span> = new Person(<span class="string">&#x27;Echo&#x27;</span>, <span class="number">26</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们创建了一个 Person 类的实例 person，并传递了 ‘Echo’ 和 26 作为构造函数的参数。构造函数会将这些参数的值分别赋给 person 实例的 name 和age 成员变量。</p>
<h3 id="3-4-构造函数的可选参数和默认值"><a href="#3-4-构造函数的可选参数和默认值" class="headerlink" title="3.4. 构造函数的可选参数和默认值"></a>3.4. 构造函数的可选参数和默认值</h3><p>构造函数的参数可以设置为可选的，并且可以为参数提供默认值。</p>
<p>可选参数使用问号（ <strong>?</strong> ）修饰符进行标记，而默认值则使用等号（**&#x3D;**）进行赋值。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span> = <span class="string">&#x27;Echo&#x27;</span>, age?: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 person 实例，但不传递 name 和 age 参数</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// 输出：Echo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">age</span>);  <span class="comment">// 输出：undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 person1 实例，只传递 name 参数</span></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Jee&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// 输出：Jee</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">age</span>);  <span class="comment">// 输出：undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 person2 实例，同时传递 name 和 age 参数</span></span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;James&#x27;</span>, <span class="number">35</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>); <span class="comment">// 输出：James</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">age</span>);  <span class="comment">// 输出：35</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，name 参数具有一个默认值 ‘Echo’，而 age 参数则是可选的。如果在创建实例时不传 name 和 age 参数，那么 name 会输出默认值 ‘Echo’，而 age 会被设置为 undefined，如果在创建实例时只传递了 name 参数，而没有传递 age 参数，那么 age 也会被设置为 undefined。</p>
<h3 id="3-5-调用其他构造函数（构造函数重载）"><a href="#3-5-调用其他构造函数（构造函数重载）" class="headerlink" title="3.5 .调用其他构造函数（构造函数重载）"></a>3.5 .调用其他构造函数（构造函数重载）</h3><p>在一个类中，可以定义多个构造函数，并通过不同的参数配置来进行重载。重载的构造函数之间可以相互调用，使用 <strong>this</strong> 关键字来引用当前类的实例。</p>
<p>构造函数重载需要定义多个具有不同参数类型和数量的构造函数签名。构造函数签名是指构造函数名称和参数列表，通过这些不同的签名来区分不同的构造函数。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">php复制代码<span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">  <span class="title function_ invoke__">constructor</span>(<span class="attr">parameter1</span>: Type1);</span><br><span class="line">  <span class="title function_ invoke__">constructor</span>(<span class="attr">parameter1</span>: Type1, <span class="attr">parameter2</span>: Type2);</span><br><span class="line">  <span class="title function_ invoke__">constructor</span>(<span class="attr">parameter1</span>: Type1, <span class="attr">parameter2</span>: Type2, <span class="attr">parameter3</span>: Type3);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_ invoke__">constructor</span>(<span class="attr">parameter1</span>: Type1, <span class="attr">parameter2</span>: Type2, <span class="attr">parameter3</span>: Type3, ...) &#123;</span><br><span class="line">    <span class="comment">// 书写构造函数实现的逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了三个构造函数签名，每个签名有不同的参数类型和数量，以提供不同的构造函数选项。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>);</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>);</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age?: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="keyword">if</span> (age) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Echo&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Echo&#x27;</span>, <span class="number">26</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>, person1.<span class="property">age</span>); <span class="comment">// 输出：Echo 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person2.<span class="property">name</span>, person2.<span class="property">age</span>); <span class="comment">// 输出：Echo 26</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了两个构造函数签名，第一个构造函数接收一个 name 参数，第二个构造函数接收一个 name 和一个 age 参数。在构造函数的实现中，根据传递的参数情况，决定是否给 age 成员变量赋值。接着，我们创建了两个实例 person1 和 person2，第一次实例化传递了一个 name 参数，调用了第一个构造函数。第二次实例化传递了一个 name 参数和一个 age 参数，调用了第二个构造函数。</p>
<p>注意：</p>
<ul>
<li>成员初始化（比如 name: string）后，才可以通过 this.name 来访问实例成员。</li>
<li>需要为构造函数指定类型注解，否则会被隐式推断为 any 类型，构造函数不需要返回值类型。</li>
</ul>
<h2 id="4-类的实例方法"><a href="#4-类的实例方法" class="headerlink" title="4. 类的实例方法"></a>4. 类的实例方法</h2><p>在 TypeScript 类中，实例方法是定义在类中的成员方法，用于操作和访问类的实例属性，并执行特定的操作。实例方法可以通过类的实例来调用，用于对特定实例进行特定操作。</p>
<h3 id="4-1-定义实例方法"><a href="#4-1-定义实例方法" class="headerlink" title="4.1. 定义实例方法"></a>4.1. 定义实例方法</h3><p>实例方法是通过在类中定义普通函数来创建的。语法格式如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">php复制代码<span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">  <span class="title function_ invoke__">methodName</span>(<span class="attr">parameter1</span>: Type1, <span class="attr">parameter2</span>: Type2): ReturnType &#123;</span><br><span class="line">    <span class="comment">// 书写方法的实现逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，methodName 是实例方法的名称，parameter1 和 parameter2 是方法的参数，Type1 和 Type2 是参数的类型，ReturnType 是方法的返回类型。</p>
<h3 id="4-2-访问实例属性"><a href="#4-2-访问实例属性" class="headerlink" title="4.2. 访问实例属性"></a>4.2. 访问实例属性</h3><p>实例方法可以通过使用 this 关键字直接访问类的实例属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHello</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，sayHello 是一个实例方法，它访问了 Person 类的 name 和 age 属性，并在控制台打印出相应的消息。</p>
<h3 id="4-3-调用实例方法"><a href="#4-3-调用实例方法" class="headerlink" title="4.3. 调用实例方法"></a>4.3. 调用实例方法</h3><p>实例方法必须通过类的实例来调用。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码const <span class="attr">person</span> = new Person(<span class="string">&quot;Echo&quot;</span>, <span class="number">26</span>)<span class="comment">;</span></span><br><span class="line">person.sayHello()<span class="comment">; // 输出：Hello, my name is Echo and I&#x27;m 26 years old.</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先创建了一个 Person 类的实例 person，然后使用 person 实例来调用 sayHello 方法。</p>
<h2 id="5-类的继承"><a href="#5-类的继承" class="headerlink" title="5. 类的继承"></a>5. 类的继承</h2><p>类的继承有2种方式：</p>
<ol>
<li>extends（继承父类）</li>
<li>implements（实现接口）</li>
</ol>
<p>说明：JS 中只有 extends，而 implements 是 TS 提供的。</p>
<h3 id="5-1-extends（继承父类）"><a href="#5-1-extends（继承父类）" class="headerlink" title="5.1. extends（继承父类）"></a>5.1. extends（继承父类）</h3><p>当一个类继承另一个类时，它会继承父类的属性和方法，并可以通过重载或添加新的属性和方法来扩展父类。继承使用 <strong>extends</strong> 关键字来建立类之间的关系。</p>
<h4 id="5-1-1-定义父类和子类"><a href="#5-1-1-定义父类和子类" class="headerlink" title="5.1.1. 定义父类和子类"></a>5.1.1. 定义父类和子类</h4><p>父类是被继承的类，子类是继承父类的类。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala复制代码<span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 书写父类的属性和方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 书写子类特有的属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，ParentClass 是父类，ChildClass 是子类，ChildClass 继承了 ParentClass 的属性和方法。</p>
<h4 id="5-1-2-继承父类的属性和方法"><a href="#5-1-2-继承父类的属性和方法" class="headerlink" title="5.1.2. 继承父类的属性和方法"></a>5.1.2. 继承父类的属性和方法</h4><p>使用 <strong>extends</strong> 关键字来建立子类对父类的继承关系。子类会继承父类的公共成员（属性和方法）。子类可以直接访问和使用继承来的属性和方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">move</span>(<span class="attr">distance</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> moved <span class="subst">$&#123;distance&#125;</span> meters.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">bark</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Woof! Woof!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，Animal 是父类，其中包含了 name 属性和 move 方法。Dog 是子类，使用 extends Animal 建立了继承关系。Dog 继承了 Animal 的属性和方法，并且定义了自己的 bark 方法。</p>
<h4 id="5-1-3-调用继承的属性和方法"><a href="#5-1-3-调用继承的属性和方法" class="headerlink" title="5.1.3. 调用继承的属性和方法"></a>5.1.3. 调用继承的属性和方法</h4><p>子类可以直接调用继承来的父类属性和方法，也可以访问自己定义的属性和方法。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arduino复制代码<span class="type">const</span> dog = <span class="keyword">new</span> <span class="built_in">Dog</span>(<span class="string">&quot;Hate&quot;</span>);</span><br><span class="line">dog.<span class="built_in">move</span>(<span class="number">10</span>);   <span class="comment">// 调用继承来自父类的方法 输出：Hate moved 10 meters.</span></span><br><span class="line">dog.<span class="built_in">bark</span>();     <span class="comment">// 调用子类自己定义的方法 输出：Woof! Woof!</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先创建了一个 Dog 类的实例 dog。我们可以通过 dog 实例调用继承自父类的 move 方法，也可以调用子类自己定义的 bark 方法。</p>
<h3 id="5-2-implements（实现接口）"><a href="#5-2-implements（实现接口）" class="headerlink" title="5.2. implements（实现接口）"></a>5.2. implements（实现接口）</h3><p>接口的实现是以类为基础的，类可以通过 <strong>implements</strong> 关键字实现一个或多个接口。通过实现接口，类必须提供接口中定义的所有属性和方法的具体实现。</p>
<h4 id="5-2-1-定义接口"><a href="#5-2-1-定义接口" class="headerlink" title="5.2.1. 定义接口"></a>5.2.1. 定义接口</h4><p>接口是一种抽象的类型，定义了一组属性和方法的规范。接口在定义时不包含具体的实现，而是描述了类应具备的特定行为和功能。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制代码<span class="keyword">interface</span> <span class="title class_">InterfaceName</span> &#123;</span><br><span class="line">  <span class="comment">// 书写接口的属性和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，InterfaceName 是一个接口，用于定义属性和方法的规范。</p>
<h4 id="5-2-2-使用-implements-实现接口"><a href="#5-2-2-使用-implements-实现接口" class="headerlink" title="5.2.2. 使用 implements 实现接口"></a>5.2.2. 使用 implements 实现接口</h4><p>使用 implements 关键字来实现接口，使得类能够满足接口定义的规范。通过实现接口，类必须提供接口中定义的所有属性和方法的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="keyword">class</span> <span class="title class_">ClassName</span> <span class="keyword">implements</span> <span class="title class_">InterfaceName</span> &#123;</span><br><span class="line">  <span class="comment">// 书写类的属性和方法的具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，ClassName 是一个类，通过 implements InterfaceName 实现了接口 InterfaceName，从而满足了接口定义的规范。</p>
<h4 id="5-2-3-实现接口的属性和方法"><a href="#5-2-3-实现接口的属性和方法" class="headerlink" title="5.2.3. 实现接口的属性和方法"></a>5.2.3. 实现接口的属性和方法</h4><p>实现接口的类必须包含接口中定义的所有属性和方法，并提供它们的具体实现。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">getArea</span>(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">radius: <span class="built_in">number</span>, color: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">radius</span> = radius;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getArea</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="variable language_">this</span>.<span class="property">radius</span> * <span class="variable language_">this</span>.<span class="property">radius</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">10</span>, <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> area = circle.<span class="title function_">getArea</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(area); <span class="comment">// 输出：314.1592653589793</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，Shape 是一个接口，定义了属性 color 和方法 getArea()。Circle 类通过 implements Shape 实现了接口 Shape，并提供了接口中定义的属性和方法的具体实现。</p>
<h2 id="6-类的修饰符"><a href="#6-类的修饰符" class="headerlink" title="6. 类的修饰符"></a>6. 类的修饰符</h2><p>在 TypeScript 中，类的修饰符用于控制类的成员（属性和方法）的可见性和访问权限。</p>
<p>类的修饰符包括：</p>
<ol>
<li>public（公有的），可以在任何地方被访问到，默认所有的属性和方法都是 public 的。</li>
<li>privete（私有的），不能在声明它的类的外部访问。</li>
<li>protected（受保护的），和 private 类似，区别是它在子类中也是允许被访问的。</li>
</ol>
<h3 id="6-1-public"><a href="#6-1-public" class="headerlink" title="6.1. public"></a>6.1. public</h3><p>public 关键字是默认的访问修饰符，如果不指定修饰符，默认为 public。公共成员在类的内部和外部都是可见的，并且可以随时访问。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">sayHello</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I&#x27;m <span class="subst">$&#123;<span class="variable language_">this</span>.age&#125;</span> years old.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Echo&quot;</span>, <span class="number">26</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// 输出：ECho</span></span><br><span class="line">person.<span class="title function_">sayHello</span>();        <span class="comment">// 输出：Hello, my name is Echo and I&#x27;m 26 years old.</span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;James&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// 输出：James</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，name、age 和 sayHello() 都是公共成员，可以在类的内部和外部进行访问。</p>
<h3 id="6-2-private"><a href="#6-2-private" class="headerlink" title="6.2. private"></a>6.2. private</h3><p>private 关键字修饰符限制成员的访问范围仅在类的内部。私有成员在类的外部不可见，只能在类的内部进行访问。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">sayHello</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Echo&quot;</span>);</span><br><span class="line">person.<span class="title function_">sayHello</span>();        <span class="comment">// 输出：Hello, my name is Echo.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// 报错：属性“name”为私有属性，只能在类“Person”中访问</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，成员 name 是私有成员，只能在类的内部进行访问，外部访问会报错。</p>
<p><strong>注意：1. 使用 private 修饰的属性或方法，在子类中也是不允许访问的。</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala复制代码<span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> name: string;</span><br><span class="line">  public constructor(name: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  constructor(name: string) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    console.log(<span class="keyword">this</span>.name); <span class="comment">// 报错：属性“name”为私有属性，只能在类“Animal”中访问</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：2. 当构造函数修饰为 private 时，该类不允许被继承或者实例化。</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala复制代码<span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  public name: string;</span><br><span class="line">  <span class="keyword">private</span> constructor(name: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123; <span class="comment">// 报错：无法扩展类“Animal”，类构造函数标记为私有</span></span><br><span class="line">  constructor(name: string) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = <span class="keyword">new</span> <span class="type">Animal</span>(&#x27;<span class="type">Hate</span>&#x27;); <span class="comment">// 报错：类“Animal”的构造函数是私有的，仅可在类声明中访问。</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-protected"><a href="#6-3-protected" class="headerlink" title="6.3. protected"></a>6.3. protected</h3><p>protected 关键字修饰符限制成员的访问范围在类的内部及其派生类中。受保护成员在类的外部不可见，但可以在类的内部和派生类中进行访问。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// 输出：Hate</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&#x27;Hate&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>注意：<strong>当构造函数修饰为 protected 时，该类只允许被继承。</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala复制代码<span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  public name: string;</span><br><span class="line">  <span class="keyword">protected</span> constructor(name: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  constructor(name: string) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const dog = <span class="keyword">new</span> <span class="type">Animal</span>(&#x27;<span class="type">Hate</span>&#x27;); <span class="comment">// 报错：类“Animal”的构造函数是受保护的，仅可在类声明中访问</span></span><br></pre></td></tr></table></figure>

<h3 id="6-4-readonly"><a href="#6-4-readonly" class="headerlink" title="6.4. readonly"></a>6.4. readonly</h3><p>readonly 是一个只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Echo&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// 输出：Echo</span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;James&#x27;</span>;    <span class="comment">// 报错：无法为“name”赋值，因为它是只读属性</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>如果 readonly 和其他访问修饰符同时存在的话，需要写在其后面。</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// public readonly name: string;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="keyword">readonly</span> name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>readonly 只读属性特点：</p>
<ul>
<li>只读属性必须在声明时或索引签名或构造函数内进行初始化赋值。</li>
<li>只读属性不能被重新赋值或修改，否则会报错。</li>
<li><strong>只能修饰属性，不能修饰方法。</strong></li>
</ul>
<p>只读属性和常量的区别：</p>
<ul>
<li>只读属性是 TypeScript 提供的一种语法，用于将类的属性标记为只读，并且只有在类的内部可以修改其值。</li>
<li>常量通常是通过 const 关键字声明的，在任何地方都无法修改其值，包括类的内部。</li>
</ul>
<h3 id="6-5-参数属性"><a href="#6-5-参数属性" class="headerlink" title="6.5. 参数属性"></a>6.5. 参数属性</h3><p>参数属性是一种简化代码的语法糖，用于在构造函数中同时声明和初始化类的成员属性。使用参数属性可以在一个地方完成属性的声明和赋值，减少了重复的代码。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>, <span class="keyword">private</span> age: <span class="built_in">number</span>, <span class="keyword">protected</span> sex: <span class="built_in">string</span>, <span class="keyword">public</span> <span class="keyword">readonly</span> height: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Echo&#x27;</span>, <span class="number">26</span>, <span class="string">&#x27;male&#x27;</span>, <span class="number">1.7</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);   <span class="comment">// 输出：Echo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">age</span>);    <span class="comment">// 报错：属性“age”为私有属性，只能在类“Person”中访问</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">sex</span>);    <span class="comment">// 报错：属性“sex”受保护，只能在类“Person”及其子类中访问</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">height</span>); <span class="comment">// 输出：1.7</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，定义了一个名为 Person 的类，类里面定义了一个 constructor 构造方法，其中参数 name 是公共属性，可以在类的内部和外部访问；参数 age 是私有属性，只能在类 Person 中访问；参数 sex 是受保护属性，只能在类 Person 及其子类中访问；参数 height 是只读属性，类的外部无法修改其值。</p>
<h2 id="7-抽象类"><a href="#7-抽象类" class="headerlink" title="7. 抽象类"></a>7. 抽象类</h2><p>使用关键字 <strong>abstract</strong> 用于定义抽象类和其中的抽象方法。</p>
<p>抽象类是一种不能直接实例化的类，它主要用作其他类的基类。抽象类可以包含抽象方法和具体方法的定义，供子类继承和实现。</p>
<h3 id="7-1-语法"><a href="#7-1-语法" class="headerlink" title="7.1. 语法"></a>7.1. 语法</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">csharp复制代码<span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractClass</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="title">method</span>(): <span class="keyword">void</span></span>; <span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">  concreteMethod(): <span class="keyword">void</span> &#123;</span><br><span class="line">    console.log(<span class="string">&quot;This is a concrete method&quot;</span>); <span class="comment">// 具体方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，AbstractClass 是一个抽象类，它包含了一个抽象方法 method() 和一个具体方法 concreteMethod()。</p>
<h3 id="7-2-抽象方法"><a href="#7-2-抽象方法" class="headerlink" title="7.2. 抽象方法"></a>7.2. 抽象方法</h3><p>抽象方法是在抽象类中声明但没有具体实现的方法。它只包含方法的签名，没有方法体，<strong>子类必须实现抽象方法。</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">scala复制代码<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  constructor(public name: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">abstract</span> sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>.name); <span class="comment">// 输出：Tom</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat = <span class="keyword">new</span> <span class="type">Cat</span>(&#x27;<span class="type">Tom</span>&#x27;);</span><br><span class="line">cat.sayHi();</span><br></pre></td></tr></table></figure>

<p>在上述示例中，抽象类 Animal 中的 sayHi() 是一个抽象方法，子类 Cat 继承了 父类 Animal 并实现了抽象方法。</p>
<h3 id="7-3-抽象类不能被实例化，只能被继承"><a href="#7-3-抽象类不能被实例化，只能被继承" class="headerlink" title="7.3. 抽象类不能被实例化，只能被继承"></a>7.3. 抽象类不能被实例化，只能被继承</h3><p>抽象类不能被实例化，只能被继承。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">csharp复制代码<span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span> &#123;</span><br><span class="line">  constructor(<span class="keyword">public</span> name: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="title">sayHi</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Animal(<span class="string">&#x27;Tom&#x27;</span>); <span class="comment">// 报错：无法创建抽象类的实例</span></span><br></pre></td></tr></table></figure>

<h3 id="7-4-特点"><a href="#7-4-特点" class="headerlink" title="7.4. 特点"></a>7.4. 特点</h3><ul>
<li>抽象类不能被实例化，只能被继承。</li>
<li>抽象类可以包含抽象方法和具体方法的定义。</li>
<li>子类必须实现抽象类中的所有抽象方法，否则子类也必须声明为抽象类。</li>
<li>如果一个类继承了一个抽象类，那么它必须实现抽象类中的抽象方法，除非它自身也声明为抽象类。</li>
<li>抽象类可以作为其他类的基类，用于提供共享的属性和方法定义。</li>
</ul>
<h1 id="十、类型兼容性"><a href="#十、类型兼容性" class="headerlink" title="十、类型兼容性"></a>十、类型兼容性</h1><p>类型兼容性是指在 TS 中，如何判断一个类型是否能够赋值给另一个类型。</p>
<h2 id="1-基本类型的兼容性"><a href="#1-基本类型的兼容性" class="headerlink" title="1. 基本类型的兼容性"></a>1. 基本类型的兼容性</h2><h3 id="1-1-相同的基本类型可以互相赋值"><a href="#1-1-相同的基本类型可以互相赋值" class="headerlink" title="1.1. 相同的基本类型可以互相赋值"></a>1.1. 相同的基本类型可以互相赋值</h3><p>当你声明一个变量并为其赋予一个特定类型的值时，TypeScript 会根据类型注解进行类型检查和推断。如果变量的类型与给定的值的类型完全匹配，那么它们可以互相赋值。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码let a: <span class="attr">number</span> = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">let b: <span class="attr">number</span> = a<span class="comment">;</span></span><br><span class="line">console.log(a, b)<span class="comment">; // 输出 10, 10</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，变量 a 被声明为 number 类型，并且被赋值为 10。 然后将变量 a 赋值给变量 b，因为 a 和 b 的类型相同，都是 number，所以赋值是允许的。</p>
<h3 id="1-2-数字字面量类型可以赋值给数值类型"><a href="#1-2-数字字面量类型可以赋值给数值类型" class="headerlink" title="1.2. 数字字面量类型可以赋值给数值类型"></a>1.2. 数字字面量类型可以赋值给数值类型</h3><p>当你声明一个变量并为其指定为数字字面量类型时，TypeScript 会将该变量视为一个特定的数字值，而不仅仅是一般的数值类型。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码let a: <span class="attr">10</span> = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">let b: <span class="attr">number</span> = a<span class="comment">;</span></span><br><span class="line">console.log(a, b)<span class="comment">; // 输出 10, 10</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，变量 a 被声明为数字字面量类型 10，它只能具有值 10，而不能是其它的值。然后将变量 a 赋值给变量 b，因为 b 的类型是 number，而 a 是数字字面量类型 5，数字字面量类型是数字类型的子类型，所以赋值是允许的。</p>
<p>需要注意的是，只有字面量类型才可以赋值给相应的数值类型，普通数值类型不能赋值给字面量类型，除非两者完全匹配。</p>
<h3 id="1-3-枚举类型可以赋值给数字类型"><a href="#1-3-枚举类型可以赋值给数字类型" class="headerlink" title="1.3. 枚举类型可以赋值给数字类型"></a>1.3. 枚举类型可以赋值给数字类型</h3><p>枚举类型在 TypeScript 中被编译成了一个具有反向映射的对象。默认情况下，枚举类型的成员值是从 0 开始递增的数字。由于枚举成员值是数字类型，所以它们可以被赋值给数字类型。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">css复制代码enum <span class="attribute">Direction</span> &#123;</span><br><span class="line">  Up,</span><br><span class="line">  <span class="attribute">Right</span>,</span><br><span class="line">  Down,</span><br><span class="line">  <span class="attribute">Left</span></span><br><span class="line">&#125;</span><br><span class="line">let <span class="attribute">direction</span>: Direction = Direction.Right;</span><br><span class="line">let num: number = direction;</span><br><span class="line">console<span class="selector-class">.log</span>(<span class="attribute">direction</span>, num); // 输出：<span class="number">1</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，将 Direction.Right 赋值给了枚举类型的变量 direction，然后又将 direction 赋值给了数字类型的变量 num，此时 num 的值为 1，与 Direction.Right 对应的枚举成员值相同。</p>
<p>需要注意的是，枚举类型不仅可以赋值给数字类型，也可以赋值给字面量类型或其他兼容的类型。这主要是由于 TypeScript 在类型系统中对枚举类型进行了特殊处理，使得枚举成员值可以被当作相应的字面量值使用。</p>
<h2 id="2-对象类型的兼容性"><a href="#2-对象类型的兼容性" class="headerlink" title="2. 对象类型的兼容性"></a>2. 对象类型的兼容性</h2><p>对象类型包括接口（interface）、类（class）、字面量对象等。</p>
<p>记住这句话：<strong>成员多的可以赋值给成员少的。</strong></p>
<h3 id="2-1-成员个数的兼容性"><a href="#2-1-成员个数的兼容性" class="headerlink" title="2.1. 成员个数的兼容性"></a>2.1. 成员个数的兼容性</h3><p>对象类型 T 能够赋值给对象类型 U，需要满足的条件是 T 中的成员个数要大于等于 U 中的成员个数。也就是说，T 可以拥有 U 中的所有成员，但 T 可能还有额外的成员。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码class Pont2D &#123;</span><br><span class="line">  x: number<span class="comment">;</span></span><br><span class="line">  y: number<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Point3D &#123;</span><br><span class="line">  x: number<span class="comment">;</span></span><br><span class="line">  y: number<span class="comment">;</span></span><br><span class="line">  z: number<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p1: <span class="attr">Pont2D</span> = &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;</span><br><span class="line">let p2: <span class="attr">Point3D</span> = &#123; x: <span class="number">2</span>, y: <span class="number">3</span>, z: <span class="number">4</span> &#125;</span><br><span class="line"><span class="attr">p1</span> = p2 // 正确，类 Point3D 拥有类 Point2D 中的所有成员</span><br><span class="line">// <span class="attr">p2</span> = p1 // 错误，类型 Point2D 中缺少属性 z，但类型 Point3D 中需要该属性</span><br></pre></td></tr></table></figure>

<p>在上述示例中，类 Point2D 具有 x 和 y 成员，类 Point3D 比类 Point2D 多了一个 z 成员，根据兼容性规则，Point3D 可以赋值给 Point2D，因为类 Point3D 拥有类 Point2D 中的所有成员。</p>
<h3 id="2-2-成员类型的兼容性"><a href="#2-2-成员类型的兼容性" class="headerlink" title="2.2. 成员类型的兼容性"></a>2.2. 成员类型的兼容性</h3><p>对象类型 T 能够赋值给对象类型 U，需要满足的条件是 T 中的每个成员的类型都能够赋值给 U 中对应成员的类型。这个规则适用于成员变量和成员函数。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码interface Animal &#123;</span><br><span class="line">  name: string<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Dog &#123;</span><br><span class="line">  name: string<span class="comment">;</span></span><br><span class="line">  breed: string<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let animal: <span class="attr">Animal</span> = &#123; name: <span class="string">&quot;Animal&quot;</span> &#125;<span class="comment">;</span></span><br><span class="line">let dog: <span class="attr">Dog</span> = &#123; name: <span class="string">&quot;Dog&quot;</span>, breed: <span class="string">&quot;Husky&quot;</span> &#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">animal</span> = dog<span class="comment">; // 正确，Dog 的成员类型包含 Animal 的成员类型</span></span><br><span class="line">// <span class="attr">dog</span> = animal<span class="comment">; // 错误，类型 Animal 中缺少属性 breed，但类型 Dog 中需要该属性</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-可选属性的兼容性"><a href="#2-3-可选属性的兼容性" class="headerlink" title="2.3. 可选属性的兼容性"></a>2.3. 可选属性的兼容性</h3><p>对象类型 T 能够赋值给对象类型 U，如果 U 中定义了可选属性，且 T 中没有对应的属性，则仍然可以进行赋值。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码interface Person &#123;</span><br><span class="line">  name: string<span class="comment">;</span></span><br><span class="line">  age?: number<span class="comment">; // 可选属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Employee &#123;</span><br><span class="line">  name: string<span class="comment">;</span></span><br><span class="line">  employeeId: string<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let person: <span class="attr">Person</span> = &#123; name: <span class="string">&quot;Echo&quot;</span>, age: <span class="number">26</span> &#125;<span class="comment">;</span></span><br><span class="line">let employee: <span class="attr">Employee</span> = &#123; name: <span class="string">&quot;James&quot;</span>, employeeId: <span class="string">&quot;123&quot;</span> &#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">person</span> = employee<span class="comment">; // 正确，虽然类型 Employee 中没有 age 属性，但类型 Person 中 age 属性是可选的</span></span><br><span class="line">// <span class="attr">employee</span> = person<span class="comment">; // 错误，类型 Person 中缺少属性 employeeId, 但类型 Employee 中需要该属性</span></span><br></pre></td></tr></table></figure>

<h2 id="3-函数类型兼容性"><a href="#3-函数类型兼容性" class="headerlink" title="3. 函数类型兼容性"></a>3. 函数类型兼容性</h2><p>函数之间的兼容性会比较复杂，需要考虑以下几个方面：</p>
<ul>
<li>参数个数</li>
<li>参数类型</li>
<li>返回值类型</li>
</ul>
<h3 id="3-1-参数个数"><a href="#3-1-参数个数" class="headerlink" title="3.1. 参数个数"></a>3.1. 参数个数</h3><p>源函数的参数个数要小于等于目标函数的参数个数。也就是说，源函数可以接受更少的参数或与目标函数相同数量的参数。多余的参数是允许的，因为在函数调用时可以忽略它们。</p>
<p>记住这句话：<strong>参数少的可以赋值给参数多的。</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">type</span> <span class="title class_">Adder</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Calculator</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, c: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">add</span>: <span class="title class_">Adder</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> a + b;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">calculate</span>: <span class="title class_">Calculator</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, c: <span class="built_in">number</span></span>) =&gt;</span> a + b + c;</span><br><span class="line"></span><br><span class="line">calculate = add; <span class="comment">// 正确，Adder 的参数个数少于 Calculator 的参数个数</span></span><br><span class="line"><span class="comment">// add = calculate; // 错误，Calculator 的参数个数多于 Adder 的参数个数</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了两个类型 Adder 和 Calculator 分别表示加法函数和计算函数。根据函数兼容性规则，add 可以赋值给 calculate，因为 Adder 的参数个数（2个）少于 Calculator 的参数个数（3个）。但是相反的赋值会导致兼容性错误，因为 Calculator 的参数个数（3个）要多于 Adder 的参数个数（2个）。</p>
<h3 id="3-2-参数类型"><a href="#3-2-参数类型" class="headerlink" title="3.2. 参数类型"></a>3.2. 参数类型</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码let <span class="attr">x</span> = (a: number) =&gt; <span class="number">0</span><span class="comment">;</span></span><br><span class="line">let <span class="attr">y</span> = (a: number, b: string) =&gt; <span class="number">0</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">y</span> = x<span class="comment">; // 正确</span></span><br><span class="line">// <span class="attr">x</span> = y<span class="comment">; // 错误</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，函数 x 的参数只有一个 a，类型为 number，函数 y 的参数有两个 a 和 b，类型分别为 number 和 string，x 可以赋值给 y，是因为 x 的每个参数都能在 y 里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 而 y 不能赋值给 x，因为 y 有个必需的第二个参数，但是 x 并没有，所以不允许赋值。</p>
<h3 id="3-3-返回值类型"><a href="#3-3-返回值类型" class="headerlink" title="3.3. 返回值类型"></a>3.3. 返回值类型</h3><p>如果返回值类型是普通类型，此时函数的返回值类型要相同。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">type</span> <span class="variable constant_">F1</span> = <span class="function">() =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F2</span> = <span class="function">() =&gt;</span> <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">func1</span>: <span class="variable constant_">F1</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">func2</span>: <span class="variable constant_">F2</span></span><br><span class="line"></span><br><span class="line">func1 = func2 <span class="comment">// 正确</span></span><br><span class="line">func2 = func1 <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>如果返回值类型是对象类型，此时<strong>成员多的可以赋值给成员少的。</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">type</span> <span class="variable constant_">F3</span> = <span class="function">() =&gt;</span> &#123; <span class="attr">name</span>: <span class="built_in">string</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F4</span> = <span class="function">() =&gt;</span> &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">func3</span>: <span class="variable constant_">F3</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">func4</span>: <span class="variable constant_">F4</span></span><br><span class="line"></span><br><span class="line">func3 = func4 <span class="comment">// 正确</span></span><br><span class="line">func4 = func3 <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<h2 id="4-类类型兼容性"><a href="#4-类类型兼容性" class="headerlink" title="4. 类类型兼容性"></a>4. 类类型兼容性</h2><p>类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, employee: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">person</span>: <span class="title class_">Person</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">employee</span>: <span class="title class_">Employee</span>;</span><br><span class="line"></span><br><span class="line">employee = person; <span class="comment">// 正确</span></span><br><span class="line">person = employee; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>私有的和受保护的成员必须来自于相同的类或者父类的派生类。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scala复制代码<span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">let person: <span class="type">Person</span>;</span><br><span class="line">let employee: <span class="type">Employee</span>;</span><br><span class="line"></span><br><span class="line">employee = person; <span class="comment">// 正确</span></span><br><span class="line">person = employee; <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user: <span class="type">User</span>;</span><br><span class="line">person = user; <span class="comment">// 错误</span></span><br><span class="line">user = person; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<h2 id="5-泛型类型兼容性"><a href="#5-泛型类型兼容性" class="headerlink" title="5. 泛型类型兼容性"></a>5. 泛型类型兼容性</h2><p>当泛型类型没有明确指定类型参数时，它被认为是一种特殊的兼容性形式，称为类型参数的默认，即泛型函数或泛型类在没有传递类型参数的情况下，它们的类型参数会被推导为any。此时，泛型类型可以兼容任意类型，也能赋值给其他泛型类型。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码type Box&lt;T&gt; = &#123;</span><br><span class="line">  value: T<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let boxA: Box&lt;number&gt;<span class="comment">;</span></span><br><span class="line">let boxB: Box&lt;any&gt;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">boxA</span> = boxB<span class="comment">; // 正确，类型参数的默认 any 能兼容任意类型</span></span><br><span class="line"><span class="attr">boxB</span> = boxA<span class="comment">; // 正确，boxA 指定的类型参数是 number，也能赋值给类型参数的默认 any</span></span><br></pre></td></tr></table></figure>

<p>当泛型类型明确指定了类型参数时，要求类型参数具有兼容的类型。这意味着泛型类型在传递不同类型参数时，需要确保它们之间满足兼容性规则。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码type Box&lt;T&gt; = &#123;</span><br><span class="line">  value: T<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let boxA: Box&lt;number&gt;<span class="comment">;</span></span><br><span class="line">let boxB: Box&lt;string&gt;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">boxA</span> = boxB<span class="comment">; // 报错，不能将类型 string 分配给类型 number</span></span><br><span class="line"><span class="attr">boxB</span> = boxA<span class="comment">; // 报错，不能将类型 number 分配给类型 string</span></span><br></pre></td></tr></table></figure>

<h1 id="十一、交叉类型（Intersection-Types）"><a href="#十一、交叉类型（Intersection-Types）" class="headerlink" title="十一、交叉类型（Intersection Types）"></a>十一、交叉类型（Intersection Types）</h1><p>交叉类型类似于接口继承，是将多个类型合并为一个类型。 也就是说我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。</p>
<p>使用符号（ <strong>&amp;</strong> ）来定义交叉类型。</p>
<h2 id="1-组合对象类型"><a href="#1-组合对象类型" class="headerlink" title="1. 组合对象类型"></a>1. 组合对象类型</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码type <span class="attr">User</span> = &#123;</span><br><span class="line">  name: string<span class="comment">;</span></span><br><span class="line">  age: number<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">type <span class="attr">Admin</span> = &#123;</span><br><span class="line">  isAdmin: boolean<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">type <span class="attr">UserAdmin</span> = User &amp; Admin<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">let userAdmin: <span class="attr">UserAdmin</span> = &#123;</span><br><span class="line">  name: &quot;John&quot;,</span><br><span class="line">  age: 30,</span><br><span class="line">  isAdmin: true</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了 User 和 Admin 两个类型，然后使用交叉类型 &amp; 将 User &amp; Admin 连接起来创建了一个新的类型 UserAdmin，该类型包含了 User 和 Admin 类型的所有成员，接着我们定义了一个变量 userAdmin，该变量同时具有 User 和 Admin 类型的属性和方法。</p>
<h2 id="2-合并函数类型"><a href="#2-合并函数类型" class="headerlink" title="2. 合并函数类型"></a>2. 合并函数类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">type</span> <span class="title class_">AddFunc</span> = &#123;</span><br><span class="line">  <span class="attr">fn</span>: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MultiplyFunc</span> = &#123;</span><br><span class="line">  <span class="attr">fn1</span>: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MathOperations</span> = <span class="title class_">AddFunc</span> &amp; <span class="title class_">MultiplyFunc</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">mathOps</span>: <span class="title class_">MathOperations</span> = &#123;</span><br><span class="line">  <span class="title function_">fn</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">fn1</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 * num2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mathOps.<span class="title function_">fn</span>(<span class="number">10</span>, <span class="number">20</span>));    <span class="comment">// 输出：30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mathOps.<span class="title function_">fn1</span>(<span class="number">10</span>, <span class="number">20</span>));   <span class="comment">// 输出：200</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了两个函数类型 AddFunc 和 MultiplyFunc，AddFunc 里面定义了 fn 函数，MultiplyFunc 里面定义了 fn1 函数，并使用交叉类型 &amp; 将 AddFunc &amp; MultiplyFunc 连接起来创建了一个新的类型 MathOperations。此时变量 mathOps 同时拥有 fn 和 fn1 两个方法。</p>
<h2 id="3-交叉类型VS接口继承"><a href="#3-交叉类型VS接口继承" class="headerlink" title="3. 交叉类型VS接口继承"></a>3. 交叉类型VS接口继承</h2><ul>
<li>相同点：都可以实现对象类型的组合。</li>
<li>不同点：两种方式实现类型组合时，对于同名属性之间，处理类型冲突的方式不同。</li>
</ul>
<p>下面是接口继承的示例，接口B继承接口A，两个接口都定义了 fn 方法，返回值都是 string 类型，但是参数的类型不同，一个 string，一个 number，由于 fn 参数 value 的类型不兼容，所以接口 B 不能继承接口 A。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">php复制代码<span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span>: (<span class="params">value: number</span>) =&gt;</span> <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span>: (<span class="params">value: <span class="keyword">string</span></span>) =&gt;</span> <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132865.webp" alt="img"></p>
<p>下面是交叉类型的示例：我们定义了 A 和 B 两个接口，然后使用交叉类型 &amp; 将 A &amp; B 连接起来创建了一个新的类型 ，接着我们定义了一个变量 c，类型为 C，变量 c 调用 fn 方法，此时参数的类型我们可以传数字类型或者字符串类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">interface</span> A &#123;</span><br><span class="line">  <span class="attr">fn</span>: <span class="function">(<span class="params">value: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> B &#123;</span><br><span class="line">  <span class="attr">fn</span>: <span class="function">(<span class="params">value: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C = A &amp; B</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: C</span><br><span class="line">c.<span class="title function_">fn</span>(<span class="number">1</span>)       <span class="comment">// 正确</span></span><br><span class="line">c.<span class="title function_">fn</span>(<span class="string">&#x27;Echo&#x27;</span>)  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<h2 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h2><p><strong>如果合并的多个接口类型存在同名属性会是什么效果呢？</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码type <span class="attr">User</span> = &#123;</span><br><span class="line">  id: number<span class="comment">;</span></span><br><span class="line">  name: string<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type <span class="attr">Admin</span> = &#123;</span><br><span class="line">  name: number<span class="comment">;</span></span><br><span class="line">  age: number<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type <span class="attr">UserAdmin</span> = User &amp; Admin</span><br><span class="line"></span><br><span class="line">const user: <span class="attr">UserAdmin</span> = &#123;</span><br><span class="line">  id: 1,</span><br><span class="line">  // name: &quot;Echo&quot;, // 错误：不能将类型“string”分配给类型“never”</span><br><span class="line">  name: 26, // 错误：不能将类型“number”分配给类型“never”</span><br><span class="line">  age: 26</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>在上面示例中，定义了两个类型 User 和 Admin，其中类型 User 中有 id 和 name 属性，类型 Admin 中有 name 和 age 属性，两个类型都有同名的 name 属性，但类型不同，一个是 string，一个是 number，合并后，name 属性的类型就是 string 和 number 两个原子类型的交叉类型，即 never。</p>
<p>此时，我们如果赋予 user 任意类型的 name 属性值都会提示类型错误。而如果我们不设置 name 属性，又会提示一个缺少必选的 name 属性的错误。在这种情况下，就意味着上述代码中交叉出来的 UserAdmin 类型是一个无用类型。</p>
<p><strong>如果同名属性的类型兼容，比如一个是 number，另一个是 number 的子类型、数字字面量类型，合并后 name 属性的类型就是两者中的子类型。</strong></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码type <span class="attr">User</span> = &#123;</span><br><span class="line">  id: number<span class="comment">;</span></span><br><span class="line">  name: number<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type <span class="attr">Admin</span> = &#123;</span><br><span class="line">  name: 2<span class="comment">;</span></span><br><span class="line">  age: number<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type <span class="attr">UserAdmin</span> = User &amp; Admin</span><br><span class="line"></span><br><span class="line">const user: <span class="attr">UserAdmin</span> = &#123;</span><br><span class="line">  id: 1,</span><br><span class="line">  // name: 2, // 正确</span><br><span class="line">  name: 22,  // 错误：不能将类型“22”分配给类型“2”</span><br><span class="line">  age: 26</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>在上面示例中，name 属性的类型就是数字字面量类型 2，因此，我们不能把任何非 2 之外的值赋予 name 属性。</p>
<p><strong>如果交叉类型中的某个成员是对象类型，那么交叉后的类型将拥有这些对象类型的所有属性</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">css复制代码interface <span class="selector-tag">A</span> &#123;</span><br><span class="line">  x: &#123;</span><br><span class="line">    isShow: boolean</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface <span class="selector-tag">B</span> &#123;</span><br><span class="line">  x: &#123;</span><br><span class="line">    name: string</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface C &#123;</span><br><span class="line">  x: &#123;</span><br><span class="line">    age: number</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ABC = <span class="selector-tag">A</span> &amp; <span class="selector-tag">B</span> &amp; C;</span><br><span class="line"></span><br><span class="line">let abc: ABC = &#123;</span><br><span class="line">  x: &#123;</span><br><span class="line">    isShow: true,</span><br><span class="line">    name: <span class="string">&#x27;Echo&#x27;</span>,</span><br><span class="line">    age: <span class="number">26</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console<span class="selector-class">.log</span>(abc); // 输出：x: &#123; isShow: true, name: <span class="string">&#x27;Echo&#x27;</span>, age: <span class="number">26</span> &#125;</span><br></pre></td></tr></table></figure>

<h1 id="十二、泛型（Generics）"><a href="#十二、泛型（Generics）" class="headerlink" title="十二、泛型（Generics）"></a>十二、泛型（Generics）</h1><h2 id="1-什么是泛型"><a href="#1-什么是泛型" class="headerlink" title="1. 什么是泛型"></a>1. 什么是泛型</h2><p>泛型（Generics）是 TypeScript 中一种允许我们在定义函数、类或接口时使用参数化类型的机制。泛型可以看作是类型参数，类似于函数中的参数，但是用于表示类型而不是值。它允许我们在定义函数、类或接口时使用占位符表示类型，并在实际使用时指定具体的类型。</p>
<h2 id="2-一个简单的例子"><a href="#2-一个简单的例子" class="headerlink" title="2. 一个简单的例子"></a>2. 一个简单的例子</h2><p>现在我们有个需求：实现一个函数，传入的函数参数是什么类型的，返回值的类型也要跟函数参数的类型相同，并且函数只能接收一个参数，你会怎么做？</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">const</span> <span class="attr">identity</span>: <span class="function">(<span class="params">value: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function">(<span class="params">value</span>) =&gt;</span> value</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">identity</span>(<span class="number">10</span>)); <span class="comment">// 输出：10，类型是number</span></span><br></pre></td></tr></table></figure>

<p>上面的示例中，我们创建了一个 identity 函数，参数值和返回值类型都为 number，调用 identity 函数，传入一个数字，会返回数字本身。但是，该函数只能接收数值类型，如果我调用函数的时候传入字符串或者布尔值类型的值，此时就会报错。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">const</span> <span class="attr">identity</span>: <span class="function">(<span class="params">value: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function">(<span class="params">value</span>) =&gt;</span> value</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">identity</span>(<span class="string">&#x27;Echo&#x27;</span>)); <span class="comment">// 报错：类型“string”的参数不能赋值给类型“number”的参数</span></span><br></pre></td></tr></table></figure>

<p>为了让函数能够接收任意类型，可以将参数类型改为any，但是，这样就失去了 TS 的类型保护，类型不安全。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">const</span> <span class="attr">identity</span>: <span class="function">(<span class="params">value: <span class="built_in">any</span></span>) =&gt;</span> <span class="built_in">any</span> = <span class="function">(<span class="params">value</span>) =&gt;</span> value</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">identity</span>(<span class="string">&#x27;Echo&#x27;</span>));    <span class="comment">// 输出：Echo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">identity</span>(<span class="number">26</span>));        <span class="comment">// 输出：26</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">identity</span>(<span class="literal">true</span>));      <span class="comment">// 输出：true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">identity</span>(<span class="literal">null</span>));      <span class="comment">// 输出：null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">identity</span>(<span class="literal">undefined</span>)); <span class="comment">// 输出：undefined</span></span><br></pre></td></tr></table></figure>

<p>为了解决上面的这些问题，我们<strong>使用泛型对上面的代码进行重构。</strong> 泛型在保证类型安全（不丢失类型信息）的同时，可以让函数等于多钟不同的类型一起工作，灵活可复用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>复制代码<span class="keyword">function</span> <span class="keyword">identity</span><span class="operator">&lt;</span>T<span class="operator">&gt;</span>(<span class="keyword">value</span>: T): T &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">identity</span><span class="operator">&lt;</span>string<span class="operator">&gt;</span>(<span class="string">&#x27;Echo&#x27;</span>));   <span class="operator">/</span><span class="operator">/</span> 输出：Echo</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">identity</span><span class="operator">&lt;</span>number<span class="operator">&gt;</span>(<span class="number">26</span>));       <span class="operator">/</span><span class="operator">/</span> 输出：<span class="number">26</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">identity</span><span class="operator">&lt;</span><span class="type">boolean</span><span class="operator">&gt;</span>(<span class="literal">true</span>));    <span class="operator">/</span><span class="operator">/</span> 输出：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，我们在函数名 identity 后添加了 ，其中 T 代表 Type，在定义泛型时通常用作第一个类型变量名称。但实际上 T 可以用任何有效名称代替。在调用函数 identity 时，在&lt;&gt;中指定类型 string，此时参数和返回值类型也都为 string。</p>
<h2 id="3-泛型语法"><a href="#3-泛型语法" class="headerlink" title="3. 泛型语法"></a>3. 泛型语法</h2><ul>
<li>在函数名称的后面添加尖括号（ <strong>&lt;&gt;</strong> ）,尖括号中添加类型变量，比如下图中的 <strong>T。</strong></li>
<li>其中 T 代表 Type，可以是任意合法的变量名称。</li>
<li>类型变量 T，是一种特殊类型的变量，它用于处理类型而不是值。</li>
<li>该类型变量相当于一个类型容器，能够捕获用户提供的类型（具体是什么类型，由用户调用该函数时指定）。</li>
<li>因为 T 是类型，因此可以将其作为函数参数和返回值的类型，表示参数和返回值具有相同的类型。</li>
</ul>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r复制代码<span class="keyword">function</span> identity<span class="operator">&lt;</span><span class="built_in">T</span><span class="operator">&gt;</span><span class="punctuation">(</span>value<span class="operator">:</span> <span class="built_in">T</span><span class="punctuation">)</span><span class="operator">:</span> <span class="built_in">T</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="built_in">return</span> value;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在下面的示例中，调用泛型函数 identity，当传入类型 number 后，这个类型就会被函数声明时指定的类型变量 T 捕获到，此时，T 的类型就是 number，所以，函数 identity 的参数和返回值的类型也都是 number。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132991.webp" alt="img"></p>
<h2 id="4-简化调用泛型函数"><a href="#4-简化调用泛型函数" class="headerlink" title="4. 简化调用泛型函数"></a>4. 简化调用泛型函数</h2><ul>
<li>在调用泛型函数时，可以<strong>省略&lt;类型&gt;来简化泛型函数的调用</strong>。</li>
<li>此时，TS 内部会采用一种叫做类型参数推断的机制，来根据传入的实参自动推断出类型变量 T 的类型。</li>
<li>当编译器无法推断类型或者推断的类型不准确时，就需要显示地传入类型参数。</li>
</ul>
<p>比如，传入实参10，TS 会自动推断出变量 num 的类型 number，并作为 T 的类型。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r复制代码<span class="keyword">function</span> identity<span class="operator">&lt;</span><span class="built_in">T</span><span class="operator">&gt;</span><span class="punctuation">(</span>value<span class="operator">:</span> <span class="built_in">T</span><span class="punctuation">)</span><span class="operator">:</span> <span class="built_in">T</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="built_in">return</span> value;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132114.webp" alt="img"></p>
<h2 id="5-多个类型参数"><a href="#5-多个类型参数" class="headerlink" title="5. 多个类型参数"></a>5. 多个类型参数</h2><p>定义泛型的时候，可以一次定义多个类型参数：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arduino复制代码function <span class="built_in">swap</span>&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;</span><br><span class="line">  <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">swap</span>([<span class="string">&#x27;Echo&#x27;</span>, <span class="number">26</span>])); <span class="comment">// [26, &#x27;Echo]</span></span><br></pre></td></tr></table></figure>

<p>上述示例中，我们定义了一个 swap 函数，用来交换输入的元组。</p>
<h2 id="6-泛型类"><a href="#6-泛型类" class="headerlink" title="6. 泛型类"></a>6. 泛型类</h2><p>泛型类（Generic Class）是指在定义类时使用泛型类型参数的类。它允许我们在类的属性、方法、构造函数以及实例化时使用泛型。</p>
<ul>
<li>在 class 名称后面添加 <strong>&lt;类型变量&gt;</strong> ，这个类就变成了泛型类。</li>
<li>在创建 class 实例时，在类名后面通过 <strong>&lt;类型&gt;</strong> 来指定明确的类型。</li>
</ul>
<p>下面是一个简单的泛型类的示例：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">kotlin复制代码<span class="keyword">class</span> <span class="title class_">Container</span>&lt;<span class="type">T</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> items: T[] = [];</span><br><span class="line"></span><br><span class="line">  addItem(item: T) &#123;</span><br><span class="line">    <span class="keyword">this</span>.items.push(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getItem(index: number): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getItems(): T[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.items;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = new Container&lt;number&gt;(); <span class="comment">// 实例化一个泛型类，指定类型参数为 number</span></span><br><span class="line">container.addItem(<span class="number">1</span>);</span><br><span class="line">container.addItem(<span class="number">2</span>);</span><br><span class="line">console.log(container.getItems()); <span class="comment">// 输出: [1, 2]</span></span><br></pre></td></tr></table></figure>

<h2 id="7-泛型接口"><a href="#7-泛型接口" class="headerlink" title="7. 泛型接口"></a>7. 泛型接口</h2><ul>
<li>在接口名称的后面添加 <strong>&lt;类型变量&gt;</strong> ，那么，这个接口就变成了泛型接口。</li>
<li>接口的类型变量，对接口中所有其它成员可见，也就是<strong>接口中所有成员都可以使用类型变量。</strong></li>
<li>使用泛型接口时，需要显示指定具体的类型。</li>
</ul>
<p>下面是一个简单的泛型接口的示例：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vbnet复制代码<span class="keyword">interface</span> KeyValuePair&lt;K, V&gt; &#123;</span><br><span class="line">  <span class="keyword">key</span>: K;</span><br><span class="line">  value: V;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pair1: KeyValuePair&lt;number, <span class="type">string</span>&gt; = &#123; <span class="keyword">key</span>: <span class="number">1</span>, value: <span class="string">&quot;one&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> pair2: KeyValuePair&lt;<span class="type">string</span>, <span class="type">boolean</span>&gt; = &#123; <span class="keyword">key</span>: <span class="string">&quot;isEnabled&quot;</span>, value: <span class="literal">true</span> &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="8-泛型参数的默认类型"><a href="#8-泛型参数的默认类型" class="headerlink" title="8. 泛型参数的默认类型"></a>8. 泛型参数的默认类型</h2><p>在 TypeScript 2.3 以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码function createArray&lt;<span class="attr">T</span> = string&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">  let result: T<span class="section">[]</span> = <span class="section">[]</span><span class="comment">;</span></span><br><span class="line">  for (let <span class="attr">i</span> = <span class="number">0</span><span class="comment">; i &lt; length; i++) &#123;</span></span><br><span class="line">    result<span class="section">[i]</span> = value<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">  return result<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-泛型约束"><a href="#9-泛型约束" class="headerlink" title="9. 泛型约束"></a>9. 泛型约束</h2><p>默认情况下，泛型函数的类型参数 T 理论上是可以是任何类型的，不同于 any，你不管使用它的什么属性或者方法都会报错（除非这个属性和方法是所有集合共有的）。</p>
<p>比如下面的示例中，我想打印出参数的 length 属性，如果不进行泛型约束 TS 是会报错的：类型“T”上不存在属性“length”。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132344.webp" alt="img"></p>
<p>报错的原因很明显，如果要解决这个问题，我们就可以通过给泛型（类型变量）添加约束。</p>
<p>下面我们通过 <strong>extends</strong> 关键字进行类型约束：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scss复制代码interface ILength &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getLength&lt;T extends ILength&gt;(value: T): T &#123;</span><br><span class="line">  console<span class="selector-class">.log</span>(value.length);</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">getLength</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])                    <span class="comment">// 正确，因为数组有 length 属性</span></span><br><span class="line"><span class="built_in">getLength</span>(&#x27;Echo&#x27;) <span class="comment">//                    // 正确，因为字符串有 length 属性</span></span><br><span class="line"><span class="built_in">getLength</span>(&#123; length: <span class="number">10</span>, name: &#x27;Echo&#x27; &#125;) <span class="comment">// 正确，因为传入的参数有 length 舒心</span></span><br><span class="line"><span class="built_in">getLength</span>(<span class="number">10</span>)                           <span class="comment">// 报错：类型“number”不能赋值给类型“ILength”的参数，因为数字不具有 length 属性</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个 ILength 接口，具有 length 属性。在泛型函数 getLength 中，使用 T extends ILength 进行约束，该约束表示：传入的类型必须具有 length 属性。</p>
<h1 id="十三、TS中的关键字"><a href="#十三、TS中的关键字" class="headerlink" title="十三、TS中的关键字"></a>十三、TS中的关键字</h1><p>TS 内置了一些常用的工具类型，来简化 TS 中一些常见的操作，它们都是基于泛型实现的，并且是内置的，所以可以直接使用。</p>
<p>在学习工具类型之前，我们先学习一些关键字和基础知识，以便我们可以更好的去学习后面的内置工具类型。</p>
<h2 id="1-keyof"><a href="#1-keyof" class="headerlink" title="1. keyof"></a>1. keyof</h2><p>在 TS 中，<strong>keyof</strong> 操作符主要用途是用于获取类型中所有键的关键字。它用于泛型中，通常与索引类型（index type）结合使用。其<strong>返回类型是联合类型</strong>。</p>
<p>下面示例中，我们定义了一个接口 Person，包含 name、age 和 gender 三个键，然后使用 keyof 来获取 Person 接口的所有键，这样，Keys 类型就是一个由 “name” | “age” | “gender” 构成的联合字面量类型。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码interface Person &#123;</span><br><span class="line">  name: string<span class="comment">;</span></span><br><span class="line">  age: number<span class="comment">;</span></span><br><span class="line">  gender: string<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type <span class="attr">Keys</span> = keyof Person<span class="comment">; // &quot;name&quot; | &quot;age&quot; | &quot;gender&quot;</span></span><br></pre></td></tr></table></figure>

<p>下面示例中，我们创建一个函数来获取对象中属性的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">function</span> getProp&lt;<span class="title class_">Type</span>, <span class="title class_">Key</span> <span class="keyword">extends</span> keyof <span class="title class_">Type</span>&gt;(<span class="attr">obj</span>: <span class="title class_">Type</span>, <span class="attr">key</span>: <span class="title class_">Key</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Echo&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">26</span>,</span><br><span class="line">  <span class="attr">gender</span>: <span class="string">&#x27;male&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getProp</span>(person, <span class="string">&#x27;name&#x27;</span>))   <span class="comment">// 输出：Echo</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getProp</span>(person, <span class="string">&#x27;age&#x27;</span>))    <span class="comment">// 输出：26</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getProp</span>(person, <span class="string">&#x27;gender&#x27;</span>)) <span class="comment">// 输出：male</span></span><br></pre></td></tr></table></figure>

<p>在 TS 中，  是一种泛型约束方式，用于限制一个泛型类型参数 key 的范围。<strong>extends</strong> 关键字表示限制 key 的取值只能是 Type 类型中已有的属性名。可以理解为：Key 只能是 Type 所有键中的任意一个，或者说只能访问对象中存在的属性。</p>
<p>在上面的例子中，getProp 函数接收两个参数：一个泛型类型参数 Type，代表输入对象的类型；一个泛型类型参数 Key，代表属性名的类型。keyof Type 实际上获取的是 person 对象所有键的联合字面量类型，也就是：’name’ | ‘age’ | ‘gender’，当我们调用调用 getProp 函数传入一个不存在的属性名，例如： ‘school’ 会引发编译错误。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202310011132463.webp" alt="img"></p>
<h2 id="2-typeof"><a href="#2-typeof" class="headerlink" title="2. typeof"></a>2. typeof</h2><p>在 TS 中，<strong>typeof</strong> 操作符的主要用途是在类型上下文中获取变量或者属性的类型。</p>
<h3 id="2-1-typeof获取变量的声明类型"><a href="#2-1-typeof获取变量的声明类型" class="headerlink" title="2.1. typeof获取变量的声明类型"></a>2.1. typeof获取变量的声明类型</h3><p>在 TS 中，typeof 可以用来返回一个变量的声明类型，如果不存在，则获取该类型的推论类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">let</span> <span class="attr">n</span>: <span class="built_in">number</span> = <span class="number">26</span></span><br><span class="line"><span class="keyword">type</span> N = <span class="keyword">typeof</span> n <span class="comment">// 等同于 typeof N = number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">s</span>: <span class="built_in">string</span> = <span class="string">&#x27;Echo&#x27;</span></span><br><span class="line"><span class="keyword">type</span> S = <span class="keyword">typeof</span> s <span class="comment">// 等同于 typeof S = string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = []</span><br><span class="line"><span class="keyword">type</span> A = <span class="keyword">typeof</span> a <span class="comment">// 等同于 typeof A = number[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">sy</span>: <span class="title class_">Symbol</span> = <span class="title class_">Symbol</span>()</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">SY</span> = <span class="keyword">typeof</span> sy <span class="comment">// 等同于 typeof SY = Symbol</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是：</p>
<ul>
<li><strong>typeof作为类型操作符后面只能跟变量。</strong></li>
</ul>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码let <span class="attr">str</span> = <span class="string">&#x27;s&#x27;</span><span class="comment">;</span></span><br><span class="line">type <span class="attr">S</span> = typeof str<span class="comment">; // 正确</span></span><br><span class="line"></span><br><span class="line">// type <span class="attr">S1</span> = typeof <span class="string">&#x27;str&#x27;</span><span class="comment">;  // 错误</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果变量没有声明类型，typeof返回变量的推断类型。</strong></li>
</ul>
<p>如果变量没有明确声明类型，typeof 将返回变量的推断类型。此时，let关键字声明的变量，可以被重新赋值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rust复制代码<span class="keyword">let</span> <span class="variable">str</span> = <span class="symbol">&#x27;Echo</span>&#x27;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">S</span> = <span class="keyword">typeof</span> <span class="type">str</span> <span class="comment">// 等同于 type S= string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以被重新赋值</span></span><br><span class="line"><span class="type">str</span> = <span class="symbol">&#x27;Steven</span>&#x27; <span class="comment">// 正确</span></span><br><span class="line"><span class="comment">// str = 26 // 报错：不能将类型“number”分配给类型“string”</span></span><br></pre></td></tr></table></figure>

<p>有时候，我们希望变量是常量，不允许被重新赋值。const 关键字可以解决这个问题。此时，基于类型推断，返回类型是等号右边的字面量类型。</p>
<p>例如，下面示例中，typeof str 返回的是字面量类型 ‘Echo’，不是字符串。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码const <span class="attr">str</span> = <span class="string">&#x27;Echo&#x27;</span></span><br><span class="line">type <span class="attr">S</span> = typeof str // 等同于：type S = <span class="string">&#x27;Echo&#x27;</span></span><br><span class="line">// <span class="attr">str</span> = <span class="string">&#x27;Steven&#x27;</span> // 报错：无法分配到“str”，因为它是常数</span><br></pre></td></tr></table></figure>

<p>在 Typescript3.4 中引入了一种新的字面量构造方式，const 断言。在 const 断言作用下，即使是 let 声明也可以限制类型扩展，变量不能被重新赋值。</p>
<p>例如，下面示例中，typeof str 返回的是字面量类型 ‘Echo’，不是字符串。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码let <span class="attr">str</span> = <span class="string">&quot;Echo&quot;</span> as const</span><br><span class="line">type <span class="attr">S</span> = typeof str // 等同于：type S = <span class="string">&quot;Echo&quot;</span></span><br><span class="line">// <span class="attr">str</span> = <span class="string">&#x27;Steven&#x27;</span> // 报错：无法分配到“<span class="string">&quot;Steven&quot;</span>”分配给类型“<span class="string">&quot;Echo&quot;</span>”</span><br></pre></td></tr></table></figure>

<p>当我们使用 const 断言构造新的字面量表达式时，应注意以下几点：</p>
<ul>
<li>表达式中的任何字面量类型都不应该被扩展。</li>
<li>对象字面量的属性，将使用 readonly 修饰。</li>
<li>数组字面量将变成 readonly 元组。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rust复制代码<span class="keyword">let</span> <span class="variable">str</span> = <span class="string">&quot;Echo&quot;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">S</span> = <span class="keyword">typeof</span> <span class="type">str</span>; <span class="comment">// 等同于：type S = &quot;Echo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">num</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">N</span> = <span class="keyword">typeof</span> num; <span class="comment">// 等同于：type N = readonly [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">obj</span> = &#123; name: <span class="string">&quot;Echo&quot;</span> &#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">O</span> = <span class="keyword">typeof</span> obj; <span class="comment">// 等同于：type O = &#123; readonly name: &quot;Echo&quot;; &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果变量明确声明了类型，推断类型不受 const 影响，typeof str 返回 str 的声明类型 string，而不是字面量类型 “Steven”，但是变量依然不能被重新赋值。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码const str: <span class="attr">string</span> = <span class="string">&quot;Echo&quot;</span><span class="comment">;</span></span><br><span class="line">type <span class="attr">S</span> = typeof str // 等同于：type S = string</span><br><span class="line"><span class="attr">str</span> = <span class="string">&quot;Steven&quot;</span> // 报错：无法分配到 <span class="string">&quot;str&quot;</span> ，因为它是常数。</span><br></pre></td></tr></table></figure>

<h3 id="2-2-typeof与对象结合使用"><a href="#2-2-typeof与对象结合使用" class="headerlink" title="2.2. typeof与对象结合使用"></a>2.2. typeof与对象结合使用</h3><p>typeof与对象结合使用，可以用来获取对象的结构类型，以及使用该类型来声明新的变量或函数参数等。</p>
<ol>
<li><strong>获取对象的类型</strong></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rust复制代码<span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="symbol">&#x27;Echo</span>&#x27;,</span><br><span class="line">  age: <span class="number">26</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = <span class="keyword">typeof</span> person</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="comment">// type Person = &#123;</span></span><br><span class="line"><span class="comment">//   name: string;</span></span><br><span class="line"><span class="comment">//   age: number;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，typeof person 返回的是对象 person 的类型，即 { name: string; age: number; }。</p>
<ol>
<li><strong>声明新变量的类型为对象的类型</strong></li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">css复制代码const person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Echo&#x27;</span>,</span><br><span class="line">  age: <span class="number">26</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const newPerson: typeof person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Steven&#x27;</span>,</span><br><span class="line">  age: <span class="number">33</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console<span class="selector-class">.log</span>(newPerson);  // 输出：&#123; name: <span class="string">&#x27;Steven&#x27;</span>, age: <span class="number">33</span> &#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 typeof person 将 newPerson 的类型声明为 { name: string; age: number; }，并赋予了新的值。</p>
<ol>
<li><strong>在函数参数中使用对象的类型</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">javascript复制代码<span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Echo&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">26</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printObj</span>(<span class="params">obj: <span class="keyword">typeof</span> person</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printObj</span>(person);  <span class="comment">// 输出：&#123; name: &#x27;Echo&#x27;, age: 26 &#125;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，函数 printObj 接收一个参数，其类型为 typeof person，即接收与对象 person 相同类型的参数。</p>
<p>需要注意的是，typeof 运算符用于获取对象类型是在静态类型检查阶段进行的，而不是在运行时期执行的。因此，它只提供了类型信息，而不会直接访问对象的值。</p>
<h3 id="2-3-typeof与接口结合使用"><a href="#2-3-typeof与接口结合使用" class="headerlink" title="2.3. typeof与接口结合使用"></a>2.3. typeof与接口结合使用</h3><p>typeof 与接口结合使用可以用于创建新类型，该类型的属性和方法将与给定对象类型保持一致。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">person</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Echo&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">26</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NewPerson</span> = <span class="keyword">typeof</span> person</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">newPerson</span>: <span class="title class_">NewPerson</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Steven&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">33</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述实例中，定义了一个名为 Person 的接口，然后创建一个对象 person，类型为 Person，接着使用 typeof 来创建一个新的类型 NewPerson，该类型的属性和方法将与 Person 接口中定义的属性和方法保持一致，这样我们就可以基于 NewPerson 来创建新的对象。</p>
<p>需要注意的是，typeof 运算符与接口结合使用通常适用于已存在的对象，它提取已知对象的类型用于创建新的类型。它不会用于动态创建对象或实例化类。</p>
<h3 id="2-4-typeof与keyof结合使用"><a href="#2-4-typeof与keyof结合使用" class="headerlink" title="2.4. typeof与keyof结合使用"></a>2.4. typeof与keyof结合使用</h3><p>keyof 主要用于获取类型的所有属性键，可以与 typeof 结合使用，获取某个类型的键集合。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bash复制代码<span class="built_in">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Echo&#x27;</span>,</span><br><span class="line">  age: 28,</span><br><span class="line">  address: <span class="string">&#x27;Guang Zhou&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Person = keyof typeof person // 等同于：<span class="built_in">type</span> Person = <span class="string">&quot;name&quot;</span> | <span class="string">&quot;age&quot;</span> | <span class="string">&quot;address&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="3-in"><a href="#3-in" class="headerlink" title="3. in"></a>3. in</h2><p>在 TS 中，<strong>in</strong> 操作符的主要用于遍历目标类型的属性 key 值。类似 for…in，一般结合 [] 一起使用。</p>
<h3 id="3-1-遍历枚举类型"><a href="#3-1-遍历枚举类型" class="headerlink" title="3.1. 遍历枚举类型"></a>3.1. 遍历枚举类型</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码enum Direction &#123;</span><br><span class="line">  Up,</span><br><span class="line">  Right,</span><br><span class="line">  Down,</span><br><span class="line">  Left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type <span class="attr">DirectionType</span> = &#123;</span><br><span class="line">  <span class="section">[value in Direction]</span>: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">type <span class="attr">DirectionType</span> = &#123;</span><br><span class="line">  0: number<span class="comment">;</span></span><br><span class="line">  1: number<span class="comment">;</span></span><br><span class="line">  2: number<span class="comment">;</span></span><br><span class="line">  3: number<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="3-2-遍历联合类型"><a href="#3-2-遍历联合类型" class="headerlink" title="3.2. 遍历联合类型"></a>3.2. 遍历联合类型</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码type <span class="attr">Property</span> = <span class="string">&#x27;name&#x27;</span> | <span class="string">&#x27;age&#x27;</span> | <span class="string">&#x27;gender&#x27;</span> | <span class="string">&#x27;address&#x27;</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">type <span class="attr">PropertyMap</span> = &#123;</span><br><span class="line">  <span class="section">[key in Property]</span>: string<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">type <span class="attr">PropertyMap</span> = &#123;</span><br><span class="line">  name: string<span class="comment">;</span></span><br><span class="line">  age: string<span class="comment">;</span></span><br><span class="line">  gender: string<span class="comment">;</span></span><br><span class="line">  address: string<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h2 id="4-extends"><a href="#4-extends" class="headerlink" title="4. extends"></a>4. extends</h2><h3 id="4-1-用于泛型函数"><a href="#4-1-用于泛型函数" class="headerlink" title="4.1. 用于泛型函数"></a>4.1. 用于泛型函数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">type</span> <span class="variable constant_">NT</span> = <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T 必须是 number 或 string 类型</span></span><br><span class="line"><span class="keyword">function</span> printValue&lt;T <span class="keyword">extends</span> <span class="variable constant_">NT</span>&gt;(<span class="attr">value</span>: T) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">printValue</span>(<span class="string">&quot;Echo&quot;</span>); <span class="comment">// 正确</span></span><br><span class="line"><span class="title function_">printValue</span>(<span class="number">26</span>);     <span class="comment">// 正确</span></span><br><span class="line"><span class="comment">// printValue(true); // 错误，布尔类型不符合约束条件</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-用于泛型类"><a href="#4-2-用于泛型类" class="headerlink" title="4.2. 用于泛型类"></a>4.2. 用于泛型类</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">scala复制代码interface <span class="type">ILength</span> &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// T 必须是具有 length 属性的类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container&lt;T</span> <span class="keyword">extends</span> <span class="title">ILength&gt;</span> </span>&#123;</span><br><span class="line">  value: <span class="type">T</span>;</span><br><span class="line"></span><br><span class="line">  constructor(value: <span class="type">T</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printLength() &#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>.value.length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const container1 = <span class="keyword">new</span> <span class="type">Container</span>(<span class="string">&quot;Echo&quot;</span>); <span class="comment">// 正确</span></span><br><span class="line">container1.printLength(); <span class="comment">// 输出: 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const container2 = new Container(26); // 错误，数字类型没有 length 属性</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-用于类继承"><a href="#4-3-用于类继承" class="headerlink" title="4.3. 用于类继承"></a>4.3. 用于类继承</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">move</span>(<span class="attr">distance</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> moved <span class="subst">$&#123;distance&#125;</span> meters.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">bark</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Woof! Woof!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Hate&quot;</span>);</span><br><span class="line">dog.<span class="title function_">move</span>(<span class="number">10</span>);   <span class="comment">// 调用继承来自父类的方法 输出：Hate moved 10 meters.</span></span><br><span class="line">dog.<span class="title function_">bark</span>();     <span class="comment">// 调用子类自己定义的方法 输出：Woof! Woof!</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-用于继承接口"><a href="#4-4-用于继承接口" class="headerlink" title="4.4. 用于继承接口"></a>4.4. 用于继承接口</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ini复制代码interface Shape &#123;</span><br><span class="line">  color: string<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Square extends Shape &#123;</span><br><span class="line">  sideLength: number<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let <span class="attr">square</span> = &lt;Square&gt;&#123;&#125;<span class="comment">;</span></span><br><span class="line"><span class="attr">square.color</span> = <span class="string">&quot;blue&quot;</span><span class="comment">;</span></span><br><span class="line"><span class="attr">square.sideLength</span> = <span class="number">10</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-5-用于类型约束"><a href="#4-5-用于类型约束" class="headerlink" title="4.5. 用于类型约束"></a>4.5. 用于类型约束</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scss复制代码interface ILength &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getLength&lt;T extends ILength&gt;(value: T): T &#123;</span><br><span class="line">  console<span class="selector-class">.log</span>(value.length);</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">getLength</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])                    <span class="comment">// 正确，因为数组有 length 属性</span></span><br><span class="line"><span class="built_in">getLength</span>(&#x27;Echo&#x27;) <span class="comment">//                    // 正确，因为字符串有 length 属性</span></span><br><span class="line"><span class="built_in">getLength</span>(&#123; length: <span class="number">10</span>, name: &#x27;Echo&#x27; &#125;) <span class="comment">// 正确，因为传入的参数有 length 舒心</span></span><br><span class="line"><span class="built_in">getLength</span>(<span class="number">10</span>)                           <span class="comment">// 报错：类型“number”不能赋值给类型“ILength”的参数，因为数字不具有 length 属性</span></span><br></pre></td></tr></table></figure>

<h3 id="4-6-用于条件类型"><a href="#4-6-用于条件类型" class="headerlink" title="4.6. 用于条件类型"></a>4.6. 用于条件类型</h3><p>TypeScript 2.8引入了条件类型表达式，类似于三元运算符。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">type</span> <span class="title class_">NoNullAndUndefined</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="literal">null</span> | <span class="literal">undefined</span> ? <span class="built_in">never</span> : T;  <span class="comment">// 如果泛型参数 T 为 null 或 undefined，那么取 never，否则直接返回 T。</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">k1</span>: <span class="title class_">NoNullAndUndefined</span>&lt;<span class="built_in">number</span>&gt;;    <span class="comment">// k1 是 number类型，因为 number 不是 null | undefined 的子集</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">k2</span>: <span class="title class_">NoNullAndUndefined</span>&lt;<span class="literal">undefined</span>&gt;; <span class="comment">// k2 是 never类型，因为 undefined 是 null | undefined 的子集</span></span><br></pre></td></tr></table></figure>

<p>条件类型也支持嵌套。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typescript复制代码<span class="keyword">type</span> <span class="title class_">TypeName</span>&lt;T&gt; =</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="string">&quot;string&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">&quot;number&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="string">&quot;boolean&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="literal">undefined</span> ? <span class="string">&quot;undefined&quot;</span> :</span><br><span class="line">  T <span class="keyword">extends</span> <span class="title class_">Function</span> ? <span class="string">&quot;function&quot;</span> : <span class="string">&quot;object&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">TypeName</span>&lt;<span class="string">&#x27;Echo&#x27;</span>&gt;;      <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">TypeName</span>&lt;<span class="number">26</span>&gt;;          <span class="comment">// &quot;number&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">TypeName</span>&lt;<span class="literal">true</span>&gt;;        <span class="comment">// &quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T3</span> = <span class="title class_">TypeName</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">void</span>&gt;;  <span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T4</span> = <span class="title class_">TypeName</span>&lt;<span class="built_in">string</span>[]&gt;;    <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="十四、泛型工具类型"><a href="#十四、泛型工具类型" class="headerlink" title="十四、泛型工具类型"></a>十四、泛型工具类型</h1><p>泛型工具类型这一章节相关的内容我想放到其它文章中来讲，因为这里涉及到的知识点有点多，一时半会写不完，大家可以持续关注我，精力有限，尽量做到每周2-3更！！！</p>
<h1 id="十五、总结"><a href="#十五、总结" class="headerlink" title="十五、总结"></a>十五、总结</h1><p>如果文章有什么错误，欢迎大家在评论区指正，如果觉得本文对您有帮助的话，欢迎👏<strong>点赞收藏</strong>哦～</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">小u</div><div class="post-copyright__author_desc">热爱可抵岁月漫长</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2023/10/01/%E6%8E%98%E9%87%91%E6%94%B6%E8%97%8F/8/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2023/10/01/%E6%8E%98%E9%87%91%E6%94%B6%E8%97%8F/8/')">【全文8W字】我是怎样从0开始学会🚀TypeScript🚀的</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2023/10/01/%E6%8E%98%E9%87%91%E6%94%B6%E8%97%8F/8/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=【全文8W字】我是怎样从0开始学会🚀TypeScript🚀的&amp;url=http://example.com/2023/10/01/%E6%8E%98%E9%87%91%E6%94%B6%E8%97%8F/8/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E6%8E%98%E9%87%91/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>掘金<span class="tagsPageCount">14</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/01/interview/selected/12/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">秒传</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/01/%E6%8E%98%E9%87%91%E6%94%B6%E8%97%8F/9/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">前端开发小技巧分享</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/10/01/%E6%8E%98%E9%87%91%E6%94%B6%E8%97%8F/1/" title="五个很实用的IDEA使用技巧"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">五个很实用的IDEA使用技巧</div></div></a></div><div><a href="/2023/10/01/%E6%8E%98%E9%87%91%E6%94%B6%E8%97%8F/11/" title="【保姆级】 Vue3 开发文档"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">【保姆级】 Vue3 开发文档</div></div></a></div><div><a href="/2023/10/01/%E6%8E%98%E9%87%91%E6%94%B6%E8%97%8F/10/" title="git解决冲突"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">git解决冲突</div></div></a></div><div><a href="/2023/10/03/%E6%8E%98%E9%87%91%E6%94%B6%E8%97%8F/13/" title="Nest + Redis + 地图，实现附近的充电宝"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-03</div><div class="title">Nest + Redis + 地图，实现附近的充电宝</div></div></a></div><div><a href="/2023/10/01/%E6%8E%98%E9%87%91%E6%94%B6%E8%97%8F/3/" title="如何编写测试用例"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">如何编写测试用例</div></div></a></div><div><a href="/2023/10/01/%E6%8E%98%E9%87%91%E6%94%B6%E8%97%8F/12/" title="前端 ”一键换肤“ 技术方案"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">前端 ”一键换肤“ 技术方案</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" ait="status"/></div></div><div class="author-info__description">Java,java,springboot,mysql,redis,教程,git,软件,编程,开发,互联网,Java 基础,Java 教程,Java程序员进阶之路,Java 入门,Vue,前端,算法</div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎来看我的博客 博客主地址：http://blog.xiaou61.top/  备用地址：https://newblog.guoyaxue.top/</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%90%E5%85%A8%E6%96%878W%E5%AD%97%E3%80%91%E6%88%91%E6%98%AF%E6%80%8E%E6%A0%B7%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%BC%9A%F0%9F%9A%80TypeScript%F0%9F%9A%80%E7%9A%84"><span class="toc-number">1.</span> <span class="toc-text">【全文8W字】我是怎样从0开始学会🚀TypeScript🚀的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BA%86%E8%A7%A3TypeScript"><span class="toc-number">2.</span> <span class="toc-text">一、了解TypeScript</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFTypeScript"><span class="toc-number">2.1.</span> <span class="toc-text">1. 什么是TypeScript</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81TypeScript"><span class="toc-number">2.2.</span> <span class="toc-text">2. 为什么需要TypeScript</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-TypeScript%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">3. TypeScript的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-TypeScript%E5%92%8CJavaScript%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">4. TypeScript和JavaScript的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81TypeScript%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">3.</span> <span class="toc-text">二、TypeScript环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91TS%E7%9A%84%E5%B7%A5%E5%85%B7%E5%8C%85"><span class="toc-number">3.1.</span> <span class="toc-text">1. 安装编译TS的工具包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%AA%8C%E8%AF%81TS%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F"><span class="toc-number">3.2.</span> <span class="toc-text">2. 验证TS是否安装成功</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-TypeScript%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="toc-number">3.3.</span> <span class="toc-text">3. TypeScript初体验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%80%E5%8C%96%E8%BF%90%E8%A1%8CTS%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.4.</span> <span class="toc-text">4. 简化运行TS的步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BF%90%E8%A1%8CTS%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">5. 运行TS文件的另一种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-TypeScript-Playground%E7%BA%BF%E4%B8%8A%E7%8E%AF%E5%A2%83"><span class="toc-number">3.6.</span> <span class="toc-text">6. TypeScript Playground线上环境</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81TypeScript%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">三、TypeScript类型注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%E4%BD%9C%E7%94%A8"><span class="toc-number">4.1.</span> <span class="toc-text">1. 类型注解作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%E7%94%A8%E9%80%94"><span class="toc-number">4.2.</span> <span class="toc-text">2. 类型注解用途</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.3.</span> <span class="toc-text">3. 类型注解注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81TypeScript%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">四、TypeScript类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-TS%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">1. TS中常用的基础类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%95%B0%E5%80%BC%EF%BC%88number%EF%BC%89"><span class="toc-number">5.1.1.</span> <span class="toc-text">1.1. 数值（number）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%B8%83%E5%B0%94%E5%80%BC%EF%BC%88boolean%EF%BC%89"><span class="toc-number">5.1.2.</span> <span class="toc-text">1.2. 布尔值（boolean）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88string%EF%BC%89"><span class="toc-number">5.1.3.</span> <span class="toc-text">1.3. 字符串（string）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-null-%E5%92%8C-undefined"><span class="toc-number">5.1.4.</span> <span class="toc-text">1.4. null 和 undefined</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-symbol"><span class="toc-number">5.1.5.</span> <span class="toc-text">1.5. symbol</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-bigint"><span class="toc-number">5.1.6.</span> <span class="toc-text">1.6. bigint</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.7.</span> <span class="toc-text">1.7. 区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-1-null-%E5%92%8C-undefined-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.7.1.</span> <span class="toc-text">1.7.1. null 和 undefined 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-2-bigint-%E5%92%8C-number-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.7.2.</span> <span class="toc-text">1.7.2. bigint 和 number 的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.8.</span> <span class="toc-text">1.8. 对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-1-%E6%95%B0%E7%BB%84%EF%BC%88Array%EF%BC%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.8.1.</span> <span class="toc-text">1.8.1. 数组（Array）类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-2-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.8.2.</span> <span class="toc-text">1.8.2. 函数类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-2-1-%E5%8D%95%E7%8B%AC%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.8.2.1.</span> <span class="toc-text">1.8.2.1. 单独指定参数、返回值的类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-2-2-%E5%90%8C%E6%97%B6%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E3%80%81%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.8.2.2.</span> <span class="toc-text">1.8.2.2. 同时指定参数、返回值的类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-2-3-%E5%87%BD%E6%95%B0%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">5.1.8.2.3.</span> <span class="toc-text">1.8.2.3. 函数没有返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-2-4-%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">5.1.8.2.4.</span> <span class="toc-text">1.8.2.4. 可选参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-2-5-%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">5.1.8.2.5.</span> <span class="toc-text">1.8.2.5. 参数默认值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-2-6-%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0"><span class="toc-number">5.1.8.2.6.</span> <span class="toc-text">1.8.2.6. 剩余参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-2-7-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">5.1.8.2.7.</span> <span class="toc-text">1.8.2.7. 函数重载</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-3-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.8.3.</span> <span class="toc-text">1.8.3. 对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-3-1-%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.8.3.1.</span> <span class="toc-text">1.8.3.1. 定义对象类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-3-2-%E5%AF%B9%E8%B1%A1%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-number">5.1.8.3.2.</span> <span class="toc-text">1.8.3.2. 对象可选属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8-3-3-%E5%AF%B9%E8%B1%A1%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">5.1.8.3.3.</span> <span class="toc-text">1.8.3.3. 对象只读属性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%83%E7%BB%84%EF%BC%88Tuple%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">2. 元组（Tuple）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%85%83%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.2.1.</span> <span class="toc-text">2.1. 元组的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%85%83%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.2. 元组的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC"><span class="toc-number">5.2.3.</span> <span class="toc-text">2.3. 元组类型的解构赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%AF%E9%80%89%E5%85%83%E7%B4%A0"><span class="toc-number">5.2.4.</span> <span class="toc-text">2.4. 元组类型的可选元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%89%A9%E4%BD%99%E5%85%83%E7%B4%A0"><span class="toc-number">5.2.5.</span> <span class="toc-text">2.5. 元组类型的剩余元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%8F%AA%E8%AF%BB%E7%9A%84%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.6.</span> <span class="toc-text">2.6. 只读的元组类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.</span> <span class="toc-text">3. 字面量类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.1.</span> <span class="toc-text">3.1. 字符串字面量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%95%B0%E5%AD%97%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.2.</span> <span class="toc-text">3.2. 数字字面量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%B8%83%E5%B0%94%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.3.</span> <span class="toc-text">3.3. 布尔字面量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E7%AC%A6%E5%8F%B7%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.4.</span> <span class="toc-text">3.4. 符号字面量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%AD%E7%9A%84%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.5.</span> <span class="toc-text">3.5. 函数参数中的字面量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%AD%E7%9A%84%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.6.</span> <span class="toc-text">3.6. 函数返回值中的字面量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E4%B8%AD%E7%9A%84%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.7.</span> <span class="toc-text">3.7. 对象属性中的字面量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-let-%E5%92%8C-const-%E5%88%86%E6%9E%90"><span class="toc-number">5.3.8.</span> <span class="toc-text">3.8. let 和 const 分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-1-let-%E5%A3%B0%E6%98%8E%E7%9A%84%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.8.1.</span> <span class="toc-text">3.8.1 let 声明的字面量类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-2-const-%E5%A3%B0%E6%98%8E%E7%9A%84%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.8.2.</span> <span class="toc-text">3.8.2 const 声明的字面量类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9E%9A%E4%B8%BE%EF%BC%88Enum%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">4. 枚举（Enum）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%9F%BA%E6%9C%AC%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.4.1.</span> <span class="toc-text">4.1. 基本枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%95%B0%E5%AD%97%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.4.2.</span> <span class="toc-text">4.2. 数字枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E9%BB%98%E8%AE%A4%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">4.2.1. 默认递增的数字枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E6%89%8B%E5%8A%A8%E8%B5%8B%E5%80%BC%E7%9A%84%E6%95%B0%E5%AD%97%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">4.2.2. 手动赋值的数字枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E8%AE%A1%E7%AE%97%E6%88%90%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%97%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.4.2.3.</span> <span class="toc-text">4.2.3. 计算成员的数字枚举</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%B8%B8%E9%87%8F%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.4.3.</span> <span class="toc-text">4.3. 常量枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E5%B8%B8%E9%87%8F%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">4.3.1. 常量枚举的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E5%B8%B8%E9%87%8F%E6%9E%9A%E4%B8%BE%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">4.3.2. 常量枚举的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E5%B8%B8%E9%87%8F%E6%9E%9A%E4%B8%BE%E4%BC%9A%E5%9C%A8%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5%E8%A2%AB%E5%88%A0%E9%99%A4"><span class="toc-number">5.4.3.3.</span> <span class="toc-text">4.3.3. 常量枚举会在编译阶段被删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.4.4.</span> <span class="toc-text">4.4. 字符串枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%A4%96%E9%83%A8%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.4.5.</span> <span class="toc-text">4.5. 外部枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E5%BC%82%E6%9E%84%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.4.6.</span> <span class="toc-text">4.6. 异构枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E5%8F%8D%E5%90%91%E6%98%A0%E5%B0%84"><span class="toc-number">5.4.7.</span> <span class="toc-text">4.7. 反向映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.4.8.</span> <span class="toc-text">4.8. 运行时的枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-%E8%81%94%E5%90%88%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.4.9.</span> <span class="toc-text">4.9. 联合枚举</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-any%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.5.</span> <span class="toc-text">5. any类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">五、接口（interface）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.1.</span> <span class="toc-text">1. 什么是接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.2.</span> <span class="toc-text">2. 定义接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8E%A5%E5%8F%A3%EF%BC%88interface%EF%BC%89%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D%EF%BC%88type%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.3.</span> <span class="toc-text">3. 接口（interface）和类型别名（type）的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%EF%BC%88extends%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">4. 接口继承（extends）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-number">6.5.</span> <span class="toc-text">5. 接口的可选属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">6.6.</span> <span class="toc-text">6. 接口的只读属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E9%A2%9D%E5%A4%96%E7%9A%84%E5%B1%9E%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-number">6.7.</span> <span class="toc-text">7. 额外的属性检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BB%BB%E6%84%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">6.8.</span> <span class="toc-text">8. 接口的任意属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.9.</span> <span class="toc-text">9. 函数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%8F%AF%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.10.</span> <span class="toc-text">10. 可索引类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%B1%BB%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.11.</span> <span class="toc-text">11. 类类型实现接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.12.</span> <span class="toc-text">12. 继承接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E7%B1%BB"><span class="toc-number">6.13.</span> <span class="toc-text">13. 接口继承类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">7.</span> <span class="toc-text">六、类型别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA"><span class="toc-number">8.</span> <span class="toc-text">七、类型推论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-number">8.1.</span> <span class="toc-text">1. 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA"><span class="toc-number">8.2.</span> <span class="toc-text">2. 基本类型推论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA"><span class="toc-number">8.3.</span> <span class="toc-text">3. 上下文类型推论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9C%80%E4%BD%B3%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA"><span class="toc-number">8.4.</span> <span class="toc-text">4. 最佳通用类型推论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E4%BD%86%E6%B2%A1%E6%9C%89%E8%B5%8B%E5%80%BC%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">8.5.</span> <span class="toc-text">5. 声明变量但没有赋值的情况</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">9.</span> <span class="toc-text">八、类型断言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-1"><span class="toc-number">9.1.</span> <span class="toc-text">1. 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%AF%AD%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">2. 语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%BB%E4%BD%95%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E6%96%AD%E8%A8%80%E4%B8%BA-any-%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.3.</span> <span class="toc-text">3. 任何类型可以断言为 any 类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-any-%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E6%96%AD%E8%A8%80%E4%B8%BA%E4%BB%BB%E4%BD%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.4.</span> <span class="toc-text">4. any 类型可以断言为任何类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80"><span class="toc-number">9.5.</span> <span class="toc-text">5. 联合类型的类型断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">9.6.</span> <span class="toc-text">6. 类型断言的限制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E4%B8%8D%E4%BC%9A%E6%94%B9%E5%8F%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9E%E9%99%85%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.6.1.</span> <span class="toc-text">6.1. 类型断言不会改变变量的实际类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%8E%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">9.6.2.</span> <span class="toc-text">6.2. 类型断言不能用于基本类型之间的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E4%B8%8D%E8%83%BD%E8%A6%86%E7%9B%96%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">9.6.3.</span> <span class="toc-text">6.3. 类型断言不能覆盖类型检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E4%B8%8D%E8%83%BD%E5%B0%86-null-%E6%88%96-undefined-%E6%96%AD%E8%A8%80%E4%B8%BA%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.6.4.</span> <span class="toc-text">6.4. 类型断言不能将 null 或 undefined 断言为其他类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%AD%98%E5%9C%A8%E7%B1%BB%E5%9E%8B%E4%BA%92%E7%9B%B8%E6%8E%92%E6%96%A5%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">9.6.5.</span> <span class="toc-text">6.5. 联合类型的类型断言存在类型互相排斥的限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%8F%8C%E9%87%8D%E6%96%AD%E8%A8%80"><span class="toc-number">9.7.</span> <span class="toc-text">7. 双重断言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80VS%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">9.8.</span> <span class="toc-text">8. 类型断言VS类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80VS%E7%B1%BB%E5%9E%8B%E5%A3%B0%E6%98%8E"><span class="toc-number">9.9.</span> <span class="toc-text">9. 类型断言VS类型声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E5%92%8C%E6%B3%9B%E5%9E%8B"><span class="toc-number">9.10.</span> <span class="toc-text">10. 类型断言和泛型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E7%B1%BB%EF%BC%88class%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">九、类（class）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">10.1.</span> <span class="toc-text">1. 类的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">10.2.</span> <span class="toc-text">2. 类的基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.</span> <span class="toc-text">3. 类的构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">10.3.1.</span> <span class="toc-text">3.1. 构造函数的基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">10.3.2.</span> <span class="toc-text">3.2. 使用构造函数初始化成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%88%9B%E5%BB%BA%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B9%B6%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.3.</span> <span class="toc-text">3.3. 创建类的实例并调用构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%E5%92%8C%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">10.3.4.</span> <span class="toc-text">3.4. 构造函数的可选参数和默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%EF%BC%89"><span class="toc-number">10.3.5.</span> <span class="toc-text">3.5 .调用其他构造函数（构造函数重载）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">10.4.</span> <span class="toc-text">4. 类的实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">10.4.1.</span> <span class="toc-text">4.1. 定义实例方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%AE%BF%E9%97%AE%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-number">10.4.2.</span> <span class="toc-text">4.2. 访问实例属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E8%B0%83%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">10.4.3.</span> <span class="toc-text">4.3. 调用实例方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">10.5.</span> <span class="toc-text">5. 类的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-extends%EF%BC%88%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%EF%BC%89"><span class="toc-number">10.5.1.</span> <span class="toc-text">5.1. extends（继承父类）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-%E5%AE%9A%E4%B9%89%E7%88%B6%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB"><span class="toc-number">10.5.1.1.</span> <span class="toc-text">5.1.1. 定义父类和子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">10.5.1.2.</span> <span class="toc-text">5.1.2. 继承父类的属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-%E8%B0%83%E7%94%A8%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">10.5.1.3.</span> <span class="toc-text">5.1.3. 调用继承的属性和方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-implements%EF%BC%88%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%EF%BC%89"><span class="toc-number">10.5.2.</span> <span class="toc-text">5.2. implements（实现接口）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.5.2.1.</span> <span class="toc-text">5.2.1. 定义接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-%E4%BD%BF%E7%94%A8-implements-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.5.2.2.</span> <span class="toc-text">5.2.2. 使用 implements 实现接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">10.5.2.3.</span> <span class="toc-text">5.2.3. 实现接口的属性和方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%B1%BB%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">10.6.</span> <span class="toc-text">6. 类的修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-public"><span class="toc-number">10.6.1.</span> <span class="toc-text">6.1. public</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-private"><span class="toc-number">10.6.2.</span> <span class="toc-text">6.2. private</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-protected"><span class="toc-number">10.6.3.</span> <span class="toc-text">6.3. protected</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-readonly"><span class="toc-number">10.6.4.</span> <span class="toc-text">6.4. readonly</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E5%8F%82%E6%95%B0%E5%B1%9E%E6%80%A7"><span class="toc-number">10.6.5.</span> <span class="toc-text">6.5. 参数属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">10.7.</span> <span class="toc-text">7. 抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E8%AF%AD%E6%B3%95"><span class="toc-number">10.7.1.</span> <span class="toc-text">7.1. 语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">10.7.2.</span> <span class="toc-text">7.2. 抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8D%E8%83%BD%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%8C%E5%8F%AA%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF"><span class="toc-number">10.7.3.</span> <span class="toc-text">7.3. 抽象类不能被实例化，只能被继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E7%89%B9%E7%82%B9"><span class="toc-number">10.7.4.</span> <span class="toc-text">7.4. 特点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">11.</span> <span class="toc-text">十、类型兼容性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">11.1.</span> <span class="toc-text">1. 基本类型的兼容性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%9B%B8%E5%90%8C%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E4%BA%92%E7%9B%B8%E8%B5%8B%E5%80%BC"><span class="toc-number">11.1.1.</span> <span class="toc-text">1.1. 相同的基本类型可以互相赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%95%B0%E5%AD%97%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E8%B5%8B%E5%80%BC%E7%BB%99%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.1.2.</span> <span class="toc-text">1.2. 数字字面量类型可以赋值给数值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E8%B5%8B%E5%80%BC%E7%BB%99%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.1.3.</span> <span class="toc-text">1.3. 枚举类型可以赋值给数字类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">11.2.</span> <span class="toc-text">2. 对象类型的兼容性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%88%90%E5%91%98%E4%B8%AA%E6%95%B0%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">11.2.1.</span> <span class="toc-text">2.1. 成员个数的兼容性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%88%90%E5%91%98%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">11.2.2.</span> <span class="toc-text">2.2. 成员类型的兼容性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">11.2.3.</span> <span class="toc-text">2.3. 可选属性的兼容性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">11.3.</span> <span class="toc-text">3. 函数类型兼容性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0"><span class="toc-number">11.3.1.</span> <span class="toc-text">3.1. 参数个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.3.2.</span> <span class="toc-text">3.2. 参数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.3.3.</span> <span class="toc-text">3.3. 返回值类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B1%BB%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">11.4.</span> <span class="toc-text">4. 类类型兼容性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7"><span class="toc-number">11.5.</span> <span class="toc-text">5. 泛型类型兼容性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B%EF%BC%88Intersection-Types%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">十一、交叉类型（Intersection Types）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BB%84%E5%90%88%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.1.</span> <span class="toc-text">1. 组合对象类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%90%88%E5%B9%B6%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.2.</span> <span class="toc-text">2. 合并函数类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8BVS%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-number">12.3.</span> <span class="toc-text">3. 交叉类型VS接口继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%B3%A8%E6%84%8F"><span class="toc-number">12.4.</span> <span class="toc-text">4. 注意</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%B3%9B%E5%9E%8B%EF%BC%88Generics%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">十二、泛型（Generics）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B"><span class="toc-number">13.1.</span> <span class="toc-text">1. 什么是泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">13.2.</span> <span class="toc-text">2. 一个简单的例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B3%9B%E5%9E%8B%E8%AF%AD%E6%B3%95"><span class="toc-number">13.3.</span> <span class="toc-text">3. 泛型语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%AE%80%E5%8C%96%E8%B0%83%E7%94%A8%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="toc-number">13.4.</span> <span class="toc-text">4. 简化调用泛型函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%A4%9A%E4%B8%AA%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">13.5.</span> <span class="toc-text">5. 多个类型参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">13.6.</span> <span class="toc-text">6. 泛型类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">13.7.</span> <span class="toc-text">7. 泛型接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E7%B1%BB%E5%9E%8B"><span class="toc-number">13.8.</span> <span class="toc-text">8. 泛型参数的默认类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">13.9.</span> <span class="toc-text">9. 泛型约束</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81TS%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">14.</span> <span class="toc-text">十三、TS中的关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-keyof"><span class="toc-number">14.1.</span> <span class="toc-text">1. keyof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-typeof"><span class="toc-number">14.2.</span> <span class="toc-text">2. typeof</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-typeof%E8%8E%B7%E5%8F%96%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E7%B1%BB%E5%9E%8B"><span class="toc-number">14.2.1.</span> <span class="toc-text">2.1. typeof获取变量的声明类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-typeof%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">14.2.2.</span> <span class="toc-text">2.2. typeof与对象结合使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-typeof%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">14.2.3.</span> <span class="toc-text">2.3. typeof与接口结合使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-typeof%E4%B8%8Ekeyof%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">14.2.4.</span> <span class="toc-text">2.4. typeof与keyof结合使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-in"><span class="toc-number">14.3.</span> <span class="toc-text">3. in</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%81%8D%E5%8E%86%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">14.3.1.</span> <span class="toc-text">3.1. 遍历枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E9%81%8D%E5%8E%86%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">14.3.2.</span> <span class="toc-text">3.2. 遍历联合类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-extends"><span class="toc-number">14.4.</span> <span class="toc-text">4. extends</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%94%A8%E4%BA%8E%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="toc-number">14.4.1.</span> <span class="toc-text">4.1. 用于泛型函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%94%A8%E4%BA%8E%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">14.4.2.</span> <span class="toc-text">4.2. 用于泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%94%A8%E4%BA%8E%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-number">14.4.3.</span> <span class="toc-text">4.3. 用于类继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E7%94%A8%E4%BA%8E%E7%BB%A7%E6%89%BF%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.4.4.</span> <span class="toc-text">4.4. 用于继承接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E7%94%A8%E4%BA%8E%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">14.4.5.</span> <span class="toc-text">4.5. 用于类型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E7%94%A8%E4%BA%8E%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">14.4.6.</span> <span class="toc-text">4.6. 用于条件类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E6%B3%9B%E5%9E%8B%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%9E%8B"><span class="toc-number">15.</span> <span class="toc-text">十四、泛型工具类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">16.</span> <span class="toc-text">十五、总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/27/" title="再见 MyBatis-Plus ！">再见 MyBatis-Plus ！</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/26/" title="“人尽皆知”的单例模式">“人尽皆知”的单例模式</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/29/" title="阿里的同事，写的代码真 TMD 优雅！">阿里的同事，写的代码真 TMD 优雅！</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/28/" title="别再用 BeanUtils 了，这款 PO VO DTO 转换神器不香么？">别再用 BeanUtils 了，这款 PO VO DTO 转换神器不香么？</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/30/" title="MyBatis过时了吗？">MyBatis过时了吗？</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="小u" target="_blank">小u</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">238</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">39</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">50</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://mydocs.guoyaxue.top/" title="旧版博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="旧版博客"/><span class="back-menu-item-text">旧版博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://pan.xiaou61.top/#/" title="免费网盘"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="免费网盘"/><span class="back-menu-item-text">免费网盘</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://cloud.xiaou61.top/" title="云盘(自用)"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="云盘(自用)"/><span class="back-menu-item-text">云盘(自用)</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://wpzc.xiaou61.top/" title="云盘转存"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="云盘转存"/><span class="back-menu-item-text">云盘转存</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://love.xiaou61.top/#/" title="关于我们(My girlFriend)"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="关于我们(My girlFriend)"/><span class="back-menu-item-text">关于我们(My girlFriend)</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">娱乐项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://fxq.xiaou61.top/#/" title="飞行棋"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="飞行棋"/><span class="back-menu-item-text">飞行棋</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/game/sqnwmai803/" title="谁去拿外卖"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="谁去拿外卖"/><span class="back-menu-item-text">谁去拿外卖</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/desktop.html" title="win12网页版"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/icon/logo.svg" alt="win12网页版"/><span class="back-menu-item-text">win12网页版</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://game.xiaou61.top/" title="在线游戏"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="在线游戏"/><span class="back-menu-item-text">在线游戏</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 开往</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><span> 开往</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>3</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JVM/" style="font-size: 0.88rem;">JVM<sup>22</sup></a><a href="/tags/Nginx/" style="font-size: 0.88rem;">Nginx<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>1</sup></a><a href="/tags/Ts/" style="font-size: 0.88rem;">Ts<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size: 0.88rem;">TypeScript<sup>1</sup></a><a href="/tags/WebApi/" style="font-size: 0.88rem;">WebApi<sup>1</sup></a><a href="/tags/coder1v5/" style="font-size: 0.88rem;">coder1v5<sup>2</sup></a><a href="/tags/css/" style="font-size: 0.88rem;">css<sup>3</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>12</sup></a><a href="/tags/javaSE/" style="font-size: 0.88rem;">javaSE<sup>3</sup></a><a href="/tags/javaWeb/" style="font-size: 0.88rem;">javaWeb<sup>2</sup></a><a href="/tags/js%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">js逆向<sup>1</sup></a><a href="/tags/leetcode/" style="font-size: 0.88rem;">leetcode<sup>3</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>8</sup></a><a href="/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/" style="font-size: 0.88rem;">书籍推荐<sup>2</sup></a><a href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%90%AC%E8%BF%90/" style="font-size: 0.88rem;">公众号搬运<sup>35</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 0.88rem;">前端<sup>10</sup></a><a href="/tags/%E5%8A%9E%E5%85%AC/" style="font-size: 0.88rem;">办公<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 0.88rem;">后端<sup>8</sup></a><a href="/tags/%E5%A4%A9%E6%B6%AF%E8%AE%BA%E5%9D%9B/" style="font-size: 0.88rem;">天涯论坛<sup>1</sup></a><a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 0.88rem;">导航<sup>1</sup></a><a href="/tags/%E5%B0%B1%E4%B8%9A/" style="font-size: 0.88rem;">就业<sup>16</sup></a><a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 0.88rem;">微信<sup>1</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/" style="font-size: 0.88rem;">技术杂谈<sup>51</sup></a><a href="/tags/%E6%8E%98%E9%87%91/" style="font-size: 0.88rem;">掘金<sup>14</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 0.88rem;">杂项<sup>1</sup></a><a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 0.88rem;">测试<sup>1</sup></a><a href="/tags/%E6%B8%A1%E4%B8%80%E5%A4%A7%E5%B8%88%E8%AF%BE/" style="font-size: 0.88rem;">渡一大师课<sup>3</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 0.88rem;">爬虫<sup>1</sup></a><a href="/tags/%E7%9B%AE%E5%BD%95/" style="font-size: 0.88rem;">目录<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>4</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 0.88rem;">虚拟机<sup>12</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>6</sup></a><a href="/tags/%E8%B7%AF%E9%A3%9E%E5%AD%A6%E9%99%A2/" style="font-size: 0.88rem;">路飞学院<sup>3</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">面向对象<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>51</sup></a><a href="/tags/%E9%A3%9E%E8%A1%8C%E6%A3%8B/" style="font-size: 0.88rem;">飞行棋<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="7409599794" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>