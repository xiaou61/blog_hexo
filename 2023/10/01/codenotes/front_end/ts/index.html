<!DOCTYPE html><html class="hide-aside" lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>一文搞懂TypeScript | 小u的博客</title><meta name="keywords" content="前端,Ts"><meta name="author" content="小u"><meta name="copyright" content="小u"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="一文搞懂TypeScript"><meta name="application-name" content="一文搞懂TypeScript"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="一文搞懂TypeScript"><meta property="og:url" content="http://example.com/2023/10/01/codenotes/front_end/ts/index.html"><meta property="og:site_name" content="小u的博客"><meta property="og:description" content="TypeScript学习第一章:TypeScript初识1.1 TypeScript学习初见TypeScript(TS)是由微软Microsoft由2012年推出的自由和开源的编程语言, 目前主流的三大框架React 、Vue 和 Angular这三大主流框架再加上最新的鸿蒙3.0都可以用TS进行开"><meta property="og:locale" content="en"><meta property="og:image" content="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png"><meta property="article:author" content="小u"><meta property="article:tag" content="Java,java,springboot,mysql,redis,教程,git,软件,编程,开发,互联网,Java 基础,Java 教程,Java程序员进阶之路,Java 入门,Vue,前端,算法"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png"><meta name="description" content="TypeScript学习第一章:TypeScript初识1.1 TypeScript学习初见TypeScript(TS)是由微软Microsoft由2012年推出的自由和开源的编程语言, 目前主流的三大框架React 、Vue 和 Angular这三大主流框架再加上最新的鸿蒙3.0都可以用TS进行开"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2023/10/01/codenotes/front_end/ts/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//hm.baidu.com"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1433b93d16cca6b366bdf23126c0c200";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"tianli","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"784b999ee9b2f0689c5a","Referer":"https://mydocs-1305448902.cos-website.ap-nanjing.myqcloud.com/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: 小u","link":"Link: ","source":"Source: 小u的博客","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小u的博客',
  title: '一文搞懂TypeScript',
  postAI: '',
  pageFillDescription: 'TypeScript学习第一章TypeScript初识, 1.1 TypeScript学习初见, 1.2 TypeScript介绍, 1.3 JS 、TS 和 ES之间的关系, 1.4 TS的竞争者有哪些?, 1. ESLint, 2. TSlint, 3. CoffeeScript, 4.Flow, TypeScript学习第二章为什么使用TypeScript?, 2.1 发现问题, 2.2 静态类型检查, 2.3 非异常故障, 2.4 使用工具, 2.5 优化编译, 2.6 显式类型, 2.7 降级编译, 2.8 严格模式, TypeScript学习第三章 常用类型, 3.1 基元类型string number 和 boolean, 3.2 数组, 3.3 any, 3.4 变量上的类型解释, 3.5 函数, 3.6 对象类型, 3.7 联合类型, 3.8 类型别名, 3.9 接口, 3.10 类型断言 as, 3.11 文字类型, 文字推理, 3.12 null和undefined, 3.13 枚举, 3.14 不太常见的原语, TypeScript学习第四章 类型缩小, 4.1 typeof类型守卫, 4.2 真值缩小, 4.3 等值缩小, 4.4 in操作符缩小, 4.5 instanceof操作符缩小, 4.6 分配缩小, 4.7 控制流分析, 4.8 使用类型谓词, 4.9 受歧视的unions, 4.10 never类型与穷尽性检查, TypeScript学习第五章 函数, 5.1 函数类型表达式, 5.2 调用签名 属性签名, 5.3 构造签名 new (params …) Ctor, 5.4 泛型函数ltTypegt, 5.4.1 类型推断, 5.4.2 限制条件, 5.4.3 使用受限值, 5.4.4 指定类型参数, 5.4.5 编写优秀通用函数的准则, 5.5 可选参数 ?, 5.5.1 回调中的可选参数, 5.6 函数重载 重载签名, 5.6.1 重载签名和实现签名, 5.6.2 编写好的重载, 5.6.3 函数内This的声明, 5.7 需要了解的其他类型, 5.7.1 void, 5.7.2 object, 5.7.3 unknown, 5.7.4 never, 5.7.5 Function, 5.8 函数展开运算符, 5.8.1 形参展开(Rest Parameters), 5.8.2 实参展开(Rest Arguments), 5.9 参数解构, 5.10 函数的可分配性 返回void类型, TypeScript学习第六章 对象类型, 6.1 属性修改器, 6.2 可选属性, 6.3 只读属性, 6.4 索引签名, 6.5 扩展类型, 6.6 交叉类型, 6.7 接口与交叉类型, 6.8 泛型对象类型, 6.9 数组类型, 6.10 只读数组类型, 6.11 元组类型, 6.12 只读元组类型, TypeScript学习第七章 类型操纵, 7.0 从类型中创建类型, 7.1 泛型, 7.1.1 Hello World, 7.1.2 使用通用类型变量, 7.1.3 泛型接口, 7.1.4 泛型类, 7.1.5 泛型约束, 7.1.6 在泛型约束中使用类型参数, 7.1.7 在泛型中使用类类型, 7.2 keyOf类型操作符, 7.3 typeof类型操作符, 7.4 索引访问类型, 7.5 条件类型, 7.5.1 条件类型约束, 7.5.2 在条件类型内进行推理, 7.5.3 分布式条件类型, 7.6 映射类型, 7.6.1 映射修改器, 7.6.2 通过 as 做key重映射, 7.6.3 进一步探索, TypeScript学习第八章 类, 8.1 类成员, 8.1.1 类属性, 8.1.2 readonly, 8.1.3 构造器, Super 调用, 8.1.4 方法, 8.1.5 Gettersx2F Setters, 8.1.6 索引签名, 8.2 类继承, 8.2.1 implements子句, 注意事项, 8.2.2 extends子句, 8.2.3 重写方法(遵守基类契约), 8.2.4 初始化顺序, 8.2.5 继承内置类型, 8.3 成员的可见性, 8.3.1 public, 8.3.2 protected, 8.2.3 private, 8.4 静态成员, 8.4.1 特殊静态名称, 8.4.2 为什么没有静态类？, 8.5 类里的static区块, 8.6 泛型类, 8.7 类运行时的this, 1. 箭头函数, 2. this参数, 8.8 this类型, 8.9 基于类型守卫的this（？？？不太会）, 8.10 参数属性构造函数参数转类属性, 8.11 类表达式, 8.12 抽象类和成员, 8.13 类之间的关系, TypeScript学习第九章：模块, 9.1 如何定义JavaScript模块, 9.2 非模块, 9.3 TypeScript中的模块, 9.3.1 ES模块语法, 9.3.2 额外的导入语法, 9.3.3 TypeScript特定的ES模块语法, 9.3.4 ES模块语法与CommonJS行为, 9.4 CommonJS 语法, 9.4.1 导出, 9.4.2 CommonJS和ES模块的互操作性, 9.5 TypeScript的模块解析选项, 9.6 TypeScript的模块输出选项, 9.7 TypeScript 命名空间学习第一章初识学习初见是由微软由年推出的自由和开源的编程语言目前主流的三大框架和这三大主流框架再加上最新的鸿蒙都可以用进行开发可以说是的超集是建立在上的语言把其他语言的一些精妙的语法带入到中让达到了一个新的高度可以在中使用以外的扩展语法同时可以结局对面向对象和静态类型的良好支持可以让我们编写更健壮更可维护的大型项目介绍因为是的超集所以要介绍不得不提一下从在引入编程社区多年以来已经成了有史以来应用最广泛的跨平台语言之一了从一开始为网页中添加一些微不足道的交互性的小型的脚本语言发展到现在各种规模的前端和后端应用程序的首选语言了虽然我们用语言编写程序的大小范围和复杂性呈指数级的增长但是语言表达不同代码单元之间的关系和能力却很弱使得成了一项难以大规模管理的任务而且也很难解决程序员经常出现的错误类型错误而语言可以很好的解决这个错误他的目标是成为程序的静态类型检查器可以在代码运行之前进行检查也就是静态编译并且呢可以确保我们程序的类型正确即进行类型检查添加了可选的静态类型和基于类的面向对象编程等等是的语言扩展不是的替代品会让前进的步伐更坚实更遥远和之间的关系又称为是的超集他包含的所有元素能运行代码并扩展了语法并添加了静态类型类模块接口类型注解等等方面的功能更加易于大项目的开发这张图表示不仅包含了和的最新内容还扩展了新的功能总的来说是的标准是的超集的竞争者有哪些和都是和一样来突出代码中可能出现的错误至少没有为检查过程添加新的语法但是这两者都不打算最为集成的工具来运行这两个的存在可以是做更少的检查但是这些检查并不适合于所有的代码库是想改进语言但是现在用的人少了因为他又成为了的标准属于是打不过了的源码的类型检查工具就是不过已经开始使用做类型检查了更悲观的判断类型而更加乐观是为了维护的代码库而建立的而是作为一种独立的语言而建立的其内部有独立的环境可以自由专注于工具的开发和整个生态系统的维护学习第二章为什么使用发现问题中每个值都有一组行为我们可以通过运行不同的操作来观察在上访问属性方法并调用它调用我们尝试直接调用但是假设我们不知道我们就无法可靠的说出尝试运行任何的这些代码会得到什么结果每个操作的结果完全取决于我们最初给的赋值我们编译代码的时候真的可以调用么也不一定有这个方法而且也不知道他们的返回值是什么通常我们在编写的时候需要对上面所述的细节牢记在心才能编写正确的代码假设我们知道了是什么如下所示但是第三行就会报错输出如果我们能避免这样的错误就完美了当我们运行我们的代码的时候选择做什么的方式是通过确定值的类型来确定他具有什么样的行为和功能的就暗指字符串是不能作为函数来调用的对于某些值比如和我们可以使用来识别他们的类型但是对于像函数之类的其他的东西没有相应的运行时机制比如下面的代码运行是有条件的也就是说这个是必须具有这个方法的只能在运行一下代码时才能知道这个是提供了什么的我们如果能够使用静态类型系统在运行代码之前预测预期的代码问题就解决了静态类型检查上述这段代码会引起理想的情况下我们希望有一个工具可以在我们代码运行之前发现这些错误就可以实现这些功能静态类型系统就描述了当前我们运行程序的时候值得形状和行为像这样的类型检查器会告诉我们什么时候代码会出现问题非异常故障在运行的时候会告诉我们他认为某些东西是没有意义的情况因为规范明确说明了在遇到某些意外情况下应该是如何表现得比如如下代码小千返回理应报错因为根本没有这个属性但是静态类型系统要求必须对调用哪些代码做系统的标记如果是在运行这段代码就会出现未定义的错误如下图所示可以在开发过程中捕获很多类似于合法的错误比如说错别字未调用函数基本的逻辑错误等等拼写错误属性在类型中不存在你找的是否是属性未调用的函数检查运算符号不能用在一个和数字之间逻辑问题和逻辑重叠使用工具安装安装使用命令来检查版本安装编译器然后我们要编译我们的因为是不能直接运行的我们必须把他编译成在终端中使用或者命令可以清屏可以使用命令来转换成例如就会生成对应的文件你好世界会出现函数实现重复的错误会出现函数实现重复的错误是因为也有这个的函数这是跟我们编译环境是矛盾的而且还需要我们重新编译所以我们需要进行优化编译过程优化编译解决和冲突问题生成配置文件自动编译发出错误文件编译成文件以后当出现函数名或者是变量名相同的时候会给我们提示重复定义的问题可以通过来生成一个配置文件来解决冲突问题先把严格模式关闭可解决未指定变量类型的问题当我们修改文件的时候我们需要重新的执行编译才能拿到最新的结果我们需要自动编译可以通过来解决自动编译的问题当我们编译完之后还是能正常运行的我们可以加一个的参数来解决这样的话如果我们在中出现错误就可以让不编译成文件了最终的命令行指令是这样的显式类型刚才我们在里把模式关闭了如果我们打开就会出现未指定变量类型的错误如果要解决这个问题我们就需要指定显式类型什么叫显式类型呢就是手工的给变量定义类型语法如下在中也不是必须指定变量的数据类型会根据你的变量自动推断数据类型如果推断不出来就会报错降级编译我们可以在就修改来更改编译目标的代码版本默认为即建议以默认值就可以目前的浏览器都能兼容严格模式不同的用户使用在类型检查中希望检查的严格程度是不同的有的人喜欢更宽松的验证体验从而仅仅验证程序的某些部分并且仍然拥有不错的工具默认情况下严格模式启用所有严格的类型检查选项为隐含的类型的表达式和声明启用错误报告当类型检查时要考虑和一般来说使用就是追求的强立即验证这些静态检查设置的越严格越可能需要更多额外的编程工作但是从长远来说是值得的它会使代码更加容易维护如果可以我们应该始终打开这些类型检查启用可以拦截和的错误启用可以拦截的错误启用可以拦截所有的严格类型检查选项包括前面两个的所以结论就是只需要开启为即可当我们遇到学习第三章常用类型基元类型和字符串例子数字例子布尔例子也是合法的在里专门指一些很少的出现在代码里的一些特殊的内置类型对于类型我们始终使用小写的和为了输出方便我们可以在的里设置一个目录设置为数组数组的定义方法有两种这种方法又称为泛型其中是任意合法的类型值得注意的是数组可以被赋值为空数组但是不能被赋值为规定类型以外的数组值如果不希望某个特定值导致类型检查错误就可以使用当一个值是的时候可以访问它的任何属性将它分配给任何类型的值或者几乎任何其它语法上的东西都是合法的但是运行的时候该报错还是报错所以我们不应该经常使用他调用时就会报错变量上的类型解释采用冒号类型的方式如果不声明会自动推断将推断成报错不能将分配给函数你好黯淡第一个是参数类型注释第二个是返回值类型注释一般来说不用定义返回值类型因为会自动推断匿名函数与函数声明有点不同当一个函数出现在出现在可以确定它如何被调用的地方的时候这个函数的参数会自动的指定类型对象类型坐标的值是坐标的值是对于参数类型注释是对象类型的对象中属性的分割可以用分号或者逗号名字是名字是使用可以指定对象中某个参数可以选择传入或者不传入不传入其值就是如何在函数体内确定某个带的参数是否传参了呢可以使用两种方法未传入时的方法体传入时的方法体第二种方式更加优雅更推荐使用联合类型的类型系统允许我们使用多种运算符从现有类型中构建新类型联合类型是由两个或多个其他类型组成的类型表示可能是这些类型中的任何一种的值这些类型中的每一种被称为联合类型的成员当前为如果需要调用一些参数的属性或者方法可以使用携带的函数来进行判断并分情况执行代码可以测试是否是一个数组根据分支来进行操作的函数共享的方法都有的属性和方法可以直接使用类型别名对象类型联合类型基元类型可以用来定义变量的类型如果是对象里面的属性和方法可以用逗号分号或直接不写来做间隔可以用来做一些平时经常会用到的类型来做复用其可以用于变量的类型指定上接口坐标的值是坐标的值是可以用接口来定义对象的类型几乎所有可以通过来定义的类型都可以用来定义类型别名和接口之间的区别扩展接口通过扩展接口扩展类型别名通过向现有的类型添加新字段接口定义相同的接口其字段会合并类型别名类型别名创建的类型创建后是不能添加新字段的类型断言返回某种类型的可以使用类型断言来指定类型注释与类型断言一样类型断言由编译器来删除不会影响代码的运行时行为也就是因为类型断言在编译时被删除所以没有与类型断言相关联的运行时检查如上代码可以在我们不知道某些代码是什么类型的时候断言为一个差不多的类型文字类型除了一般类型和还可以在类型位置引用特定的字符串和数字一种方法是考虑如何以不同的方式声明变量和两者都允许更改变量中保存的内容不允许这反映在如何为文字创建类型上可以表示任何可能的字符串那是如何在类型系统中描述它的因为只能表示个可能的字符串所以具有文本类型表示就其本身而言文字类型不是很有价值正确错误拥有一个只能由一个值的变量并没有多大用处但是通过将文字组合成联合你可以表达一个更有用的概念例如只接受一组特定已知值的函数数字文字类型的工作方式相同也可以将这些与非文字类型结合使用还有一种文字类型布尔文字只有两种布尔文字类型它们是类型和类型本身实际上只是联合类型的别名文字推理当你使用对象初始化变量时假定该对象的属性稍后可能会更改值例如如果你写了这样的代码不假定先前具有的字段值后又分配是错误的另一种说法是必须有属性而非是因为类型用于确定读取和写入行为这同样适合用于字符串在上面的例子中推断是不是因为代码可以在创建和调用之间进行评估认为这段代码有错误有两种方法可以解决这个问题可以通过在任一位置添加类型断言来更改推理方案方案方案表示我打算始终拥有文字类型从而防止之后可能分配给该字段方案的意思是我知道其他原因具有值可以使用将整个对象转换为类型文字该后缀就像定义确保所有属性分配的文本类型而不是一个更一般的或和有两个原始值用于表示不存在或未初始化的值和有两个对应的同名类型这些类型的行为取决于您是否在设置选择关闭使用仍然可以正常访问的值并且可以将值分配给任何类型的属性这类似于没有空检查的语言例如的行为方式缺乏对这些值的检查往往是错误的主要来源如果在他们的代码库中这样做可行我们总是建议大家打开开启使用你需要在对该值使用方法或属性之前测试这些值就像在使用可选属性之前检查一样我们可以使用缩小来检查可能的值做一些事非空断言运算符后缀也有一种特殊的语法可以在不进行任何显式检查的情况下从类型中移除和移除类型在任何表达式之后写入实际上是一种类型断言即该值不是使用可以指定对象中某个参数可以选择传入或者不传入不传入其值就是正确就像其他类型断言一样这不会更改代码的运行时行为因此仅当你知道该值不能是或时使用才是重要的枚举枚举是添加到的一项功能它允许描述一个值该值可能是一组可能的命名常量之一与大多数功能不同这不是的类型级别的添加而是添加到语言和运行时的内容因此你确定你确实需要枚举在做些事情否则请不要使用可以在参考页中阅读有关枚举的更多信息源码编译后的代码不太常见的原语值得一提的是中一些较新的原语它们在类型系统中也实现了我们先简单的看两个例子从开始中有一个用于非常大的整数的原语通过函数创建通过文本语法创建你可以在发行说明中了解有关的更多信息中有一个原语用于通过函数创建全局唯一引用这里的代码不可能执行此条件将始终返回因为类型和没有重叠学习第四章类型缩小假设我们有一个名为的函数尚未实现我们来扩充一下功能如果是它会将其视为我们将要添加到的空格数如果是它只在上做让我们尝试实现这样的话我们在处会遇到错误警告我们运算符不能应用于类型和这个逻辑是对的因为我们没有明确检查是否为也没有处理它是的情况所以我们我们这样做如果这大部分看起来像无趣的代码这也算是重点吧除了我们设置的注解之外这段代码看起来就像我们的想法是的类型系统旨在使编写典型的代码变得尽可能容易而不需要弯腰去获得类型安全虽然看起来不多但实际上有很多价值在这里就像使用静态类型分析运行时的值一样它在的运行时控制流构造上叠加了类型分析如条件三元组循环真实性检查等这些都会影响到这些类型在我们的检查中看到并将其理解为一种特殊形式的代码称为类型保护遵循我们的程序可能采取的执行路径以分析一个值在特定位置的最具体的可能类型它查看这些特殊的检查称为类型防护和赋值将类型细化为比声明的更具体的类型的过程被称为类型缩小在许多编辑器中我们可以观察这些类型的变化我们甚至会在我们的例子中这样做可以理解几种不同的缩小结构类型守卫正如我们所见支持运算符它可以提供有关我们在运行时拥有的值类型的非常基本的信息期望它返回一组特定的字符串就像我们刚才在中看到的那样这个运算符经常出现在许多库中可以理解为它缩小在不同分支中的类型在中检查的返回值是一种类型保护因为对操作进行编码从而返回不同的值所以它知道对做了什么例如请注意上面的列表中不返回做点事在函数中我们尝试检查是否为对象来代替检查它是否为数组类型现在可能是强调数组是中的对象类型的好时机但事实证明在中实际上也是这是历史上的不幸事故之一有足够经验的用户可能不会感到惊讶但并不是每个人都在中遇到过这种情况幸运的是让我们知道只缩小到而不仅仅是这可能是我们所谓的真实性检查的一个很好的过渡真值缩小真值检查是我们在中经常做的一件事在中我们可以在条件语句布尔否定等中使用任何表达式例如语句不希望它们的条件总是具有类型现在共有人在线现在没有人在线在总条件语句首先把他们的条件强制转化为以使其有意义然后根据结果是还是来选择他们的分支像下面这些值都强制转换为空字符串的版本其他值被强制转化为你始终可以在函数中运行值获得或使用较短的双布尔否定将值强制转换为后者的优点是推断出一个狭窄的文字布尔类型而将第一个推断为类型这两个结果都返回利用这个特性我们可以防范诸如或之类的值时例如让我们尝试将它用于我们的函数我们通过检查是否为真消除了上述错误这可以防止我们在运行代码的时候出现一些错误例如但请记住对原语的真值检查通常容易出错例如考虑改写别这样原因在下边我们将整个函数体包裹在一个真值检查中但是这有一个小小的缺点我们可能不再正确处理空字符串的情况在这里根本不会报错如果你不熟悉这是值得注意的通常可以帮你及早发现错误但是如果你选择对某个值不做任何处理那么它可以做的就只有这么多而不会考虑过多逻辑方面的问题如果需要你可以确保程序规范性处理此类情况关于通过真实性缩小范围的最后一点是通过布尔否定把逻辑从否定分支中过滤掉等值缩小也使用分支语句做和等值检查来实现类型缩小例如现在可以在上调用字符串类型的方法了当我们在上面的示例中检查和是否相等时知道它们的类型也必须相等由于是和都可以采用的唯一常见类型因此知道如果都是则程序走第一个分支中检查特定的字面量值而不是变量也有效在我们关于真值缩小的部分中我们编写了一个容易出错的函数因为它没有正确处理空字符串相反我们可以做一个特定的检查来阻止并且仍然正确地从里移除更宽松的相等性检查和也能被正确缩小如果你不熟悉如何检查某个变量是否因为有时不仅要检查它是否是特定的值还要检查它是否可能是这同样适用于它检查一个值是否为或现在你只需要这个和就可以搞定了从类型中排除了和现在我们可以安全地乘以了操作符缩小有一个运算符用于确定对象是否具有某个名称的属性运算符考虑到了这一点以此来缩小潜在类型的范围例如使用代码这里的是字符串是联合类型值为的分支缩小需要具有可选或必需属性的类型的值值为的分支缩小需要具有可选或缺失属性的类型的值另外可选属性还将存在于缩小的两侧例如人类可以游泳和飞行使用正确的设备因此应该出现在检查的两侧操作符缩小有一个运算符检查一个值是否是另一个值的实例更具体地在中检查的原型链是否含有虽然我们不会在这里深入探讨当我们进入类学习时你会看到更多这样的内容它们大多数可以使用关键字实例化正如你可能已经猜到的那样也是一个类型保护在由保护的分支中实现缩小分配缩小正如我们之前所提到的当我们为任何变量赋值时会检查赋值的右侧并适当缩小左侧请注意这些分配中的每一个都是有效的即使在我们第一次赋值后观察到的类型更改为我们仍然可以将赋值给这是因为声明类型开始是如果我们分配了一个给我们就会看到一个错误因为它不是声明类型的一部分出错了控制流分析到目前为止我们已经通过一些基本实例来说明如何在特定分支中缩小范围但是除了从每个变量中走出来并在条件等中寻找类型保护之外还有更多的事情要做比如从其第一个块中返回能够分析这段代码并看到在是数字的情况下主体的其余部分是不可达的因此它能够将数字从的类型中移除从缩小到用于该函数的其余部分这种基于可达性的代码分析被称为控制流分析使用这种流分析来缩小类型因为它遇到了类型守卫和赋值当一个变量被分析时控制流可以一次又一次地分裂和重新合并该变量可以被观察到在每个点上有不同的类型使用类型谓词到目前为止我们已经用现有的结构来处理窄化问题然而有时你想更直接地控制整个代码中的类型变化为了定义一个用户定义的类型保护我们只需要定义一个函数其返回类型是一个类型谓词在这个例子中是我们的类型谓词谓词的形式是其中必须是当前函数签名中的参数名称返回一个代表是不是该任何时候被调用时如果原始类型是兼容的将把该变量缩小到该特定类型这里的和都可以访问了注意不仅知道在分支中是一条鱼它还知道在分支中你没有一条所以你一定有一只你可以使用类型守卫来过滤的数组获得的数组或者等同于对于更复杂的例子该谓词可能需要重复使用受歧视的到目前为止我们所看的大多数例子都是围绕着用简单的类型如和来缩小单个变量虽然这很常见但在中大多数时候我们要处理的是稍微复杂的结构为了激发灵感让我们想象一下我们正试图对圆形和方形等形状进行编码圆记录了它们的半径方记录了它们的边长我们将使用一个叫做的字段来告诉我们正在处理的是哪种形状这里是定义的第一个尝试注意我们使用的是字符串字面类型的联合和分别告诉我们应该把这个形状当作一个圆形还是方形通过使用而不是我们可以避免拼写错误的问题我们可以编写一个函数根据它处理的是圆形还是方形来应用正确的逻辑我们首先尝试处理圆形在下这给了我们一个错误这是很恰当的因为可能没有被定义但是如果我们对属性进行适当的检查呢嗯仍然不知道该怎么做我们遇到了一个问题即我们对我们的值比类型检查器知道的更多我们可以尝试使用一个非空的断言后面的那个叹号来说明肯定存在但这感觉并不理想我们不得不用那些非空的断言对类型检查器声明一个叹号以说服它相信是被定义的但是如果我们开始移动代码这些断言就容易出错此外在之外我们也可以意外地访问这些字段因为在读取这些字段时可选属性被认为总是存在的我们绝对可以做得更好的这种编码的问题是类型检查器没有办法根据种类属性知道或是否存在我们需要把我们知道的东西传达给类型检查器考虑到这一点让我们再来定义一下在这里我们正确地将分成了两种类型为属性设置了不同的值但是和在它们各自的类型中被声明为必需的属性让我们看看当我们试图访问的半径时会发生什么就像我们对的第一个定义一样这仍然是一个错误当半径是可选的时候我们得到了一个错误仅在中因为无法判断该属性是否存在现在是一个联合体告诉我们可能是一个而并没有定义半径这两种解释都是正确的但只有我们对的新编码仍然在之外导致错误但是如果我们在此尝试检查属性呢这就摆脱了错误当中的每个类型都包含一个与字面类型相同的属性时认为这是一个有区别的并且可以缩小的成员在这种情况下就是那个共同属性这就是的判别属性检查属性是否为就可以剔除中所有没有类型属性的类型这就把的范围缩小到了这个类型同样的检查方法也适用于语句现在我们可以试着编写完整的而不需要任何讨厌的叹号非空的断言这里最重要的是的编码向传达正确的信息是至关重要的这个信息就是和实际上是具有特定种类字段的两个独立类型这样做让我们写出类型安全的代码看起来与我们本来要写的没有区别从那里类型系统能够做正确的事情并找出我们语句的每个分支中的类型辨证的联合体不仅仅适用于谈论圆形和方形它们适合于在中表示任何类型的消息传递方案比如在网络上发送消息通信或者在状态管理框架中编码突变类型与穷尽性检查在缩小范围时你可以将一个联合体的选项减少到你已经删除了所有的可能性并且什么都不剩的程度在这些情况下将使用一个类型来代表一个不应该存在的状态类型可以分配给每个类型但是没有任何类型可以分配给除了本身这意味着你可以使用缩小并依靠的出现在语句中做详尽的检查例如在我们的函数中添加一个默认值试图将形状分配给当每个可能的情况都没有被处理时就会引发在联盟中添加一个新成员将导致错误学习第五章函数函数是任何应用程序的基本构件无论它们是本地函数从另一个模块导入还是一个类上的方法它们也是值就像其他值一样有很多方法来描述如何调用函数让我们来学习一下如何编写描述函数的类型函数类型表达式描述一个函数的最简单是用一个函数类型表达式这些类型在语法上类似于箭头函数语法意味着有一个参数的函数名为类型为字符串没有返回值就像函数声明一样如果没有指定参数类型它就隐含为类型当然我们可以用一个类型别名来命名一个函数类型调用签名属性签名在中除了可调用之外函数还可以有属性然而函数类型表达式的语法不允许声明属性如果我们想用属性来描述可调用的东西我们可以在一个类型别名中写一个调用签名值得注意的是类型别名中缩写的函数类型表达式返回值是用冒号而不是箭头函数且实际应用时所传入函数返回值必须与此函数类型表达式声明的相同和如果函数体内没有操作参数的行为可以不传参数比如对象类型函数的属性签名函数类型表达式不能用而是用传入正常参数使用且正常返回值不传入参数且不正常返回值不传入参数且正常返回值正常报错正常构造签名函数也可以用操作符来调用将这些成为构造函数因为它们通常会创建一个新的对象你可以通过在调用签名前面添加关键字来写一个构造签名返回的是一个类或者构造函数在调用签名前加就是构造签名返回的是一个构造函数或者类可以理解为构造函数有些对象如的对象可以在有或没有的情况下被调用你可以在同一类型中任意地结合调用和构造签名因为可以在不使用的情况下调用所以代码正常下一个实例构造函数的接口是一个构造签名返回一个类的构造函数类的接口里面有一个函数创建类的函数具体的类来实现必须要有函数具体的类来实现必须要有函数泛型函数在写一个函数时输入的类型与输出的类型有关或者两个输入的类型以某种方式相关这是常见的让我们考虑一下一个返回数组种第一个元素的函数这个函数完成了它的工作但不幸的是它的返回类型是如果该函数返回数组元素的类型会更好在中当我们想描述两个值之间的对应关系时会使用泛型我们通过在函数签名中声明一个类型参数来做到这一点通过给这个函数添加一个类型参数并在两个地方使用它我们已经在函数的输入数组和输出返回值之间建立了一个联系现在当我们调用它时一个更具体的类型就出来了是类型是类型是类型类型推断请注意在这个例子中我们没有必要指定类型类型是由推断出来的自动选择我们也可以使用多个类型参数例如一个独立版本的看起来可能是这样的参数是字符串类型是类型请注意在这个例子中可以推断出输入类型参数的类型从给定的字符串数组以及基于函数表达式的返回值数字的输出类型参数限制条件我们经写了一些通用函数可以对任何类型的值进行操作有时我们想把两个值联系起来但只能对某个值的子集进行操作这种在这种情况下我们可以使用一个约束条件来限制一个类型参数可以接受的类型让我们写一个函数返回两个值中较长的值要做到这一点我们需要一个长度属性是一个数字我们通过写一个扩展子句将类型参数限制在这个类型上的类型是是的类型错误数字没有长度属性在这个例子中有一些有趣的事情需要注意我们允许推断的返回类型返回类型推断也适用于通用函数因为我们将约束为所以我们被允许访问和参数的属性如果没有类型约束我们就不能访问这些属性因为这些值可能是一些没有长度属性的其他类型和的类型是根据参数推断出来的记住泛型就是把两个或多个具有相同类型的值联系起来最后正如我们所希望的对的调用被拒绝了因为数字类型没有一个属性使用受限值这里有一个使用通用约束条件时的常见错误看起来这个函数没有问题被限制为而且这个函数要么返回要么返回一个与该限制相匹配的值问题是该函数承诺返回与传入的对象相同的类型而不仅仅是与约束条件相匹配的一些对象如果这段代码是合法的你可以写出肯定无法工作的代码获得值在此崩溃因为数组有一个切片方法但没有返回对象指定类型参数通常可以推断出通用调用中的预期类型参数但并非总是如此例如假设你写了一个函数来合并两个数组通常情况下用不匹配的数组调用这个函数是一个错误然而如果你打算这样做你在调用函数时可以手动指定类型编写优秀通用函数的准则编写泛型函数很有趣而且很容易被类型参数所迷惑有太多的类型参数或在不需要的地方使用约束会使推理不那么成功使你的函数的调用者感到沮丧类型参数下推下面是两种看似的函数写法推荐不推荐乍一看这些可能是相同的但是写这个函数的一个更好的方法它的推断返回类型是但的推断返回类型是因为必须使用约束类型来解析表达式而不是在调用期间等待解析该元素规则在可能的情况下使用类型参数本身而不是对其进行约束使用更少的类型参数下面是另一对类似的函数我们已经创建了一个类型参数它并不涉及两个值这总是一个值得标记的坏习惯因为它意味着想要指定类型参数的调用者必须无缘无故地手动指定一个额外的类型参数除了使函数更难阅读和推理外什么也没做规则总是尽可能少的使用类型参数类型参数应该出现两次及以上有时候我们会忘记一个函数可能不需要是通用的我们完全可以写一个更简单的版本记住类型参数是用来关联多个值的类型的如果一个类型参数在函数签名中只使用一次那么它就没有任何关系规则如果一个类型的参数只出现在一个地方请重新考虑你是否真的需要它可选参数中的函数经常需要一个可变数量的参数例如的方法需要一个可选的数字计数个参数个参数我们可以在中通过将参数用标记正确正确虽然参数被指定为类型但参数实际上将具有类型因为在中未指定的参数会得到的值你也可以提供一个参数默认值现在在的主体中将具有类型因为任何的参数将被替换为请注意当一个参数是可选的调用者总是可以传递未定义的参数因为这只是模拟一个丢失的参数以下调用都是正确的回调中的可选参数一旦你了解了可选参数和函数类型表达式在编写调用回调的函数时就很容易犯以下错误我们在写作为一个可选参数时通常是想让这些调用都是合法的这实际上意味着回调可能会被调用只有一个参数换句话说该函数定义说实现可能是这样的我现在不想提供索引反过来会强制执行这个意思并发出实际上不可能的错误在中如果你调用一个形参多于实参的函数额外的参数会被简单地忽略的行为也是如此参数较少的函数相同的类型总是可以取代参数较多的函数的位置当为回调写一个函数类型时永远不要写一个可选参数除非你打算在不传递该参数的情况下调用函数函数重载重载签名一些函数可以在不同的参数数量和类型中被调用例如你可能会写一个函数来产生一个它需要一个时间戳一个参数或一个月日年规格三个参数在中我们可以通过编写重载签名来指定一个可以以不同方式调用的函数要做到这一点要写一些数量的函数签名通常是两个或更多然后是函数的主体重载签名重载签名在这个例子中我们写了两个重载一个接受一个参数另一个接受三个参数这前两个签名被称为重载签名然后我们写了一个具有兼容签名的函数实现函数有一个实现签名但这个签名不能被直接调用即使我们写了一个在所需参数之后有两个可选参数的函数它也不能以两个参数被调用重载签名和实现签名这是一个常简的混乱的来源通常我们会写这样的代码却不明白为什么会出现错误期望能够以零参调用同样用于编写函数体的签名不能从外面看到实现的签名从外面是看不到的在编写重载函数时你应该总是在函数的实现上面有两个或多个签名实现签名也必须与重载签名兼容例如这些函数有错误因为实现签名没有以正确的方式匹配重载参数类型不正确返回类型不正确编写好的重载和泛型一样在使用函数重载时有一些准则是你应该遵循的遵循这些原则将使你的函数更容易调用更容易理解更容易实现让我们考虑一个返回字符串或数组长度的函数这个函数是好的我们可以用字符串或数组来调用它然而我们不能用一个可能是字符串或数组的值来调用它因为只能将一个函数调用解析为一个重载因为两个重载都有相同的参数数量和相同的返回类型我们可以改写一个非重载版本的函数这就好得多了调用者可以用任何一种值来调用它而且作为额外的奖励我们不需要找出一个正确的实现签名在可能的情况下总是倾向于使用联合类型的参数而不是重载参数函数内的声明会通过代码分析来推断函数中应该是什么比如下面的例子理解函数有一个对应的它是外部对象这个对于很多情况来说已经足够了但是有很多情况下你需要更多的控制代表什么对象规范规定你不能有一个叫的参数所以使用这个语法空间让你在函数体中声明的类型需要了解的其他类型有一些额外的类型你会想要认识它们在处理函数类型时经常出现像所有的类型一样你可以在任何地方使用它们但这些类型在函数的上下文中特别相关表示没有返回值的函数的返回值当一个函数没有任何返回语句或者没有从这些返回语句中返回任何明确的值时它都是推断出来类型推断出的返回类型是在中一个不返回任何值的函数将隐含地返回的值然而在中和是不一样的在本章末尾有进一步的细节和是不一样的特殊类型指的是任何不是基元的值或这与空对象类型不同也与全局类型不同你很可能永远不会使用不是始终使用请注意在中函数值是对象它们有属性在它们的原型链中有是的实例你可以对它们调用等等由于这个原因函数类型在中被认为是类型代表任何值这与类型相似但更安全因为对未知值做任何事情都是不合法的正确这在描述函数类型时很有用因为你可以描述接受任何值的函数而不需要在函数体中有值反之你可以描述一个返回未知类型的值的函数需要小心对待有些函数永远不会返回一个值类型标识永远不会被观察到的值载一个返回类型中这意味着函数抛出了一个异常或终止程序的执行也出现在确定一个中没有任何东西的时候做一些事再做一些事全局性的类型描述了诸如和其他存在于中所有函数值的属性它还有一个特殊的属性即类型的值总是可以被调用这些调用返回这是一个无类型的函数调用一般来说最好避免因为返回类型都不安全如果你需要接受一个任意的函数但不打算调用它一般来说的类型比较安全函数展开运算符形参展开除了使用可选参数或重载来制作可以接受各种固定参数数量的函数之外我们还可以使用休止参数来定义接受无限制数量的参数的函数参数出现在所有其他参数之后并使用的语法获得的值在中这些参数的类型注解是隐含的而不是任何给出的类型注解必须是或的形式或一个元组类型我们将在后面学习实参展开反之我们可以使用语法从数组中提供可变数量的参数例如数组的方法需要任意数量的参数请注意一般来说并不假定数组是不可变的这可能会导致一些令人惊讶的行为推断的类型是一个有零或多个数字的数组不专指两个数字这种情况的最佳解决方案取决于你的代码但一般来说是最直接的解决方案推断为个长度的元组正确参数解构可以使用参数重构来方便地将作为参数提供的对象解压到函数主体的一个或多个局部变量中在中它看起来像这样对象的类型注解在结构的语法之后这看起来有点啰嗦但你也可以在这里使用一个命名的类型与之前的例子相同函数的可分配性返回类型函数的返回类型可以产生一些不寻常的但却是预期的行为返回类型为的上下文类型并不强迫函数不返回东西另一种说法是一个具有返回类型的上下文函数类型在实现时可以返回任何其他的值但它会被忽略因此以下类型的实现是有效的而当这些函数之一的返回值被分配给另一个变量时它将保留的类型这种行为的存在使得下面的代码是有效的即使返回一个数字而方法期望一个返回类型为的函数还有一个需要注意的特殊情况当一个字面的函数定义有一个的返回类型时该函数必须不返回任何东西学习第六章对象类型在中我们分组和传递数据的基本方式是通过对象在中我们通过对象类型来表示这些对象正如我们所见它们可以是匿名的匿名对象或者可以通过使用一个接口来命名它们接口中定义了一个对象类型包含和或者类型别名类型别名种定义了一个对象类型其包含和在上面的三个例子中我们写了一些函数这些函数接收包含属性必须是一个和必须是一个的对象属性修改器对象类型中的每个属性都可以指定几件事类型属性是否是可选的以及属性是否可以被写入可选属性很多时候我们会发现自己处理的对象可能有一个属性设置在这些情况下我们可以在这些属性的名字后面加上一个问号把它们标记为可选的在这个例子中和都被认为是可选的我们可以选择提供它们中的任何一个所以上面对的每个调用都是有效的所有的可选性实际上是说如果属性被设置它最好有一个特定的类型我们也可以从这些属性中读取但当我们在下读取时会告诉我们它们可能是未定义的因为未赋值时值为在中即使该属性从未被设置过我们仍然可以访问它它只是会给我们未定义的值我们可以专门处理未定义请注意这种为未指定的值设置默认值的模式非常普遍以至于有语法来支持它注意此时用了解构的语法将里的参数结构出来并给和设置了默认值在这里我们为的参数使用了一个解构模式并为和提供了默认值现在和都肯定存在于的主体中但对于的任何调用者来说是可选的请注意目前还没有办法将类型注释放在解构模式中这是因为下面的语法在中已经有了不同的含义在一个对象解构模式中意味着获取属性并在本地重新定义为一个名为的变量同样创建一个名为的变量其值基于参数的只读属性对于属性也可以被标记为只读虽然它不会在运行时改变任何行为但在类型检查期间可以在一个属性前加一个标记为只读的属性不能被写入可以读取但不能重新设置值使用修饰符并不一定意味着一个值是完全不可改变的或者换句话说它的内部内容不能被改变它只是意味着该属性本身不能被重新写入我们可以从读取和更新属性但是我们不能写到上的属性本身管理对含义的预期是很重要的在的开发过程中对于一个对象应该如何被使用的问题它是有用的信号在检查两个类型的属性是否兼容时并不考虑这些类型的属性是否是所以属性也可以通过别名来改变正常工作打印打印索引签名有时你并不提前知道一个类型的所有属性名称但你知道值的类型在这些情况下你可以使用一个索引签名来描述可能的值的类型比如说上面我们有一个接口它有一个索引签名这个索引签名指出当一个被数字索引时它将返回一个字符串索引签名的属性类型必须是或支持两种类型的索引器是可能的但是从数字索引器返回的类型必须是字符串索引器返回的类型的子类型这是因为当用数字进行索引时实际上在索引到一个对象之前将其转换为字符串这意味着用一个数字进行索引和用一个字符串进行索引是一样的所以两者需要一致虽然字符串索引签名是描述字典模式的一种强大方式但它也强制要求所有的属性与它们的返回类型相匹配这是因为字符串索引声明也可以作为在下面的例子中的类型与字符串索引的类型不匹配类型检查器会给出一个错误然而如果索引签名是属性类型的联合不同类型的属性是可以接受的正确是类型正确是类型最后你可以使索引签名为只读以防止对其索引的赋值你不能设置因为这个索引签名是只读的扩展类型有一些类型可能是其他类型的更具体的版本这是很常见的例如我们可能有一个类型描述发送信件和包裹所需的字段在某些情况下这就足够了但是如果一个地址的小区内有多个单元那么地址往往有一个单元号与之相关我们就可以描述一个这就完成了工作但这里的缺点是当我们的变化是纯粹的加法时我们不得不重复的所有其他字段相反我们可以扩展原始的类型只需添加特有的新字段接口上的关键字允许我们有效地从其他命名的类型中复制成员并添加我们想要的任何新成员这对于减少我们不得不写的类型声明模板以及表明同一属性的几个不同声明可能是相关的意图来说是非常有用的例如不需要重复属性而且因为源于我们会知道这两种类型在某种程度上是相关的接口也可以从多个类型中扩展交叉类型接口允许我们通过扩展其他类型建立起新的类型提供了另一种结构称为交叉类型主要用于组合现有的对象类型交叉类型是用操作符定义的在这里我们将和相交产生了一个新的类型它拥有和的所有成员正确错误接口与交叉类型我们刚刚看了两种组合类型的方法它们很相似但实际上有细微的不同对于接口我们可以使用子句来扩展其他类型而对于交叉类型我们也可以做类似的事情并用类型别名来命名结果两者之间的主要区别在于如何处理冲突这种区别通常是你在接口和交叉类型的类型别名之间选择一个的主要原因之一接口可以定义多次多次的声明会自动合并但是类型别名如果定义多次会报错泛型对象类型让我们想象一下一个可以包含任何数值的盒子类型字符串数字长颈鹿等等现在内容属性的类型是任意这很有效但会导致下一步的意外我们可以使用但这意味着在我们已经知道内容类型的情况下我们需要做预防性检查或者使用容易出错的类型断言我们需要检查或者用类型断言一种安全的方法是为每一种类型的内容搭建不同的盒子类型但这意味着我们必须创建不同的函数或函数的重载以对这些类型进行操作那是一个很大的模板此外我们以后可能需要引入新的类型和重载这是令人沮丧的因为我们的盒子类型和重载实际上都是一样的相反我们可以做一个通用的类型声明一个参数类型你可以把这句话理解为一个类型的盒子是它的内容具有类型的东西以后当我们引用时我们必须给一个类型参数来代替把想象成一个真实类型的模板其中是一个占位符会被替换成其他类型当看到时它将用字符串替换中的每个实例并最终以这样的方式工作换句话说和我们之前的工作起来是一样的盒子是可重用的因为可以用任何东西来代替这意味着当我们需要一个新类型的盒子时我们根本不需要声明一个新的盒子类型尽管如果我们想的话我们当然可以等价于这也意味着我们可以完全避免重载而是使用通用函数通过使用一个类型别名来代替由于类型别名与接口不同它不仅可以描述对象类型我们还可以用它来编写其他类型的通用辅助类型我们将在稍后回到类型别名通用对象类型通常是某种容器类型它的工作与它们所包含的元素类型无关数据结构以这种方式工作是很理想的这样它们就可以在不同的数据类型中重复使用数组类型我们一直在使用这样一种类型数组类型每当我们写出或这样的类型时这实际上只是和的缩写这两样都能用和上面的类型一样本身也是一个通用类型获取或设置数组的长度移除数组中的最后一个元素并返回向一个数组添加新元素并返回数组的新长度现代还提供了其他通用的数据结构比如和这实际上意味着由于和的行为方式它们可以与任何类型的集合一起工作只读数组类型是一个特殊的类型描述了不应该被改变的数组我们可以从读数据第一个值是但我们不能改变的值和属性的修饰符一样它主要是一个我们可以用来了解意图的工具当我们看到一个返回的函数时它告诉我们我们根本不打算改变其内容而当我们看到一个消耗的函数时它告诉我们可以将任何数组传入该函数而不用担心它会改变其内容与不同没有一个我们可以使用的构造函数相反我们可以将普通的分配给正如为提供了的速记语法一样它也为提供了只读的速记语法最后要注意的是与属性修改器不同可分配性在普通和之间不是双向的元组类型类型是另一种类型它确切地知道包含多少个元素以及它在特定位置包含哪些类型这里是一个和的元组类型像一样它在运行时没有表示但对来说是重要的对于类型系统来说描述了其索引包含字符串和索引包含数字的数组如果我们试图索引超过元素的数量我们会得到一个错误我们还可以使用的数组析构来对元组进行解构除了这些长度检查像这样的简单元组类型等同于的版本它为特定的索引声明属性并且用数字字面类型声明长度专有属性其他成员另一件你可能感兴趣的事情是元组可以通过在元素的类型后面写出问号可选的元组元素只能出现在末尾而且还影响到长度的类型提供的坐标有个维度图元也可以有其余元素这些元素必须是类型描述了一个元组其前两个元素分别是字符串和数字但后面可以有任意数量的布尔描述了一个元组其第一个元素是字符串然后是任意数量的布尔运算最后是一个数字描述了一个元组其起始元素是任意数量的布尔运算最后是一个字符串然后是一个数字一个有其余元素的元组没有集合的长度它只有一组不同位置的知名元素基本上等同于当你想用一个其余参数接受可变数量的参数并且你需要一个最小的元素数量但你不想引入中间变量时这很方便只读元组类型关于类型的最后一点说明类型有只读特性可以通过在它们前面粘贴一个修饰符来指定就像数组的速记语法一样正如你所期望的在中不允许向只读元组的任何属性写入在大多数代码中元组往往被创建并不被修改所以在可能的情况下将类型注释为只读元组是一个很好的默认这一点也很重要因为带有断言的数组字面量将被推断为只读元组类型在这里从未修改过它的元素而是期望一个可变的元组由于的类型被推断为只读的它与不兼容因为该类型不能保证的元素不被修改学习第七章类型操纵从类型中创建类型的类型系统非常强大因为它允许使用其他类型的术语来表达类型这个想法的最简单的形式是泛型我们实际上有各种各样的类型操作符可以使用也可以用我们已经有的值来表达类型通过结合各种类型操作符我们可以用一种简洁可维护的方式来表达复杂的操作和值在本节中我们将介绍用现有的类型或值来表达一个新类型的方法泛型型带参数的类型类型操作符操作符创建新类型类型操作符使用操作符来创建新的类型索引访问类型使用语法来访问一个类型的子集条件类型在类型系统中像语句一样行事的类型映射类型通过映射现有类型中的每个属性来创建类型模板字面量类型通过模板字面字符串改变属性的映射类型泛型软件工程的一个主要部分是建立组件这些组件不仅有定义明确和一致的而且还可以重复使用能够处理今天的数据和明天的数据的组件将为你建立大型软件系统提供最灵活的能力泛型能够创建一个在各种类型上工作的组件而不是单一的类型这使得用户可以消费这些组件并使用他们自己的类型首先让我们做一下泛型的身份函数身份函数使用个函数他将返回传入的任何内容你一用类似于命令的方式来考虑它如果没有泛型我们将不得不给身份函数一个特定的类型或者我们可以用任意类型来描述身份函数使用当然是通用的因为它将使函数接受类型的任何和所有的类型但实际上我们在函数返回时失去了关于该类型的信息如果我们传入一个数字我们唯一的信息就是任何类型都可以被返回相反我们需要一种方法来捕获参数的类型以便我们也可以用它来表示返回的内容在这里我们将使用一个类型变量这是一种特殊的变量对类型而不是数值起作用我们现在已经在身份函数中添加了一个类型变量这个允许我们捕获用户提供的类型例如数字这样我们就可以在以后使用这些信息这里我们再次使用作为返回类型经过检查我们现在可以看到参数和返回类型使用的是相同的类型这使得我们可以将类型信息从函数的一侧输入然后从另一侧输出我们说这个版本的身份函数是通用的因为它在一系列的类型上工作与使用任何类型不同的是它也和第一个使用数字作为参数和返回类型的身份函数一样精确即它不会丢失任何信息一旦我们写好了通用身份函数我们就可以用两种方式之一来调用它第一种方式是将所有的参数包括类型参数都传递给函数这里我们明确地将设置为作为函数调用的参数之一用参数周围的而不是来表示第二种方式可能也是最常见的这里我们使用类型参数推理也就是说我们希望编译器根据我们传入的参数的类型自动为我们设置的值注意我们不必在角括号中明确地传递类型编译器只是查看了这个值并将设置为其类型虽然类型参数推断是一个有用的工具可以使代码更短更易读但当编译器不能推断出类型时你可能需要像我们在前面的例子中那样明确地传入类型参数这在更复杂的例子中可能发生使用通用类型变量当你开始使用泛型时你会注意到当你创建像这样的泛型函数时编译器会强制要求你在函数主体中正确使用任何泛型参数也就是说你实际上是把这些参数当作是任何和所有的类型让我们来看看我们前面的函数如果我们想在每次调用时将参数的长度记录到控制台该怎么办我们可能很想这样写当我们这样做时编译器会给我们一个错误说我们在使用的成员但我们没有说有这个成员记住我们在前面说过这些类型的变量可以代表任何和所有的类型所以使用这个函数的人可以传入一个类型的数字而这个数字没有一个成员比方说我们实际上是想让这个函数在的数组上工作而不是直接在上工作既然我们在处理数组那么成员应该是可用的我们可以像创建其他类型的数组那样来描述它你可以把的类型理解为通用函数接收一个类型参数和一个参数是一个数组并返回一个数组如果我们传入一个数字数组我们会得到一个数字数组因为会绑定到数字这允许我们使用我们的通用类型变量作为我们正在处理的类型的一部分而不是整个类型给我们更大的灵活性我们也可以这样来写这个例子数组有一个所以不会再出错了你可能已经从其他语言中熟悉了这种类型的风格在下一节中我们将介绍如何创建你自己的通用类型如泛型接口在前几节中我们创建了在一系列类型上工作的通用身份函数在这一节中我们将探讨函数本身的类型以及如何创建通用接口泛型函数的类型与非泛型函数的类型一样类型参数列在前面与函数声明类似我们也可以为类型中的通用类型参数使用一个不同的名字只要类型变量的数量和类型变量的使用方式一致我们也可以把泛型写成一个对象字面类型的调用签名这让我们开始编写我们的第一个泛型接口让我们把前面例子中的对象字面类型移到一个接口中在一个类似的例子中我们可能想把通用参数移到整个接口的参数上这可以让我们看到我们的泛型是什么类型例如而不是仅仅这使得类型参数对接口的所有其他成员可见请注意我们的例子已经改变了变成了稍微不同的东西我们现在没有描述一个泛型函数而是有一个非泛型的函数签名它是泛型类型的一部分当我们使用时我们现在还需要指定相应的类型参数这里是有效地锁定了底层调用签名将使用什么了解什么时候把类型参数直接放在调用签名上什么时候把它放在接口本身将有助于描述一个类型的哪些方面是通用的除了泛型接口之外我们还可以创建泛型类注意不可能创建泛型枚举和命名空间泛型类一个泛型类的形状与泛型接口相似泛型类在类的名字后面有一个角括号中的泛型参数列表这是对类相当直白的使用但你可能已经注意到没有任何东西限制它只能使用数字类型我们本可以使用字符串或更复杂的对象就像接口一样把类型参数放在类本身可以让我们确保类的所有属性都与相同的类型一起工作正如我们在关于类的章节中提到的一个类的类型有两个方面静态方面和实例方面通用类只在其实例侧而非静态侧具有通用性所以在使用类时静态成员不能使用类的类型参数泛型约束如果你还记得前面的例子你有时可能想写一个通用函数在一组类型上工作而你对这组类型会有什么能力有一定的了解在我们的例子中我们希望能够访问属性但是编译器无法证明每个类型都有一个属性所以它警告我们不能做这个假设我们希望限制这个函数与和所有类型一起工作而不是与和所有同时具有属性的类型一起工作只要这个类型有这个成员我们就允许它但它必须至少有这个成员要做到这一点我们必须把我们的要求作为一个约束条件列在可以是什么为了做到这一点我们将创建一个接口来描述我们的约束在这里我们将创建一个接口它有一个单一的属性然后我们将使用这个结合关键字来表示我们的约束条件接口声明了一个具有的对象现在我们知道它有一个属性所以不再有错误了因为泛型函数现在被限制了它将不再对和所有的类型起作用相反我们需要传入其类型具有所有所需属性的值在泛型约束中使用类型参数你可以声明一个受另一个类型参数约束的类型参数例如在这里我们想从一个给定名称的对象中获取一个属性我们想确保我们不会意外地获取一个不存在于上的属性所以我们要在这两种类型之间放置一个约束条件在泛型中使用类类型在中使用泛型创建工厂时有必要通过其构造函数来引用类的类型比如说一个更高级的例子使用原型属性来推断和约束类类型的构造函数和实例方之间的关系类型操作符运算符接收一个对象类型并产生其键的字符串或数字字面联合下面的类型与是同一类型如果该类型有一个字符串或数字索引签名将返回这些类型注意在这个例子中是这是因为对象的键总是被强制为字符串所以总是与相同类型在与映射类型结合时变得特别有用我们将在后面进一步了解类型操作符已经有一个操作符你可以在表达式上下文中使用输出添加了一个操作符你可以在类型上下文中使用它来引用一个变量或属性的类型这对基本类型来说不是很有用但结合其他类型操作符你可以使用来方便地表达许多模式举一个例子让我们先看看预定义的类型它接收一个函数类型并产生其返回类型如果我们试图在一个函数名上使用我们会看到一个指示性的错误请记住值和类型并不是一回事为了指代值的类型我们使用故意限制了你可以使用的表达式种类具体来说只有在标识符即变量名或其属性上使用是合法的这有助于避免混乱的陷阱即编写你认为是在执行的代码但其实不是我们认为使用索引访问类型我们可以使用一个索引访问类型来查询另一个类型上的特定属性索引类型本身就是一个类型所以我们可以完全使用或者其他类型如果你试图索引一个不存在的属性你甚至会看到一个错误另一个使用任意类型进行索引的例子是使用来获取一个数组元素的类型我们可以把它和结合起来方便地获取一个数组字面的元素类型或者你只能在索引时使用类型这意味着你不能使用来做一个变量引用然而你可以使用类型别名来实现类似的重构风格条件类型在大多数有用的程序的核心我们必须根据输入来做决定程序也不例外但鉴于数值可以很容易地被内省这些决定也是基于输入的类型条件类型有助于描述输入和输出的类型之间的关系条件类型的形式看起来有点像中的条件表达式当左边的类型可以赋值给右边的类型时那么你将得到第一个分支中的类型真分支否则你将得到后一个分支中的类型假分支子类可以赋值给父类从上面的例子来看条件类型可能并不立即显得有用我们可以告诉自己是否并选择或但条件类型的威力来自于它所带来的好处条件类型的力量来自于将它们与泛型一起使用例如让我们来看看下面这个函数一些字段另一些字段的这些重载描述了一个单一的函数该函数根据其输入的类型做出选择注意一些事情如果一个库必须在其中反复做出同样的选择这就会变得很麻烦我们必须创建三个重载一个用于确定类型的情况一个用于一个用于一个用于最一般的情况取一个对于所能处理的每一种新类型重载的数量都会呈指数级增长相反我们可以在一个条件类型中对该逻辑进行编码然后我们可以使用该条件类型将我们的重载简化为一个没有重载的单一函数条件类型约束通常条件类型中的检查会给我们提供一些新的信息就像用类型守卫缩小范围可以给我们一个更具体的类型一样条件类型的真正分支将通过我们检查的类型进一步约束泛型例如让我们来看下面的例子在这个例子中出错是因为不知道有一个叫做的属性我们可以对进行约束就不会再抱怨然而如果我们想让接受任何类型并在消息属性不可用的情况下默认为类型呢我们可以通过将约束条件移出并引入一个条件类型来做到这一点在真正的分支中知道会有一个消息属性作为另一个例子我们也可以写一个叫做的类型将数组类型平铺到它们的元素类型上但在其他方面则不做处理提取出元素类型单独一个类型当被赋予一个数组类型时它使用一个带有数字的索引访问来获取的元素类型否则它只是返回它被赋予的类型在条件类型内进行推理我们只是发现自己使用条件类型来应用约束条件然后提取出类型这最终成为一种常见的操作而条件类型使它变得更容易条件类型为我们提供了一种方法来推断我们在真实分支中使用关键字进行对比的类型例如我们可以在中推断出元素类型而不是用索引访问类型手动提取出来在这里我们使用关键字来声明性地引入一个名为的新的通用类型变量而不是指定如何在真实分支中检索的元素类型这使我们不必考虑如何挖掘和探测我们感兴趣的类型的结构我们可以使用关键字编写一些有用的辅助类型别名例如对于简单的情况我们可以从函数类型中提取出返回类型给泛型传入类型条件类型会返回当从一个具有多个调用签名的类型如重载函数的类型进行推断时从最后一个签名进行推断据推测这是最容许的万能情况不可能根据参数类型的列表来执行重载解析分布式条件类型当条件类型作用于一个通用类型时当给定一个联合类型时它们就变成了分布式的例如以下面的例子为例如果我们将一个联合类型插入那么条件类型将被应用于该联合的每个成员这里发生的情况是分布在并对联合的每个成员类型进行映射以达到有效的目的这给我们留下了通常情况下分布性是需要的行为为了避免这种行为你可以用方括号包围关键字的每一边不再是一个联合类型映射类型当你不想重复定义类型一个类型可以以另一个类型为基础创建新类型映射类型建立在索引签名的语法上索引签名用于声明没有被提前声明的属性类型映射类型是一种通用类型它使用的联合经常通过创建迭代键来创建一个类型在这个例子中将从类型中获取所有属性并将它们的值改为布尔值映射修改器在映射过程中有两个额外的修饰符可以应用和它们分别影响可变性和可选性你可以通过用或作为前缀来删除或添加这些修饰语如果你不加前缀那么就假定是从一个类型的属性中删除属性从一个类型的属性中删除可选属性通过做重映射在及以后的版本中你可以通过映射类型中的子句重新映射映射类型中的键你可以利用模板字面类型等功能从先前的属性名称中创建新的属性名称来是首字母大写你可以通过条件类型产生滤掉的键过滤掉为的键删除属性你可以映射任意的联合体不仅仅是的联合体还有任何类型的联合体进一步探索映射类型与本类型操作部分的其他功能配合得很好例如这里有一个使用条件类型的映射类型它根据一个对象的属性是否被设置为字面意义上的返回或学习第八章类提供了对中引入的关键词的完全支持与其他的语言一样增加了类型注释和其他语法允许你表达类和其他类型之间的关系类成员这里有一个最基本的类一个空的类这个类还不是很有用所以我们开始添加一些成员类属性在一个类上声明字段创建一个公共的可写属性映射类型是一种泛型类型它使用通常通过创建的联合来迭代键来创建类型与其他位置一样类型注解是可选的但如果不指定将是一个隐含的类型字段也可以有初始化器这些初始化器将在类被实例化时自动运行就像和一样一个类属性的初始化器将被用来推断其类型设置控制是否需要在构造函数中初始化类字段请注意该字段需要在构造函数本身中初始化不会分析你从构造函数中调用的方法来检测初始化因为派生类可能会覆盖这些方法而无法初始化成员如果你打算通过构造函数以外的方式来确定初始化一个字段例如也许一个外部库为你填充了你的类的一部分你可以使用确定的赋值断言操作符没有初始化但没报错字段的前缀可以是修饰符这可以防止在构造函数之外对该字段进行赋值构造器类构造函数与函数非常相似你可以添加带有类型注释的参数默认值和重载带默认值的正常签名重载类的构造函数签名和函数签名之间只有一些区别构造函数不能有类型参数这属于外层类的声明我们将在后面学习构造函数不能有返回类型注释类的实例类型总是被返回的调用就像在中一样如果你有一个基类在使用任何成员之前你需要在构造器主体中调用在中打印一个错误的值在中抛出异常在中忘记调用是一个很容易犯的错误但会在必要时告诉你方法一个类上的函数属性被称为方法方法可以使用与函数和构造函数相同的所有类型注释除了标准的类型注解并没有为方法添加其他新的东西请注意在一个方法体中仍然必须通过访问字段和其他方法方法体中的非限定名称将总是指代包围范围内的东西这是在试图修改第行的而不是类属性类也可以有访问器请注意一个没有额外逻辑的字段支持的对在中很少有用如果你不需要在操作中添加额外的逻辑暴露公共字段也是可以的对访问器有一些特殊的推理规则如果存在但没有则该属性自动是只读的如果没有指定参数的类型它将从的返回类型中推断出来访问器和设置器必须有相同的成员可见性从开始可以有不同类型的访问器用于获取和设置不允许等索引签名类可以声明索引签名这些签名的作用与其他对象类型的索引签名相同因为索引签名类型需要同时捕获方法的类型所以要有用地使用这些类型并不容易一般来说最好将索引数据存储在另一个地方而不是在类实例本身类继承像其他具有面向对象特性的语言一样中的类可以继承自基类子句你可以使用一个子句来检查一个类是否满足了一个特定的接口如果一个类不能正确地实现它就会发出一个错误类也可以实现多个接口例如注意事项重要的是要明白子句只是检查类是否可以被当作接口类型来对待它根本不会改变类的类型或方法一个常见的错误来源于是认为子句会改变类的类型实际上它不会注意这里没有错误在这个例子中我们也许期望的类型会受到的参数的影响事实并非如此实现子句并没有改变类主体的检查方式或其类型的推断同样地实现一个带有可选属性的接口并不能创建该属性子句类可以从基类中扩展出来派生类拥有其基类的所有属性和方法也可以定义额外的成员基类的类方法派生的类方法重写方法遵守基类契约派生类也可以覆盖基类的一个字段或属性你可以使用语法来访问基类方法注意因为类是一个简单的查找对象没有超级字段的概念强制要求派生类总是其基类的一个子类型例如这里有一个合法的方法来覆盖一个方法派生类遵循其基类契约是很重要的请记住通过基类引用来引用派生类实例是非常常见的而且总是合法的通过基类引用对派生实例进行取别名没问题如果没有遵守的约定怎么办使这个参数成为必需的如果我们不顾错误编译这段代码这个样本就会崩溃崩溃因为名称将是初始化顺序在某些情况下类的初始化顺序可能会令人惊讶让我们考虑一下这段代码打印而不是这里发生了什么按照的定义类初始化的顺序是基类的字段被初始化基类构造函数运行派生类的字段被初始化派生类构造函数运行这意味着基类构造函数在自己的构造函数中看到了自己的值因为派生类的字段初始化还没有运行继承内置类型注意如果你不打算继承等内置类型或者你的编译目标明确设置为或以上你可以跳过本节在中返回对象的构造函数隐含地替代了的任何调用者的的值生成的构造函数代码有必要捕获的任何潜在返回值并将其替换为因此子类化等可能不再像预期那样工作这是由于等的构造函数使用的来调整原型链然而在中调用构造函数时没有办法确保的值其他的下级编译器一般默认有同样的限制对于一个像下面这样的子类你可能会发现方法在构造这些子类所返回的对象上可能是未定义的所以调用会导致错误将在子类的实例和它们的实例之间被打破所以将返回作为建议你可以在任何调用后立即手动调整原型明确地设置原型然而的任何子类也必须手动设置原型对于不支持的运行时你可以使用来代替不幸的是这些变通方法在和更早的版本上不起作用我们可以手动将原型中的方法复制到实例本身例如到但是原型链本身不能被修复成员的可见性你可以使用来控制某些方法或属性对类外的代码是否可见类成员的默认可见性是公共的一个公共成员可以在任何地方被访问因为已经是默认的可见性修饰符所以你永远不需要在类成员上写它但为了风格可读性的原因可能会选择这样做受保护的成员只对它们所声明的类的子类可见在此可以访问受保护的成员没有问题无权访问受保护成员的暴露派生类需要遵循它们的基类契约但可以选择公开具有更多能力的基类的子类型这包括将受保护的成员变成公开没有修饰符所以默认为公共和一样但不允许从子类中访问该成员不能从类外访问不能在子类中访问属性为私有属性只能在类因为私有成员对派生类是不可见的所以派生类不能增加其可见性跨实例的私有访问不同的语言对同一个类的不同实例是否可以访问对方的私有成员有不同的处理方法虽然像和等语言允许这样做但不允许确实允许跨实例的私有访问可以访问注意事项像类型系统的其他方面一样和只在类型检查中被强制执行这意味着的运行时解构如或简单的属性查询仍然可以访问一个私有或保护的成员在环境中将打印也允许在类型检查时使用括号符号进行访问这使得私有声明的字段可能更容易被单元测试之类的东西所访问缺点是这些字段是软性私有的不能严格执行私有特性在类型检查期间不允许正确与的不同的字段在编译后仍然是的并且不提供前面提到的像括号符号访问那样的转义窗口使其成为硬当编译到或更少时将使用来代替如果你需要保护你的类中的值免受恶意行为的影响你应该使用提供硬运行时隐私的机制如闭包或私有字段请注意这些在运行时增加的隐私检查可能会影响性能静态成员类可以有静态成员这些成员并不与类的特定实例相关联它们可以通过类的构造函数对象本身来访问静态成员也可以使用相同的和可见性修饰符静态成员也会被继承特殊静态名称一般来说从函数原型覆盖属性是不安全的不可能的因为类本身就是可以用调用的函数所以某些静态名称不能使用像和这样的函数属性定义为静态成员是无效的为什么没有静态类和没有像和那样有一个叫做静态类的结构这些结构体的存在只是因为这些语言强制所有的数据和函数都在一个类里面因为这个限制在中不存在所以不需要它们一个只有一个实例的类在中通常只是表示为一个普通的对象例如我们不需要中的静态类语法因为一个普通的对象甚至是顶级函数也可以完成这个工作不需要首选备选首选备选类里的区块静态块允许你写一串有自己作用域的语句可以访问包含类中的私有字段这意味着我们可以用写语句的所有能力来写初始化代码不泄露变量并能完全访问我们类的内部结构泛型类类和接口一样可以是泛型的当一个泛型类用实例化时其类型参数的推断方式与函数调用的方式相同类可以像接口一样使用通用约束和默认值静态成员中的类型参数这段代码事不合法的可能不太明显为什么呢静态成员不能引用类的类型参数请记住类型总是被完全擦除的在运行时只有一个属性这意味着设置如果有可能的话也会改变这可不是什么好事一个泛型类的静态成员永远不能引用该类的类型参数类运行时的重要的是要记住并没有改变的运行时行为而的运行时行为偶尔很奇特比如对这一点的处理确实是不寻常的输出而不是长话短说默认情况下函数内的值取决于函数的调用方式在这个例子中因为函数是通过引用调用的所以它的值是而不是类实例这很少是你希望发生的事情提供了一些方法来减轻或防止这种错误箭头函数如果你有一个经常会被调用的函数失去了它的上下文那么使用一个箭头函数而不是方法定义是有意义的输出这有一些权衡值保证在运行时是正确的即使是没有经过检查的代码也是如此这将使用更多的内存因为每个类实例将有它自己的副本每个函数都是这样定义的你不能在派生类中使用因为在原型链中没有入口可以获取基类方法参数在方法或函数定义中一个名为的初始参数在中具有特殊的意义这些参数在编译过程中会被删除带有参数的输入编译后的结果检查调用带有参数的函数是否在正确的上下文中进行我们可以不使用箭头函数而是在方法定义中添加一个参数以静态地确保方法被正确调用正确错误这种方法做出了与箭头函数方法相反的取舍调用者仍然可能在不知不觉中错误地使用类方法每个类定义只有一个函数被分配而不是每个类实例一个函数基类方法定义仍然可以通过调用类型在类中一个叫做的特殊类型动态地指向当前类的类型让我们来看看这有什么用在这里推断出的返回类型是而不是现在让我们做一个的子类你也可以在参数类型注释中使用这与其他写法不同如果你有一个派生类它的方法现在只接受该同一派生类的其他实例报错类型中缺少属性但类型中需要该属性基于类型守卫的不太会你可以在类和接口的方法的返回位置使用当与类型缩小混合时例如语句目标对象的类型将被缩小到指定的基于的类型保护的一个常见用例是允许对一个特定字段进行懒惰验证例如这种情况下当被验证为真时就会从框内持有的值中删除一个未定义值参数属性构造函数参数转类属性提供了特殊的语法可以将构造函数参数变成具有相同名称和值的类属性这些被称为参数属性通过在构造函数参数前加上可见性修饰符或中的一个来创建由此产生的字段会得到这些修饰符类表达式类表达式与类声明非常相似唯一真正的区别是类表达式不需要一个名字尽管我们可以通过它们最终绑定的任何标识符来引用它们抽象类和成员中的类方法和字段可以是抽象的一个抽象的方法或抽象的字段是一个没有提供实现的方法或字段这些成员必须存在于一个抽象类中不能直接实例化抽象类的作用是作为子类的基类实现所有的抽象成员当一个类没有任何抽象成员时我们就说它是具体的让我们看一个例子我们不能用来实例化因为它是抽象的相反我们需要创建一个派生类并实现抽象成员抽象构造签名有时你想接受一些类的构造函数产生一个从某些抽象类派生出来的类的实例例如你可能想写这样的代码正确地告诉你你正试图实例化一个抽象类毕竟鉴于的定义写这段代码是完全合法的它最终会构造一个抽象类槽糕相反你想写一个函数接受具有结构化签名的东西现在正确地告诉你哪些类的构造函数可以被调用可以因为它是具体的但不能类之间的关系在大多数情况下中的类在结构上与其他类型相同是可以比较的例如这两个类可以互相替代使用因为它们是相同的正确同样地即使没有明确的继承类之间的子类型关系也是存在的正确这听起来很简单但有几种情况似乎比其他情况更奇怪空的类没有成员在一个结构化类型系统中一个没有成员的类型通常是其他任何东西的超类型所以如果你写了一个空类不要任何东西都可以用来代替它不能用做任何事以下调用均可学习第九章模块有很长的历史有不同的方式来处理模块化的代码从年开始出现已经实现了对许多这些格式的支持但随着时间的推移社区和规范已经趋向于一种名为模块或模块的格式你可能知道它是语法在年被加入到规范中到年在大多数网络浏览器和运行时中都有广泛的支持为了突出重点本手册将涵盖及其流行的前驱语法如何定义模块在中就像在中一样任何包含顶级或的文件都被认为是一个模块相反一个没有任何顶级导入或导出声明的文件被视为一个脚本其内容可在全局范围内使用因此也可用于模块模块在自己的范围内执行而不是在全局范围内这意味着在模块中声明的变量函数类等在模块外是不可见的除非它们被明确地用某种导出形式导出相反要使用从不同模块导出的变量函数类接口等必须使用导入的形式将其导入非模块在我们开始之前重要的是要了解认为什么才是模块规范声明任何没有或顶层的文件都应该被认为是一个脚本而不是一个模块顶层该特性可以让模块对外表现为一个函数允许模块去数据并阻塞其它导入这些数据的模块只有在数据确定并准备好的时候导入数据的模块才可以执行相应的代码在一个脚本文件中变量和类型被声明为在共享的全局范围内并且假定你会使用编译器选项将多个输入文件加入一个输出文件或者在你的中使用多个标签来加载这些文件顺序正确如果你有一个目前没有任何导入或导出的文件但你希望被当作一个模块来处理请添加这一行这将改变该文件使其成为一个什么都不输出的模块无论你的模块目标是什么这个语法都有效中的模块在中编写基于模块的代码时有三个主要方面需要考虑语法我想用什么语法来导入和导出东西模块解析模块名称或路径和磁盘上的文件之间是什么关系模块输出目标我编译出来的模块应该是什么样子的模块语法一个文件可以通过声明一个主要出口然后通过以下方式导入除了默认的导出你还可以通过省略的实现有一个以上的变量和函数的导出这些可以通过语法在另一个文件中使用额外的导入语法可以使用这样的格式来重命名一个导入你可以将上述语法混合并匹配到一个单一的中你可以把所有导出的对象用把它们放到一个命名空间你可以通过导入一个文件而不把任何变量纳入你的当前模块在这种情况下没有任何作用然而中的所有代码都被解析了这可能引发影响其他对象的副作用特定的模块语法类型可以使用与值相同的语法进行导出和导入用两个概念扩展了语法用于声明一个类型的导入这是一个导入语句只能导入类型内联类型导入还允许以为前缀的单个导入以表明导入的引用是一个类型模块语法与行为有语法它直接与和的相关联使用的在大多数情况下与这些环境的相同但这种语法确保你在文件中与的输出有对的匹配语法是上大多数模块的交付格式即使你使用上面的模块语法进行编写对语法的工作方式有一个简单的了解也会帮助你更容易地进行调试导出标识符是通过在一个全局调用的上设置属性来导出的然后这些文件可以通过语句导入或者你可以使用中的析构功能来简化一下和模块的互操作性关于默认导入和模块命名空间对象导入之间的区别和之间存在着功能上的不匹配这个后面章节会详细介绍的模块解析选项模块解析是指从或语句中获取一个字符串并确定该字符串所指的文件的过程包括两种解析策略经典和当编译器选项不是时经典策略是默认的是为了向后兼容策略复制了在模式下的工作方式对和有额外的检查在中有许多标志影响模块策略关于这些策略如何工作的全部细节你可以参考模块解析的模块输出选项有两个选项会影响输出它决定了哪些功能被降级转换为在旧的运行时运行哪些保持不变它决定了哪些代码用于模块之间的相互作用你使用的是由你期望运行代码的运行时中的可用功能决定的这可能是你支持的最古老的网络浏览器你期望运行的最低版本的或者可能来自于你的运行时的独特约束比如所有模块之间的通信都是通过模块加载器进行的编译器选项决定使用哪一个在运行时模块加载器负责在执行一个模块之前定位和执行该模块的所有依赖项例如这里是一个使用模块语法的文件展示了的一些不同选项请注意实际上与原来的相同你可以在模块参考中看到所有可用的选项以及它们发出的代码是什么样子命名空间有自己的模块格式称为命名空间这比模块标准要早这种语法对于创建复杂的定义文件有很多有用的功能并且在中仍然被积极使用虽然没有被废弃但命名空间中的大部分功能都存在于中我们建议你使用它来与的方向保持一致你可以在参考页中了解更多关于命名空间的信息',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-05 19:32:54',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://mydocs.guoyaxue.top/" title="旧版博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="旧版博客"/><span class="back-menu-item-text">旧版博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://pan.xiaou61.top/#/" title="免费网盘"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="免费网盘"/><span class="back-menu-item-text">免费网盘</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://cloud.xiaou61.top/" title="云盘(自用)"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="云盘(自用)"/><span class="back-menu-item-text">云盘(自用)</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://wpzc.xiaou61.top/" title="云盘转存"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="云盘转存"/><span class="back-menu-item-text">云盘转存</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://love.xiaou61.top/#/" title="关于我们(My girlFriend)"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="关于我们(My girlFriend)"/><span class="back-menu-item-text">关于我们(My girlFriend)</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">娱乐项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://fxq.xiaou61.top/#/" title="飞行棋"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="飞行棋"/><span class="back-menu-item-text">飞行棋</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/game/sqnwmai803/" title="谁去拿外卖"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="谁去拿外卖"/><span class="back-menu-item-text">谁去拿外卖</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/desktop.html" title="win12网页版"><img class="back-menu-item-icon" src="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/icon/logo.svg" alt="win12网页版"/><span class="back-menu-item-text">win12网页版</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://game.xiaou61.top/" title="在线游戏"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="在线游戏"/><span class="back-menu-item-text">在线游戏</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">小u的博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 开往</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><span> 开往</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>3</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JVM/" style="font-size: 1.05rem;">JVM<sup>22</sup></a><a href="/tags/Nginx/" style="font-size: 1.05rem;">Nginx<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>1</sup></a><a href="/tags/Ts/" style="font-size: 1.05rem;">Ts<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size: 1.05rem;">TypeScript<sup>1</sup></a><a href="/tags/WebApi/" style="font-size: 1.05rem;">WebApi<sup>1</sup></a><a href="/tags/coder1v5/" style="font-size: 1.05rem;">coder1v5<sup>2</sup></a><a href="/tags/css/" style="font-size: 1.05rem;">css<sup>3</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>12</sup></a><a href="/tags/javaSE/" style="font-size: 1.05rem;">javaSE<sup>3</sup></a><a href="/tags/javaWeb/" style="font-size: 1.05rem;">javaWeb<sup>2</sup></a><a href="/tags/js%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">js逆向<sup>1</sup></a><a href="/tags/leetcode/" style="font-size: 1.05rem;">leetcode<sup>3</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>8</sup></a><a href="/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/" style="font-size: 1.05rem;">书籍推荐<sup>2</sup></a><a href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%90%AC%E8%BF%90/" style="font-size: 1.05rem;">公众号搬运<sup>35</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 1.05rem;">前端<sup>10</sup></a><a href="/tags/%E5%8A%9E%E5%85%AC/" style="font-size: 1.05rem;">办公<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 1.05rem;">后端<sup>8</sup></a><a href="/tags/%E5%A4%A9%E6%B6%AF%E8%AE%BA%E5%9D%9B/" style="font-size: 1.05rem;">天涯论坛<sup>1</sup></a><a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 1.05rem;">导航<sup>1</sup></a><a href="/tags/%E5%B0%B1%E4%B8%9A/" style="font-size: 1.05rem;">就业<sup>16</sup></a><a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 1.05rem;">微信<sup>1</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/" style="font-size: 1.05rem;">技术杂谈<sup>51</sup></a><a href="/tags/%E6%8E%98%E9%87%91/" style="font-size: 1.05rem;">掘金<sup>14</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 1.05rem;">杂项<sup>1</sup></a><a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 1.05rem;">测试<sup>1</sup></a><a href="/tags/%E6%B8%A1%E4%B8%80%E5%A4%A7%E5%B8%88%E8%AF%BE/" style="font-size: 1.05rem;">渡一大师课<sup>3</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 1.05rem;">爬虫<sup>1</sup></a><a href="/tags/%E7%9B%AE%E5%BD%95/" style="font-size: 1.05rem;">目录<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>4</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 1.05rem;">虚拟机<sup>12</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>6</sup></a><a href="/tags/%E8%B7%AF%E9%A3%9E%E5%AD%A6%E9%99%A2/" style="font-size: 1.05rem;">路飞学院<sup>3</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">面向对象<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>51</sup></a><a href="/tags/%E9%A3%9E%E8%A1%8C%E6%A3%8B/" style="font-size: 1.05rem;">飞行棋<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">234</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">September 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">May 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Ts/" itemprop="url">Ts</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/Ts/%E5%89%8D%E7%AB%AF/" itemprop="url">前端</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>前端</span></a><a class="article-meta__tags" href="/tags/Ts/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Ts</span></a></span></div></div><h1 class="post-title" itemprop="name headline">一文搞懂TypeScript</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-09-30T23:34:06.258Z" title="Created 2023-10-01 07:34:06">2023-10-01</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-08-05T11:32:54.485Z" title="Updated 2023-08-05 19:32:54">2023-08-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为邯郸"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>邯郸</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2023/10/01/codenotes/front_end/ts/"><header><a class="post-meta-categories" href="/categories/Ts/" itemprop="url">Ts</a><a class="post-meta-categories" href="/categories/Ts/%E5%89%8D%E7%AB%AF/" itemprop="url">前端</a><a href="/tags/%E5%89%8D%E7%AB%AF/" tabindex="-1" itemprop="url">前端</a><a href="/tags/Ts/" tabindex="-1" itemprop="url">Ts</a><h1 id="CrawlerTitle" itemprop="name headline">一文搞懂TypeScript</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小u</span><time itemprop="dateCreated datePublished" datetime="2023-09-30T23:34:06.258Z" title="Created 2023-10-01 07:34:06">2023-10-01</time><time itemprop="dateCreated datePublished" datetime="2023-08-05T11:32:54.485Z" title="Updated 2023-08-05 19:32:54">2023-08-05</time></header><h2 id="TypeScript学习第一章-TypeScript初识"><a href="#TypeScript学习第一章-TypeScript初识" class="headerlink" title="TypeScript学习第一章:TypeScript初识"></a>TypeScript学习第一章:TypeScript初识</h2><h3 id="1-1-TypeScript学习初见"><a href="#1-1-TypeScript学习初见" class="headerlink" title="1.1 TypeScript学习初见"></a>1.1 TypeScript学习初见</h3><p><strong>TypeScript</strong>(TS)是由微软Microsoft由2012年推出的<strong>自由</strong>和开源的编程语言, 目前主流的三大框架React 、Vue 和 Angular这三大主流框架再加上最新的鸿蒙3.0都可以用TS进行开发.</p>
<p>可以说 TS 是 JS 的<strong>超集</strong>, 是建立在JavaScript上的语言. TypeScript把其他语言的一些精妙的语法, 带入到JavaScript中, 让JS达到了一个新的高度。</p>
<p>可以在TS中使用JS以外的扩展语法, 同时可以结局TS对面向对象和静态类型的良好支持, 可以让我们编写更健壮、更可维护的<strong>大型项目</strong>。</p>
<h3 id="1-2-TypeScript介绍"><a href="#1-2-TypeScript介绍" class="headerlink" title="1.2 TypeScript介绍"></a>1.2 TypeScript介绍</h3><p>因为TypeScript是JavaScript的超集, 所以要介绍TS, 不得不提一下JS, JS从在引入编程社区20多年以来, 已经成了有史以来应用最广泛的跨平台语言之一了, 从一开始为网页中添加一些微不足道的、交互性的小型的脚本语言发展到现在各种规模的前端和后端应用程序的首选语言了.</p>
<p>虽然我们用JS语言编写程序的大小、范围和复杂性呈指数级的增长, 但是<strong>JS语言表达不同代码单元之间的关系和能力却很弱</strong>, 使得JS成了一项难以大规模管理的任务, 而且也很难解决程序员经常出现的错误: <strong>类型错误</strong>.</p>
<p>而TS语言可以很好的解决这个错误, 他的目标是成为JS程序的<strong>静态类型检查器</strong>, 可以在代码运行之前进行检查, 也就是静态编译, 并且呢, 可以确保我们程序的类型正确(即进行类型检查).</p>
<p>TS添加了<strong>可选的静态类型</strong>和<strong>基于类的面向对象编程</strong>等等, 是JS的语言扩展, 不是JS的替代品, 会让JS前进的步伐更坚实、更遥远.</p>
<h3 id="1-3-JS-、TS-和-ES之间的关系"><a href="#1-3-JS-、TS-和-ES之间的关系" class="headerlink" title="1.3 JS 、TS 和 ES之间的关系"></a>1.3 JS 、TS 和 ES之间的关系</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927536.png" alt="image-20220305193623661"></p>
<p><strong>ES6</strong>又称为<strong>ECMAScript 2015</strong>, TypeScript 是 JS 的超集, 他包含Javascript的所有元素, 能运行Javascript代码, 并扩展了JS语法, 并添加了<strong>静态类型</strong> <strong>类</strong> <strong>模块</strong> <strong>接口</strong> <strong>类型注解</strong>等等方面的功能, 更加易于<strong>大项目</strong>的开发.</p>
<p>这张图表示TS不仅包含了JS和ES的最新内容, 还扩展了新的功能.</p>
<p>总的来说, ECMAScript是JS的标准, TS是JS的超集.</p>
<h3 id="1-4-TS的竞争者有哪些"><a href="#1-4-TS的竞争者有哪些" class="headerlink" title="1.4 TS的竞争者有哪些?"></a>1.4 TS的竞争者有哪些?</h3><h4 id="1-ESLint"><a href="#1-ESLint" class="headerlink" title="1. ESLint"></a>1. ESLint</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927596.png" alt="image-20220305195615323"></p>
<h4 id="2-TSlint"><a href="#2-TSlint" class="headerlink" title="2. TSlint"></a>2. TSlint</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927724.png" alt="image-20220305201315681"></p>
<p>1 和 2 都是和TypeScript一样来突出代码中可能出现的错误, 至少i没有为检查过程添加新的语法, 但是这两者都不打算最为IDE集成的工具来运行, 这两个的存在可以是TS做更少的检查, 但是这些检查并不适合于所有的代码库。</p>
<h4 id="3-CoffeeScript"><a href="#3-CoffeeScript" class="headerlink" title="3. CoffeeScript"></a>3. CoffeeScript</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927791.png" alt="image-20220305204137006"></p>
<p>CoffeeScript是想改进JS语言, 但是现在用的人少了, 因为他又成为了JS的标准, 属于是打不过JS了。</p>
<h4 id="4-Flow"><a href="#4-Flow" class="headerlink" title="4.Flow"></a>4.Flow</h4><p>Vue2的源码的类型检查工具就是flow, 不过Vue3已经开始使用TS做类型检查了.</p>
<p>Flow更悲观的判断类型, 而TS更加乐观.</p>
<p>Flow是为了维护Facebook的代码库而建立的, 而TS是作为一种独立的语言而建立的, 其内部有独立的环境, 可以自由<strong>专注于工具的开发</strong>和<strong>整个生态系统的维护</strong></p>
<h2 id="TypeScript学习第二章-为什么使用TypeScript"><a href="#TypeScript学习第二章-为什么使用TypeScript" class="headerlink" title="TypeScript学习第二章:为什么使用TypeScript?"></a>TypeScript学习第二章:为什么使用TypeScript?</h2><h3 id="2-1-发现问题"><a href="#2-1-发现问题" class="headerlink" title="2.1 发现问题"></a>2.1 发现问题</h3><p>JS中每个值都有一组行为, 我们可以通过运行不同的操作来观察:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 &#x27;message&#x27; 上访问属性方法 &#x27;toLowerCase&#x27;, 并调用它</span></span><br><span class="line">message.<span class="title function_">toLowerCase</span>();</span><br><span class="line"><span class="comment">// 调用 &#x27;message&#x27;</span></span><br><span class="line"><span class="title function_">message</span>();</span><br></pre></td></tr></table></figure>

<p>我们尝试直接调用message, 但是假设我们不知道message, 我们就无法可靠的说出尝试运行任何的这些代码会得到什么结果, 每个操作的结果完全取决于我们最初给message的赋值. 我们编译代码的时候<strong>真的可以调用message()么</strong>, 也<strong>不一定有toLowerCase()这个方法</strong>, 而且也<strong>不知道他们的返回值是什么.</strong></p>
<p>通常我们在编写js的时候需要对上面所述的细节牢记在心, 才能编写正确的代码。</p>
<p>假设我们知道了message 是什么，如下所示，但是第三行就会报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line">message.<span class="title function_">toLowerCase</span>(); <span class="comment">// 输出hello world</span></span><br><span class="line"><span class="title function_">message</span>(); <span class="comment">// TypeError: message is not a function</span></span><br></pre></td></tr></table></figure>

<p>如果我们能避免这样的错误, 就完美了, 当我们运行我们的代码的时候, 选择做什么的方式, 是通过确定值的类型, 来确定他具有什么样的行为和功能的, <code>TypeError</code> 就暗指字符串是不能作为函数来调用的. 对于某些值, 比如<code>string</code>和<code>number</code>, 我们可以使用typeof来识别他们的类型.</p>
<p>但是对于像函数之类的其他的东西, 没有相应的运行时机制, 比如下面的代码, 运行是有条件的, 也就是说这个x是必须具有flip这个方法的, js只能在运行一下代码时才能知道这个x是提供了什么的, 我们如果能够使用静态类型系统, 在运行代码之前预测预期的代码,问题就解决了.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> x.<span class="title function_">flip</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-静态类型检查"><a href="#2-2-静态类型检查" class="headerlink" title="2.2 静态类型检查"></a>2.2 静态类型检查</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> message = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="title function_">message</span>() <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<p>上述这段代码会引起TypeError, 理想的情况下, 我们希望有一个工具可以在我们代码运行之前发现这些错误, TS就可以实现这些功能. 静态类型系统就描述了当前我们运行程序的时候, 值得形状和行为, 像TS这样的类型检查器, 会告诉我们什么时候代码会出现问题.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927902.png" alt="image-20220306105518308"></p>
<h3 id="2-3-非异常故障"><a href="#2-3-非异常故障" class="headerlink" title="2.3 非异常故障"></a>2.3 非异常故障</h3><p>JS 在运行的时候会告诉我们他认为某些东西是没有意义的情况, 因为ECMA规范明确说明了JS在遇到某些意外情况下应该是如何表现得, 比如如下代码:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&quot;小千&quot;</span>,</span><br><span class="line">	<span class="attr">age</span>:<span class="number">26</span>,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">user.<span class="property">location</span>; <span class="comment">// 返回undefined, 理应报错, 因为根本没有location这个属性</span></span><br></pre></td></tr></table></figure>

<p>但是静态类型系统要求必须对调用哪些代码做系统的标记, 如果是在TS运行这段代码, 就会出现location未定义的错误, 如下图所示:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927141.png" alt="image-20220306112014184"></p>
<p>TS可以在开发过程中捕获很多类似于合法的错误, 比如说错别字, 未调用函数, 基本的逻辑错误等等:</p>
<p><strong>拼写错误</strong>: 属性toLocaeleLowerCase在String类型中不存在, 你找的是否是toLocaleLowerCase属性?</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2022.cnblogs.com/blog/2550942/202204/2550942-20220403120412179-1118863773.png" alt="image-20220306112736191"></p>
<p><strong>未调用的函数检查</strong>: 运算符号 &lt; 不能用在一个 ‘() &#x3D;&gt; number’ 和 number数字之间.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2022.cnblogs.com/blog/2550942/202204/2550942-20220403120411975-1644199148.png" alt="image-20220306113634410"></p>
<p><strong>逻辑问题</strong>: value !&#x3D;&#x3D; ‘a’ 和 value &#x3D;&#x3D;&#x3D; ‘b’逻辑重叠.</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2022.cnblogs.com/blog/2550942/202204/2550942-20220403120411713-788652177.png" alt="image-20220306114014604"></p>
<h3 id="2-4-使用工具"><a href="#2-4-使用工具" class="headerlink" title="2.4 使用工具"></a>2.4 使用工具</h3><ol>
<li>安装VSCode</li>
<li>安装Node.js:使用命令 <code>node -v</code>来检查nodejs版本</li>
<li>安装TypeScript编译器: <code>npm i typescript -g</code></li>
</ol>
<p>然后我们要编译我们的TS, 因为TS是不能直接运行的, 我们必须把他编译成JS.</p>
<blockquote>
<p>在终端中使用cls 或者 clear命令可以清屏</p>
</blockquote>
<p>可以使用tsc命令来转换TS 成 JS: 例如 <code>tsc hello.ts</code>, 就会生成对应的JS文件.</p>
<p>hello.ts:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 你好, 世界</span></span><br><span class="line"><span class="comment">// console.log(&#x27;Hello World&#x27;)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 会出现函数实现重复的错误</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">person, date</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Helo <span class="subst">$&#123;person&#125;</span>, today is <span class="subst">$&#123;date&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&#x27;xiaoqian&#x27;</span>,<span class="string">&#x27;2021/12/04&#x27;</span>)</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>会出现函数实现重复的错误是因为hello.js也有这个greet的函数, 这是跟我们编译环境是矛盾的, 而且还需要我们重新编译ts, 所以我们需要进行优化编译过程.</p>
<h3 id="2-5-优化编译"><a href="#2-5-优化编译" class="headerlink" title="2.5 优化编译"></a>2.5 优化编译</h3><ol>
<li>解决TS和JS冲突问题 <code>tsc --init ## 生成配置文件</code></li>
<li>自动编译 <code>tsc --watch</code></li>
<li>发出错误 <code>tsc --noEmitOnError hello.ts</code></li>
</ol>
<p>TS文件编译成JS文件以后, 当出现函数名或者是变量名相同的时候, 会给我们提示重复定义的问题,可以通过<code>tsc --init</code>来生成一个配置文件来解决冲突问题. 先把严格模式strict关闭, 可解决未指定变量类型的问题.</p>
<p>当我们修改TS文件的时候, 我们需要重新的执行编译, 才能拿到最新的结果我们需要自动编译, 可以通过<code>tsc --watch</code> 来解决自动编译的问题.</p>
<p>当我们编译完之后, JS还是能正常运行的, 我们可以加一个noEmitOnError的参数来解决, 这样的话如果我们在TS中出现错误就可以让TS不编译成JS文件了.</p>
<p>最终的命令行指令是这样的:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc <span class="attr">--watch</span> <span class="attr">--noEmitOnError</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-显式类型"><a href="#2-6-显式类型" class="headerlink" title="2.6 显式类型"></a>2.6 显式类型</h3><p>刚才我们在tsconfig.json里把strict模式关闭了, 如果我们打开, 就会出现未指定变量类型的错误, 如果要解决这个问题, 我们就需要指定显式类型:</p>
<p>什么叫显式类型呢, 就是手工的给变量定义类型, 语法如下:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">person: <span class="built_in">string</span>, date: <span class="built_in">Date</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Helo <span class="subst">$&#123;person&#125;</span>, today is <span class="subst">$&#123;date.toDateString()&#125;</span>.`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在TS中, 也不是必须指定变量的数据类型, TS会根据你的变量自动推断数据类型, 如果推断不出来就会报错.</p>
<h3 id="2-7-降级编译"><a href="#2-7-降级编译" class="headerlink" title="2.7 降级编译"></a>2.7 降级编译</h3><p>我们可以在tsconfig.json 就修改target来更改TS编译目标的代码版本.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		......</span><br><span class="line">		<span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> &#x27;es5&#x27;<span class="punctuation">,</span></span><br><span class="line">		......</span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>默认为es2016, 即es7, 建议以默认值就可以, 目前的浏览器都能兼容</p>
<h3 id="2-8-严格模式"><a href="#2-8-严格模式" class="headerlink" title="2.8 严格模式"></a>2.8 严格模式</h3><p>不同的用户使用TS在类型检查中希望检查的严格程度是不同的, 有的人喜欢更宽松的验证体验, 从而仅仅验证程序的某些部分, 并且仍然拥有不错的工具.</p>
<p>默认情况下:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		......<span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">/* 严格模式: 启用所有严格的类型检查选项。*/</span> </span><br><span class="line">		<span class="attr">&quot;noImplicitAny&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">/* 为隐含的&#x27;any&#x27;类型的表达式和声明启用错误报告。*/</span></span><br><span class="line">		<span class="attr">&quot;strictNullChecks&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">/* 当类型检查时，要考虑&#x27;null&#x27;和&#x27;undefined&#x27; */</span></span><br><span class="line">		......</span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>一般来说使用TS就是追求的强立即验证, 这些静态检查设置的越严格, 越可能需要更多额外的编程工作, 但是从长远来说是值得的, 它会使代码更加容易维护. 如果可以我们应该始终打开这些类型检查.</p>
<p>启用strictNullChecks可以拦截null 和undefined 的错误, 启用noImplicitAny可以拦截any的错误, 启用strict可以拦截所有的严格类型检查选项, 包括前面两个的.</p>
<p>所以结论就是只需要开启”strict”为true即可, 当我们遇到</p>
<h2 id="TypeScript学习第三章-常用类型"><a href="#TypeScript学习第三章-常用类型" class="headerlink" title="TypeScript学习第三章: 常用类型"></a>TypeScript学习第三章: 常用类型</h2><h3 id="3-1-基元类型string-number-和-boolean"><a href="#3-1-基元类型string-number-和-boolean" class="headerlink" title="3.1 基元类型string number 和 boolean"></a>3.1 基元类型string number 和 boolean</h3><ol>
<li>string: 字符串, 例子: ‘Hello’, ‘World’.</li>
<li>number: 数字, 例子: 42, -100.</li>
<li>boolean: 布尔, 例子: true, false.</li>
</ol>
<p>String Number Boolean 也是合法的, 在TS里专门指一些很少的, 出现在代码里的一些特殊的内置类型, 对于类型我们始终使用小写的string, number 和 boolean.</p>
<p>为了输出方便我们可以在tsconfig.json的rootDir里设置一个目录<code>&quot;./src&quot;</code>, 设置outDir为<code>&quot;./dist&quot;</code>.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">str</span>: <span class="built_in">string</span> = <span class="string">&#x27;hello typescript&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">num</span>: <span class="built_in">number</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">bool</span>: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-数组"><a href="#3-2-数组" class="headerlink" title="3.2 数组"></a>3.2 数组</h3><p>数组的定义方法有两种:</p>
<ol>
<li>type[]</li>
<li>Array</li>
</ol>
<p>Array这种方法又称为泛型, 其中type是任意合法的类型.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">arr</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span> ,<span class="number">8</span>]</span><br><span class="line"><span class="comment">// arr = [&#x27;a&#x27;]</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">arr2</span>: <span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr2 = []</span><br></pre></td></tr></table></figure>

<p>值得注意的是, 数组可以被赋值为空数组[], 但是不能被赋值为规定类型以外的数组值.</p>
<h3 id="3-3-any"><a href="#3-3-any" class="headerlink" title="3.3 any"></a>3.3 any</h3><p>如果<strong>不希望某个特定值导致类型检查错误</strong>, 就可以使用any.</p>
<p><strong>当一个值是any的时候, 可以访问它的任何属性, 将它分配给任何类型的值, 或者几乎任何其它语法上的东西都是合法的</strong>. 但是运行的时候该报错还是报错, 所以我们不应该经常使用他.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">obj</span>: <span class="built_in">any</span> = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// js调用时就会报错</span></span><br><span class="line"><span class="title function_">obj</span>()</span><br><span class="line">obj.<span class="property">bar</span> = <span class="number">100</span></span><br><span class="line">obj = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">n</span>: <span class="built_in">number</span> = obj</span><br></pre></td></tr></table></figure>

<h3 id="3-4-变量上的类型解释"><a href="#3-4-变量上的类型解释" class="headerlink" title="3.4 变量上的类型解释"></a>3.4 变量上的类型解释</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">myName</span>: <span class="built_in">string</span> = <span class="string">&quot;Felixlu&quot;</span></span><br></pre></td></tr></table></figure>

<p>采用(冒号:) + (类型string)的方式.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">my</span>: <span class="built_in">string</span> = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line"><span class="comment">// 如果不声明, 会自动推断</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">&quot;Bleak&quot;</span> <span class="comment">// 将myName推断成string</span></span><br><span class="line">myName = <span class="number">100</span> <span class="comment">// 报错, 不能将number分配给string.</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-函数"><a href="#3-5-函数" class="headerlink" title="3.5 函数"></a>3.5 函数</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span> (<span class="attr">name</span>: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello,&quot;</span> + name.<span class="title function_">toUpperCase</span>() + <span class="string">&quot;!!!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> greet2 = (<span class="attr">name</span>: <span class="built_in">string</span>): <span class="function"><span class="params">string</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;你好,&quot;</span> + name</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&quot;Bleak&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">greet2</span>(<span class="string">&quot;黯淡&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>第一个name: string是参数类型注释, 第二个: void是返回值类型注释.</p>
<p>一般来说不用定义返回值类型, 因为会自动推断.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&quot;xiaoqian&quot;</span>, <span class="string">&#x27;xiaoha&#x27;</span>, <span class="string">&#x27;xiaoxi&#x27;</span>]</span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">toUpperCase</span>());</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">toLowerCase</span>());  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>匿名函数</strong>与函数声明有点不同, 当一个函数出现在出现在TS可以确定它如何被调用的地方的时候, <strong>这个函数的参数会自动的指定类型</strong>.</p>
<h3 id="3-6-对象类型"><a href="#3-6-对象类型" class="headerlink" title="3.6 对象类型"></a>3.6 对象类型</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printCoord</span>(<span class="params">pt: &#123;x: <span class="built_in">number</span>; y: <span class="built_in">number</span>&#125;</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;坐标的x值是: &quot;</span> + pt.<span class="property">x</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;坐标的y值是: &quot;</span> + pt.<span class="property">y</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">printCoord</span>(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">7</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>对于参数类型注释是对象类型的, 对象中属性的分割可以用 <strong>分号;</strong> 或者 <strong>逗号,</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printName</span>(<span class="params">obj: &#123;first: <span class="built_in">string</span>, last?: <span class="built_in">string</span>&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(obj.<span class="property">last</span> === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;名字是:&quot;</span> + obj.<span class="property">first</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;名字是:&quot;</span> + obj.<span class="property">first</span> + obj.<span class="property">last</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">printName</span>(&#123;</span><br><span class="line">    <span class="attr">first</span>: <span class="string">&quot;Mr.&quot;</span>,</span><br><span class="line">    <span class="attr">last</span>: <span class="string">&quot;Bleak&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用?可以指定对象中某个参数可以选择传入或者不传入, 不传入其值就是undefined.</p>
<p>如何在函数体内确定某个带?的参数是否传参了呢?可以使用两种方法</p>
<ol>
<li><pre><code class="tsx">if(obj.last === undefined) &#123;// 未传入时的方法体
        
    &#125; else &#123;// 传入时的方法体
        
    &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```tsx</span><br><span class="line">   console.log(obj.last?.toUpperCase())</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>第二种方式更加优雅, 更推荐使用</p>
<h3 id="3-7-联合类型"><a href="#3-7-联合类型" class="headerlink" title="3.7 联合类型"></a>3.7 联合类型</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">id</span>: <span class="built_in">number</span> | <span class="built_in">string</span> </span><br></pre></td></tr></table></figure>

<p>TS的类型系统允许我们使用多种运算符, 从现有类型中构建新类型union.</p>
<p>联合类型是由两个或多个其他类型组成的类型. 表示可能是这些类型中的任何一种的值, 这些类型中的每一种被称为联合类型的成员.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params">id: <span class="built_in">number</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;当前Id为:&quot;</span> + id)</span><br><span class="line">    <span class="comment">// console.log(id.toUpperCase())</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">printId</span>(<span class="number">101</span>)</span><br><span class="line"><span class="title function_">printId</span>(<span class="string">&#x27;202&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果需要调用一些参数的属性或者方法, 可以使用JS携带的typeof函数来进行判断并分情况执行代码.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">welcomePeople</span>(<span class="params">x: <span class="built_in">string</span>[] | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(x)) &#123; <span class="comment">// Array.isArray(x)可以测试x是否是一个数组</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + x.<span class="title function_">join</span>(<span class="string">&#x27; and &#x27;</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Welcome lone traveler &quot;</span> + x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="title function_">welcomePeople</span>([<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>])</span><br><span class="line"><span class="title function_">welcomePeople</span>(<span class="string">&#x27;A&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>根据分支来进行操作的函数.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 共享的方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getFirstThree</span>(<span class="params">x: <span class="built_in">number</span>[] | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>都有的属性和方法, 可以直接使用.</p>
<h3 id="3-8-类型别名"><a href="#3-8-类型别名" class="headerlink" title="3.8 类型别名"></a>3.8 类型别名</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123;</span><br><span class="line">	<span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">	<span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125; <span class="comment">// 对象类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printCoord</span>(<span class="params">pt: Point</span>) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printCoord</span>(&#123;<span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">ID</span> = <span class="built_in">number</span> | <span class="built_in">string</span> <span class="comment">// 联合类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params">id: ID</span>) &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">printId</span>(<span class="number">100</span>)</span><br><span class="line"><span class="title function_">printId</span>(<span class="string">&#x27;2333&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UserInputSanitizedString</span> = <span class="built_in">string</span> <span class="comment">// 基元类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sanitizedString</span>(<span class="params">str: <span class="built_in">string</span></span>): <span class="title class_">UserInputSanitizedString</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> str.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> userInput = <span class="title function_">sanitizedString</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(userInput)</span><br></pre></td></tr></table></figure>

<p>type可以用来<strong>定义变量的类型</strong>, 如果是对象, 里面的属性和方法可以用逗号, 分号; 或直接不写来做间隔, 可以用来做一些平时经常会用到的类型来做复用, 其可以用于变量的类型指定上.</p>
<h3 id="3-9-接口"><a href="#3-9-接口" class="headerlink" title="3.9 接口"></a>3.9 接口</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">	<span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">	<span class="attr">y</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printCoord</span>(<span class="params">pt: Point</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;坐标x的值是: &quot;</span> + pt.<span class="property">x</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;坐标y的值是: &quot;</span> + pt.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printCoord</span>(&#123; <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">100</span> &#125;)</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>可以用接口来<strong>定义对象的类型</strong>, 几乎所有可以通过interface来定义的类型都可以用type来定义</p>
<p>类型别名type 和接口interface之间的区别:</p>
<ol>
<li>扩展接口: 通过extends</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bear</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">honey</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="attr">bear</span>: <span class="title class_">Bear</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;winie&#x27;</span>,</span><br><span class="line">    <span class="attr">honey</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bear.<span class="property">name</span>, bear.<span class="property">honey</span>)</span><br></pre></td></tr></table></figure>

<p>扩展类型别名: 通过 &amp;</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Animal</span>  = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bear</span> = <span class="title class_">Animal</span> &amp; &#123;</span><br><span class="line">    <span class="attr">honey</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="attr">bear</span>: <span class="title class_">Bear</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;winie&quot;</span>,</span><br><span class="line">    <span class="attr">honey</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>向现有的类型添加新字段</p>
<p>接口: 定义相同的接口, 其字段会合并.</p>
</li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyWindow</span> &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MyWindow</span> &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="attr">w</span>: <span class="title class_">MyWindow</span> = &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;hello ts&#x27;</span>,</span><br><span class="line">    <span class="attr">count</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型别名: 类型别名创建的类型创建后是不能添加新字段的</p>
<h3 id="3-10-类型断言-as"><a href="#3-10-类型断言-as" class="headerlink" title="3.10 类型断言 as"></a>3.10 类型断言 as</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myCanvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;main_canvas&quot;</span>)  <span class="comment">// 返回某种类型的HTMLElement</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 可以使用类型断言来指定</span></span><br><span class="line"><span class="keyword">const</span> myCanvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;main_canvas&quot;</span>) <span class="keyword">as</span> <span class="title class_">HTMLCanvasElement</span></span><br><span class="line"><span class="keyword">const</span> myCanvas = &lt;<span class="title class_">HTMLCanvasElement</span>&gt;<span class="variable language_">document</span>.<span class="title function_">getElementById</span>()</span><br></pre></td></tr></table></figure>

<p>类型注释与类型断言一样, 类型断言由编译器来删除, 不会影响代码的运行时行为, 也就是因为类型断言在编译时被删除, 所以没有与类型断言相关联的运行时检查.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = (<span class="string">&#x27;hello&#x27;</span> <span class="keyword">as</span> <span class="built_in">unknown</span>) <span class="keyword">as</span> <span class="built_in">number</span></span><br></pre></td></tr></table></figure>

<p>如上代码可以在我们不知道某些代码是什么类型的时候断言为一个差不多的类型.</p>
<h3 id="3-11-文字类型"><a href="#3-11-文字类型" class="headerlink" title="3.11 文字类型"></a>3.11 文字类型</h3><p>除了一般类型<code>string</code> 和<code>number</code>, 还可以在类型位置引用特定的字符串和数字.</p>
<p>一种方法是考虑js如何以不同的方式声明变量. <code>var</code>和<code>let</code>两者都允许更改变量中保存的内容, <code>const</code>不允许, 这反映在TS如何为文字创建类型上</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> testString = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">testString = <span class="string">&quot;Olá Mundo&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// &#x27;testString&#x27;可以表示任何可能的字符串，那TypeScript是如何在类型系统中描述它的</span></span><br><span class="line">testString;</span><br><span class="line"><span class="keyword">const</span> constantString = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="comment">// 因为&#x27;constantString&#x27;只能表示1个可能的字符串，所以具有文本类型表示</span></span><br><span class="line">constantString;</span><br></pre></td></tr></table></figure>

<p>就其本身而言, 文字类型不是很有价值</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="string">&quot;hello&quot;</span>  = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">x = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">x = <span class="string">&quot;howdy&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2022.cnblogs.com/blog/2550942/202204/2550942-20220403120411495-32076888.png" alt="image-20220310180605751"></p>
<p>拥有一个只能由一个值的变量并没有多大用处!</p>
<p>但是通过将文字组合成联合，你可以表达一个更有用的概念——例如，<strong>只接受一组特定已知值的函数</strong>：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printText</span>(<span class="params">s: <span class="built_in">string</span>, alignment: <span class="string">&quot;left&quot;</span> | <span class="string">&quot;right&quot;</span> | <span class="string">&quot;center&quot;</span></span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">printText</span>(<span class="string">&quot;Hello, world&quot;</span>, <span class="string">&quot;left&quot;</span>);</span><br><span class="line"><span class="title function_">printText</span>(<span class="string">&quot;G&#x27;day, mate&quot;</span>, <span class="string">&quot;centre&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2022.cnblogs.com/blog/2550942/202204/2550942-20220403120411299-477523014.png" alt="image-20220310185517746"></p>
<p>数字文字类型的工作方式相同:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">a: <span class="built_in">string</span>, b: <span class="built_in">string</span></span>): -<span class="number">1</span> | <span class="number">0</span> | <span class="number">1</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a === b ? <span class="number">0</span> : a &gt; b ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以将这些与非文字类型结合使用:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Options</span> &#123;</span><br><span class="line">	<span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">configure</span>(<span class="params">x: Options | <span class="string">&quot;auto&quot;</span></span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">configure</span>(&#123; <span class="attr">width</span>: <span class="number">100</span> &#125;);</span><br><span class="line"><span class="title function_">configure</span>(<span class="string">&quot;auto&quot;</span>);</span><br><span class="line"><span class="title function_">configure</span>(<span class="string">&quot;automatic&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2022.cnblogs.com/blog/2550942/202204/2550942-20220403120411050-1916158135.png" alt="image-20220310190609259"></p>
<p>还有一种文字类型：布尔文字。只有两种布尔文字类型，它们是类型 <code>true</code> 和 <code>false</code> 。类型 boolean 本身实际上只是联合类型 <code>union</code> 的别名 <code>true | false</code> 。</p>
<h4 id="文字推理"><a href="#文字推理" class="headerlink" title="文字推理"></a>文字推理</h4><p>当你使用对象初始化变量时，TypeScript 假定该对象的属性稍后可能会更改值。例如，如果你写了这样的代码：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">counter</span>: <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>(someCondtion) &#123;</span><br><span class="line">	obj.<span class="property">counter</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TypeScript 不假定先前具有的字段值 <code>0</code> ，后又分配 <code>1</code> 是错误的。另一种说法是 <code>obj.counter</code> 必须有 <code>number</code> 属性， 而非是 <code>0</code> ，因为类型用于确定读取和写入行为。</p>
<p>这同样适合用于字符串:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleRequest</span>(<span class="params">url: <span class="built_in">string</span>, method: <span class="string">&#x27;GET&#x27;</span> | <span class="string">&#x27;POST&#x27;</span> | <span class="string">&#x27;GUESS&#x27;</span></span>) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> req = &#123; <span class="attr">url</span>: <span class="string">&#x27;https://example.com&#x27;</span>, <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span> &#125;;</span><br><span class="line"><span class="title function_">handleRequest</span>(req.<span class="property">url</span>, req.<span class="property">method</span>);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2022.cnblogs.com/blog/2550942/202204/2550942-20220403120410861-1471067420.png" alt="image-20220310193046700"></p>
<p>在上面的例子 <code>req.method</code> 中推断是 <code>string</code> ，不是 <code>&quot;GET&quot;</code> 。因为代码可以在创建 <code>req</code> 和调用之间进行<strong>评估</strong>，TypeScript 认为这段代码有错误。</p>
<p>有两种方法可以解决这个问题:</p>
<ol>
<li><strong>可以通过在任一位置添加类型断言来更改推理:</strong></li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方案 1:</span></span><br><span class="line"><span class="keyword">const</span> req = &#123; <span class="attr">url</span>: <span class="string">&quot;https://example.com&quot;</span>, <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span> <span class="keyword">as</span> <span class="string">&quot;GET&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 方案 2</span></span><br><span class="line"><span class="title function_">handleRequest</span>(req.<span class="property">url</span>, req.<span class="property">method</span> <span class="keyword">as</span> <span class="string">&quot;GET&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>方案1表示“我打算 req.method 始终拥有文字类型<code>&quot;GET&quot;</code> ”，从而防止之后可能分配<code>&quot;GUESS&quot;</code>给该字段。</p>
<p>方案 2 的意思是“我知道其他原因<code>req.method</code>具有<code>&quot;GET&quot;</code>值”。</p>
<ol>
<li><strong>可以使用 <code>as const</code> 将整个对象转换为类型文字</strong></li>
</ol>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> req = &#123; <span class="attr">url</span>: <span class="string">&quot;https://example.com&quot;</span>, <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span> &#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="title function_">handleRequest</span>(req.<span class="property">url</span>, req.<span class="property">method</span>);</span><br></pre></td></tr></table></figure>

<p>该<code>as const</code>后缀就像<code>const</code>定义，确保所有属性分配的文本类型，而不是一个更一般的<code>string</code>或 <code>number</code> 。</p>
<h3 id="3-12-null和undefined"><a href="#3-12-null和undefined" class="headerlink" title="3.12 null和undefined"></a>3.12 <code>null</code>和<code>undefined</code></h3><p>JavaScript 有两个原始值用于表示不存在或未初始化的值： <code>null</code> 和 <code>undefined</code>.</p>
<p>TypeScript有两个对应的同名类型。这些类型的行为取决于您是否在<code>tsconfig.json</code>设置<code>strictNullChecks</code>选择。</p>
<ul>
<li><p><code>strictNullChecks</code>关闭</p>
<p>使用false，<strong>仍然可以正常访问的值，并且可以将值分配给任何类型的属性</strong>。这类似于没有空检查的语言 （例如 C##、Java）的行为方式。缺乏对这些值的检查往往是错误的主要来源；如果在他们的代码库中这样做可行，我们总是建议大家打开。</p>
</li>
<li><p><code>strictNullChecks</code>开启</p>
<p>使用true，你需要在对该值使用方法或属性之前测试这些值。就像在使用可选属性之前检查一样，我们可以使用缩小来检查可能的值：</p>
</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">x: <span class="built_in">string</span> | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 做一些事</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + x.<span class="title function_">toUpperCase</span>());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>非空断言运算符</strong>(<code>!</code>后缀)</li>
</ul>
<p>TypeScript 也有一种特殊的语法 <code>null</code> ， <code>undefined</code> , 可以在不进行任何显式检查的情况下，从类型中移除和移除类型。 <code>!</code> 在任何表达式之后写入实际上是一种类型断言，即该值不是 <code>null</code> or <code>undefined</code> ：</p>
<p>使用<code>?</code>可以指定对象中某个参数可以选择传入或者不传入, 不传入其值就是undefined.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">liveDangerously</span>(<span class="params">x?: <span class="built_in">number</span> | <span class="literal">null</span></span>) &#123;</span><br><span class="line">	<span class="comment">// 正确</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(x!.<span class="title function_">toFixed</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像其他类型断言一样，这不会更改代码的运行时行为，因此仅 <code>!</code> 当你知道该值不能是 <code>null</code> 或 <code>undefined</code> 时使用才是重要的。</p>
<h3 id="3-13-枚举"><a href="#3-13-枚举" class="headerlink" title="3.13 枚举"></a>3.13 枚举</h3><p>枚举是 TypeScript 添加到 JavaScript 的一项功能，它允许描述一个值，该值可能是一组可能的命名常量之一。与大多数 TypeScript 功能不同，这不是JavaScript 的类型级别的添加，而是添加到语言和运行时的内容。因此，你确定你确实需要枚举在做些事情，否则请不要使用。可以在<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/enums.html">Enum参考页</a>中阅读有关枚举的更多信息。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts源码</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    <span class="title class_">Up</span> = <span class="number">1</span>,</span><br><span class="line">    <span class="title class_">Down</span>,</span><br><span class="line">    <span class="title class_">Left</span>,</span><br><span class="line">    <span class="title class_">Right</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Up</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 编译后的js代码</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Direction</span>;</span><br><span class="line">(<span class="keyword">function</span> (<span class="params">Direction</span>) &#123;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Up&quot;</span>] = <span class="number">1</span>] = <span class="string">&quot;Up&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Down&quot;</span>] = <span class="number">2</span>] = <span class="string">&quot;Down&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Left&quot;</span>] = <span class="number">3</span>] = <span class="string">&quot;Left&quot;</span>;</span><br><span class="line">    <span class="title class_">Direction</span>[<span class="title class_">Direction</span>[<span class="string">&quot;Right&quot;</span>] = <span class="number">4</span>] = <span class="string">&quot;Right&quot;</span>;</span><br><span class="line">&#125;)(<span class="title class_">Direction</span> || (<span class="title class_">Direction</span> = &#123;&#125;));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Direction</span>.<span class="property">Up</span>);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2022.cnblogs.com/blog/2550942/202204/2550942-20220403120410625-1139473086.png" alt="image-20220310202728792"></p>
<h3 id="3-14-不太常见的原语"><a href="#3-14-不太常见的原语" class="headerlink" title="3.14 不太常见的原语"></a>3.14 不太常见的原语</h3><p>值得一提的是JavaScript中一些较新的原语, 它们在 TypeScript 类型系统中也实现了。我们先简单的看两个例子：</p>
<ul>
<li><code>bigint</code></li>
</ul>
<p>从 ES2020(ES11) 开始，JavaScript 中有一个用于非常大的整数的原语<code>BigInt</code> :</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过bigint函数创建bigint</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">oneHundred</span>: <span class="built_in">bigint</span> = <span class="title class_">BigInt</span>(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 通过文本语法创建BigInt</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">anotherHundred</span>: <span class="built_in">bigint</span> = <span class="number">100n</span>;</span><br></pre></td></tr></table></figure>

<p>你可以在<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html##bigint">TypeScript 3.2</a>发行说明中了解有关 BigInt 的更多信息。</p>
<ul>
<li><code>symbol</code></li>
</ul>
<p>JavaScript 中有一个原语 <code>Symbol()</code> ，用于通过函数创建全局唯一引用：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = <span class="title class_">Symbol</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> secondName = <span class="title class_">Symbol</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (firstName === secondName) &#123;</span><br><span class="line">	<span class="comment">// 这里的代码不可能执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2022.cnblogs.com/blog/2550942/202204/2550942-20220403120410409-785165317.png" alt="image-20220310203640547"></p>
<p>此条件将始终返回 <code>false</code> ，因为类型<code>typeof firstName</code>和<code>typeof secondName</code>没有重叠。</p>
<h2 id="TypeScript学习第四章-类型缩小"><a href="#TypeScript学习第四章-类型缩小" class="headerlink" title="TypeScript学习第四章: 类型缩小"></a>TypeScript学习第四章: 类型缩小</h2><p>假设我们有一个名为padLeft的函数:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span>, input: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;尚未实现!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来扩充一下功能: 如果<code>padding</code>是<code>number</code>, 它会将其视为我们将要添加到<code>input</code>的空格数; 如果<code>padding</code>是<code>string</code>, 它只在input上做<code>padding</code>. 让我们尝试实现:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span>, input: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Array</span>(padding + <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>) + input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话, 我们在padding + 1处会遇到错误. TS警告我们, 运算符+不能应用于类型<code>number | string</code> 和 <code>string</code>, 这个逻辑是对的, 因为我们没有明确检查padding是否为<code>number</code>, 也没有处理它是<code>string</code>的情况, 所以我们我们这样做:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span>, input: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Array</span>(padding + <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>) + input;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> padding + input;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这大部分看起来像无趣的JavaScript代码，这也算是重点吧。除了我们设置的注解之外，这段 TypeScript代码看起来就像JavaScript。</p>
<p>我们的想法是，TypeScript的类型系统旨在使编写典型的 JavaScript代码变得尽可能容易，而不需要弯腰去获得类型安全。</p>
<p>虽然看起来不多，但实际上有很多价值在这里。就像TypeScript使用静态类型分析运行时的值一样，它在JavaScript的运行时控制流构造上叠加了类型分析，如if&#x2F;else、条件三元组、循环、真实性检查等，这些都会影响到这些类型。</p>
<p>在我们的if检查中，TypeScript看到<code>typeof padding ===&quot;number&quot;</code>，并将其理解为一种特殊形式的代码，称为<strong>类型保护</strong>。<strong>TypeScript遵循我们的程序可能采取的执行路径，以分析一个值在特定位置的最具体的可能类型</strong>。它查看这些特殊的检查（称为<strong>类型防护</strong>）和赋值，<strong>将类型细化为比声明的更具体的类型的过程被称为类型缩小</strong>。在许多编辑器中，我们可以观察这些类型的变化，我们甚至会在我们的例子中这样做。</p>
<p>TypeScript 可以理解几种不同的缩小结构.</p>
<h3 id="4-1-typeof类型守卫"><a href="#4-1-typeof类型守卫" class="headerlink" title="4.1 typeof类型守卫"></a>4.1 <code>typeof</code>类型守卫</h3><p>正如我们所见, Js支持<code>typeof</code>运算符, 它可以提供有关我们在运行时拥有的值类型的非常基本的信息.</p>
<p>TS期望它返回一组特定的字符串:</p>
<ul>
<li><code>&quot;string&quot;</code></li>
<li><code>&quot;number&quot;</code></li>
<li><code>&quot;bigint&quot;</code></li>
<li><code>&quot;boolean&quot;</code></li>
<li><code>&quot;symbol&quot;</code></li>
<li><code>&quot;undefined&quot;</code></li>
<li><code>&quot;object&quot;</code></li>
<li><code>&quot;function&quot;</code></li>
</ul>
<p>就像我们刚才在<code>padLeft</code>中看到的那样, 这个运算符经常出现在许多JavaScript库中, TS可以理解为, 它缩小在不同分支中的类型.</p>
<p>在TS中, 检查<code>typeof</code>的返回值是一种类型保护. 因为TS对<code>typeof</code>操作进行编码, 从而返回不同的值, 所以它知道对JS做了什么. 例如, 请注意上面的列表中, <code>typeof</code> 不返回<code>null</code>.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printAll</span>(<span class="params">strs: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">        	<span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(strs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 做点事</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2022.cnblogs.com/blog/2550942/202204/2550942-20220403120410187-617755105.png" alt="image-20220311230619295"></p>
<p>在 <code>printAll</code> 函数中，我们尝试检查 <code>strs</code> 是否为对象，来代替检查它是否为数组类型（现在可能是强调数组是 JavaScript 中的对象类型的好时机）。但事实证明，在 JavaScript 中，<code>typeof null</code> 实际上也是 <code>&quot;object&quot;</code> ! 这是历史上的不幸事故之一。</p>
<p>有足够经验的用户可能不会感到惊讶，但并不是每个人都在 JavaScript 中遇到过这种情况；幸运的是， ts 让我们知道， <code>strs</code> 只缩小到 <code>string[] | null</code> ，而不仅仅是 string[].</p>
<p>这可能是我们所谓的“真实性”检查的一个很好的过渡。</p>
<h3 id="4-2-真值缩小"><a href="#4-2-真值缩小" class="headerlink" title="4.2 真值缩小"></a>4.2 真值缩小</h3><p>真值检查是我们在JS中经常做的一件事. 在JS中, 我们可以在条件 <code>&amp;&amp;</code> <code>||</code> <code>if</code>语句布尔否定(!)等中使用任何表达式.</p>
<p>例如, <code>if</code>语句不希望它们的条件总是具有类型<code>boolean</code></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getUserOnlineMessage</span>(<span class="params">numUserOnline: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(numUserOnline) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`现在共有 <span class="subst">$&#123;numUserOnline&#125;</span> 人在线!`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;现在没有人在线:(&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JS总, if条件语句, 首先把他们的条件强制转化为boolean以使其有意义, 然后根据结果是true还是false来选择他们的分支. 像下面这些值都强制转换为false:</p>
<ul>
<li>0</li>
<li>NaN</li>
<li>“” (空字符串)</li>
<li>On (bigint 0的版本)</li>
<li>null</li>
<li>undefined</li>
</ul>
<p>其他值被强制转化为<code>true</code>. 你始终可以在<code>Boolean</code>函数中运行值获得<code>boolean</code>, 或使用较短的双布尔否定将值强制转换为<code>boolean</code>.(后者的优点是ts推断出一个狭窄的文字布尔类型true, 而将第一个推断为<code>boolean</code>类型)</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这两个结果都返回 true</span></span><br><span class="line"><span class="title class_">Boolean</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// type: boolean, value: true</span></span><br><span class="line">!!<span class="string">&quot;world&quot;</span>; <span class="comment">// type: true, value: true</span></span><br></pre></td></tr></table></figure>

<p>利用这个特性, 我们可以防范诸如<code>null</code>或<code>undefined</code>之类的值时. 例如, 让我们尝试将它用于我们的<code>printAll</code>函数.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printAll</span>(<span class="params">strs: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs &amp;&amp; <span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(strs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过检查<code>strs</code>是否为真, 消除了上述错误. 这可以防止我们在运行代码的时候出现一些错误, 例如:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">TypeError</span>: <span class="literal">null</span> is not iterable</span><br></pre></td></tr></table></figure>

<p>但请记住, 对原语的真值检查通常容易出错. 例如, 考虑改写<code>printAll</code>:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printAll</span>(<span class="params">strs: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="comment">// !!!!!!!!!!!!!!!!</span></span><br><span class="line">    <span class="comment">// 别这样!</span></span><br><span class="line">    <span class="comment">// 原因在下边</span></span><br><span class="line">    <span class="comment">// !!!!!!!!!!!!!!!!</span></span><br><span class="line">    <span class="keyword">if</span> (strs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        	<span class="variable language_">console</span>.<span class="title function_">log</span>(strs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将整个函数体包裹在一个真值检查中, 但是这有一个小小的缺点: 我们可能不再正确处理<code>空字符串</code>的情况.</p>
<p>TS在这里根本不会报错, 如果你不熟悉JS, 这是值得注意的. TS通常可以帮你及早发现错误, 但是如果你选择对某个值不做任何处理, 那么它可以做的就只有这么多, 而不会考虑过多逻辑方面的问题, 如果需要, 你可以确保linter(程序规范性)处理此类情况.</p>
<p>关于通过真实性缩小范围的最后一点，是通过布尔否定 <code>!</code> 把逻辑从否定分支中过滤掉。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multiplyAll</span>(<span class="params"> </span></span><br><span class="line"><span class="params">    values: <span class="built_in">number</span>[] | <span class="literal">undefined</span>,</span></span><br><span class="line"><span class="params">    factor: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"> </span>): <span class="built_in">number</span>[] | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!values) &#123;</span><br><span class="line">    	<span class="keyword">return</span> values;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> values.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> x * factor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-等值缩小"><a href="#4-3-等值缩小" class="headerlink" title="4.3 等值缩小"></a>4.3 等值缩小</h3><p>ts也使用分支语句做<code>===</code> <code>!==</code> <code>==</code>和 <code>!=</code> 等值检查, 来实现类型缩小. 例如:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span>, y: <span class="built_in">string</span> | <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">        <span class="comment">// 现在可以在x,y上调用字符串类型的方法了</span></span><br><span class="line">        x.<span class="title function_">toUpperCase</span>();</span><br><span class="line">        y.<span class="title function_">toLowerCase</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们在上面的示例中检查 x 和 y 是否相等时，TypeScript知道它们的类型也必须相等。由于 string 是 x 和 y 都可以采用的唯一常见类型，因此TypeScript 知道 x 、 y 如果都是 <code>string</code> ，则程序走第一个分支中 。</p>
<p>检查特定的字面量值（而不是变量）也有效。在我们关于真值缩小的部分中，我们编写了一个 printAll 容易出错的函数，因为它没有正确处理空字符串。相反，我们可以做一个特定的检查来阻止 null ，并且 TypeScript 仍然正确地从 strs 里移除 null 。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printAll</span>(<span class="params">strs: <span class="built_in">string</span> | <span class="built_in">string</span>[] | <span class="literal">null</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> s <span class="keyword">of</span> strs) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> strs === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(strs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript 更宽松的相等性检查 <code>==</code> 和 <code>!=</code> ，也能被正确缩小。如果你不熟悉，如何检查某个变量是否 <code>== null</code> ，因为有时不仅要检查它是否是特定的值 <code>null</code> ，还要检查它是否可能是 <code>undefined</code> 。这同样适用 于 <code>== undefined</code> ：<strong>它检查一个值是否为 null 或 undefined</strong> 。现在你只需要这个 <code>==</code> 和 <code>!=</code> 就可以搞定了。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">	<span class="attr">value</span>: <span class="built_in">number</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiplyValue</span>(<span class="params">container: Container, factor: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="comment">// 从类型中排除了undefined 和 null</span></span><br><span class="line">    <span class="keyword">if</span> (container.<span class="property">value</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(container.<span class="property">value</span>);</span><br><span class="line">        <span class="comment">// 现在我们可以安全地乘以“container.value”了</span></span><br><span class="line">        container.<span class="property">value</span> *= factor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiplyValue</span>(&#123;<span class="attr">value</span>: <span class="number">5</span>&#125;, <span class="number">5</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiplyValue</span>(&#123;<span class="attr">value</span>: <span class="literal">null</span>&#125;, <span class="number">5</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiplyValue</span>(&#123;<span class="attr">value</span>: <span class="literal">undefined</span>&#125;, <span class="number">5</span>))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">multiplyValue</span>(&#123;<span class="attr">value</span>: <span class="string">&#x27;5&#x27;</span>&#125;, <span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2022.cnblogs.com/blog/2550942/202204/2550942-20220403120409938-1420488579.png" alt="image-20220312115410324"></p>
<h3 id="4-4-in操作符缩小"><a href="#4-4-in操作符缩小" class="headerlink" title="4.4 in操作符缩小"></a>4.4 <code>in</code>操作符缩小</h3><p>JavaScript 有一个运算符，用于确定对象是否具有某个名称的属性： <code>in</code> 运算符。TypeScript 考虑到了这 一点，以此来缩小潜在类型的范围。 例如，使用代码： <code>&quot;value&quot; in x</code> 。这里的 <code>&quot;value&quot;</code> 是<strong>字符串string</strong>， <code>x</code> 是联合类型。值为“true”的分支缩小，需要 x 具有可选或必需属性的类型的值；值为 <code>“false”</code> 的分支缩小，<strong>需要具有可选或缺失属性的类型的值</strong>。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123; <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bird</span> = &#123; <span class="attr">fly</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">animal: Fish | Bird</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;swim&quot;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    	<span class="keyword">return</span> animal.<span class="title function_">swim</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> animal.<span class="title function_">fly</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，可选属性还将存在于缩小的两侧，例如，人类可以游泳和飞行（使用正确的设备），因此应该出 现在 <code>in</code> 检查的两侧：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123; <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bird</span> = &#123; <span class="attr">fly</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Human</span> = &#123; swim?: <span class="function">() =&gt;</span> <span class="built_in">void</span>; fly?: <span class="function">() =&gt;</span> <span class="built_in">void</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params">animal: Fish | Bird | Human</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;swim&quot;</span> <span class="keyword">in</span> animal) &#123;</span><br><span class="line">    	<span class="comment">// animal: Fish | Human</span></span><br><span class="line">    	animal;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// animal: Bird | Human</span></span><br><span class="line">    	animal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-instanceof操作符缩小"><a href="#4-5-instanceof操作符缩小" class="headerlink" title="4.5 instanceof操作符缩小"></a>4.5 <code>instanceof</code>操作符缩小</h3><p>JS有一个运算符<code>instanceof</code>检查一个值是否是另一个值的“实例”。更具体地，在JavaScript 中 <code>x instanceof Foo</code> 检查 <code>x</code> 的原型链是否含有 <code>Foo.prototype</code> 。虽然我们不会在这里深入探讨，当 我们进入 <code>类(class)</code> 学习时，你会看到更多这样的内容，它们大多数可以使用 <code>new</code> 关键字实例化。 正如你可能已经猜到的那样， <code>instanceof</code> 也是一个类型保护，TypeScript 在由 <code>instanceof</code> 保护的分支中实现缩小。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logValue</span>(<span class="params">x: <span class="built_in">Date</span> | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">toUTCString</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="title function_">toUpperCase</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">logValue</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()) <span class="comment">// Mon, 15 Nov 2021 22:34:37 GMT</span></span><br><span class="line"><span class="title function_">logValue</span>(<span class="string">&#x27;hello ts&#x27;</span>) <span class="comment">// HELLO TS</span></span><br></pre></td></tr></table></figure>

<h3 id="4-6-分配缩小"><a href="#4-6-分配缩小" class="headerlink" title="4.6 分配缩小"></a>4.6 分配缩小</h3><p>正如我们之前所提到的, 当我们为任何变量赋值时, TS会检查赋值的右侧并适当缩小左侧.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let x: string | number</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span> ? <span class="number">10</span> : <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// let x: number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">x = <span class="string">&quot;goodbye!&quot;</span>;</span><br><span class="line"><span class="comment">// let x: string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br></pre></td></tr></table></figure>

<p>请注意，这些分配中的每一个都是有效的。即使在我们第一次赋值后观察到的类型 x 更改为 <code>number</code> ， 我们仍然可以将 <code>string</code> 赋值给 x 。这是因为<strong>声明类型 x 开始是 <code>string | number</code></strong> 。</p>
<p>如果我们分配了一个 <code>boolean</code> 给 x ，我们就会看到一个错误，因为它不是声明类型的一部分。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span> ? <span class="number">10</span> : <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"><span class="comment">// let x: string | number</span></span><br><span class="line">x = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// let x: number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 出错了~! </span></span><br><span class="line">x = <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// let x: string | number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2022.cnblogs.com/blog/2550942/202204/2550942-20220403120409694-308293469.png" alt="image-20220312123406176"></p>
<h3 id="4-7-控制流分析"><a href="#4-7-控制流分析" class="headerlink" title="4.7 控制流分析"></a>4.7 控制流分析</h3><p>到目前为止, 我们已经通过一些基本实例来说明TS如何在特定分支中缩小范围. 但是除了从每个变量中走出来, 并在<code>if</code>、<code>while</code> 条件等中寻找类型保护之外, 还有更多的事情要做, 比如:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params">padding: <span class="built_in">number</span> | <span class="built_in">string</span>, input: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Array</span>(padding + <span class="number">1</span>).<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>) + input;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> padding + input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>padLeft从其第一个if块中返回. TS能够分析这段代码,并看到在padding是数字的情况下, 主体的其余部分（ <code>return padding + input;</code> ）是不可达的。因此，它能够将数字从 <code>padding</code> 的类型中移除（从string|number缩小到string），用于该函数的其余部分。</p>
<p>这种基于可达性的代码分析被称为控制流分析，TypeScript使用这种流分析来缩小类型，因为它遇到了 类型守卫和赋值。当一个变量被分析时，控制流可以一次又一次地分裂和重新合并，该变量可以被观察到在每个点上有不同的类型.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span>;</span><br><span class="line">    </span><br><span class="line">    x = <span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// let x: boolean</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span>) &#123;</span><br><span class="line">        x = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="comment">// let x: string</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// let x: number</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// let x: string | number</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = <span class="title function_">example</span>()</span><br><span class="line">x = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">x = <span class="number">100</span></span><br><span class="line">x = <span class="literal">true</span> <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2022.cnblogs.com/blog/2550942/202204/2550942-20220403120409410-141228654.png" alt="image-20220312180252869"></p>
<h3 id="4-8-使用类型谓词"><a href="#4-8-使用类型谓词" class="headerlink" title="4.8 使用类型谓词"></a>4.8 使用类型谓词</h3><p>到目前为止，我们已经用现有的JavaScript结构来处理窄化问题，然而有时你想更直接地控制整个代码中的类型变化。</p>
<p>为了定义一个用户定义的类型保护，我们只需要定义一个函数，其返回类型是一个类型谓词.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fish</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">swim</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bird</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">fly</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isFish</span>(<span class="params">pet: Fish | Bird</span>): pet is <span class="title class_">Fish</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (pet <span class="keyword">as</span> <span class="title class_">Fish</span>).<span class="property">swim</span> !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中， <code>pet is Fish</code> 是我们的类型谓词。谓词的形式是 <code>parameterName is Type</code> ，其中 parameterName 必须是<strong>当前函数签名中的参数名称</strong>, 返回一个boolean, 代表是不是该<code>Type</code></p>
<p>任何时候 <code>isFish</code> 被调用时，如果原始类型是兼容的，TypeScript将把该变量缩小到该特定类型。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSmallPet</span>(<span class="params"></span>): <span class="title class_">Fish</span> | <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">fish</span>: <span class="title class_">Fish</span> = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;gold fish&#x27;</span>,</span><br><span class="line">        <span class="attr">swim</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fish is swimming.&#x27;</span>)</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">bird</span>: <span class="title class_">Bird</span> = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;sparrow&#x27;</span>,</span><br><span class="line">        <span class="attr">fly</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bird is flying.&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() &lt; <span class="number">0.5</span> ? bird : fish</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里 pet 的 swim 和 fly 都可以访问了</span></span><br><span class="line"><span class="keyword">let</span> pet = <span class="title function_">getSmallPet</span>() <span class="comment">// </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pet)</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isFish</span>(pet)) &#123;</span><br><span class="line">    pet.<span class="title function_">swim</span>()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pet.<span class="title function_">fly</span>() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，TypeScript不仅知道 <code>pet</code> 在 <code>if</code> 分支中是一条鱼；它还知道在 <code>else</code> 分支中，你没有一条 <code>Fish</code> ，所以你一定有一只 <code>Bird</code> 。</p>
<p>你可以使用类型守卫 <code>isFish</code> 来过滤 <code>Fish | Bird</code> 的数组，获得 <code>Fish</code> 的数组。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">zoo</span>: (<span class="title class_">Fish</span> | <span class="title class_">Bird</span>)[] = [<span class="title function_">getSmallPet</span>(), <span class="title function_">getSmallPet</span>(), <span class="title function_">getSmallPet</span>()]</span><br><span class="line"><span class="keyword">const</span> <span class="attr">underWater1</span>: <span class="title class_">Fish</span>[] = zoo.<span class="title function_">filter</span>(isFish)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(underWater1)</span><br><span class="line"><span class="comment">// 或者，等同于</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">underWater2</span>: <span class="title class_">Fish</span>[] = zoo.<span class="title function_">filter</span>(isFish) <span class="keyword">as</span> <span class="title class_">Fish</span>[]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(underWater2)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 对于更复杂的例子，该谓词可能需要重复使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">underWatch3</span>: <span class="title class_">Fish</span>[] = zoo.<span class="title function_">filter</span>((pet): pet is <span class="title class_">Fish</span> =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (pet.<span class="property">name</span> === <span class="string">&#x27;frog&#x27;</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">isFish</span>(pet)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-9-受歧视的unions"><a href="#4-9-受歧视的unions" class="headerlink" title="4.9 受歧视的unions"></a>4.9 受歧视的<code>unions</code></h3><p>到目前为止，我们所看的大多数例子都是围绕着用简单的类型（如 <code>string</code> 、 <code>boolean</code> 和 <code>number</code> ）来缩小单个变量。虽然这很常见，但在JavaScript中，大多数时候我们要处理的是稍微复杂的结构。</p>
<p>为了激发灵感，让我们想象一下，我们正试图对圆形和方形等形状进行编码。圆记录了它们的半径，方记录了它们的边长。我们将使用一个叫做 <code>kind</code> 的字段来告诉我们正在处理的是哪种形状。这里是定义 Shape 的第一个尝试。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span> | <span class="string">&quot;square&quot;</span>;</span><br><span class="line">    radius?: <span class="built_in">number</span>;</span><br><span class="line">    sideLength?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，我们使用的是字符串字面类型的联合。 <code>&quot;circle&quot;</code> 和 <code>&quot;square&quot;</code> 分别告诉我们应该把这个形状 当作一个圆形还是方形。通过使用 <code>&quot;circle&quot; | &quot;square &quot;</code> 而不是<code>string</code> ，我们可以避免拼写错误的问题。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleShape</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">    <span class="comment">// oops!</span></span><br><span class="line">    <span class="keyword">if</span> (shape.<span class="property">kind</span> === <span class="string">&quot;rect&quot;</span>) &#123;</span><br><span class="line">    	<span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2022.cnblogs.com/blog/2550942/202204/2550942-20220403120409151-1775049510.png" alt="image-20220312213533490"></p>
<p>我们可以编写一个 <code>getArea</code> 函数，根据它处理的是圆形还是方形来应用正确的逻辑。我们首先尝试处理圆形。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img2022.cnblogs.com/blog/2550942/202204/2550942-20220403120408934-478698697.png" alt="image-20220312214029711"></p>
<p>在<code>strictNullChecks</code>下，这给了我们一个错误——这是很恰当的，因为<code>radius</code>可能没有被定义。 但是如果我们对<code>kind</code>属性进行适当的检查呢？</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shape.<span class="property">kind</span> === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗯, TypeScript 仍然不知道该怎么做。我们遇到了一个问题，即我们对我们的值比类型检查器知道的更多。我们可以尝试使用一个非空的断言 ( <code>radius</code> 后面的那个叹号 <code>!</code> ) 来说明 <code>radius</code> 肯定存在。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shape.<span class="property">kind</span> === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span>! ** <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这感觉并不理想。我们不得不用那些非空的断言对类型检查器声明一个叹号（<code>!</code>），以说服它相信 <code>shape.radius</code> 是被定义的，但是如果我们开始移动代码，这些断言就容易出错。此外，在 <code>strictNullChecks</code> 之外，我们也可以意外地访问这些字段（因为在读取这些字段时，可选属性被认为总是存在的)。我们绝对可以做得更好.</p>
<p>Shape 的这种编码的问题是，类型检查器没有办法根据种类属性知道 <code>radius</code> 或 <code>sideLength</code> 是否存在。我们需要把我们知道的东西传达给类型检查器。考虑到这一点，让我们再来定义一下<code>Shape</code>.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">    <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Square</span> &#123;</span><br><span class="line">    <span class="attr">kind</span>: <span class="string">&quot;square&quot;</span>;</span><br><span class="line">    <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = <span class="title class_">Circle</span> | <span class="title class_">Square</span>;</span><br></pre></td></tr></table></figure>

<p>在这里，我们正确地将 Shape 分成了两种类型，为 <code>kind</code> 属性设置了不同的值，但是 <code>radius</code> 和 <code>sideLength</code> 在它们各自的类型中被声明为必需的属性。</p>
<p>让我们看看当我们试图访问 <code>Shape</code> 的半径时会发生什么。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927947.png" alt="image-20220312215150736"></p>
<p>就像我们对 Shape 的第一个定义一样，这仍然是一个错误。当半径是可选的时候，我们得到了一个错误（仅在 <code>strictNullChecks</code> 中），因为 TypeScript 无法判断该属性是否存在。现在 Shape 是一个联合体，TypeScript 告诉我们 <code>shape</code> 可能是一个 <code>Square</code> ，而Square并没有定义半径 <code>radius</code> 。 这两种解释都是正确的，但只有我们对 Shape 的新编码仍然在 <code>strictNullChecks</code> 之外导致错误.</p>
<p>但是, 如果我们在此尝试检查kind属性呢?</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (shape.<span class="property">kind</span> === <span class="string">&quot;circle&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// shape: Circle</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就摆脱了错误! 当 <code>union</code> 中的每个类型都包含一个与字面类型相同的属性时，TypeScript 认为这是一 个有区别的 <code>union</code> ，并且可以缩小 <code>union</code> 的成员。</p>
<p>在这种情况下， <code>kind</code> 就是那个共同属性（这就是 Shape 的判别属性）。检查 <code>kind</code> 属性是否为 <code>&quot;circle&quot;</code> ，就可以剔除 <code>Shape</code> 中所有没有 <code>&quot;circle&quot;</code> 类型属性的类型。这就把 <code>Shape</code> 的范围缩小到 了 <code>Circle</code> 这个类型。</p>
<p>同样的检查方法也适用于 <code>switch</code> 语句。现在我们可以试着编写完整的 <code>getArea</code> ，而不需要任何讨厌 的叹号 <code>!</code> 非空的断言。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (shape.<span class="property">kind</span>) &#123;</span><br><span class="line">        <span class="comment">// shape: Circle</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;circle&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// shape: Square</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;square&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> shape.<span class="property">sideLength</span> ** <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最重要的是 <code>Shape</code> 的编码。向 TypeScript 传达正确的信息是至关重要的，这个信息就是 <code>Circle</code> 和 <code>Square</code> 实际上是具有特定种类字段的两个独立类型。这样做让我们写出类型安全的TypeScript代码， 看起来与我们本来要写的JavaScript没有区别。从那里，类型系统能够做 “正确 “的事情，并找出我们 <code>switch</code> 语句的每个分支中的类型.</p>
<p>辨证的联合体不仅仅适用于谈论圆形和方形。它们适合于在JavaScript中表示任何类型的消息传递方案， 比如在网络上发送消息（ <code>client/server</code> 通信），或者在状态管理框架中编码突变.</p>
<h3 id="4-10-never类型与穷尽性检查"><a href="#4-10-never类型与穷尽性检查" class="headerlink" title="4.10 never类型与穷尽性检查"></a>4.10 <code>never</code>类型与穷尽性检查</h3><p>在缩小范围时，你可以将一个联合体的选项减少到你已经删除了所有的可能性并且什么都不剩的程度。 在这些情况下，TypeScript将使用一个 <code>never</code> 类型来代表一个不应该存在的状态。</p>
<p><code>never</code> 类型可以分配给每个类型；但是，没有任何类型可以分配给<code>never</code>（除了never本身）。这意味着你可以使用缩小并依靠 <code>never</code> 的出现在 <code>switch</code> 语句中做详尽的检查。</p>
<p>例如，在我们的 <code>getArea</code> 函数中添加一个默认值，试图将形状分配给 <code>never</code> ，当每个可能的情况都没有被处理时，就会引发。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = <span class="title class_">Circle</span> | <span class="title class_">Square</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (shape.<span class="property">kind</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;circle&quot;</span>:</span><br><span class="line">        	<span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;square&quot;</span>:</span><br><span class="line">        	<span class="keyword">return</span> shape.<span class="property">sideLength</span> ** <span class="number">2</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">const</span> <span class="attr">_exhaustiveCheck</span>: <span class="built_in">never</span> = shape;</span><br><span class="line">            <span class="keyword">return</span> _exhaustiveCheck;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>Shape</code> 联盟中添加一个新成员，将导致TypeScript错误</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Triangle</span> &#123;</span><br><span class="line">    <span class="attr">kind</span>: <span class="string">&quot;triangle&quot;</span>;</span><br><span class="line">    <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = <span class="title class_">Circle</span> | <span class="title class_">Square</span> | <span class="title class_">Triangle</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArea</span>(<span class="params">shape: Shape</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (shape.<span class="property">kind</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;circle&quot;</span>:</span><br><span class="line">        	<span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * shape.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;square&quot;</span>:</span><br><span class="line">        	<span class="keyword">return</span> shape.<span class="property">sideLength</span> ** <span class="number">2</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">        	<span class="keyword">const</span> <span class="attr">_exhaustiveCheck</span>: <span class="built_in">never</span> = shape;</span><br><span class="line">        	<span class="keyword">return</span> _exhaustiveCheck;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927962.png" alt="image-20220312220623399"></p>
<h2 id="TypeScript学习第五章-函数"><a href="#TypeScript学习第五章-函数" class="headerlink" title="TypeScript学习第五章: 函数"></a>TypeScript学习第五章: 函数</h2><p>函数是任何<strong>应用程序</strong>的<strong>基本构件</strong>，无论它们是本地函数，从另一个模块导入，还是一个类上的方法。它们也是值，就像其他值一样，TypeScript有很多方法来描述如何调用函数。让我们来学习一下如何编写描述函数的类型。</p>
<h3 id="5-1-函数类型表达式"><a href="#5-1-函数类型表达式" class="headerlink" title="5.1 函数类型表达式"></a>5.1 函数类型表达式</h3><p>描述一个函数的最简单是用一个函数类型表达式. 这些类型在语法上类似于箭头函数.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greeter</span>(<span class="params">fn: (a: <span class="built_in">string</span>) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">	<span class="title function_">fn</span>(<span class="string">&quot;Hello, World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printToConsole</span>(<span class="params">s: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">greeter</span>(printToConsole);</span><br></pre></td></tr></table></figure>

<p>语法 <code>(a: string) =&gt; void</code> 意味着<strong>有一个参数的函数</strong>，名为 <code>a</code> ，类型为<strong>字符串</strong>，<strong>没有返回值</strong>“。就像函数声明一样，如果没有指定参数类型，它就隐含为 <code>any</code> 类型。</p>
<p>当然, 我们可以用一个类型别名来命名一个函数类型.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GreetFunction</span> = <span class="function">(<span class="params">a: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greeter</span>(<span class="params">fn: GreetFunction</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-调用签名-属性签名"><a href="#5-2-调用签名-属性签名" class="headerlink" title="5.2 调用签名: 属性签名"></a>5.2 调用签名: 属性签名</h3><p>在JavaScript中，除了可调用之外，<strong>函数</strong>还<strong>可以有属性</strong>。然而，函数类型表达式的语法不允许声明属性。 如果我们想用属性来描述可调用的东西，我们可以在一个<strong>类型别名</strong>中写一个<strong>调用签名</strong>。</p>
<p>值得注意的是, 类型别名中缩写的函数类型表达式返回值是用冒号:而不是箭头函数&#x3D;&gt;, 且实际应用时所传入函数返回值必须与此函数类型表达式声明的相同(fn1和fn2), 如果函数体内没有操作参数的行为, 可以不传参数(比如fn3).</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">DescribableFunction</span> = &#123; <span class="comment">// 对象类型</span></span><br><span class="line">    <span class="attr">description</span>: <span class="built_in">string</span> <span class="comment">// 函数的属性签名</span></span><br><span class="line">    (<span class="attr">someArg</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span> <span class="comment">// 函数类型表达式, 不能用=&gt; 而是用:</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">fn: DescribableFunction</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(fn.<span class="property">description</span> + <span class="string">&quot; returned &quot;</span> + <span class="title function_">fn</span>(<span class="number">6</span>))</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 传入正常参数使用且正常返回值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">n: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">fn1.<span class="property">description</span> = <span class="string">&quot;hello&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不传入参数且不正常返回值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;lalala&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn2.<span class="property">description</span> = <span class="string">&quot;heihei&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不传入参数且正常返回值</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn3</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">fn3.<span class="property">description</span> = <span class="string">&quot;hehehe&quot;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="title function_">doSomething</span>(fn1) <span class="comment">// 正常</span></span><br><span class="line"><span class="title function_">doSomething</span>(fn2) <span class="comment">// 报错</span></span><br><span class="line"><span class="title function_">doSomething</span>(fn3) <span class="comment">// 正常</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927979.png" alt="img"></p>
<h3 id="5-3-构造签名-new-params-…-Ctor"><a href="#5-3-构造签名-new-params-…-Ctor" class="headerlink" title="5.3 构造签名 new (params, …): Ctor"></a>5.3 构造签名 new (params, …): Ctor</h3><p>JS函数也可以用<code>new</code>操作符来调用. TS将这些成为构造函数, 因为它们通常会创建一个新的对象。你可以通过<strong>在调用签名前面添加 <code>new</code> 关键字来写一个构造签名</strong>, <strong>返回的是一个类或者构造函数.</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ctor</span> &#123;</span><br><span class="line">    <span class="attr">s</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">s: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    	<span class="variable language_">this</span>.<span class="property">s</span> = s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SomeConstructor</span> = &#123; <span class="comment">// 在调用签名前加new就是构造签名</span></span><br><span class="line">	<span class="keyword">new</span> (<span class="attr">s</span>: <span class="built_in">string</span>): <span class="title class_">Ctor</span> <span class="comment">// 返回的是一个构造函数或者类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">ctor: SomeConstructor</span>) &#123; <span class="comment">// SomeConstructor可以理解为构造函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">ctor</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> f = <span class="title function_">fn</span>(<span class="title class_">Ctor</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">s</span>)</span><br></pre></td></tr></table></figure>

<p>有些对象，如 JavaScript 的 <code>Date</code> 对象，可以在有 <code>new</code> 或没有 <code>new</code> 的情况下被调用。你可以在同一类型中任意地结合调用和构造签名.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">CallOrConstruct</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> (<span class="attr">s</span>: <span class="built_in">string</span>): <span class="title class_">Date</span> </span><br><span class="line">    (): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">date: CallOrConstruct</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title function_">date</span>(<span class="string">&#x27;2021-11-20&#x27;</span>)</span><br><span class="line">    <span class="keyword">let</span> n = <span class="title function_">date</span>() <span class="comment">// 因为Date可以在不使用new的情况下调用所以代码正常</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(d)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_">fn</span>(<span class="title class_">Date</span>)</span><br></pre></td></tr></table></figure>

<p>下一个实例</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clock构造函数的接口, 是一个构造签名, 返回一个ClockInterface类的构造函数</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> (<span class="attr">hour</span>: <span class="built_in">number</span>, <span class="attr">minute</span>: <span class="built_in">number</span>): <span class="title class_">ClockInterface</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Clock类的接口, 里面有一个tick()函数</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">    <span class="title function_">tick</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建Clock类的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createClock</span>(<span class="params"> </span></span><br><span class="line"><span class="params">    ctor: ClockConstructor,</span></span><br><span class="line"><span class="params">    hour: <span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">    minute: <span class="built_in">number</span></span></span><br><span class="line"><span class="params"> </span>): <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">ctor</span>(hour, minute);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体的类来实现ClockInterface, 必须要有tick函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DigitalClock</span> <span class="keyword">implements</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">    <span class="attr">h</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">m</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">h</span> = h</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m</span> = m</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;beep beep&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体的类来实现ClockInterface, 必须要有tick函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnalogClock</span> <span class="keyword">implements</span> <span class="title class_">ClockInterface</span> &#123;</span><br><span class="line">    <span class="attr">h</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">m</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">h</span> = h</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m</span> = m</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">tick</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;tick tock&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> digital = <span class="title function_">createClock</span>(<span class="title class_">DigitalClock</span>, <span class="number">12</span>, <span class="number">17</span>);</span><br><span class="line"><span class="keyword">let</span> analog = <span class="title function_">createClock</span>(<span class="title class_">AnalogClock</span>, <span class="number">7</span>, <span class="number">32</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(digital)</span><br><span class="line">analog.<span class="title function_">tick</span>()</span><br></pre></td></tr></table></figure>

<h3 id="5-4-泛型函数"><a href="#5-4-泛型函数" class="headerlink" title="5.4 泛型函数&lt;Type&gt;"></a>5.4 泛型函数<code>&lt;Type&gt;</code></h3><p>在写一个函数时, 输入的类型与输出的类型有关, 或者两个输入的类型以某种方式相关, 这是常见的. 让我们考虑一下一个返回数组种第一个元素的函数.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">firstElement</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数完成了它的工作，但不幸的是它的返回类型是 <code>any</code> 。如果该函数返回数组元素的类型会更好。</p>
<p>在TypeScript中，当我们想描述两个值之间的对应关系时，会使用泛型。我们通过在函数签名中声明一个类型参数来做到这一点:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> firstElement&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过给这个函数添加一个类型参数 <code>Type</code> ，并在两个地方使用它，我们已经在函数的输入（数组）和输出（返回值）之间建立了一个联系。现在当我们调用它时，一个更具体的类型就出来了：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s 是 &#x27;string&#x27; 类型</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="title function_">firstElement</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);</span><br><span class="line"><span class="comment">// n 是 &#x27;number&#x27; 类型</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="title function_">firstElement</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// u 是 undefined 类型</span></span><br><span class="line"><span class="keyword">const</span> u = <span class="title function_">firstElement</span>([]);</span><br></pre></td></tr></table></figure>

<h4 id="5-4-1-类型推断"><a href="#5-4-1-类型推断" class="headerlink" title="5.4.1 类型推断"></a>5.4.1 类型推断</h4><p>请注意, 在这个例子中, 我们没有必要指定类型. 类型是由TS推断出来的——自动选择.</p>
<p>我们也可以使用多个类型参数. 例如, 一个独立版本的map看起来可能是这样的:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> map&lt;<span class="title class_">Input</span>, <span class="title class_">Output</span>&gt;(<span class="attr">arr</span>: <span class="title class_">Input</span>[], <span class="attr">func</span>: <span class="function">(<span class="params">arg: Input</span>) =&gt;</span> <span class="title class_">Output</span>): <span class="title class_">Output</span>[] &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">map</span>(func)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 参数&#x27;n&#x27;是&#x27;字符串&#x27;类型。</span></span><br><span class="line"><span class="comment">// &#x27;parsed&#x27;是&#x27;number[]&#x27;类型。</span></span><br><span class="line"><span class="keyword">const</span> parsed = <span class="title function_">map</span>([<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>], <span class="function">(<span class="params">n</span>) =&gt;</span> <span class="built_in">parseInt</span>(n));</span><br></pre></td></tr></table></figure>

<p>请注意，在这个例子中，TypeScript可以推断出输入类型参数的类型（从给定的字符串数组string），以及基于函数表达式的返回值（数字number）的输出类型参数。</p>
<h4 id="5-4-2-限制条件"><a href="#5-4-2-限制条件" class="headerlink" title="5.4.2 限制条件"></a>5.4.2 限制条件</h4><p>我们i经写了一些通用函数, 可以对任何类型的值进行操作. 有时我们想把两个值联系起来, 但只能对某个值的子集进行操作. 这种在这种情况下，我们可以使用一个<strong>约束条件</strong>来<strong>限制一个类型参数可以接受的类型</strong>。</p>
<p>让我们写一个函数，返回两个值中较长的值。要做到这一点，我们需要一个长度属性，是一个数字。我们通过写一个扩展子句将类型参数限制在这个类型上.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> longest&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125;&gt;(<span class="attr">a</span>: <span class="title class_">Type</span>, <span class="attr">b</span>: <span class="title class_">Type</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="property">length</span> &gt;= b.<span class="property">length</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> a;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// longerArray 的类型是 &#x27;number[]&#x27;</span></span><br><span class="line"><span class="keyword">const</span> longerArray = <span class="title function_">longest</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// longerString 是 &#x27;alice&#x27;|&#x27;bob&#x27; 的类型。</span></span><br><span class="line"><span class="keyword">const</span> longerString = <span class="title function_">longest</span>(<span class="string">&quot;alice&quot;</span>, <span class="string">&quot;bob&quot;</span>);</span><br><span class="line"><span class="comment">// 错误! 数字没有&#x27;长度&#x27;属性</span></span><br><span class="line"><span class="keyword">const</span> notOK = <span class="title function_">longest</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，有一些有趣的事情需要注意。我们允许TypeScript推断 <code>longest</code> 的返回类型。返回类型推断也适用于通用函数。</p>
<p>因为我们将 Type 约束为 <code>&#123; length: number &#125;</code> ，所以我们被允许访问 a 和 b 参数的 <code>.length</code> 属 性。如果没有类型约束，我们就不能访问这些属性，因为这些值可能是一些没有长度属性的其他类型。</p>
<p>longerArray 和 longerString 的类型是根据参数推断出来的。记住，<strong>泛型就是把两个或多个具有相同类型的值联系起来</strong>。 最后，正如我们所希望的，对 longest(10, 100) 的调用被拒绝了，因为数字类型没有一个 <code>.length</code> 属性</p>
<h4 id="5-4-3-使用受限值"><a href="#5-4-3-使用受限值" class="headerlink" title="5.4.3 使用受限值"></a>5.4.3 使用受限值</h4><p>这里有一个使用通用约束条件时的常见错误。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> minimumLength&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> &#123; <span class="attr">length</span>: <span class="built_in">number</span> &#125;&gt;(</span><br><span class="line">    <span class="attr">obj</span>: <span class="title class_">Type</span>,</span><br><span class="line">    <span class="attr">minimum</span>: <span class="built_in">number</span></span><br><span class="line">): <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="property">length</span> &gt;= minimum) &#123;</span><br><span class="line">    	<span class="keyword">return</span> obj</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> &#123; <span class="attr">length</span>: minimum &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来这个函数没有问题–Type被限制为<code>&#123; length: number &#125;</code>，而且这个函数要么返回Type，要么返回一 个与该限制相匹配的值。问题是，该函数<strong>承诺返回与传入的对象相同的类型</strong>，<strong>而不仅仅是与约束条件相匹配的一些对象</strong>。如果这段代码是合法的，你可以写出肯定无法工作的代码。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927383.png" alt="image-20220315123636487"></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#x27;arr&#x27; 获得值： &#123; length: 6 &#125;</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="title function_">minimumLength</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">6</span>);</span><br><span class="line"><span class="comment">//在此崩溃，因为数组有一个&#x27;切片&#x27;方法，但没有返回对象!</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">slice</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<h4 id="5-4-4-指定类型参数"><a href="#5-4-4-指定类型参数" class="headerlink" title="5.4.4 指定类型参数"></a>5.4.4 指定类型参数</h4><p>TypeScript 通常可以推断出通用调用中的预期类型参数，但并非总是如此。例如，假设你写了一个函数来合并两个数组：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> combine&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr1</span>: <span class="title class_">Type</span>[], <span class="attr">arr2</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span>[] &#123;</span><br><span class="line">    <span class="keyword">return</span> arr1.<span class="title function_">concat</span>(arr2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下，用不匹配的数组调用这个函数是一个错误：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="title function_">combine</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;hello&quot;</span>]);</span><br></pre></td></tr></table></figure>

<p>然而，如果你打算这样做，你在调用函数时可以手动指定类型:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = combine&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">&quot;hello&quot;</span>])</span><br></pre></td></tr></table></figure>

<h4 id="5-4-5-编写优秀通用函数的准则"><a href="#5-4-5-编写优秀通用函数的准则" class="headerlink" title="5.4.5 编写优秀通用函数的准则"></a>5.4.5 编写优秀通用函数的准则</h4><p>编写泛型函数很有趣，而且很容易被类型参数所迷惑。有太多的类型参数或在不需要的地方使用约束，会使推理不那么成功，使你的函数的调用者感到沮丧。</p>
<ul>
<li><strong>类型参数下推</strong></li>
</ul>
<p>下面是两种看似的函数写法:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> firstElement1&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr</span>: <span class="title class_">Type</span>[]) &#123;</span><br><span class="line">	<span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> firstElement2&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt;(<span class="attr">arr</span>: <span class="title class_">Type</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a: number (推荐)</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">firstElement1</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">// b: any (不推荐)</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="title function_">firstElement2</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure>

<p>乍一看，这些可能是相同的，但 <code>firstElement1</code> 是写这个函数的一个更好的方法。它的推断返回类型是<code>Type</code>，但 <code>firstElement2</code> 的推断返回类型是 <code>any</code> ，因为TypeScript必须使用约束类型来解析<code>arr[0]</code> 表达式，而不是在调用期间 “等待 “解析该元素。</p>
<blockquote>
<p><strong>规则</strong>: 在可能的情况下, 使用类型参数本身, 而不是对其进行约束</p>
</blockquote>
<ul>
<li><strong>使用更少的类型参数</strong></li>
</ul>
<p>下面是另一对类似的函数:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> filter1&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arr</span>: <span class="title class_">Type</span>[], <span class="attr">func</span>: <span class="function">(<span class="params">arg: Type</span>) =&gt;</span> <span class="built_in">boolean</span>): <span class="title class_">Type</span>[] &#123;</span><br><span class="line">	<span class="keyword">return</span> arr.<span class="title function_">filter</span>(func);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> filter2&lt;<span class="title class_">Type</span>, <span class="title class_">Func</span> <span class="keyword">extends</span> (<span class="attr">arg</span>: <span class="title class_">Type</span>) =&gt; <span class="built_in">boolean</span>&gt;(</span><br><span class="line">    <span class="attr">arr</span>: <span class="title class_">Type</span>[],</span><br><span class="line">    <span class="attr">func</span>: <span class="title class_">Func</span></span><br><span class="line">): <span class="title class_">Type</span>[] &#123;</span><br><span class="line">	<span class="keyword">return</span> arr.<span class="title function_">filter</span>(func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们已经创建了一个类型参数 <code>Func</code> ，它并不涉及两个值。这总是一个值得标记的坏习惯，因为它意味着想要指定类型参数的调用者必须无缘无故地手动指定一个额外的类型参数。 Func 除了使函数更难阅读和推理外，什么也没做。</p>
<blockquote>
<p><strong>规则:</strong> 总是尽可能少的使用类型参数</p>
</blockquote>
<ul>
<li><strong>类型参数应该出现两次及以上</strong></li>
</ul>
<p>有时候我们会忘记, 一个函数可能不需要是通用的:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> greet&lt;<span class="title class_">Str</span> <span class="keyword">extends</span> <span class="built_in">string</span>&gt;(<span class="attr">s</span>: <span class="title class_">Str</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">greet</span>(<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们完全可以写一个更简单的版本:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">s: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记住，类型参数是用来关联多个值的类型的。如果一个类型参数在函数签名中只使用一次，那么它就没有任何关系。</p>
<blockquote>
<p><strong>规则:</strong> 如果一个类型的参数只出现在一个地方, 请重新考虑你是否真的需要它</p>
</blockquote>
<h3 id="5-5-可选参数"><a href="#5-5-可选参数" class="headerlink" title="5.5 可选参数 ?"></a>5.5 可选参数 ?</h3><p>JavaScript中的函数经常需要一个可变数量的参数。例如，<code>number</code>的 <code>toFixed</code> 方法需要一个可选的数字计数。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">n: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="title function_">toFixed</span>()); <span class="comment">// 0 个参数</span></span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="title function_">toFixed</span>(<span class="number">3</span>)); <span class="comment">// 1 个参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以在TypeScript中通过将参数用 <code>?</code> 标记：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x?: <span class="built_in">number</span></span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(); <span class="comment">// 正确</span></span><br><span class="line"><span class="title function_">f</span>(<span class="number">10</span>); <span class="comment">// 正确</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>虽然参数被指定为 number 类型，但 <code>x</code> 参数实际上将具有 <code>number | undefined</code> 类型，因为在 JavaScript中未指定的参数会得到 <code>undefined</code> 的值。</p>
<p>你也可以提供一个参数默认值</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x = <span class="number">10</span></span>) &#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在在 <code>f</code> 的主体中， x 将具有 <code>number</code> 类型，因为任何 <code>undefined</code> 的参数将被替换为10 。请注意，当一个参数是可选的，调用者总是可以传递未定义的参数，因为这只是模拟一个 “丢失 “的参数：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x?: <span class="built_in">number</span></span>): <span class="built_in">void</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 以下调用都是正确的</span></span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"><span class="title function_">f</span>(<span class="number">10</span>);</span><br><span class="line"><span class="title function_">f</span>(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure>

<h4 id="5-5-1-回调中的可选参数"><a href="#5-5-1-回调中的可选参数" class="headerlink" title="5.5.1 回调中的可选参数"></a>5.5.1 回调中的可选参数</h4><p>一旦你了解了可选参数和函数类型表达式, 在编写调用回调的函数时就很容易犯以下错误:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myForEach</span>(<span class="params">arr: <span class="built_in">any</span>[], callback: (arg: <span class="built_in">any</span>, index?: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    	<span class="title function_">callback</span>(arr[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在写<code>index?</code>作为一个可选参数时, 通常是想让这些调用都是合法的:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">myForEach</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a))</span><br><span class="line"><span class="title function_">myForEach</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a, i</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(a, i))</span><br></pre></td></tr></table></figure>

<p>这实际上意味着回调可能会被调用，只有一个参数。换句话说，该函数定义说，实现可能是这样的：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myForEach</span>(<span class="params">arr: <span class="built_in">any</span>[], callback: (arg: <span class="built_in">any</span>, index?: <span class="built_in">number</span>) =&gt; <span class="built_in">void</span></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 我现在不想提供索引</span></span><br><span class="line">        <span class="title function_">callback</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反过来，TypeScript会强制执行这个意思，并发出实际上不可能的错误：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">myForEach</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">a, i</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i.<span class="title function_">toFixed</span>())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927563.png" alt="image-20220315173641328"></p>
<p>在JavaScript中，如果你<strong>调用一个形参多于实参的函数</strong>，<strong>额外的参数会被简单地忽略</strong>。TypeScript的行为也是如此。</p>
<p><strong>参数较少的函数</strong>（相同的类型）总是可以取代参数较多的函数的位置。</p>
<blockquote>
<p>当为回调写一个函数类型时, 永远不要写一个可选参数, 除非你打算在不传递该参数的情况下调用函数.</p>
</blockquote>
<h3 id="5-6-函数重载-重载签名"><a href="#5-6-函数重载-重载签名" class="headerlink" title="5.6 函数重载: 重载签名"></a>5.6 函数重载: 重载签名</h3><p>一些 JavaScript 函数可以在不同的参数数量和类型中被调用。例如，你可能会写一个函数来产生一个 <code>Date</code>，它需要一个时间戳（一个参数）或一个月&#x2F;日&#x2F;年规格（三个参数）。</p>
<p>在TypeScript中，我们可以通过编写<strong>重载签名</strong>来指定一个可以以不同方式调用的函数。要做到这一点， <strong>要写一些数量的函数签名（通常是两个或更多），然后是函数的主体</strong>：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeDate</span>(<span class="params">timestamp: <span class="built_in">number</span></span>): <span class="title class_">Date</span> <span class="comment">// 重载签名</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeDate</span>(<span class="params">m: <span class="built_in">number</span>, d: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title class_">Date</span> <span class="comment">// 重载签名</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">makeDate</span>(<span class="params">mOrTimestamp: <span class="built_in">number</span>, d?: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>): <span class="title class_">Date</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(d !== <span class="literal">undefined</span> &amp;&amp; y !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(y, mOrTimestamp, d)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(mOrTimestamp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> d1 = <span class="title function_">makeDate</span>(<span class="number">12345678</span>)</span><br><span class="line"><span class="keyword">const</span> d2 = <span class="title function_">makeDate</span>(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">const</span> d3 = <span class="title function_">makeDate</span>(<span class="number">1</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927645.png" alt="image-20220315211022165"></p>
<p>在这个例子中，我们写了两个重载：一个接受一个参数，另一个接受三个参数。这前两个签名被称为<strong>重载签名</strong>。</p>
<p>然后，我们写了一个<strong>具有兼容签名的函数实现</strong>。函数有一个实现签名，但这个签名不能被直接调用。即使我们写了一个在所需参数之后有两个可选参数的函数，它也不能以两个参数被调用</p>
<h4 id="5-6-1-重载签名和实现签名"><a href="#5-6-1-重载签名和实现签名" class="headerlink" title="5.6.1 重载签名和实现签名"></a>5.6.1 重载签名和实现签名</h4><p>这是一个常简的混乱的来源. 通常我们会写这样的代码, 却不明白为什么会出现错误:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="built_in">void</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 期望能够以零参调用</span></span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927711.png" alt="image-20220315231331099"></p>
<p>同样, 用于编写函数体的签名不能从外面”看到”:</p>
<blockquote>
<p>实现的签名从外面是看不到的. <strong>在编写重载函数时, 你应该总是在函数的实现上面有两个或多个签名.</strong></p>
</blockquote>
<p><strong>实现签名也必须与重载签名兼容</strong>. 例如, 这些函数有错误, 因为实现签名没有以正确的方式匹配重载:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">boolean</span></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="comment">// 参数类型不正确</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">boolean</span></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927777.png" alt="image-20220315232556054"></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="comment">// 返回类型不正确</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="built_in">boolean</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;oops&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927872.png" alt="image-20220315232701448"></p>
<h4 id="5-6-2-编写好的重载"><a href="#5-6-2-编写好的重载" class="headerlink" title="5.6.2 编写好的重载"></a>5.6.2 编写好的重载</h4><p>和泛型一样，在使用函数重载时，有一些准则是你应该遵循的。遵循这些原则将使你的函数更容易调用，更容易理解，更容易实现。</p>
<p>让我们考虑一个返回字符串或数组长度的函数：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">arr: <span class="built_in">any</span>[]</span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">x: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数是好的；我们可以用字符串或数组来调用它。然而，我们不能用一个可能是字符串或数组的值来调用它，因为TypeScript只能将一个函数调用解析为一个重载：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">len</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">len</span>([<span class="number">0</span>]); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">len</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span> ? <span class="string">&quot;hello&quot;</span> : [<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927939.png" alt="image-20220315233748639"></p>
<p>因为两个重载都有相同的参数数量和相同的返回类型，我们可以改写一个非重载版本的函数：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">len</span>(<span class="params">x: <span class="built_in">any</span>[] | <span class="built_in">string</span></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> x.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">len</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">len</span>([<span class="number">0</span>]); <span class="comment">// OK</span></span><br><span class="line"><span class="title function_">len</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() &gt; <span class="number">0.5</span> ? <span class="string">&quot;hello&quot;</span> : [<span class="number">0</span>]); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<p>这就好得多了! 调用者可以用任何一种值来调用它，而且作为额外的奖励，我们不需要找出一个正确的实现签名。</p>
<blockquote>
<p>在可能的情况下，总是倾向于使用联合类型的参数而不是重载参数</p>
</blockquote>
<h4 id="5-6-3-函数内This的声明"><a href="#5-6-3-函数内This的声明" class="headerlink" title="5.6.3 函数内This的声明"></a>5.6.3 函数内<code>This</code>的声明</h4><p>TS会通过代码分析来推断函数中<code>this</code>应该是什么, 比如下面的例子:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="number">123</span>,</span><br><span class="line">	<span class="attr">admin</span>: <span class="literal">false</span>,</span><br><span class="line">	<span class="attr">becomeAdmin</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">this</span>.<span class="property">admin</span> = <span class="literal">true</span>;</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>TS理解函数<code>user.becomeAdmin</code>有一个对应的<code>this</code>, 它是外部对象<code>user</code>. 这个对于很多情况来说已经足够了, 但是有很多情况下你需要更多的控制<code>this</code>代表什么对象&#x2F;</p>
<p>JavaScript规范规定， 你不能有一个叫 <code>this</code> 的参数，所以TypeScript使用这个语法空间，让你在函数体中声明 <code>this</code> 的类型。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Card</span> &#123;</span><br><span class="line">  <span class="attr">suit</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">card</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Deck</span> &#123;</span><br><span class="line">  <span class="attr">suits</span>: <span class="built_in">string</span>[];</span><br><span class="line">  <span class="attr">cards</span>: <span class="built_in">number</span>[];</span><br><span class="line">  <span class="title function_">createCardPicker</span>(<span class="attr">this</span>: <span class="title class_">Deck</span>): <span class="function">() =&gt;</span> <span class="title class_">Card</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">deck</span>: <span class="title class_">Deck</span> = &#123;</span><br><span class="line">  <span class="attr">suits</span>: [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>],</span><br><span class="line">  <span class="attr">cards</span>: <span class="title class_">Array</span>(<span class="number">52</span>),</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> The function now explicitly specifies that its callee must be of type Deck</span></span><br><span class="line">  <span class="attr">createCardPicker</span>: <span class="keyword">function</span>(<span class="params"><span class="variable language_">this</span>: Deck</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> pickedCard = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * <span class="number">52</span>);</span><br><span class="line">          <span class="keyword">let</span> pickedSuit = <span class="title class_">Math</span>.<span class="title function_">floor</span>(pickedCard / <span class="number">13</span>);</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">return</span> &#123;<span class="attr">suit</span>: <span class="variable language_">this</span>.<span class="property">suits</span>[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(deck.<span class="title function_">createCardPicker</span>()())</span><br></pre></td></tr></table></figure>

<h3 id="5-7-需要了解的其他类型"><a href="#5-7-需要了解的其他类型" class="headerlink" title="5.7 需要了解的其他类型"></a>5.7 需要了解的其他类型</h3><p>有一些额外的类型你会想要认识，它们在处理函数类型时经常出现。像所有的类型一样，你可以在任何地方使用它们，但这些类型在函数的上下文中特别相关.</p>
<h4 id="5-7-1-void"><a href="#5-7-1-void" class="headerlink" title="5.7.1 void"></a>5.7.1 <code>void</code></h4><p><code>void</code>表示没有返回值的函数的返回值. 当一个函数没有任何返回语句, 或者没有从这些返回语句中返回任何明确的值时, 它都是推断出来<code>void</code>类型.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推断出的返回类型是void</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">noop</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JavaScript中，一个不返回任何值的函数将隐含地返回 <code>undefinded</code> 的值。然而，在TypeScript中， void 和 <code>undefined</code> 是不一样的。在本章末尾有进一步的细节。</p>
<blockquote>
<p>void 和 undefined是不一样的</p>
</blockquote>
<h4 id="5-7-2-object"><a href="#5-7-2-object" class="headerlink" title="5.7.2 object"></a>5.7.2 <code>object</code></h4><p>特殊类型<code>object</code>指的是任何不是基元的值（ <code>string</code> 、 <code>number</code> 、 <code>bigint</code> 、 <code>boolean</code> 、 <code>symbol</code> 、 <code>null</code> 或 <code>undefined</code> ）。这与空对象类型 { } 不同，也与全局类型 <code>Object</code> 不同。你很可能永远不会使用 <code>Object</code> 。</p>
<blockquote>
<p><code>object</code> 不是 <code>Object</code> 。始终使用 <code>object</code> !</p>
</blockquote>
<p>请注意，在JavaScript中，<strong>函数值是对象</strong>。它们有属性，在它们的原型链中有 <strong>Object.prototype</strong> ，是 <strong>Object</strong> 的实例，你可以对它们调用 <strong>Object.key</strong> ，等等。由于这个原因，函数类型在TypeScript中被 认为是 <strong>object</strong> 。</p>
<h4 id="5-7-3-unknown"><a href="#5-7-3-unknown" class="headerlink" title="5.7.3 unknown"></a>5.7.3 <code>unknown</code></h4><p><code>unknown</code>类型代表任何值. 这与<code>any</code>类型相似, 但更安全, 因为对未知<code>unknown</code>值做任何事情都是不合法的.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params">a: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">	a.<span class="title function_">b</span>(); <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params">a: <span class="built_in">unknown</span></span>) &#123;</span><br><span class="line">	a.<span class="title function_">b</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927287.png" alt="image-20220316114327682"></p>
<p>这在描述函数类型时很有用，因为你可以描述接受任何值的函数，而不需要在函数体中有 any 值。 反之，你可以描述一个返回未知类型的值的函数:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">safeParse</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="built_in">unknown</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">parse</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 需要小心对待&#x27;obj&#x27;!</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title function_">safeParse</span>(someRandomString);</span><br></pre></td></tr></table></figure>

<h4 id="5-7-4-never"><a href="#5-7-4-never" class="headerlink" title="5.7.4 never"></a>5.7.4 <code>never</code></h4><p>有些函数永远不会返回一个值：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fail</span>(<span class="params">msg: <span class="built_in">string</span></span>): <span class="built_in">never</span> &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>never</code> 类型标识永远不会被观察到的值. 载一个返回类型中, 这意味着函数抛出了一个异常或终止程序的执行.</p>
<p>never 也出现在TypeScript确定一个 <code>union</code> 中没有任何东西的时候。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">	<span class="comment">// 做一些事</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">	<span class="comment">// 再做一些事</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	x; <span class="comment">// &#x27;never&#x27;!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-7-5-Function"><a href="#5-7-5-Function" class="headerlink" title="5.7.5 Function"></a>5.7.5 <code>Function</code></h4><p>全局性的 <code>Function</code> 类型描述了诸如 <code>bind</code> 、 <code>call</code> 、 <code>apply</code> 和其他存在于JavaScript中所有函数值的属性。它还有一个特殊的属性，即 <code>Function</code> 类型的值总是可以被调用；这些调用返回 <code>any</code> 。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">f: <span class="built_in">Function</span></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title function_">f</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一个无类型的函数调用，一般来说最好避免，因为 any 返回类型都不安全。 如果你需要接受一个任意的函数，但不打算调用它，一般来说， <code>() =&gt; void</code> 的类型比较安全。</p>
<h3 id="5-8-函数展开运算符"><a href="#5-8-函数展开运算符" class="headerlink" title="5.8 函数展开运算符"></a>5.8 函数展开运算符</h3><h4 id="5-8-1-形参展开-Rest-Parameters"><a href="#5-8-1-形参展开-Rest-Parameters" class="headerlink" title="5.8.1 形参展开(Rest Parameters)"></a>5.8.1 形参展开(Rest Parameters)</h4><p>除了使用可选参数或重载来制作可以接受各种固定参数数量的函数之外，我们还可以使用<strong>休止参数</strong>来定义接受无限制数量的参数的函数。</p>
<p><code>rest</code> 参数出现在所有其他参数之后，并使用 <code>...</code> 的语法：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">n: <span class="built_in">number</span>, ...m: <span class="built_in">number</span>[]</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> m.<span class="title function_">map</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> n * x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27; 获得的值 [10, 20, 30, 40]</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="title function_">multiply</span>(<span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>在TypeScript中，这些参数的类型注解是隐含的 <code>any[]</code> ，而不是 <code>any</code> ，任何给出的类型注解必须是 <code>Array</code> 或 <code>T[]</code> 的形式，或一个元组类型(我们将在后面学习).</p>
<h4 id="5-8-2-实参展开-Rest-Arguments"><a href="#5-8-2-实参展开-Rest-Arguments" class="headerlink" title="5.8.2 实参展开(Rest Arguments)"></a>5.8.2 实参展开(Rest Arguments)</h4><p>反之, 我们可以使用<code>spread</code>语法从数组中提供可变数量的参数. 例如数组的<code>push</code>方法需要任意数量的参数.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">arr1.<span class="title function_">push</span>(...arr2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1) <span class="comment">//[ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>

<p>请注意，一般来说，TypeScript并不假定数组是不可变的。这可能会导致一些令人惊讶的行为。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推断的类型是 number[] -- &quot;一个有零或多个数字的数组&quot;。</span></span><br><span class="line"><span class="comment">// 不专指两个数字</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="number">8</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> angle = <span class="title class_">Math</span>.<span class="title function_">atan2</span>(...args);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927419.png" alt="image-20220316151519852"></p>
<p>这种情况的最佳解决方案取决于你的代码，但一般来说， <code>const context</code> 是最直接的解决方案</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推断为2个长度的元组</span></span><br><span class="line"><span class="keyword">const</span> args = [<span class="number">8</span>, <span class="number">5</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> angle = <span class="title class_">Math</span>.<span class="title function_">atan2</span>(...args);</span><br></pre></td></tr></table></figure>

<h3 id="5-9-参数解构"><a href="#5-9-参数解构" class="headerlink" title="5.9 参数解构"></a>5.9 参数解构</h3><p>可以使用<strong>参数重构</strong>来方便地将作为参数提供的对象，解压到函数主体的<strong>一个或多个局部变量</strong>中。在 JavaScript中，它看起来像这样：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">&#123; a, b, c &#125;</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>(&#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">3</span>, <span class="attr">c</span>: <span class="number">9</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>对象的类型注解在结构的语法之后:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params"> &#123; a, b, c &#125;: &#123; a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, c: <span class="built_in">number</span> &#125;</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这看起来有点啰嗦，但你也可以在这里使用一个命名的类型：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与之前的例子相同</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">ABC</span> = &#123; <span class="attr">a</span>: <span class="built_in">number</span>; <span class="attr">b</span>: <span class="built_in">number</span>; <span class="attr">c</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">&#123; a, b, c &#125;: ABC</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-10-函数的可分配性-返回void类型"><a href="#5-10-函数的可分配性-返回void类型" class="headerlink" title="5.10 函数的可分配性: 返回void类型"></a>5.10 函数的可分配性: 返回<code>void</code>类型</h3><p>函数的 <code>void</code> 返回类型可以产生一些不寻常的，但却是预期的行为。</p>
<p>返回类型为 <code>void</code> 的上下文类型并不强迫函数不返回东西。另一种说法是，一个具有 <code>void</code> 返回类型的上下文函数类型（ <code>type vf = () =&gt; void</code> ），在实现时，可以返回任何其他的值，但它会被忽略。</p>
<p>因此，以下 <code>() =&gt; void</code> 类型的实现是有效的：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> voidFunc = <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">f1</span>: voidFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">f2</span>: voidFunc = <span class="function">() =&gt;</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">f3</span>: voidFunc = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而当这些函数之一的返回值被分配给另一个变量时，它将保留 <code>void</code> 的类型</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = <span class="title function_">f1</span>();</span><br><span class="line"><span class="keyword">const</span> v2 = <span class="title function_">f2</span>();</span><br><span class="line"><span class="keyword">const</span> v3 = <span class="title function_">f3</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(v1) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(v2) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(v3) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这种行为的存在使得下面的代码是有效的，即使 <code>Array.prototype.push</code> 返回一个数字，而<code>Array.prototype.forEach</code> 方法期望一个返回类型为 <code>void</code> 的函数：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> src = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> dst = [<span class="number">0</span>];</span><br><span class="line">src.<span class="title function_">forEach</span>(<span class="function">(<span class="params">el</span>) =&gt;</span> dst.<span class="title function_">push</span>(el));</span><br></pre></td></tr></table></figure>

<p>还有一个需要注意的特殊情况，当一个字面的函数定义有一个 <code>void</code> 的返回类型时，该函数<strong>必须不返回任何东西</strong>。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f3 = <span class="keyword">function</span> (<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927486.png" alt="image-20220316161210582"></p>
<h2 id="TypeScript学习第六章-对象类型"><a href="#TypeScript学习第六章-对象类型" class="headerlink" title="TypeScript学习第六章: 对象类型"></a>TypeScript学习第六章: 对象类型</h2><p>在JavaScript中，我们<strong>分组</strong>和<strong>传递数据</strong>的基本方式是通过对象。在TypeScript中，我们通过对象类型来表示这些对象。</p>
<p>正如我们所见，它们可以是<strong>匿名</strong>的：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">person: &#123; name: <span class="built_in">string</span>; age: <span class="built_in">number</span> &#125;</span>) &#123; <span class="comment">// 匿名对象&#123; name: string; age: number &#125;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + person.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者可以通过使用一个<strong>接口</strong>来命名它们：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123; <span class="comment">// 接口中定义了一个对象类型,包含name和age</span></span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">person: Person</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello &#x27;</span> + person.<span class="property">name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者<strong>类型别名</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123; <span class="comment">// 类型别名种定义了一个对象类型, 其包含name和age</span></span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">person: Person</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + person.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的三个例子中，我们写了一些函数，这些函数接收包含属性 <code>name</code> （必须是一个 <code>string</code> ）和 <code>age</code> （必须是一个 <code>number</code> ）的对象.</p>
<h3 id="6-1-属性修改器"><a href="#6-1-属性修改器" class="headerlink" title="6.1 属性修改器"></a>6.1 属性修改器</h3><p>对象类型中的每个属性都可以指定几件事：<strong>类型</strong>、<strong>属性是否是可选</strong>的，以及属<strong>性是否可以被写入</strong>。</p>
<h3 id="6-2-可选属性"><a href="#6-2-可选属性" class="headerlink" title="6.2 可选属性"></a>6.2 可选属性</h3><p>很多时候，我们会发现自己处理的对象可能有一个属性设置。在这些情况下，我们可以在这些属性的名 字后面加上一个问号（<code>?</code>），把它们标记为可选的</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Shape</span> = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">PaintOptions</span> &#123;</span><br><span class="line">    <span class="attr">shape</span>: <span class="title class_">Shape</span>;</span><br><span class="line">    xPos?: <span class="built_in">number</span>;</span><br><span class="line">    yPos?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">paintShape</span>(<span class="params">opts: PaintOptions</span>) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="attr">shape</span>: <span class="title class_">Shape</span> = &#123;&#125;</span><br><span class="line"><span class="title function_">paintShape</span>(&#123; shape &#125;);</span><br><span class="line"><span class="title function_">paintShape</span>(&#123; shape, <span class="attr">xPos</span>: <span class="number">100</span> &#125;);</span><br><span class="line"><span class="title function_">paintShape</span>(&#123; shape, <span class="attr">yPos</span>: <span class="number">100</span> &#125;);</span><br><span class="line"><span class="title function_">paintShape</span>(&#123; shape, <span class="attr">xPos</span>: <span class="number">100</span>, <span class="attr">yPos</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>在这个例子中， <code>xPos</code> 和 <code>yPos</code> 都被认为是可选的。我们可以选择提供它们中的任何一个，所以上面对 <code>paintShape</code> 的每个调用都是有效的。所有的可选性实际上是说，如果属性被设置，它最好有一个特定 的类型。</p>
<p>我们也可以从这些属性中读取，但当我们在 strictNullChecks 下读取时，TypeScript会告诉我们它们可能是未定义的。<strong>因为未赋值时值为<code>undefined</code></strong>.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">paintShape</span>(<span class="params">opts: PaintOptions</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> xPos = opts.<span class="property">xPos</span>;</span><br><span class="line">    <span class="keyword">let</span> yPos = opts.<span class="property">yPos</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在JavaScript中，即使该属性从未被设置过，我们仍然可以访问它–它只是会给我们未定义的值。我们可以专门处理未定义。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">paintShape</span>(<span class="params">opts: PaintOptions</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> xPos = opts.<span class="property">xPos</span> === <span class="literal">undefined</span> ? <span class="number">0</span> : opts.<span class="property">xPos</span>;</span><br><span class="line">	<span class="keyword">let</span> yPos = opts.<span class="property">yPos</span> === <span class="literal">undefined</span> ? <span class="number">0</span> : opts.<span class="property">yPos</span>;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，这种为未指定的值设置默认值的模式非常普遍，以至于JavaScript有语法来支持它。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">paintShape</span>(<span class="params">&#123; shape, xPos = <span class="number">0</span>, yPos = <span class="number">0</span> &#125;: PaintOptions</span>) &#123;<span class="comment">// 注意, 此时用了解构的语法, 将PaintOptions里的参数结构出来, 并给xPos和yPos设置了默认值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;x coordinate at&quot;</span>, xPos);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;y coordinate at&quot;</span>, yPos);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们为 paintShape 的参数使用了一个解构模式，并为 <code>xPos</code> 和 <code>yPos</code> 提供了默认值。现在 <code>xPos</code> 和 <code>yPos</code> 都肯定存在于 <code>paintShape</code> 的主体中，但对于 paintShape 的任何调用者来说是可选 的。</p>
<blockquote>
<p>请注意，目前还<strong>没有办法将类型注释放在解构模式</strong>中。这是因为下面的语法在JavaScript中已经有了不同的含义。</p>
</blockquote>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">redner</span>(<span class="params">args: Shape | <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params">&#123; shape: Shape, xPos: <span class="built_in">number</span> = <span class="number">100</span> /*...*/ &#125;</span>) &#123;</span><br><span class="line">    <span class="title function_">render</span>(shape);</span><br><span class="line">    <span class="title function_">render</span>(xPos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927661.png" alt="image-20220318114416875"></p>
<p>在一个对象解构模式中， <code>shape: Shape</code> 意味着 “获取属性 <code>shape</code> ，并在本地重新定义为一个名为 <code>Shape</code> 的变量。同样， <code>xPos: number</code> 创建一个名为<code>number</code>的变量，其值基于参数的 <code>xPos</code> 。</p>
<h3 id="6-3-只读属性"><a href="#6-3-只读属性" class="headerlink" title="6.3 只读属性"></a>6.3 只读属性</h3><p>对于TypeScript，属性也可以被标记为只读。虽然它不会在运行时改变任何行为，但在类型检查期间， 可以在一个属性前加<code>readonly</code>一个标记为只读的属性不能被写入.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">SomeType</span> &#123;</span><br><span class="line">	<span class="keyword">readonly</span> <span class="attr">prop</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">obj: SomeType</span>) &#123;</span><br><span class="line">    <span class="comment">// 可以读取 &#x27;obj.prop&#x27;.</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`prop has the value &#x27;<span class="subst">$&#123;obj.prop&#125;</span>&#x27;.`</span>);</span><br><span class="line">    <span class="comment">// 但不能重新设置值</span></span><br><span class="line">    obj.<span class="property">prop</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927799.png" alt="image-20220318120302281"></p>
<p>使用 <code>readonly</code> 修饰符并不一定意味着一个值是完全不可改变的。或者换句话说，它的内部内容不能被 改变，它只是意味着<strong>该属性本身不能被重新写入</strong>。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Home</span> &#123;</span><br><span class="line">	<span class="keyword">readonly</span> <span class="attr">resident</span>: &#123; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">age</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">visitForBirthday</span>(<span class="params">home: Home</span>) &#123;</span><br><span class="line">    <span class="comment">// 我们可以从&#x27;home.resident&#x27;读取和更新属性。</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Happy birthday <span class="subst">$&#123;home.resident.name&#125;</span>!`</span>);</span><br><span class="line">    home.<span class="property">resident</span>.<span class="property">age</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">evict</span>(<span class="params">home: Home</span>) &#123;</span><br><span class="line">    <span class="comment">// 但是我们不能写到&#x27;home&#x27;上的&#x27;resident&#x27;属性本身。</span></span><br><span class="line">    home.<span class="property">resident</span> = &#123;</span><br><span class="line">    	<span class="attr">name</span>: <span class="string">&quot;Victor the Evictor&quot;</span>,</span><br><span class="line">    	<span class="attr">age</span>: <span class="number">42</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927937.png" alt="image-20220318121511267"></p>
<p>管理对 <code>readonly</code> 含义的预期是很重要的。在TypeScript的开发过程中，对于一个对象应该如何被使用 的问题，它是有用的信号。TypeScript在检查两个类型的属性是否兼容时，并不考虑这些类型的属性是 否是 <code>readonly</code> ，<strong>所以 <code>readony</code> 属性也可以通过别名来改变</strong>.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadonlyPerson</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">writablePerson</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Person McPersonface&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">42</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 正常工作</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">readonlyPerson</span>: <span class="title class_">ReadonlyPerson</span> = writablePerson;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(readonlyPerson.<span class="property">age</span>); <span class="comment">// 打印 &#x27;42&#x27;</span></span><br><span class="line">writablePerson.<span class="property">age</span>++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(readonlyPerson.<span class="property">age</span>); <span class="comment">// 打印 &#x27;43&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-4-索引签名"><a href="#6-4-索引签名" class="headerlink" title="6.4 索引签名"></a>6.4 索引签名</h3><p>有时你并不提前知道一个类型的所有属性名称，但你知道值的类型。</p>
<p>在这些情况下，你可以使用一个<strong>索引签名</strong>来描述可能的值的类型，比如说：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">StringArray</span> &#123;</span><br><span class="line">	[<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">myArray</span>: <span class="title class_">StringArray</span> = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> secondItem = myArray[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>上面，我们有一个 <code>StringArray</code> 接口，它有一个索引签名。这个索引签名指出，当一个 <code>StringArray</code> 被数字索引时，它将返回一个字符串。</p>
<p>索引签名的属性类型必须是 <code>string</code> 或 <code>number</code> 。</p>
<p>支持两种类型的索引器是可能的，但是从数字索引器返回的类型必须是字符串索引器返回的类型的子类型。这是因为当用 “数字 “进行索引时，JavaScript实际上在索引到一个对象之前将其转换为 “字符串”。这意味着用 100 （一个数字）进行索引和用 “100” （一个字符串）进行索引是一样的，所以两者需要一致。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">breed</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NotOkay</span> &#123;</span><br><span class="line">	[<span class="attr">x</span>: <span class="built_in">number</span>]: <span class="title class_">Animal</span>;</span><br><span class="line">	[<span class="attr">x</span>: <span class="built_in">string</span>]: <span class="title class_">Dog</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927052.png" alt="image-20220318122304718"></p>
<p>虽然字符串索引签名是描述 “字典 “模式的一种强大方式，但它也强制要求所有的属性与它们的返回类型相匹配。这是因为字符串索引声明 <code>obj.property</code> 也可以作为 <code>obj[&quot;property&quot;]</code> 。在下面的例子中， <code>name</code> 的类型与字符串索引的类型不匹配，类型检查器会给出一个错误：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">NumberDictionary</span> &#123;</span><br><span class="line">    [<span class="attr">index</span>: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>; <span class="comment">// ok</span></span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927104.png" alt="image-20220318122351693"></p>
<p>然而，如果索引签名是属性类型的联合，不同类型的属性是可以接受的:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">NumberOrStringDictionary</span> &#123;</span><br><span class="line">    [<span class="attr">index</span>: <span class="built_in">string</span>]: <span class="built_in">number</span> | <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>; <span class="comment">// 正确, length 是 number 类型</span></span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>; <span class="comment">// 正确, name 是 string 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，你可以使索引签名为只读，以防止对其索引的赋值：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ReadonlyStringArray</span> &#123;</span><br><span class="line">	<span class="keyword">readonly</span> [<span class="attr">index</span>: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myArray</span>: <span class="title class_">ReadonlyStringArray</span> = <span class="title function_">getReadOnlyStringArray</span>();</span><br><span class="line">myArray[<span class="number">2</span>] = <span class="string">&quot;Mallory&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>你不能设置 <code>myArray[2]</code> ，因为这个索引签名是只读的。</p>
<h3 id="6-5-扩展类型"><a href="#6-5-扩展类型" class="headerlink" title="6.5 扩展类型"></a>6.5 扩展类型</h3><p>有一些类型可能是其他类型的更具体的版本，这是很常见的。例如，我们可能有一个 BasicAddress 类 型，描述发送信件和包裹所需的字段。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">BasicAddress</span> &#123;</span><br><span class="line">    name?: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">street</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">city</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">country</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">postalCode</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在某些情况下，这就足够了，但是如果一个地址的小区内有多个单元，那么地址往往有一个单元号与之 相关。我们就可以描述一个<code>AddressWithUnit</code> ：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AddressWithUnit</span> &#123;</span><br><span class="line">    name?: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">unit</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">street</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">city</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">country</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">postalCode</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就完成了工作，但这里的缺点是，当我们的变化是纯粹的加法时，我们不得不重复 BasicAddress 的 所有其他字段。相反，我们可以扩展原始的 BasicAddress 类型，只需添加 AddressWithUnit 特有的 新字段：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">BasicAddress</span> &#123;</span><br><span class="line">    name?: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">street</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">city</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">country</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">postalCode</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AddressWithUnit</span> <span class="keyword">extends</span> <span class="title class_">BasicAddress</span> &#123;</span><br><span class="line">	<span class="attr">unit</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口上的 <code>extends</code> 关键字，允许我们<strong>有效地从其他命名的类型中复制成员</strong>，并<strong>添加我们想要的任何新成员</strong>。这对于减少我们不得不写的类型声明模板，以及表明同一属性的几个不同声明可能是<strong>相关</strong>的意图来说，是非常有用的。例如， AddressWithUnit 不需要重复 street 属性，而且因为 street 源于 BasicAddress ，我们会知道这两种类型在某种程度上是相关的。</p>
<p>接口也可以从多个类型中扩展。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Colorful</span> &#123;</span><br><span class="line">	<span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">	<span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ColorfulCircle</span> <span class="keyword">extends</span> <span class="title class_">Colorful</span>, <span class="title class_">Circle</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="attr">cc</span>: <span class="title class_">ColorfulCircle</span> = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">    <span class="attr">radius</span>: <span class="number">42</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-6-交叉类型"><a href="#6-6-交叉类型" class="headerlink" title="6.6 交叉类型"></a>6.6 交叉类型</h3><p>接口允许我们通过扩展其他类型建立起新的类型。TypeScript提供了另一种结构，称为<strong>交叉类型</strong>，主要用于<strong>组合现有的对象类型</strong>。</p>
<p>交叉类型是用 <code>&amp;</code> 操作符定义的.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Colorful</span> &#123;</span><br><span class="line">	<span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">	<span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ColorfulCircle</span> = <span class="title class_">Colorful</span> &amp; <span class="title class_">Circle</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="attr">cc</span>: <span class="title class_">ColorfulCircle</span> = &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">    <span class="attr">radius</span>: <span class="number">42</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，我们将 <code>Colorful</code> 和 <code>Circle</code> 相交，产生了一个新的类型，它拥有 <code>Colorful</code> 和 <code>Circle</code> 的 所有成员。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">draw</span>(<span class="params">circle: Colorful &amp; Circle</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Color was <span class="subst">$&#123;circle.color&#125;</span>`</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Radius was <span class="subst">$&#123;circle.radius&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="title function_">draw</span>(&#123; <span class="attr">color</span>: <span class="string">&quot;blue&quot;</span>, <span class="attr">radius</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="title function_">draw</span>(&#123; <span class="attr">color</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">raidus</span>: <span class="number">42</span> &#125;);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927362.png" alt="image-20220318154900691"></p>
<h3 id="6-7-接口与交叉类型"><a href="#6-7-接口与交叉类型" class="headerlink" title="6.7 接口与交叉类型"></a>6.7 接口与交叉类型</h3><p>我们刚刚看了两种组合类型的方法，它们很相似，但实际上有细微的不同。对于接口，我们可以使用 <code>extends</code> 子句来扩展其他类型，而对于交叉类型，我们也可以做类似的事情，并用类型别名来命名结 果。两者之间的主要区别在于如何处理冲突，这种区别通常是你在接口和交叉类型的类型别名之间选择 一个的主要原因之一。</p>
<p>接口可以定义多次, 多次的声明会自动合并</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Sister</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Sister</span> &#123;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">sisterAn</span>: <span class="title class_">Sister</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;sisterAn&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">sisterRan</span>: <span class="title class_">Sister</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;sisterRan&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927406.png" alt="image-20220318172349457"></p>
<p>但是类型别名如果定义多次，会报错：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Sister</span> = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Sister</span> = &#123;</span><br><span class="line">	<span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927538.png" alt="image-20220318172503903"></p>
<h3 id="6-8-泛型对象类型"><a href="#6-8-泛型对象类型" class="headerlink" title="6.8 泛型对象类型"></a>6.8 泛型对象类型</h3><p>让我们想象一下，一个可以包含任何数值的盒子类型：字符串、数字、长颈鹿，等等.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">	<span class="attr">contents</span>: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，内容属性的类型是任意，这很有效，但会导致下一步的意外。</p>
<p>我们可以使用 <code>unknown</code> ，但这意味着在我们已经知道内容类型的情况下，我们需要做预防性检查，或者使用容易出错的类型断言。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">	<span class="attr">contents</span>: <span class="built_in">unknown</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="title class_">Box</span> = &#123;</span><br><span class="line">	<span class="attr">contents</span>: <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 我们需要检查 &#x27;x.contents&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> x.<span class="property">contents</span> === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">contents</span>.<span class="title function_">toLowerCase</span>());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 或者用类型断言</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((x.<span class="property">contents</span> <span class="keyword">as</span> <span class="built_in">string</span>).<span class="title function_">toLowerCase</span>());</span><br></pre></td></tr></table></figure>

<p>一种安全的方法是为每一种类型的内容搭建不同的盒子类型:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">NumberBox</span> &#123;</span><br><span class="line">	<span class="attr">contents</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">StringBox</span> &#123;</span><br><span class="line">	<span class="attr">contents</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BooleanBox</span> &#123;</span><br><span class="line">	<span class="attr">contents</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这意味着我们必须创建不同的函数，或函数的重载，以对这些类型进行操作：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setContents</span>(<span class="params">box: StringBox, newContents: <span class="built_in">string</span></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setContents</span>(<span class="params">box: NumberBox, newContents: <span class="built_in">number</span></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setContents</span>(<span class="params">box: BooleanBox, newContents: <span class="built_in">boolean</span></span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setContents</span>(<span class="params">box: &#123; contents: <span class="built_in">any</span> &#125;, newContents: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">	box.<span class="property">contents</span> = newContents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那是一个很大的模板。此外，我们以后可能需要引入新的类型和重载。这是令人沮丧的，因为我们的盒 子类型和重载实际上都是一样的.</p>
<p>相反, 我们可以做一个通用的<code>Box</code>类型, 声明一个参数类型:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">    <span class="attr">contents</span>: <span class="title class_">Type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以把这句话理解为：”一个类型的盒子，是它的内容具有类型的东西”。以后，当我们引用 <code>Box</code> 时， 我们必须给一个类型参数来代替 <code>Type</code> 。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">box</span>: <span class="title class_">Box</span>&lt;<span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure>

<p>把 <code>Box</code> 想象成一个真实类型的模板，其中 <code>Type</code> 是一个占位符，会被替换成其他类型。当 TypeScript看到 <code>Box&lt;string&gt;</code>时，它将用字符串替换 <code>Box&lt;Type&gt;</code> 中的每个 <code>Type</code> 实例，并最终以 <code>&#123; contents: string &#125;</code> 这样的方式工作。换句话说， <code>Box</code> 和我们之前的 <code>StringBox</code> 工作起来是一样的。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">	<span class="attr">contents</span>: <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">StringBox</span> &#123;</span><br><span class="line">	<span class="attr">contents</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">boxA</span>: <span class="title class_">Box</span>&lt;<span class="built_in">string</span>&gt; = &#123; <span class="attr">contents</span>: <span class="string">&quot;hello&quot;</span> &#125;;</span><br><span class="line">boxA.<span class="property">contents</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> <span class="attr">boxB</span>: <span class="title class_">StringBox</span> = &#123; <span class="attr">contents</span>: <span class="string">&quot;world&quot;</span> &#125;;</span><br><span class="line">boxB.<span class="property">contents</span>;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><strong>盒子是可重用的，因为Type可以用任何东西来代替</strong>。这意味着当我们需要一个新类型的盒子时，我们根 本不需要声明一个新的盒子类型（尽管如果我们想的话，我们当然可以）。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">	<span class="attr">contents</span>: <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Apple</span> &#123;</span><br><span class="line">	<span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 等价于 &#x27;&#123; contents: Apple &#125;&#x27;.</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AppleBox</span> = <span class="title class_">Box</span>&lt;<span class="title class_">Apple</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>这也意味着我们可以完全避免重载，而是使用通用函数。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> setContents&lt;<span class="title class_">Type</span>&gt;(<span class="attr">box</span>: <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt;, <span class="attr">newContents</span>: <span class="title class_">Type</span>) &#123;</span><br><span class="line">	box.<span class="property">contents</span> = newContents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用一个类型别名来代替：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">	<span class="attr">contents</span>: <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于类型别名与接口不同，它不仅可以描述对象类型，我们还可以用它来编写<strong>其他类型的通用辅助类 型</strong>。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OrNull</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> | <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OneOrMany</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> | <span class="title class_">Type</span>[];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OneOrManyOrNull</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">OrNull</span>&lt;<span class="title class_">OneOrMany</span>&lt;<span class="title class_">Type</span>&gt;&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">OneOrManyOrNullStrings</span> = <span class="title class_">OneOrManyOrNull</span>&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>我们将在稍后回到类型别名。</p>
<p>通用<strong>对象类型通常是某种容器类型</strong>，<strong>它的工作与它们所包含的元素类型无关</strong>。<strong>数据结构以这种方式工作是很理想的，这样它们就可以在不同的数据类型中重复使用</strong>。</p>
<h3 id="6-9-数组类型"><a href="#6-9-数组类型" class="headerlink" title="6.9 数组类型"></a>6.9 数组类型</h3><p>我们一直在使用这样一种类型：<strong>数组类型</strong>。每当我们写出 <code>number[]</code> 或 <code>string[]</code> 这样的类型时，这 实际上只是 <code>Array&lt;number&gt;</code> 和 <code>Array&lt;string&gt;</code> 的缩写:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">value: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;</span>) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> <span class="attr">myArray</span>: <span class="built_in">string</span>[] = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这两样都能用</span></span><br><span class="line"><span class="title function_">doSomething</span>(myArray);</span><br><span class="line"><span class="title function_">doSomething</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)); </span><br></pre></td></tr></table></figure>

<p>和上面的 Box 类型一样， <code>Array</code> 本身也是一个通用类型。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Array</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取或设置数组的长度。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 移除数组中的最后一个元素并返回。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="title function_">pop</span>(): <span class="title class_">Type</span> | <span class="literal">undefined</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 向一个数组添加新元素，并返回数组的新长度。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="title function_">push</span>(...<span class="attr">items</span>: <span class="title class_">Type</span>[]): <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现代JavaScript还提供了其他通用的数据结构，比如 <code>Map&lt;K, V&gt;</code> , <code>Set&lt;T&gt;</code> , 和 <code>Promise&lt;T&gt;</code> 。这实际上意味着，由于 <code>Map</code> 、 <code>Set</code> 和 <code>Promise</code> 的行为方式，它们可以与任何类型的集合一起工作。</p>
<h3 id="6-10-只读数组类型"><a href="#6-10-只读数组类型" class="headerlink" title="6.10 只读数组类型"></a>6.10 只读数组类型</h3><p><code>ReadonlyArray</code> 是一个特殊的类型，描述了不应该被改变的数组。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doStuff</span>(<span class="params">values: ReadonlyArray&lt;<span class="built_in">string</span>&gt;</span>) &#123;</span><br><span class="line">    <span class="comment">// 我们可以从 &#x27;values&#x27; 读数据...</span></span><br><span class="line">    <span class="keyword">const</span> copy = values.<span class="title function_">slice</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`第一个值是 <span class="subst">$&#123;values[<span class="number">0</span>]&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// ...但我们不能改变 &#x27;vulues&#x27; 的值。</span></span><br><span class="line">    values.<span class="title function_">push</span>(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927705.png" alt="image-20220318182849048"></p>
<p>和属性的 <code>readonly</code> 修饰符一样，它主要是一个<strong>我们可以用来了解意图的工具</strong>。当我们看到一个返回<code>ReadonlyArrays</code> 的函数时，它<strong>告诉我们我们根本不打算改变其内容</strong>，而当我们看到一个消耗<code>ReadonlyArrays</code> 的函数时，它告诉我们可以将任何数组传入该函数，而不用担心它会改变其内容。</p>
<p>与 Array 不同，没有一个我们可以使用的 <code>ReadonlyArray</code> 构造函数。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ReadonlyArray</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927776.png" alt="image-20220318183634902"></p>
<p>相反，我们可以将普通的 <code>Array</code> 分配给 <code>ReadonlyArray</code> 。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">roArray</span>: <span class="title class_">ReadonlyArray</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>正如 TypeScript为 <code>Array&lt;Type&gt;</code> 提供了 <code>Type[]</code> 的速记语法一样，它也为 <code>ReadonlyArray&lt;Type&gt;</code>提 供了只读 <code>Type[]</code> 的速记语法。</p>
<p>最后要注意的是，与 readony 属性修改器不同，可分配性在普通 Array 和 ReadonlyArray 之间不是 双向的。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="keyword">readonly</span> <span class="built_in">string</span>[] = [];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>: <span class="built_in">string</span>[] = [];</span><br><span class="line"> </span><br><span class="line">x = y;</span><br><span class="line">y = x;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927848.png" alt="image-20220318184952440"></p>
<h3 id="6-11-元组类型"><a href="#6-11-元组类型" class="headerlink" title="6.11 元组类型"></a>6.11 元组类型</h3><p>Tuple 类型是另一种 Array 类型，它确切地知道包含多少个元素，以及它在特定位置包含哪些类型。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">StringNumberPair</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br></pre></td></tr></table></figure>

<p>这里， <code>StringNumberPair</code> 是一个 <code>string</code> 和 <code>number</code> 的元组类型。像 <code>ReadonlyArray</code> 一样，它在运行时没有表示，但对TypeScript来说是重要的。对于类型系统来说， <code>StringNumberPair</code> 描述了其 索引 0 包含字符串和 索引1 包含数字的数组。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">pair: [<span class="built_in">string</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> a = pair[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">const</span> b = pair[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">doSomething</span>([<span class="string">&quot;hello&quot;</span>, <span class="number">42</span>])</span><br></pre></td></tr></table></figure>

<p>如果我们试图索引超过元素的数量，我们会得到一个错误：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">pair: [<span class="built_in">string</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">	<span class="keyword">const</span> c = pair[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927026.png" alt="image-20220318201702970"></p>
<p>我们还可以使用JavaScript的数组析构来对元组进行解构。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">stringHash: [<span class="built_in">string</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [inputString, hash] = stringHash;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(inputString);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(hash);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>除了这些长度检查，像这样的简单元组类型等同于 Array 的版本，它为特定的索引声明属性，并且用数字字面类型声明长度。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">StringNumberPair</span> &#123;</span><br><span class="line">    <span class="comment">// 专有属性</span></span><br><span class="line">    <span class="attr">length</span>: <span class="number">2</span>;</span><br><span class="line">    <span class="number">0</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="number">1</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">// 其他 &#x27;Array&lt;string | number&gt;&#x27; 成员...</span></span><br><span class="line">    <span class="title function_">slice</span>(start?: <span class="built_in">number</span>, end?: <span class="built_in">number</span>): <span class="title class_">Array</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一件你可能感兴趣的事情是，元组可以通过在元素的类型后面写出问号（<code>?</code>）—— 可选的元组，元素 只能出现在末尾，而且还影响到长度的类型。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Either2</span>dOr3d = [<span class="built_in">number</span>, <span class="built_in">number</span>, <span class="built_in">number</span>?];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setCoordinate</span>(<span class="params">coord: Either2dOr3d</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [x, y, z] = coord;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`提供的坐标有 <span class="subst">$&#123;coord.length&#125;</span> 个维度`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图元也可以有其余元素，这些元素必须是 <code>array</code>&#x2F;<code>tuple</code> 类型.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">StringNumberBooleans</span> = [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="built_in">boolean</span>[]];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringBooleansNumber</span> = [<span class="built_in">string</span>, ...<span class="built_in">boolean</span>[], <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">BooleansStringNumber</span> = [...<span class="built_in">boolean</span>[], <span class="built_in">string</span>, <span class="built_in">number</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><code>StringNumberBooleans</code> 描述了一个元组，其前两个元素分别是字符串和数字，但后面可以有任意数量的布尔。</li>
<li><code>StringBooleansNumber</code> 描述了一个元组，其第一个元素是字符串，然后是任意数量的布尔运算，最后是一个数字。</li>
<li><code>BooleansStringNumber</code> 描述了一个元组，其起始元素是任意数量的布尔运算，最后是一个字符 串，然后是一个数字。</li>
</ul>
<p>一个有其余元素的元组没有集合的 “长度”——它只有一组不同位置的知名元素。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">readButtonInput</span>(<span class="params">...args: [<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="built_in">boolean</span>[]]</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [name, version, ...input] = args;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(version)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(input)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="attr">data</span>: <span class="built_in">boolean</span>[] = [<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>]</span><br><span class="line"><span class="keyword">const</span> <span class="attr">args</span>:[<span class="built_in">string</span>, <span class="built_in">number</span>, ...<span class="built_in">boolean</span>[]] = [<span class="string">&quot;Hello world&quot;</span>, <span class="number">100</span>, ...data]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(args)</span><br><span class="line"><span class="title function_">readButtonInput</span>(...args)</span><br><span class="line"><span class="comment">// [ &#x27;Hello world&#x27;, 100, true, false, true ]</span></span><br><span class="line"><span class="comment">// Hello world</span></span><br><span class="line"><span class="comment">// 100</span></span><br><span class="line"><span class="comment">// [ true, false, true ]</span></span><br></pre></td></tr></table></figure>

<p>基本上等同于:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">readButtonInput</span>(<span class="params">name: <span class="built_in">string</span>, version: <span class="built_in">number</span>, ...input: <span class="built_in">boolean</span>[]</span>) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你想用一个其余(rest)参数接受可变数量的参数，并且你需要一个最小的元素数量，但你不想引入中间变量时，这很方便。</p>
<h3 id="6-12-只读元组类型"><a href="#6-12-只读元组类型" class="headerlink" title="6.12 只读元组类型"></a>6.12 只读元组类型</h3><p>关于 <code>tuple</code> 类型的最后一点说明： <code>tuple</code> 类型有只读特性，可以通过在它们前面粘贴一个 <code>readonly</code> 修饰符来指定——就像数组的速记语法一样.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">pair: <span class="keyword">readonly</span> [<span class="built_in">string</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正如你所期望的，在TypeScript中不允许向只读元组的任何属性写入:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params">pair: <span class="keyword">readonly</span> [<span class="built_in">string</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">	pair[<span class="number">0</span>] = <span class="string">&quot;hello!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在大多数代码中，元组往往被创建并不被修改，所以在可能的情况下，将类型注释为只读元组是一个很 好的默认。这一点也很重要，因为带有 <code>const</code> 断言的数组字面量将被推断为只读元组类型.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point = [<span class="number">3</span>, <span class="number">4</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">distanceFromOrigin</span>(<span class="params">[x, y]: [<span class="built_in">number</span>, <span class="built_in">number</span>]</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(x ** <span class="number">2</span> + y ** <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">distanceFromOrigin</span>(point);</span><br></pre></td></tr></table></figure>

<p>在这里， <code>distanceFromOrigin</code> 从未修改过它的元素，而是期望一个可变的元组。由于 <code>point</code> 的类型被推断为只读的 <code>[3, 4]</code> ，它与 <code>[number, number]</code> 不兼容，因为该类型不能保证 <code>point</code> 的元素不被修改。</p>
<h2 id="TypeScript学习第七章-类型操纵"><a href="#TypeScript学习第七章-类型操纵" class="headerlink" title="TypeScript学习第七章: 类型操纵"></a>TypeScript学习第七章: 类型操纵</h2><h3 id="7-0-从类型中创建类型"><a href="#7-0-从类型中创建类型" class="headerlink" title="7.0 从类型中创建类型"></a>7.0 从类型中创建类型</h3><p>TS的类型系统非常强大, 因为它允许使用其他类型的术语来表达类型.</p>
<p>这个想法的最简单的形式是<strong>泛型</strong>, 我们实际上有各种各样的类型操作符可以使用. 也可以用我们已经有的值来表达类型.</p>
<p>通过结合各种类型操作符，我们可以用一种简洁、可维护的方式来表达复杂的操作和值. 在本节中，我们将介绍用现有的类型或值来表达一个新类型的方法.</p>
<ul>
<li>泛型型 - 带参数的类型</li>
<li>Keyof 类型操作符- <code>keyof</code> 操作符创建新类型</li>
<li>Typeof 类型操作符 - 使用 <code>typeof</code> 操作符来创建新的类型</li>
<li>索引访问类型 - 使用 <code>Type[&#39;a&#39;]</code> 语法来访问一个类型的子集</li>
<li>条件类型 - 在类型系统中像<code>if</code>语句一样行事的类型</li>
<li>映射类型 - 通过映射现有类型中的每个属性来创建类型</li>
<li>模板字面量类型 - 通过模板字面字符串改变属性的映射类型</li>
</ul>
<h3 id="7-1-泛型"><a href="#7-1-泛型" class="headerlink" title="7.1 泛型"></a>7.1 泛型</h3><p>软件工程的一个主要部分是建立组件，这些组件不仅有定义明确和一致的API，而且还可以<strong>重复使用</strong>。能够处理今天的数据和明天的数据的组件将为你建立大型软件系统提供最灵活的能力。</p>
<p>泛型能够创建一个在各种类型上工作的组件，而不是单一的类型。这使得用户可以消费这些组件并使用他们自己的类型。</p>
<h4 id="7-1-1-Hello-World"><a href="#7-1-1-Hello-World" class="headerlink" title="7.1.1 Hello World"></a>7.1.1 Hello World</h4><p>首先, 让我们做一下泛型的”Hello World”: 身份函数. <strong>身份函数使用个函数, 他将返回传入的任何内容</strong>. 你一用类似于echo命令的方式来考虑它.</p>
<p>如果没有泛型, 我们将不得不给身份函数一个特定的类型.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">echo</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，我们可以用任意类型来描述身份函数:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">echo</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="built_in">any</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>any</code> 当然是通用的，因为它将使函数接受 <code>arg</code> 类型的任何和所有的类型，但实际上<strong>我们在函数返回时失去了关于该类型的信息</strong>。如果我们传入一个数字，我们唯一的信息就是任何类型都可以被返回。</p>
<p>相反，我们需要一种方法来捕获参数的类型，以便我们也可以用它来表示返回的内容。在这里，我们将使用一个类型变量，这是一种特殊的变量，对类型而不是数值起作用。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> echo&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在已经在身份函数中添加了一个类型变量 <code>Type</code> 。这个 <code>Type</code> 允许我们捕获用户提供的类型（例如数字），这样我们就可以在以后使用这些信息。这里，我们再次使用<code>Type</code>作为返回类型。经过检查， 我们现在可以看到参数和返回类型使用的是相同的类型。这使得我们可以将类型信息从函数的一侧输入，然后从另一侧输出。</p>
<p>我们说这个版本的身份函数是通用的，因为它在一系列的类型上工作。与使用任何类型不同的是，它也和第一个使用数字作为参数和返回类型的身份函数一样精确（即，它不会丢失任何信息）。</p>
<p>一旦我们写好了通用身份函数，我们就可以用两种方式之一来调用它。第一种方式是将所有的参数，包括类型参数，都传递给函数：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> output = echo&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;myString&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这里我们明确地将 <code>Type</code> 设置为 <code>string</code> ，作为函数调用的参数之一，用参数周围的 <code>&lt;&gt;</code> 而不是 <code>()</code> 来表示。</p>
<p>第二种方式可能也是最常见的。这里我们使用类型参数推理——也就是说，我们希望编译器根据我们传入的参数的类型，自动为我们设置 <code>Type</code> 的值。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> output = <span class="title function_">echo</span>(<span class="string">&quot;myString&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>注意，我们不必在角括号（<code>&lt;&gt;</code>）中明确地传递类型；编译器只是查看了 <code>&quot;myString &quot;</code>这个值，并将<code>Type</code>设置为其类型。虽然类型参数推断是一个有用的工具，可以使代码更短、更易读，但当编译器不能推断出类型时，你可能需要像我们在前面的例子中那样明确地传入类型参数，这在更复杂的例子中可能发生。</p>
<h4 id="7-1-2-使用通用类型变量"><a href="#7-1-2-使用通用类型变量" class="headerlink" title="7.1.2 使用通用类型变量"></a>7.1.2 使用通用类型变量</h4><p>当你开始使用泛型时，你会注意到，当你创建像<code>echo</code> 这样的泛型函数时，编译器会强制要求你在函数主体中正确使用任何泛型参数。也就是说，你实际上是把这些参数当作是任何和所有的类型。</p>
<p>让我们来看看我们前面的<code>echo</code>函数。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> echo&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们想在每次调用时将参数<code>arg</code>的长度记录到控制台，该怎么办？我们可能很想这样写：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> loggingIdentity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927125.png" alt="image-20220319155123528"></p>
<p>当我们这样做时，编译器会给我们一个错误，说我们在使用 <code>arg</code> 的 <code>.length</code> 成员，但我们没有说<code>arg</code> 有这个成员。记住，我们在前面说过，这些类型的变量可以代表任何和所有的类型，所以使用这个函数的人可以传入一个 <code>number</code>类型的数字 ，而这个数字没有一个 <code>.length</code> 成员。</p>
<p>比方说，我们实际上是想让这个函数在 <code>Type</code> 的数组上工作，而不是直接在 <code>Type</code> 上工作。既然我们在 处理数组，那么 <code>.length</code> 成员应该是可用的。我们可以像创建其他类型的数组那样来描述它。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> loggingIdentity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>[]): <span class="title class_">Type</span>[] &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>你可以把 <code>loggingIdentity</code> 的类型理解为 “通用函数 <code>loggingIdentity</code> 接收一个类型参数 <code>Type</code> 和一个参数<code>arg</code> ， <code>arg</code> 是一个 Type 数组，并返回一个 <code>Type</code> 数组。” 如果我们传入一个数字数组，我们会得到一个数字数组，因为<code>Type</code>会绑定到数字。这允许我们使用我们的通用类型变量 <code>Type</code> 作为我们正在处理的类型的一部分，而不是整个类型，给我们更大的灵活性。</p>
<p>我们也可以这样来写这个例子:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> loggingIdentity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Type</span>&gt;): <span class="title class_">Array</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>); <span class="comment">// 数组有一个.length，所以不会再出错了</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能已经从其他语言中熟悉了这种类型的风格。在下一节中，我们将介绍如何创建你自己的通用类型，如 <code>Array&lt;Type&gt;</code>.</p>
<h4 id="7-1-3-泛型接口"><a href="#7-1-3-泛型接口" class="headerlink" title="7.1.3 泛型接口"></a>7.1.3 泛型接口</h4><p>在前几节中，我们创建了在一系列类型上工作的通用身份函数。在这一节中，我们将探讨函数本身的类型以及如何创建通用接口。</p>
<p>泛型函数的类型与非泛型函数的类型一样，类型参数列在前面，与函数声明类似：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: &lt;<span class="title class_">Type</span>&gt;<span class="function">(<span class="params">arg: Type</span>) =&gt;</span> <span class="title class_">Type</span> = identity</span><br></pre></td></tr></table></figure>

<p>我们也可以为类型中的通用类型参数使用一个不同的名字，只要类型变量的数量和类型变量的使用方式一致。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: &lt;<span class="title class_">Input</span>&gt;<span class="function">(<span class="params">arg: Input</span>) =&gt;</span> <span class="title class_">Input</span> = identity</span><br></pre></td></tr></table></figure>

<p>我们也可以把泛型写成一个<strong>对象字面类型的调用签名</strong>。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: &#123; &lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#125; = identity</span><br></pre></td></tr></table></figure>

<p>这让我们开始编写我们的第一个泛型接口。让我们把前面例子中的对象字面类型移到一个接口中。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericIdentityFn</span> &#123;</span><br><span class="line">	&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: <span class="title class_">GenericIdentityFn</span> = identity</span><br></pre></td></tr></table></figure>

<p>在一个类似的例子中，我们<strong>可能想把通用参数移到整个接口的参数上</strong>。<strong>这可以让我们看到我们的泛型是什么类型</strong>（例如， <code>Dictionary&lt;string&gt;</code> 而不是仅仅 <code>Dictionary</code> ）。这使得类型参数对接口的所有其他成员可见。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericIdentityFn</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">	(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> identity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">myIdentity</span>: <span class="title class_">GenericIdentityFn</span>&lt;<span class="built_in">number</span>&gt; = identity</span><br></pre></td></tr></table></figure>

<p>请注意，我们的例子已经改变了，变成了稍微不同的东西。我们现在没有描述一个泛型函数，而是有一个<strong>非泛型的函数签名</strong>，它是<strong>泛型类型的一部分</strong>。当我们使用 <code>GenericIdentityFn</code> 时，我们现在还<strong>需要指定相应的类型参数</strong>（这里是：number），有效地锁定了底层调用签名将使用什么。了解什么时候把类型参数直接放在调用签名上，什么时候把它放在接口本身，将有助于描述一个类型的哪些方面是通用的。</p>
<p>除了<strong>泛型接口</strong>之外，我们还可以创建<strong>泛型类</strong>。注意，不可能创建泛型枚举和命名空间。</p>
<h4 id="7-1-4-泛型类"><a href="#7-1-4-泛型类" class="headerlink" title="7.1.4 泛型类"></a>7.1.4 泛型类</h4><p>一个泛型类的形状与泛型接口相似。泛型类在类的名字后面有一个角括号（<code>&lt;&gt;</code>）中的泛型参数列表.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericNumber</span>&lt;<span class="title class_">NumType</span>&gt; &#123;</span><br><span class="line">	<span class="attr">zeroValue</span>: <span class="title class_">NumType</span>;</span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params">x: NumType, y: NumType</span>) =&gt;</span> <span class="title class_">NumType</span> </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">zeroValue:NumType, fn: (x: NumType, y: NumType) =&gt; NumType </span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">zeroValue</span> = zeroValue</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">add</span> = fn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> <span class="title class_">GenericNumber</span>&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>, <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myGenericNumber.<span class="property">zeroValue</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myGenericNumber.<span class="title function_">add</span>(<span class="number">100</span>, <span class="number">200</span>)) <span class="comment">// 300</span></span><br></pre></td></tr></table></figure>

<p>这是对 <code>GenericNumber</code> 类相当直白的使用，但你可能已经注意到，没有任何东西限制它只能使用数字类型。我们本可以使用字符串或更复杂的对象。</p>
<p>就像接口一样，把类型参数放在类本身，可以让我们确保类的所有属性都与相同的类型一起工作。</p>
<p>正如我们在关于类的章节中提到的，一个类的类型有两个方面：<strong>静态方面</strong>和<strong>实例方面</strong>。通用类只在其实例侧而非静态侧具有通用性，所以在使用类时，静态成员不能使用类的类型参数。</p>
<h4 id="7-1-5-泛型约束"><a href="#7-1-5-泛型约束" class="headerlink" title="7.1.5 泛型约束"></a>7.1.5 泛型约束</h4><p>如果你还记得前面的例子，你有时可能想写一个通用函数，在一组类型上工作，而你对这组类型会有什么能力有一定的了解。在我们的 <code>loggingIdentity</code> 例子中，我们希望能够访问 <code>arg.length</code> 属性，但是编译器无法证明每个类型都有一个 <code>.length</code> 属性，所以它警告我们不能做这个假设:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> loggingIdentity&lt;<span class="title class_">Type</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望限制这个函数与 <code>any</code> 和所有类型一起工作，而不是与 <code>any</code> 和所有同时具有 <code>.length</code> 属性的类型一起工作。只要这个类型有这个成员，我们就允许它，但它必须至少有这个成员。要做到这一点，我们必须把我们的要求作为一个约束条件列在 <code>Type</code> 可以是什么。</p>
<p>为了做到这一点，我们将创建一个接口来描述我们的约束。在这里，我们将创建一个接口，它有一个单一的 <code>.length</code>属性，然后我们将使用这个结合 <code>extends</code> 关键字来表示我们的约束条件。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthwise</span> &#123; <span class="comment">//接口声明了一个具有number的对象</span></span><br><span class="line">	<span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> loggingIdentity&lt;<span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">arg</span>: <span class="title class_">Type</span>): <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>); <span class="comment">// 现在我们知道它有一个 .length 属性，所以不再有错误了</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为泛型函数现在被限制了，它将不再对 <code>any</code> 和<code>所有的类型</code>起作用。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">loggingIdentity</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927347.png" alt="image-20220319163625405"></p>
<p>相反，我们需要传入其类型具有所有所需属性的值。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">loggingIdentity</span>(&#123; <span class="attr">length</span>: <span class="number">10</span>, <span class="attr">value</span>: <span class="number">3</span> &#125;);</span><br><span class="line"><span class="title function_">loggingIdentity</span>([<span class="string">&quot;sdas&quot;</span>,<span class="string">&#x27;sdasd&#x27;</span>])</span><br></pre></td></tr></table></figure>

<h4 id="7-1-6-在泛型约束中使用类型参数"><a href="#7-1-6-在泛型约束中使用类型参数" class="headerlink" title="7.1.6 在泛型约束中使用类型参数"></a>7.1.6 在泛型约束中使用类型参数</h4><p>你可以声明一个受另一个类型参数约束的类型参数。例如，在这里我们想<strong>从一个给定名称的对象中获取一个属性</strong>。我们想确保我们不会意外地获取一个不存在于 <code>obj</code> 上的属性，所以我们要在这两种类型之间放置一个约束条件。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getProperty&lt;<span class="title class_">Type</span>, <span class="title class_">Key</span> <span class="keyword">extends</span> keyof <span class="title class_">Type</span>&gt;(<span class="attr">obj</span>: <span class="title class_">Type</span>, <span class="attr">key</span>: <span class="title class_">Key</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="title function_">getProperty</span>(x, <span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="title function_">getProperty</span>(x, <span class="string">&quot;m&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927399.png" alt="image-20220319164046297"></p>
<h4 id="7-1-7-在泛型中使用类类型"><a href="#7-1-7-在泛型中使用类类型" class="headerlink" title="7.1.7 在泛型中使用类类型"></a>7.1.7 在泛型中使用类类型</h4><p>在TS中使用泛型创建工厂时，有必要通过其构造函数来引用类的类型。比如说：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> create&lt;<span class="title class_">Type</span>&gt;(<span class="attr">c</span>: &#123; <span class="keyword">new</span> (): <span class="title class_">Type</span> &#125;): <span class="title class_">Type</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">c</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个更高级的例子，使用<strong>原型属性</strong>来推断和约束类类型的构造函数和实例方之间的关系。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BeeKeeper</span> &#123;</span><br><span class="line">	<span class="attr">hasMask</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ZooKeeper</span> &#123;</span><br><span class="line">	<span class="attr">nametag</span>: <span class="built_in">string</span> = <span class="string">&quot;Mikle&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="attr">numLegs</span>: <span class="built_in">number</span> = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bee</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">	<span class="attr">keeper</span>: <span class="title class_">BeeKeeper</span> = <span class="keyword">new</span> <span class="title class_">BeeKeeper</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lion</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">	<span class="attr">keeper</span>: <span class="title class_">ZooKeeper</span> = <span class="keyword">new</span> <span class="title class_">ZooKeeper</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> createInstance&lt;A <span class="keyword">extends</span> <span class="title class_">Animal</span>&gt;(<span class="attr">c</span>: <span class="keyword">new</span> () =&gt; A): A &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">c</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="attr">lionNametag</span>:<span class="built_in">string</span> = <span class="title function_">createInstance</span>(<span class="title class_">Lion</span>).<span class="property">keeper</span>.<span class="property">nametag</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BeeMask</span>:<span class="built_in">boolean</span> = <span class="title function_">createInstance</span>(<span class="title class_">Bee</span>).<span class="property">keeper</span>.<span class="property">hasMask</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(lionNametag, <span class="title class_">BeeMask</span>) <span class="comment">// Mikle true</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-keyOf类型操作符"><a href="#7-2-keyOf类型操作符" class="headerlink" title="7.2 keyOf类型操作符"></a>7.2 <code>keyOf</code>类型操作符</h3><p><code>keyof</code> 运算符<strong>接收一个对象类型</strong>，并<strong>产生其键的字符串或数字字面联合</strong>。下面的类型<code>P</code>与 <code>&quot;x&quot;|&quot;y &quot;</code>是同一类型。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Point</span> = &#123; <span class="attr">x</span>: <span class="built_in">number</span>; <span class="attr">y</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> P = keyof <span class="title class_">Point</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p1</span>:P = <span class="string">&#x27;x&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p2</span>:P = <span class="string">&#x27;y&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果该类型有一个字符串或数字索引签名， <code>keyof</code> 将返回这些类型。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Arrayish</span> = &#123; [<span class="attr">n</span>: <span class="built_in">number</span>]: <span class="built_in">unknown</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> A = keyof <span class="title class_">Arrayish</span>; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>:A = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Mapish</span> = &#123; [<span class="attr">k</span>: <span class="built_in">string</span>]: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> M = keyof <span class="title class_">Mapish</span>; <span class="comment">// string|number</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">m</span>:M = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">m2</span>:M = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>注意，在这个例子中， <code>M</code>是 <code>string|number</code> ——这是因为<strong>JavaScript对象的键总是被强制为字符串，所以 <code>obj[0]</code>总是与<code>obj[&quot;0&quot;]</code>相同.</strong></p>
<p><code>keyof</code>类型在与映射类型结合时变得特别有用，我们将在后面进一步了解。</p>
<h3 id="7-3-typeof类型操作符"><a href="#7-3-typeof类型操作符" class="headerlink" title="7.3 typeof类型操作符"></a>7.3 <code>typeof</code>类型操作符</h3><p>JavaScript已经有一个 <code>typeof</code> 操作符，你可以在表达式上下文中使用。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出 &quot;string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&quot;Hello world&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>TypeScript添加了一个 <code>typeof</code> 操作符，你可以在类型上下文中使用它来引用一个变量或属性的类型</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">n</span>: <span class="keyword">typeof</span> s;</span><br><span class="line">n = <span class="string">&#x27;world&#x27;</span></span><br><span class="line">n= <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927531.png" alt="image-20220319171226789"></p>
<p>这对基本类型来说不是很有用，但结合其他类型操作符，你可以使用<code>typeof</code>来方便地表达许多模式。举一个例子，让我们先看看预定义的类型 <code>ReturnType&lt;T&gt;</code> 。它接收一个<strong>函数类型并产生其返回类型</strong>：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Predicate</span> = <span class="function">(<span class="params">x: <span class="built_in">unknown</span></span>) =&gt;</span> <span class="built_in">boolean</span>;</span><br><span class="line"><span class="keyword">type</span> K = <span class="title class_">ReturnType</span>&lt;<span class="title class_">Predicate</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>如果我们试图在一个函数名上使用 <code>ReturnType</code> ，我们会看到一个指示性的错误。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">3</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> P = <span class="title class_">ReturnType</span>&lt;f&gt;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927675.png" alt="image-20220319171912944"></p>
<p>请记住，值和类型并不是一回事。为了指代值<code>f</code>的类型，我们使用 <code>typeof</code> 。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">3</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> P = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> f&gt;</span><br></pre></td></tr></table></figure>

<p>TypeScript 故意限制了你可以使用 <code>typeof</code> 的表达式种类。</p>
<p>具体来说，只有在标识符（即变量名）或其属性上使用<code>typeof</code>是合法的。这有助于避免混乱的陷阱，即编写你认为是在执行的代码，但其实不是。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们认为使用 = ReturnType&lt;typeof msgbox&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">shouldContinue</span>: <span class="keyword">typeof</span> <span class="title function_">msgbox</span>(<span class="string">&quot;Are you sure you want to continue?&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927738.png" alt="image-20220319173349705"></p>
<h3 id="7-4-索引访问类型"><a href="#7-4-索引访问类型" class="headerlink" title="7.4 索引访问类型"></a>7.4 索引访问类型</h3><p>我们可以使用一个索引访问类型来查询另一个类型上的特定属性:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123; <span class="attr">age</span>: <span class="built_in">number</span>; <span class="attr">name</span>: <span class="built_in">string</span>; <span class="attr">alive</span>: <span class="built_in">boolean</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[<span class="string">&quot;age&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">age1</span>: <span class="title class_">Age</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">age2</span>: <span class="title class_">Age</span> = <span class="string">&quot;1100&quot;</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927809.png" alt="image-20220319173757408"></p>
<p>索引类型本身就是一个类型，所以我们可以完全使用 <code>unions</code>、 <code>keyof</code> 或者其他类型。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">alive</span>: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// type I1 = string | number</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">Person</span>[<span class="string">&quot;age&quot;</span> | <span class="string">&quot;name&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">i11</span>:<span class="variable constant_">I1</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">i12</span>:<span class="variable constant_">I1</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// type I2 = string | number | boolean</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">I2</span> = <span class="title class_">Person</span>[keyof <span class="title class_">Person</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">i21</span>:<span class="variable constant_">I2</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">i22</span>:<span class="variable constant_">I2</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">i23</span>:<span class="variable constant_">I2</span> = <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// type I3 = Person[AliveOrName];</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">AliveOrName</span> = <span class="string">&quot;alive&quot;</span> | <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">aon1</span>:<span class="title class_">AliveOrName</span> = <span class="string">&#x27;alive&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">aon2</span>:<span class="title class_">AliveOrName</span> = <span class="string">&#x27;name&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果你试图索引一个不存在的属性，你甚至会看到一个错误：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="variable constant_">I1</span> = <span class="title class_">Person</span>[<span class="string">&quot;alve&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927919.png" alt="image-20220319174550622"></p>
<p>另一个使用任意类型进行索引的例子是使用 <code>number</code> 来获取一个数组元素的类型。我们可以把它和<code>typeof</code> 结合起来，方便地获取一个数组字面的元素类型。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyArray</span> = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">15</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span>, <span class="attr">age</span>: <span class="number">23</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&quot;Eve&quot;</span>, <span class="attr">age</span>: <span class="number">38</span> &#125;,</span><br><span class="line">    ];</span><br><span class="line"><span class="comment">/* type Person = &#123;</span></span><br><span class="line"><span class="comment">    name: string;</span></span><br><span class="line"><span class="comment">    age: number;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = <span class="keyword">typeof</span> <span class="title class_">MyArray</span>[<span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>:<span class="title class_">Person</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;xiaoqian&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// type Age = number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="keyword">typeof</span> <span class="title class_">MyArray</span>[<span class="built_in">number</span>][<span class="string">&quot;age&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">age</span>:<span class="title class_">Age</span> = <span class="number">11</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// type Age2 = number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age2</span> = <span class="title class_">Person</span>[<span class="string">&quot;age&quot;</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="attr">age2</span>:<span class="title class_">Age2</span> = <span class="number">11</span></span><br></pre></td></tr></table></figure>

<p>你只能在索引时使用类型，这意味着你不能使用 <code>const</code> 来做一个变量引用:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> key = <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[key];</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927035.png" alt="image-20220319181153794"></p>
<p>然而，你可以使用类型别名来实现类似的重构风格：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> key = <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Age</span> = <span class="title class_">Person</span>[key];</span><br></pre></td></tr></table></figure>

<h3 id="7-5-条件类型"><a href="#7-5-条件类型" class="headerlink" title="7.5 条件类型"></a>7.5 条件类型</h3><p>在大多数有用的程序的核心，我们必须根据输入来做决定。<code>JavaScript</code>程序也不例外，但鉴于数值可以很容易地被内省，这些决定也是基于输入的类型。条件类型有助于描述输入和输出的类型之间的关系。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="title function_">live</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="title function_">woof</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// type Example1 = number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Example1</span> = <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> ? <span class="built_in">number</span> : <span class="built_in">string</span>;</span><br><span class="line"><span class="comment">// type Example2 = string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Example2</span> = <span class="title class_">RegExp</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> ? <span class="built_in">number</span> : <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>

<p>条件类型的形式看起来有点像JavaScript中的条件表达式（ <code>condition? trueExpression : falseExpression</code>)</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">SomeType</span> <span class="keyword">extends</span> <span class="title class_">OtherType</span> ? <span class="title class_">TrueType</span> : <span class="title class_">FalseType</span>;</span><br></pre></td></tr></table></figure>

<p>当 <strong>extends 左边的类型可以赋值给右边的类型时，那么你将得到第一个分支中的类型（”真 “分支）； 否则你将得到后一个分支中的类型（”假 “分支）</strong>。</p>
<p><strong>子类可以赋值给父类!!!</strong></p>
<p>从上面的例子来看，条件类型可能并不立即显得有用——我们可以告诉自己是否 <code>Dog extends Animal</code> ，并选择 <code>number</code> 或 <code>string</code> ！</p>
<p>但条件类型的威力来自于它所带来的好处。条件类型的力量来自于将它们与泛型一起使用。</p>
<p>例如，让我们来看看下面这个 <code>createLabel</code> 函数：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IdLabel</span> &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="built_in">number</span> <span class="comment">/* 一些字段 */</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NameLabel</span> &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span> <span class="comment">/* 另一些字段 */</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createLabel</span>(<span class="params">id: <span class="built_in">number</span></span>): <span class="title class_">IdLabel</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createLabel</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title class_">NameLabel</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createLabel</span>(<span class="params">nameOrId: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title class_">IdLabel</span> | <span class="title class_">NameLabel</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createLabel</span>(<span class="params">nameOrId: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title class_">IdLabel</span> | <span class="title class_">NameLabel</span> &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="string">&quot;unimplemented&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createLabel</code>的这些重载描述了一个单一的JavaScript函数，该函数根据其输入的类型做出选择。注意 一些事情：</p>
<ul>
<li>如果一个库必须在其API中反复做出同样的选择，这就会变得很麻烦。</li>
<li>我们必须创建三个重载：一个用于确定类型的情况（一个用于 <code>string</code> ，一个用于 <code>number</code> ），一个用于最一般的情况（取一个 <code>string | number</code> ）。对于 <code>createLabel</code> 所能处理的每一种新类型，重载的数量都会呈指数级增长。</li>
</ul>
<p>相反，我们可以在一个条件类型中对该逻辑进行编码：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">NameOrId</span>&lt;T <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span>&gt; = T <span class="keyword">extends</span> <span class="built_in">number</span></span><br><span class="line">? <span class="title class_">IdLabel</span></span><br><span class="line">: <span class="title class_">NameLabel</span>;</span><br></pre></td></tr></table></figure>

<p>然后我们可以使用该条件类型，将我们的重载简化为一个没有重载的单一函数。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IdLabel</span> &#123;</span><br><span class="line">	<span class="attr">id</span>: <span class="built_in">number</span> <span class="comment">/* some fields */</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">NameLabel</span> &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="built_in">string</span> <span class="comment">/* other fields */</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NameOrId</span>&lt;T <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span>&gt; = T <span class="keyword">extends</span> <span class="built_in">number</span>? <span class="title class_">IdLabel</span>: <span class="title class_">NameLabel</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> createLabel&lt;T <span class="keyword">extends</span> <span class="built_in">number</span> | <span class="built_in">string</span>&gt;(<span class="attr">idOrName</span>: T): <span class="title class_">NameOrId</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="string">&quot;unimplemented&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// let a: NameLabel</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="title function_">createLabel</span>(<span class="string">&quot;typescript&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// let b: IdLabel</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="title function_">createLabel</span>(<span class="number">2.8</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// let c: NameLabel | IdLabel</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="title function_">createLabel</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() ? <span class="string">&quot;hello&quot;</span> : <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<h4 id="7-5-1-条件类型约束"><a href="#7-5-1-条件类型约束" class="headerlink" title="7.5.1 条件类型约束"></a>7.5.1 条件类型约束</h4><p>通常，条件类型中的检查会给我们提供一些新的信息。就像用类型守卫缩小范围可以给我们一个更具体的类型一样，条件类型的真正分支将通过我们检查的类型进一步约束泛型。</p>
<p>例如, 让我们来看下面的例子:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Message</span>&lt;T&gt; = T[<span class="string">&quot;message&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927248.png" alt="image-20220319215006086"></p>
<p>在这个例子中，TypeScript出错是因为 <code>T</code> 不知道有一个叫做 <code>message</code> 的属性。我们可以对 <code>T</code> 进行约束，TypeScript就不会再抱怨。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MessageOf</span>&lt;T <span class="keyword">extends</span> &#123; <span class="attr">message</span>: <span class="built_in">unknown</span> &#125;&gt; = T[<span class="string">&quot;message&quot;</span>];</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Email</span> &#123;</span><br><span class="line">	<span class="attr">message</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EmailMessageContents</span> = <span class="title class_">MessageOf</span>&lt;<span class="title class_">Email</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>然而，如果我们想让 <code>MessageOf</code> 接受任何类型，并在消息属性不可用的情况下，默认为 <code>never</code> 类型 呢？我们可以通过将约束条件移出，并引入一个条件类型来做到这一点。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MessageOf</span>&lt;T&gt; = T <span class="keyword">extends</span> &#123; <span class="attr">message</span>: <span class="built_in">unknown</span> &#125; ? T[<span class="string">&quot;message&quot;</span>] : <span class="built_in">never</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Email</span> &#123;</span><br><span class="line">	<span class="attr">message</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">	<span class="title function_">bark</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// type EmailMessageContents = string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">EmailMessageContents</span> = <span class="title class_">MessageOf</span>&lt;<span class="title class_">Email</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">emc</span>:<span class="title class_">EmailMessageContents</span> = <span class="string">&#x27;balabala...&#x27;</span></span><br><span class="line"><span class="comment">// type DogMessageContents = never</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DogMessageContents</span> = <span class="title class_">MessageOf</span>&lt;<span class="title class_">Dog</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">dmc</span>:<span class="title class_">DogMessageContents</span> = <span class="string">&#x27;error&#x27;</span> <span class="keyword">as</span> <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<p>在真正的分支中，TypeScript知道 <code>T</code> 会有一个消息属性。</p>
<p>作为另一个例子，我们也可以写一个叫做 <code>Flatten</code> 的类型，<strong>将数组类型平铺到它们的元素类型上</strong>，但在其他方面则不做处理.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Flatten</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">any</span>[] ? T[<span class="built_in">number</span>] : T;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 提取出元素类型</span></span><br><span class="line"><span class="comment">// type Str = string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Str</span> = <span class="title class_">Flatten</span>&lt;<span class="built_in">string</span>[]&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 单独一个类型。</span></span><br><span class="line"><span class="comment">// type Num = number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Num</span> = <span class="title class_">Flatten</span>&lt;<span class="built_in">number</span>&gt;</span><br></pre></td></tr></table></figure>

<p>当 <code>Flatten</code> 被赋予一个数组类型时，它使用一个带有数字的索引访问来获取 <code>string[]</code> 的元素类型。 否则，它只是返回它被赋予的类型。</p>
<h4 id="7-5-2-在条件类型内进行推理"><a href="#7-5-2-在条件类型内进行推理" class="headerlink" title="7.5.2 在条件类型内进行推理"></a>7.5.2 在条件类型内进行推理</h4><p>我们只是发现自己使用条件类型来应用约束条件，然后提取出类型。这最终成为一种常见的操作，而条件类型使它变得更容易。</p>
<p>条件类型为我们提供了一种方法来推断我们在真实分支中使用 <code>infer</code> 关键字进行对比的类型。例如, 我们可以在 <code>Flatten</code> 中推断出元素类型，而不是用索引访问类型 “手动 “提取出来。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Flatten</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;infer <span class="title class_">Item</span>&gt; ? <span class="title class_">Item</span> : <span class="title class_">Type</span></span><br></pre></td></tr></table></figure>

<p>在这里，我们使用 <code>infer</code> 关键字来声明性地引入一个名为 <code>Item</code> 的新的通用类型变量，而不是指定如何在真实分支中检索 <code>Type</code> 的元素类型。这使我们不必考虑如何挖掘和探测我们感兴趣的类型的结构。</p>
<p>我们可以使用 <code>infer</code> 关键字编写一些有用的辅助类型别名。例如，对于简单的情况，我们可以从函数类型中提取出返回类型。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">GetReturnType</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">never</span>[]) =&gt; infer <span class="title class_">Return</span>? <span class="title class_">Return</span> : <span class="built_in">never</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// type Num = number</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Num</span> = <span class="title class_">GetReturnType</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="comment">// type Str = string</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Str</span> = <span class="title class_">GetReturnType</span>&lt;<span class="function">(<span class="params">x: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="comment">// type Bools = boolean[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Bools</span> = <span class="title class_">GetReturnType</span>&lt;<span class="function">(<span class="params">a: <span class="built_in">boolean</span>, b: <span class="built_in">boolean</span></span>) =&gt;</span> <span class="built_in">boolean</span>[]&gt;;</span><br><span class="line"><span class="comment">// 给泛型传入 string 类型，条件类型会返回 never</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Never</span> = <span class="title class_">GetReturnType</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">nev</span>:<span class="title class_">Never</span> = <span class="string">&#x27;error&#x27;</span> <span class="keyword">as</span> <span class="built_in">never</span></span><br></pre></td></tr></table></figure>

<p>当从一个具有多个调用签名的类型（如重载函数的类型）进行推断时，从最后一个签名进行推断（据推测，这是最容许的万能情况）。不可能根据参数类型的列表来执行重载解析。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">stringOrNum</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">stringOrNum</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> <span class="title function_">stringOrNum</span>(<span class="params">x: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// type T1 = string | number</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">ReturnType</span>&lt;<span class="keyword">typeof</span> stringOrNum&gt;;</span><br></pre></td></tr></table></figure>

<h4 id="7-5-3-分布式条件类型"><a href="#7-5-3-分布式条件类型" class="headerlink" title="7.5.3 分布式条件类型"></a>7.5.3 分布式条件类型</h4><p>当条件类型作用于一个通用类型时，当给定一个联合类型时，它们就变成了分布式的。例如，以下面的例子为例：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToArray</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="built_in">any</span>? <span class="title class_">Type</span>[] : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure>

<p>如果我们将一个联合类型插入<code>ToArray</code>，那么条件类型将被应用于该联合的每个成员。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToArray</span>&lt;<span class="title class_">Type</span>&gt; = <span class="title class_">Type</span> <span class="keyword">extends</span> <span class="built_in">any</span> ? <span class="title class_">Type</span>[] : <span class="built_in">never</span>;</span><br><span class="line"><span class="comment">// type StrArrOrNumArr = string[] | number[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StrArrOrNumArr</span> = <span class="title class_">ToArray</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>这里发生的情况是，<code>StrArrOrNumArr</code>分布在：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> | <span class="built_in">number</span>;</span><br></pre></td></tr></table></figure>

<p>并对联合的每个成员类型进行映射，以达到有效的目的：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ToArray</span>&lt;<span class="built_in">string</span>&gt; | <span class="title class_">ToArray</span>&lt;<span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>这给我们留下了：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>[] | <span class="built_in">number</span>[];<span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>通常情况下，分布性是需要的行为。为了避免这种行为，你可以用<strong>方括号包围 <code>extends</code> 关键字的每一边</strong>。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToArrayNonDist</span>&lt;<span class="title class_">Type</span>&gt; = [<span class="title class_">Type</span>] <span class="keyword">extends</span> [<span class="built_in">any</span>] ? <span class="title class_">Type</span>[] : <span class="built_in">never</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// &#x27;StrArrOrNumArr&#x27;不再是一个联合类型</span></span><br><span class="line"><span class="comment">// type StrArrOrNumArr = (string | number)[]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StrArrOrNumArr</span> = <span class="title class_">ToArrayNonDist</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="7-6-映射类型"><a href="#7-6-映射类型" class="headerlink" title="7.6 映射类型"></a>7.6 映射类型</h3><p>当你不想重复定义类型，一个类型可以以另一个类型为基础创建新类型。</p>
<p>映射类型建立在索引签名的语法上，<strong>索引签名用于声明没有被提前声明的属性类型</strong>。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OnlyBoolsAndHorses</span> = &#123;</span><br><span class="line">	[<span class="attr">key</span>: <span class="built_in">string</span>]: <span class="built_in">boolean</span> | <span class="title class_">Horse</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="attr">confroms</span>: <span class="title class_">OnlyBoolsAndHorses</span> = &#123;</span><br><span class="line">	<span class="attr">del</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">rodney</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>映射类型是一种通用类型，它使用 <code>Property in keyof Type</code> 的联合（经常通过 <code>keyof</code> 创建）迭代键来创建一个类型。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">OptionsFlags</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">	[<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中， <code>OptionsFlags</code> 将从 <code>Type</code> 类型中获取所有属性，并将它们的值改为布尔值。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FeatureFlags</span> = &#123;</span><br><span class="line">    <span class="attr">darkMode</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">    <span class="attr">newUserProfile</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type FeatureOptions = &#123;</span></span><br><span class="line"><span class="comment">    darkMode: boolean;</span></span><br><span class="line"><span class="comment">    newUserProfile: boolean;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FeatureOptions</span> = <span class="title class_">OptionsFlags</span>&lt;<span class="title class_">FeatureFlags</span>&gt;;</span><br></pre></td></tr></table></figure>

<h4 id="7-6-1-映射修改器"><a href="#7-6-1-映射修改器" class="headerlink" title="7.6.1 映射修改器"></a>7.6.1 映射修改器</h4><p>在映射过程中，有两个额外的修饰符可以应用： <code>readonly</code> 和 <code>?</code> ，它们分别影响<strong>可变性</strong>和<strong>可选性</strong>。</p>
<p>你可以通过用 <code>-</code> 或 <code>+</code> 作为前缀来删除或添加这些修饰语。<strong>如果你不加前缀，那么就假定是 <code>+</code></strong> 。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">CreateMutable</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">    <span class="comment">// 从一个类型的属性中删除 &quot;readonly&quot;属性</span></span><br><span class="line">    -<span class="keyword">readonly</span> [<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="title class_">Type</span>[<span class="title class_">Property</span>];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LockedAccount</span> = &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type UnlockedAccount = &#123;</span></span><br><span class="line"><span class="comment">    id: string;</span></span><br><span class="line"><span class="comment">    name: string;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">UnlockedAccount</span> = <span class="title class_">CreateMutable</span>&lt;<span class="title class_">LockedAccount</span>&gt;</span><br><span class="line"><span class="comment">// 从一个类型的属性中删除 &quot;可选&quot; 属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Concrete</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">	[<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]-?: <span class="title class_">Type</span>[<span class="title class_">Property</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MaybeUser</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">string</span>;</span><br><span class="line">    name?: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type User = &#123;</span></span><br><span class="line"><span class="comment">    id: string;</span></span><br><span class="line"><span class="comment">    name: string;</span></span><br><span class="line"><span class="comment">    age: number;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = <span class="title class_">Concrete</span>&lt;<span class="title class_">MaybeUser</span>&gt;;</span><br></pre></td></tr></table></figure>

<h4 id="7-6-2-通过-as-做key重映射"><a href="#7-6-2-通过-as-做key重映射" class="headerlink" title="7.6.2 通过 as 做key重映射"></a>7.6.2 通过 <code>as</code> 做<code>key</code>重映射</h4><p>在TypeScript 4.1及以后的版本中，你可以通过映射类型中的<code>as</code>子句重新映射映射类型中的键。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">MappedTypeWithNewProperties</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">	[<span class="title class_">Properties</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span> <span class="keyword">as</span> <span class="title class_">NewKeyType</span>]: <span class="title class_">Type</span>[<span class="title class_">Properties</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以利用<code>模板字面类型</code>等功能，从先前的属性名称中创建新的属性名称。</p>
<p><code>Capitalize&lt;string &amp; Property&gt;</code>来是string首字母大写</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Getters</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">	[<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span> <span class="keyword">as</span> <span class="string">`get<span class="subst">$&#123;Capitalize&lt;<span class="built_in">string</span> &amp; Property&gt;&#125;</span>`</span>]: <span class="function">() =&gt;</span><span class="title class_">Type</span>[<span class="title class_">Property</span>]</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">location</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type LazyPerson = &#123;</span></span><br><span class="line"><span class="comment">    getName: () =&gt; string;</span></span><br><span class="line"><span class="comment">    getAge: () =&gt; number;</span></span><br><span class="line"><span class="comment">    getLocation: () =&gt; string;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LazyPerson</span> = <span class="title class_">Getters</span>&lt;<span class="title class_">Person</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>你可以通过条件类型产生 <code>never</code> 滤掉的键。</p>
<p><code>Exclude&lt;Property, &quot;kind&quot;&gt;</code> 过滤掉key为”kind”的键</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除 &quot;kind&quot;属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">RemoveKindField</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">	[<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span> <span class="keyword">as</span> <span class="title class_">Exclude</span>&lt;<span class="title class_">Property</span>, <span class="string">&quot;kind&quot;</span>&gt;]: <span class="title class_">Type</span>[<span class="title class_">Property</span>]</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type KindlessCircle = &#123;</span></span><br><span class="line"><span class="comment">	radius: number;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>;</span><br><span class="line">    <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">KindlessCircle</span> = <span class="title class_">RemoveKindField</span>&lt;<span class="title class_">Circle</span>&gt;;</span><br></pre></td></tr></table></figure>

<p>你可以映射任意的联合体，不仅仅是 <code>string | number | symbol</code> 的联合体，还有任何类型的联合体.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">EventConfig</span>&lt;<span class="title class_">Events</span> <span class="keyword">extends</span> &#123; <span class="attr">kind</span>: <span class="built_in">string</span> &#125;&gt; = &#123;</span><br><span class="line">	[E <span class="keyword">in</span> <span class="title class_">Events</span> <span class="keyword">as</span> E[<span class="string">&quot;kind&quot;</span>]]: <span class="function">(<span class="params">event: E</span>) =&gt;</span> <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">SquareEvent</span> = &#123; <span class="attr">kind</span>: <span class="string">&quot;square&quot;</span>, <span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">CircleEvent</span> = &#123; <span class="attr">kind</span>: <span class="string">&quot;circle&quot;</span>, <span class="attr">radius</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type Config = &#123;</span></span><br><span class="line"><span class="comment">    square: (event: SquareEvent) =&gt; void;</span></span><br><span class="line"><span class="comment">    circle: (event: CircleEvent) =&gt; void;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Config</span> = <span class="title class_">EventConfig</span>&lt;<span class="title class_">SquareEvent</span> | <span class="title class_">CircleEvent</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="7-6-3-进一步探索"><a href="#7-6-3-进一步探索" class="headerlink" title="7.6.3 进一步探索"></a>7.6.3 进一步探索</h4><p>映射类型与本类型操作部分的其他功能配合得很好，例如，这里有一个使用条件类型的映射类型 ，它根据一个对象的属性 <code>pii</code> 是否被设置为字面意义上的 <code>true</code> ，返回 <code>true</code> 或 <code>false</code> .</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ExtractPII</span>&lt;<span class="title class_">Type</span>&gt; = &#123;</span><br><span class="line">	[<span class="title class_">Property</span> <span class="keyword">in</span> keyof <span class="title class_">Type</span>]: <span class="title class_">Type</span>[<span class="title class_">Property</span>] <span class="keyword">extends</span> &#123; <span class="attr">pii</span>: <span class="literal">true</span> &#125; ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type ObjectsNeedingGDPRDeletion = &#123;</span></span><br><span class="line"><span class="comment">    id: false;</span></span><br><span class="line"><span class="comment">    name: true;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DBFields</span> = &#123;</span><br><span class="line">    <span class="attr">id</span>: &#123; <span class="attr">format</span>: <span class="string">&quot;incrementing&quot;</span> &#125;;</span><br><span class="line">    <span class="attr">name</span>: &#123; <span class="attr">type</span>: <span class="built_in">string</span>; <span class="attr">pii</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ObjectsNeedingGDPRDeletion</span> = <span class="title class_">ExtractPII</span>&lt;<span class="title class_">DBFields</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="TypeScript学习第八章-类"><a href="#TypeScript学习第八章-类" class="headerlink" title="TypeScript学习第八章: 类"></a>TypeScript学习第八章: 类</h2><p>TS提供了对ES2015(ES6)中引入的<code>class</code>关键词的完全支持.</p>
<p>与其他的JS语言一样,TS增加了类型注释和其他语法, 允许你表达类和其他类型之间的关系.</p>
<h3 id="8-1-类成员"><a href="#8-1-类成员" class="headerlink" title="8.1 类成员"></a>8.1 类成员</h3><p>这里有一个最基本的类——一个空的类</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这个类还不是很有用, 所以我们开始添加一些成员.</p>
<h4 id="8-1-1-类属性"><a href="#8-1-1-类属性" class="headerlink" title="8.1.1 类属性"></a>8.1.1 类属性</h4><p>在一个类上声明字段, 创建一个公共的可写属性: 映射类型是一种泛型类型，它使用<code>PropertyKey</code> (通常通过<code>key of</code>创建)的联合来迭代键来创建类型:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> pt = <span class="keyword">new</span> <span class="title class_">Point</span>()</span><br><span class="line">pt.<span class="property">x</span> = <span class="number">0</span></span><br><span class="line">pt.<span class="property">y</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>与其他位置一样，类型注解是可选的，但如果不指定，将是一个隐含的 <code>any</code> 类型。</p>
<p>字段也可以有初始化器；这些初始化器将在类被实例化时自动运行。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">	x = <span class="number">0</span></span><br><span class="line">	y = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> pt = <span class="keyword">new</span> <span class="title class_">Point</span>()</span><br><span class="line"><span class="comment">// Prints 0, 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;pt.x&#125;</span>, <span class="subst">$&#123;pt.y&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>

<p>就像 <code>const</code> 、 <code>let</code> 和 <code>var</code> 一样，一个类属性的初始化器将被用来推断其类型。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pt = <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">pt.<span class="property">x</span> = <span class="string">&quot;0&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927446.png" alt="image-20220320211743010"></p>
<ul>
<li><code>--strictPropertyInitialization</code></li>
</ul>
<p><code>strictPropertyInitialization</code>设置控制是否需要在构造函数中初始化类字段。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GoodGreeter</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，该字段需要在构造函数本身中初始化。TypeScript不会分析你从构造函数中调用的方法来检测初始化，因为派生类可能会覆盖这些方法而无法初始化成员。</p>
<p><strong>如果你打算通过构造函数以外的方式来确定初始化一个字段（例如，也许一个外部库为你填充了你的类的一部分），你可以使用确定的赋值断言操作符 <code>!</code> 。</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OKGreeter</span> &#123;</span><br><span class="line">    <span class="comment">// 没有初始化, 但没报错</span></span><br><span class="line">    name!: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-1-2-readonly"><a href="#8-1-2-readonly" class="headerlink" title="8.1.2 readonly"></a>8.1.2 <code>readonly</code></h4><p>字段的前缀可以是<code>readonly</code>修饰符。这可以防止在构造函数之外对该字段进行赋值。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span> = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">otherName?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (otherName !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    		<span class="variable language_">this</span>.<span class="property">name</span> = otherName;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="title function_">err</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;not ok&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">Greeter</span>();</span><br><span class="line">g.<span class="property">name</span> = <span class="string">&quot;also not ok&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927552.png" alt="image-20220320231821746"></p>
<h4 id="8-1-3-构造器"><a href="#8-1-3-构造器" class="headerlink" title="8.1.3 构造器"></a>8.1.3 构造器</h4><p>类构造函数与函数非常相似。你可以添加带有类型注释的参数、默认值和重载:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">	<span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">	<span class="attr">y</span>: <span class="built_in">number</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 带默认值的正常签名</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">y</span>: <span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 重载</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">string</span></span>);</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">s: <span class="built_in">string</span></span>);</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">xs: <span class="built_in">any</span>, y?: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(y !== undefinded) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">x</span> = xs</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">y</span> = y</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">y</span> = xs</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类的构造函数签名和函数签名之间只有一些区别：</p>
<ul>
<li>构造函数不能有类型参数–这属于外层类的声明，我们将在后面学习。</li>
<li>构造函数不能有返回类型注释——类的实例类型总是被返回的.</li>
</ul>
<h5 id="Super-调用"><a href="#Super-调用" class="headerlink" title="Super 调用"></a>Super 调用</h5><p>就像在JavaScript中一样，如果你有一个基类，<strong>在使用任何 <code>this.</code> 成员之前，你需要在构造器主体中调用 <code>super();</code></strong> .</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">	k = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 在ES5中打印一个错误的值；在ES6中抛出异常。</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">k</span>);</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927617.png" alt="image-20220321100612315"></p>
<p>在JavaScript中，忘记调用 <code>super</code> 是一个很容易犯的错误，但TypeScript会在必要时告诉你。</p>
<h4 id="8-1-4-方法"><a href="#8-1-4-方法" class="headerlink" title="8.1.4 方法"></a>8.1.4 方法</h4><p>一个类上的函数属性被称为方法。方法可以使用与函数和构造函数相同的所有类型注释。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">    y = <span class="number">10</span>;</span><br><span class="line">    <span class="title function_">scale</span>(<span class="attr">n</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> *= n;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> *= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了标准的类型注解，TypeScript并没有为方法添加其他新的东西。</p>
<p>请注意，在一个方法体中，仍然必须通过 this 访问字段和其他方法。方法体中的非限定名称将总是指代包围范围内的东西。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">string</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 这是在试图修改第1行的&#x27;x&#x27;，而不是类属性。</span></span><br><span class="line">        x = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-1-5-Getters-Setters"><a href="#8-1-5-Getters-Setters" class="headerlink" title="8.1.5 Getters&#x2F; Setters"></a>8.1.5 Getters&#x2F; Setters</h4><p>类也可以有访问器:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">	_length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">length</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_length</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">length</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_length</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意，一个没有额外逻辑的字段支持的 get&#x2F;set 对在JavaScript中很少有用。如果你不需要在 get&#x2F;set 操作中添加额外的逻辑，暴露公共字段也是可以的.</p>
</blockquote>
<p>TypeScript对访问器有一些特殊的推理规则:</p>
<ul>
<li>如果存在 <code>get</code> ，但没有 <code>set</code> ，则该属性自动是只读的.</li>
<li>如果没有指定<code>setter</code>参数的类型，它将从<code>getter</code>的返回类型中推断出来.</li>
<li>访问器和设置器必须有相同的成员可见性.</li>
</ul>
<p>从TS4.3开始, 可以有不同类型的访问器用于获取和设置.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thing</span> &#123;</span><br><span class="line">    _size = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">size</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_size</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">size</span>(<span class="params">value: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> num = <span class="title class_">Number</span>(value);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 不允许NaN、Infinity等</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="title class_">Number</span>.<span class="built_in">isFinite</span>(num)) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_size</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_size</span> = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-1-6-索引签名"><a href="#8-1-6-索引签名" class="headerlink" title="8.1.6 索引签名"></a>8.1.6 索引签名</h4><p>类可以声明索引签名；这些签名的作用与其他对象类型的索引签名相同。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    [<span class="attr">s</span>: <span class="built_in">string</span>]: <span class="built_in">boolean</span> | (<span class="function">(<span class="params">s: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">boolean</span>);</span><br><span class="line">    <span class="title function_">check</span>(<span class="params">s: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="variable language_">this</span>[s] <span class="keyword">as</span> <span class="built_in">boolean</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为索引签名类型需要同时捕获方法的类型，所以要有用地使用这些类型并不容易。一般来说，<strong>最好将索引数据存储在另一个地方，而不是在类实例本身</strong>。</p>
<h3 id="8-2-类继承"><a href="#8-2-类继承" class="headerlink" title="8.2 类继承"></a>8.2 类继承</h3><p>像其他具有面向对象特性的语言一样，JavaScript中的类可以继承自基类。</p>
<h4 id="8-2-1-implements子句"><a href="#8-2-1-implements子句" class="headerlink" title="8.2.1 implements子句"></a>8.2.1 <code>implements</code>子句</h4><p>你可以使用一个 <code>implements</code> 子句来检查一个类，是否满足了一个特定的接口。如果一个类不能正确地实现它，就会发出一个错误。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Pingable</span> &#123;</span><br><span class="line">	<span class="title function_">ping</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sonar</span> <span class="keyword">implements</span> <span class="title class_">Pingable</span> &#123;</span><br><span class="line">    <span class="title function_">ping</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;ping!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ball</span> <span class="keyword">implements</span> <span class="title class_">Pingable</span> &#123;</span><br><span class="line">    <span class="title function_">pong</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;pong!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927723.png" alt="image-20220321110136536"></p>
<p>类也可以实现多个接口, 例如<code>class C implements A, B &#123;&#125;</code></p>
<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><p>重要的是要明白, <code>implements</code>子句只是检查类是否可以被当作接口类型来对待. 它根本不会改变类的类型或方法. 一个常见的错误来源于是认为<code>implements</code>子句会改变类的类型, 实际上它不会.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Checkable</span> &#123;</span><br><span class="line">    <span class="title function_">check</span>(<span class="attr">name</span>:<span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NameChecker</span> <span class="keyword">implements</span> <span class="title class_">Checkable</span> &#123;</span><br><span class="line">    <span class="title function_">check</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="comment">// any: 注意这里没有错误</span></span><br><span class="line">        <span class="keyword">return</span> s.<span class="title function_">toLowercse</span>() === <span class="string">&#x27;ok&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927793.png" alt="image-20220321112155234"></p>
<p>在这个例子中，我们也许期望 s 的类型会受到 <code>check</code> 的 <code>name: string</code> 参数的影响。事实并非如此–实现子句并没有改变类主体的检查方式或其类型的推断。</p>
<p>同样地，实现一个带有可选属性的接口并不能创建该属性。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> A &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    y?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">implements</span> A &#123;</span><br><span class="line">	x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">c.<span class="property">y</span> = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927956.png" alt="image-20220321113416176"></p>
<h4 id="8-2-2-extends子句"><a href="#8-2-2-extends子句" class="headerlink" title="8.2.2 extends子句"></a>8.2.2 <code>extends</code>子句</h4><p>类可以从基类中扩展出来。<strong>派生类</strong>拥有其<strong>基类的所有属性和方法</strong>，<strong>也可以定义额外的成员</strong>。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">move</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Moving along!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">    <span class="title function_">woof</span>(<span class="params">times: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;woof!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类的类方法</span></span><br><span class="line">d.<span class="title function_">move</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生的类方法</span></span><br><span class="line">d.<span class="title function_">woof</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h4 id="8-2-3-重写方法-遵守基类契约"><a href="#8-2-3-重写方法-遵守基类契约" class="headerlink" title="8.2.3 重写方法(遵守基类契约)"></a>8.2.3 重写方法(遵守基类契约)</h4><p>派生类也可以覆盖基类的一个字段或属性. 你可以使用<code>super.</code>语法来访问基类方法. 注意，因为JavaScript类是一个简单的查找对象，没有 “超级字段 “的概念.</p>
<p>TypeScript强制要求派生类总是其基类的一个子类型.</p>
<p>例如，这里有一个合法的方法来覆盖一个方法.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params">name?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        	<span class="variable language_">super</span>.<span class="title function_">greet</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name.toUpperCase()&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line">d.<span class="title function_">greet</span>();</span><br><span class="line">d.<span class="title function_">greet</span>(<span class="string">&quot;reader&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>派生类遵循其基类契约是很重要的</strong>。请记住，<strong>通过基类引用来引用派生类实例</strong>是非常常见的（而且总是合法的！）。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过基类引用对派生实例进行取别名</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: <span class="title class_">Base</span> = d;</span><br><span class="line"><span class="comment">// 没问题</span></span><br><span class="line">b.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure>

<p>如果<code>Derived</code>没有遵守<code>Base</code>的约定怎么办？</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">    <span class="comment">// 使这个参数成为必需的</span></span><br><span class="line">    <span class="title function_">greet</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;name.toUpperCase()&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927166.png" alt="image-20220321132941006"></p>
<p>如果我们不顾错误编译这段代码，这个样本就会崩溃：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: <span class="title class_">Base</span> = <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line"><span class="comment">// 崩溃，因为 &quot;名称 &quot;将是 undefined。</span></span><br><span class="line">b.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927221.png" alt="image-20220321135711089"></p>
<h4 id="8-2-4-初始化顺序"><a href="#8-2-4-初始化顺序" class="headerlink" title="8.2.4 初始化顺序"></a>8.2.4 初始化顺序</h4><p>在某些情况下，JavaScript类的初始化顺序可能会令人惊讶。让我们考虑一下这段代码：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    name = <span class="string">&quot;base&quot;</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;My name is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">	name = <span class="string">&quot;derived&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印 &quot;base&quot;, 而不是 &quot;derived&quot;</span></span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br></pre></td></tr></table></figure>

<p>这里发生了什么？</p>
<p>按照JavaScript的定义，类初始化的顺序是：</p>
<ul>
<li>基类的字段被初始化</li>
<li>基类构造函数运行</li>
<li>派生类的字段被初始化</li>
<li>派生类构造函数运行</li>
</ul>
<p>这意味着基类构造函数在自己的构造函数中看到了自己的<code>name</code>值，因为派生类的字段初始化还没有运行.</p>
<h4 id="8-2-5-继承内置类型"><a href="#8-2-5-继承内置类型" class="headerlink" title="8.2.5 继承内置类型"></a>8.2.5 继承内置类型</h4><blockquote>
<p>注意: 如果你不打算继承Array、Error、Map等内置类型，或者你的编译目标明确设置为 ES6&#x2F;ES2015或以上，你可以跳过本节.</p>
</blockquote>
<p>在ES2015中，返回对象的构造函数隐含地替代了 <code>super(...)</code> 的任何调用者的 <code>this</code> 的值。生成的构造函数代码有必要捕获 <code>super(...)</code> 的任何潜在返回值并将其替换为 <code>this</code> 。</p>
<p>因此，子类化 <code>Error</code> 、 <code>Array</code> 等可能不再像预期那样工作。这是由于 <code>Error</code> 、 <code>Array</code>等的构造函数使用ECMAScript 6的 <code>new.target</code> 来调整原型链；然而，在ECMAScript 5中调用构造函数时，没有办法确保 <code>new.target</code> 的值。其他的下级编译器一般默认有同样的限制。</p>
<p>对于一个像下面这样的子类:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">m: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    	<span class="variable language_">super</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会发现：</p>
<ul>
<li>方法在构造这些子类所返回的对象上可能是未定义的，所以调用 <code>sayHello</code> 会导致错误。</li>
<li><code>instanceof</code>将在子类的实例和它们的实例之间被打破，所以 <code>(new MsgError()) instanceof MsgError</code> 将返回 <code>false</code> 。</li>
</ul>
<p>作为建议, 你可以在任何<code>super(...)</code>调用后立即手动调整原型.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MsgError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">m: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    	<span class="variable language_">super</span>(m);</span><br><span class="line">    	<span class="comment">// 明确地设置原型。</span></span><br><span class="line">    	<span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(<span class="variable language_">this</span>, <span class="title class_">MsgError</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而， <code>MsgError</code> 的任何子类也必须手动设置原型。对于不支持 <code>Object.setPrototypeOf</code> 的运行时， 你可以使用<code>__proto__</code> 来代替。</p>
<p>不幸的是，这些变通方法在IE10 和更早的版本上不起作用。我们可以手动将原型中的方法复制到实例本身（例如 M<code>sgError.prototype</code> 到 <code>this</code> ），但是原型链本身不能被修复。</p>
<h3 id="8-3-成员的可见性"><a href="#8-3-成员的可见性" class="headerlink" title="8.3 成员的可见性"></a>8.3 成员的可见性</h3><p>你可以使用TypeScript来控制某些方法或属性对类外的代码是否可见.</p>
<h4 id="8-3-1-public"><a href="#8-3-1-public" class="headerlink" title="8.3.1 public"></a>8.3.1 <code>public</code></h4><p>类成员的默认可见性是公共( <code>public</code> )的。一个公共( <code>public</code> )成员可以在任何地方被访问.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">Greeter</span>();</span><br><span class="line">g.<span class="title function_">greet</span>();</span><br></pre></td></tr></table></figure>

<p>因为 <code>public</code> 已经是默认的可见性修饰符，所以你永远不需要在类成员上写它，但为了风格&#x2F;可读性的原因，可能会选择这样做。</p>
<h4 id="8-3-2-protected"><a href="#8-3-2-protected" class="headerlink" title="8.3.2 protected"></a>8.3.2 <code>protected</code></h4><p>受保护的( <code>protected</code> )成员只对它们所声明的类的子类可见.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="title function_">getName</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpecialGreeter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Greeter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">howdy</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 在此可以访问受保护的成员</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Howdy, &quot;</span> + <span class="variable language_">this</span>.<span class="title function_">getName</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> g = <span class="keyword">new</span> <span class="title class_">SpecialGreeter</span>();</span><br><span class="line">g.<span class="title function_">greet</span>(); <span class="comment">// 没有问题</span></span><br><span class="line">g.<span class="title function_">getName</span>(); <span class="comment">// 无权访问</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308051927485.png" alt="image-20220321150131541"></p>
<ul>
<li>受保护成员的暴露</li>
</ul>
<p>派生类需要遵循它们的基类契约，但可以选择公开具有更多能力的基类的子类型。这包括将受保护的成员变成公开。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">	<span class="keyword">protected</span> m = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">    <span class="comment">// 没有修饰符，所以默认为&#x27;公共&#x27;(&#x27;public&#x27;)</span></span><br><span class="line">    m = <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d.<span class="property">m</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h4 id="8-2-3-private"><a href="#8-2-3-private" class="headerlink" title="8.2.3 private"></a>8.2.3 <code>private</code></h4><p><code>private</code>和<code>protected</code>一样, 但不允许从子类中访问该成员.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line"><span class="comment">// 不能从类外访问</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">x</span>);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">    <span class="title function_">showX</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 不能在子类中访问: 属性&quot;x&quot;为私有属性, 只能在类</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为私有( <code>private</code> )成员对派生类是不可见的，所以派生类不能增加其可见性.</p>
<ul>
<li>跨实例的私有访问</li>
</ul>
<p>不同的OOP语言对同一个类的不同实例，是否可以访问对方的私有成员，有不同的处理方法。虽然像 Java、C##、C++、Swift和PHP等语言允许这样做，但Ruby不允许。</p>
<p>TypeScript确实允许跨实例的私有访问:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> x = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">sameAs</span>(<span class="params">other: A</span>) &#123;</span><br><span class="line">        <span class="comment">// 可以访问</span></span><br><span class="line">        <span class="keyword">return</span> other.<span class="property">x</span> === <span class="variable language_">this</span>.<span class="property">x</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意事项</li>
</ul>
<p>像TypeScript类型系统的其他方面一样， <code>private</code> 和 <code>protected</code> 只在类型检查中被强制执行。</p>
<p>这意味着JavaScript的运行时解构，如<code>in</code>或简单的属性查询，仍然可以访问一个私有或保护的成员。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySafe</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> secretKey = <span class="number">12345</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在JS环境中...</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">MySafe</span>();</span><br><span class="line"><span class="comment">// 将打印 12345</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">secretKey</span>);</span><br></pre></td></tr></table></figure>

<p><code>private</code> 也允许在类型检查时使用括号符号进行访问。这使得私有声明的字段可能更容易被单元测试之类的东西所访问，缺点是这些字段是软性私有的，不能严格执行私有特性。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySafe</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> secretKey = <span class="number">12345</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">MySafe</span>();</span><br><span class="line"><span class="comment">// 在类型检查期间不允许</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="property">secretKey</span>);</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s[<span class="string">&quot;secretKey&quot;</span>]);</span><br></pre></td></tr></table></figure>

<p>与TypeScript的 <code>private</code> 不同，JavaScript的 <code>private</code> 字段(##)在编译后仍然是 <code>private</code> 的，并且不提供前面提到的像括号符号访问那样的转义窗口，使其成为硬 <code>private</code>.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    ##barkAmount = <span class="number">0</span>;</span><br><span class="line">    personality = <span class="string">&quot;happy&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 0</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.##barkAmount)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>()</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dog.<span class="property">barkAmount</span>)</span><br></pre></td></tr></table></figure>

<p>当编译到ES2021或更少时，TypeScript将使用<code>WeakMaps</code>来代替 <code>##</code> 。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> _Dog_barkAmount;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        _Dog_barkAmount.<span class="title function_">set</span>(<span class="variable language_">this</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">personality</span> = <span class="string">&quot;happy&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">_Dog_barkAmount = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br></pre></td></tr></table></figure>

<p>如果你需要保护你的类中的值免受恶意行为的影响，你应该使用提供硬运行时隐私的机制，如<strong>闭包</strong>、 <code>WeakMaps</code> 或<strong>私有字段</strong>。请注意，这些在运行时增加的隐私检查可能会影响性能。</p>
<h3 id="8-4-静态成员"><a href="#8-4-静态成员" class="headerlink" title="8.4 静态成员"></a>8.4 静态成员</h3><p>类可以有静态成员。这些成员并不与类的特定实例相关联。它们<strong>可以通过类的构造函数对象本身来访问。</strong></p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">printX</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">x</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">x</span>);</span><br><span class="line"><span class="title class_">MyClass</span>.<span class="title function_">printX</span>();</span><br></pre></td></tr></table></figure>

<p>静态成员也可以使用相同的 <code>public</code> 、 <code>protected</code> 和 <code>private</code> 可见性修饰符</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyClass</span>.<span class="property">x</span>);</span><br></pre></td></tr></table></figure>

<p>静态成员也会被继承</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getGreeting</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">	myGreeting = <span class="title class_">Derived</span>.<span class="title function_">getGreeting</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-4-1-特殊静态名称"><a href="#8-4-1-特殊静态名称" class="headerlink" title="8.4.1 特殊静态名称"></a>8.4.1 特殊静态名称</h4><p>一般来说，从函数原型覆盖属性是不安全的&#x2F;不可能的。因为类本身就是可以用 <code>new</code> 调用的函数，所以某些静态名称不能使用。像 <code>name</code> 、 <code>length</code>和<code>call</code>这样的函数属性，定义为静态成员是无效的。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> name = <span class="string">&quot;S!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-4-2-为什么没有静态类？"><a href="#8-4-2-为什么没有静态类？" class="headerlink" title="8.4.2 为什么没有静态类？"></a>8.4.2 为什么没有静态类？</h4><p>TypeScript（和JavaScript）没有像C##和Java那样有一个叫做静态类的结构。</p>
<p>这些结构体的存在，只是因为这些语言强制所有的数据和函数都在一个类里面；因为这个限制在TypeScript中不存在，所以不需要它们。<strong>一个只有一个实例的类，在JavaScript&#x2F;TypeScript中通常只是表示为一个普通的对象。</strong></p>
<p>例如，我们不需要TypeScript中的 “静态类 “语法，因为一个普通的对象（甚至是顶级函数）也可以完成这个工作。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要 &quot;static&quot; class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStaticClass</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 首选 (备选 1)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 首选 (备选 2)</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyHelperObject</span> = &#123;</span><br><span class="line">	<span class="title function_">dosomething</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="8-5-类里的static区块"><a href="#8-5-类里的static区块" class="headerlink" title="8.5 类里的static区块"></a>8.5 类里的<code>static</code>区块</h3><p>静态块允许你写一串有自己作用域的语句，可以访问包含类中的私有字段。这意味着我们可以用写语句的所有能力来写初始化代码，不泄露变量，并能完全访问我们类的内部结构。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ##count = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">count</span>() &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="title class_">Foo</span>.##count;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> lastInstances = &#123;</span><br><span class="line">                <span class="attr">length</span>: <span class="number">100</span></span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="title class_">Foo</span>.##count += lastInstances.<span class="property">length</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-6-泛型类"><a href="#8-6-泛型类" class="headerlink" title="8.6 泛型类"></a>8.6 泛型类</h3><p>类，和接口一样，可以是泛型的。当一个泛型类用<code>new</code>实例化时，其类型参数的推断方式与函数调用的方式相同。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">    <span class="attr">contents</span>: <span class="title class_">Type</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">value: Type</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">contents</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// const b: Box&lt;string&gt;</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Box</span>(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>类可以像接口一样使用通用约束和默认值.</p>
<ul>
<li>静态成员中的类型参数</li>
</ul>
<p>这段代码事不合法的， 可能不太明显， 为什么呢？</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 静态成员不能引用类的类型参数。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="attr">defaultValue</span>: <span class="title class_">Type</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Box&lt;string&gt;.defaultValue = &#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">// console.log(Box&lt;number&gt;.defaultValue)</span></span><br></pre></td></tr></table></figure>

<p>请记住，类型总是被完全擦除的! 在运行时，只有一个<code>Box.defaultValue</code>属性。这意味着设置<code>Box.defaultValue</code>（如果有可能的话）也会改变<code>Box.defaultValue</code>，这可不是什么好事。</p>
<p><strong>一个泛型类的静态成员永远不能引用该类的类型参数.</strong></p>
<h3 id="8-7-类运行时的this"><a href="#8-7-类运行时的this" class="headerlink" title="8.7 类运行时的this"></a>8.7 类运行时的<code>this</code></h3><p>重要的是要记住，TS并没有改变JS的运行时行为，而JavaScript的运行时行为偶尔很奇特。</p>
<p>比如，JavaScript对这一点的处理确实是不寻常的：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;obj&quot;</span>,</span><br><span class="line">    <span class="attr">getName</span>: c.<span class="property">getName</span>,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 输出 &quot;obj&quot;, 而不是 &quot;MyClass&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">getName</span>())</span><br></pre></td></tr></table></figure>

<p>长话短说，默认情况下，函数内this的值取决于函数的调用方式。在这个例子中，因为函数是通过obj引用调用的，所以它的this值是obj而不是类实例。</p>
<p>这很少是你希望发生的事情! TypeScript提供了一些方法来减轻或防止这种错误.</p>
<h4 id="1-箭头函数"><a href="#1-箭头函数" class="headerlink" title="1. 箭头函数"></a>1. 箭头函数</h4><p>如果你有一个经常会被调用的函数，失去了它的 <code>this</code> 上下文，那么使用一个箭头函数而不是方法定义是有意义的。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">    getName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="keyword">const</span> g = c.<span class="property">getName</span>;</span><br><span class="line"><span class="comment">// 输出 &quot;MyClass&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">g</span>());</span><br></pre></td></tr></table></figure>

<p>这有一些权衡：</p>
<ul>
<li>this 值保证在运行时是正确的，即使是没有经过TypeScript检查的代码也是如此。</li>
<li>这将使用更多的内存，因为每个类实例将有它自己的副本，每个函数都是这样定义的。</li>
<li>你不能在派生类中使用 <code>super.getName</code> ，因为在原型链中没有入口可以获取基类方法。</li>
</ul>
<h4 id="2-this参数"><a href="#2-this参数" class="headerlink" title="2. this参数"></a>2. <code>this</code>参数</h4><p>在方法或函数定义中，一个名为 <code>this</code> 的初始参数在TypeScript中具有特殊的意义。这些参数在编译过程中会被删除。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带有 &quot;this&quot; 参数的 TypeScript 输入</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"><span class="variable language_">this</span>: SomeType, x: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译后的JavaScript结果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x</span>) &#123;</span><br><span class="line">	<span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TypeScript检查调用带有 <code>this</code> 参数的函数，是否在正确的上下文中进行。我们可以不使用箭头函数，而是在方法定义中添加一个 <code>this</code> 参数，以静态地确保方法被正确调用.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    name = <span class="string">&quot;MyClass&quot;</span>;</span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"><span class="variable language_">this</span>: MyClass</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line">c.<span class="title function_">getName</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">const</span> g = c.<span class="property">getName</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">g</span>());</span><br></pre></td></tr></table></figure>

<p>这种方法做出了与箭头函数方法相反的取舍：</p>
<ul>
<li>JavaScript调用者仍然可能在不知不觉中错误地使用类方法</li>
<li>每个类定义只有一个函数被分配，而不是每个类实例一个函数</li>
<li>基类方法定义仍然可以通过 super 调用。</li>
</ul>
<h3 id="8-8-this类型"><a href="#8-8-this类型" class="headerlink" title="8.8 this类型"></a>8.8 <code>this</code>类型</h3><p>在类中，一个叫做 <code>this</code> 的特殊类型动态地指向当前类的类型。让我们来看看这有什么用：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="attr">contents</span>: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// (method) Box.set(value: string): this</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">value: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">contents</span> = value;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，TypeScript推断出 <code>set</code> 的返回类型是 <code>this</code> ，而不是 <code>Box</code> 。现在让我们做一个<code>Box</code>的子类：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClearableBox</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Box</span> &#123;</span><br><span class="line">    <span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">    	<span class="variable language_">this</span>.<span class="property">contents</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">ClearableBox</span>();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// const b: ClearableBox</span></span><br><span class="line"><span class="keyword">const</span> b = a.<span class="title function_">set</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br></pre></td></tr></table></figure>

<p>你也可以在参数类型注释中使用 <code>this</code> :</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="attr">content</span>: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="title function_">sameAs</span>(<span class="params">other: <span class="variable language_">this</span></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> other.<span class="property">content</span> === <span class="variable language_">this</span>.<span class="property">content</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> box = <span class="keyword">new</span> <span class="title class_">Box</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="title function_">sameAs</span>(box))</span><br></pre></td></tr></table></figure>

<p>这与其他写法不同：Box，如果你有一个派生类，它的<code>sameAs</code>方法现在只接受该同一派生类的其他实例。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line">    <span class="attr">content</span>: <span class="built_in">string</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="title function_">sameAs</span>(<span class="params">other: <span class="variable language_">this</span></span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> other.<span class="property">content</span> === <span class="variable language_">this</span>.<span class="property">content</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedBox</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Box</span> &#123;</span><br><span class="line">	<span class="attr">otherContent</span>: <span class="built_in">string</span> = <span class="string">&quot;?&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> base = <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line"><span class="keyword">const</span> derived = <span class="keyword">new</span> <span class="title class_">DerivedBox</span>();</span><br><span class="line">derived.<span class="title function_">sameAs</span>(base);  <span class="comment">// 报错 类型 &quot;Box&quot; 中缺少属性 &quot;otherContent&quot;，但类型 &quot;DerivedBox&quot; 中需要该属性。</span></span><br></pre></td></tr></table></figure>

<h3 id="8-9-基于类型守卫的this（？？？不太会）"><a href="#8-9-基于类型守卫的this（？？？不太会）" class="headerlink" title="8.9 基于类型守卫的this（？？？不太会）"></a>8.9 基于类型守卫的<code>this</code>（<strong>？？？不太会）</strong></h3><p>你可以在类和接口的方法的返回位置使用 <code>this is Type</code> 。当与类型缩小混合时（例如<code>if</code>语句），目标对象的类型将被缩小到指定的Type。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSystemObject</span> &#123;</span><br><span class="line">    <span class="title function_">isFile</span>(): <span class="variable language_">this</span> is <span class="title class_">FileRep</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">FileRep</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">isDirectory</span>(): <span class="variable language_">this</span> is <span class="title class_">Directory</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Directory</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">isNetworked</span>(): <span class="variable language_">this</span> is <span class="title class_">Networked</span> &amp; <span class="variable language_">this</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">networked</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">	<span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> path: <span class="built_in">string</span>, <span class="keyword">private</span> networked: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileRep</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FileSystemObject</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">path: <span class="built_in">string</span>, <span class="keyword">public</span> content: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(path, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Directory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">FileSystemObject</span> &#123;</span><br><span class="line">    <span class="attr">children</span>: <span class="title class_">FileSystemObject</span>[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Networked</span> &#123;</span><br><span class="line">    <span class="attr">host</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">fso</span>: <span class="title class_">FileSystemObject</span> = <span class="keyword">new</span> <span class="title class_">FileRep</span>(<span class="string">&quot;foo/bar.txt&quot;</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fso.<span class="title function_">isFile</span>()) &#123;</span><br><span class="line">    <span class="comment">// const fso: FileRep</span></span><br><span class="line">    fso.<span class="property">content</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fso.<span class="title function_">isDirectory</span>()) &#123;</span><br><span class="line">    <span class="comment">// const fso: Directory</span></span><br><span class="line">    fso.<span class="property">children</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fso.<span class="title function_">isNetworked</span>()) &#123;</span><br><span class="line">    <span class="comment">// const fso: Networked &amp; FileSystemObject</span></span><br><span class="line">    fso.<span class="property">host</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于 <code>this</code> 的类型保护的一个常见用例，是允许对一个特定字段进行懒惰验证。例如，这种情况下，当hasValue 被验证为真时，就会从框内持有的值中删除一个未定义值。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &lt;T&gt; &#123;</span><br><span class="line">    value?: T;</span><br><span class="line">    <span class="title function_">hasValue</span>(): <span class="variable language_">this</span> is &#123; <span class="attr">value</span>: T&#125; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span> !== <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> box = <span class="keyword">new</span> <span class="title class_">Box</span>();</span><br><span class="line">box.<span class="property">value</span> = <span class="string">&quot;Gameboy&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// (property) Box&lt;unknown&gt;.value?: unknownbox.value;</span></span><br><span class="line"><span class="keyword">if</span> (box.<span class="title function_">hasValue</span>()) &#123;</span><br><span class="line">    <span class="comment">// (property) value: unknown</span></span><br><span class="line">    box.<span class="property">value</span>;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h3 id="8-10-参数属性，构造函数参数转类属性"><a href="#8-10-参数属性，构造函数参数转类属性" class="headerlink" title="8.10 参数属性，构造函数参数转类属性"></a>8.10 参数属性，构造函数参数转类属性</h3><p>TypeScript提供了特殊的语法，可以将构造函数参数变成具有相同名称和值的类属性。这些被称为参数属性，通过在构造函数参数前加上可见性修饰符 <code>public</code> 、 <code>private</code> 、 <code>protected</code> 或 <code>readonly</code> 中的一个来创建。由此产生的字段会得到这些修饰符.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Params</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="keyword">readonly</span> x: <span class="built_in">number</span>, <span class="keyword">protected</span> y: <span class="built_in">number</span>, <span class="keyword">private</span> z: <span class="built_in">number</span></span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// No body necessary</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Params</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// (property) Params.x: number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">x</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">z</span>);</span><br></pre></td></tr></table></figure>

<h3 id="8-11-类表达式"><a href="#8-11-类表达式" class="headerlink" title="8.11 类表达式"></a>8.11 类表达式</h3><p>类表达式与类声明非常相似。唯一真正的区别是，类表达式不需要一个名字，尽管我们可以通过它们最终绑定的任何标识符来引用它们。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someClass = <span class="keyword">class</span>&lt;<span class="title class_">Type</span>&gt; &#123;</span><br><span class="line">    <span class="attr">content</span>: <span class="title class_">Type</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">value: Type</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">content</span> = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// const m: someClass&lt;string&gt;</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title function_">someClass</span>(<span class="string">&quot;Hello, world&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="8-12-抽象类和成员"><a href="#8-12-抽象类和成员" class="headerlink" title="8.12 抽象类和成员"></a>8.12 抽象类和成员</h3><p>TypeScript中的类、方法和字段可以是抽象的。</p>
<p>一个抽象的方法或抽象的字段是一个没有提供实现的方法或字段。这些成员必须存在于一个抽象类中， 不能直接实例化。</p>
<p>抽象类的作用是作为子类的基类，实现所有的抽象成员。当一个类没有任何抽象成员时，我们就说它是具体的。</p>
<p>让我们看一个例子：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="title function_">getName</span>(): <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">printName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="title function_">getName</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Base</span>();</span><br></pre></td></tr></table></figure>

<p>我们不能用 <code>new</code> 来实例化 <code>Base</code> ，因为它是抽象的。相反，我们需要创建一个派生类并实现抽象成员.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> d = <span class="keyword">new</span> <span class="title class_">Derived</span>();</span><br><span class="line">d.<span class="title function_">printName</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>抽象构造签名</li>
</ul>
<p>有时你想接受一些类的构造函数，产生一个从某些抽象类派生出来的类的实例。</p>
<p>例如，你可能想写这样的代码：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">ctor: <span class="keyword">typeof</span> Base</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">ctor</span>();</span><br><span class="line">    instance.<span class="title function_">printName</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TypeScript正确地告诉你，你正试图实例化一个抽象类。毕竟，鉴于greet的定义，写这段代码是完全合 法的，它最终会构造一个抽象类.</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 槽糕</span></span><br><span class="line"><span class="title function_">greet</span>(<span class="title class_">Base</span>);</span><br></pre></td></tr></table></figure>

<p>相反，你想写一个函数，接受具有结构化签名的东西：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">ctor: <span class="keyword">new</span>() =&gt; Base</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="title function_">ctor</span>();</span><br><span class="line">    instance.<span class="title function_">printName</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">greet</span>(<span class="title class_">Derived</span>);</span><br><span class="line"><span class="title function_">greet</span>(<span class="title class_">Base</span>);</span><br></pre></td></tr></table></figure>

<p>现在TypeScript正确地告诉你哪些类的构造函数可以被调用:<code>Derived</code> 可以，因为它是具体的，但<code>Base</code>不能。</p>
<h3 id="8-13-类之间的关系"><a href="#8-13-类之间的关系" class="headerlink" title="8.13 类之间的关系"></a>8.13 类之间的关系</h3><p>在大多数情况下，TypeScript中的类在结构上与其他类型相同，是可以比较的。</p>
<p>例如，这两个类可以互相替代使用，因为它们是相同的：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point1</span> &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point2</span> &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Point1</span> = <span class="keyword">new</span> <span class="title class_">Point2</span>()</span><br></pre></td></tr></table></figure>

<p>同样地，即使没有明确的继承，类之间的子类型关系也是存在的：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">salary</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">p</span>: <span class="title class_">Person</span> = <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br></pre></td></tr></table></figure>

<p>这听起来很简单，但有几种情况似乎比其他情况更奇怪。</p>
<p>空的类没有成员。在一个结构化类型系统中，一个没有成员的类型通常是其他任何东西的超类型。所以如果你写了一个空类（不要！），任何东西都可以用来代替它。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x: Empty</span>) &#123;</span><br><span class="line">    <span class="comment">// 不能用&#x27;x&#x27;做任何事</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 以下调用均可</span></span><br><span class="line">!<span class="title function_">fn</span>(<span class="variable language_">window</span>);</span><br><span class="line"><span class="title function_">fn</span>(&#123;&#125;);</span><br><span class="line"><span class="title function_">fn</span>(fn);</span><br></pre></td></tr></table></figure>

<h2 id="TypeScript学习第九章：模块"><a href="#TypeScript学习第九章：模块" class="headerlink" title="TypeScript学习第九章：模块"></a>TypeScript学习第九章：模块</h2><p>JavaScript有很长的历史，有不同的方式来<strong>处理模块化的代码</strong>。TypeScript从2012年开始出现，已经实现了对许多这些格式的支持，但随着时间的推移，社区和JavaScript规范已经趋向于一种名为ES模块 （或<strong>ES6模块</strong>）的格式。你可能知道它是 import&#x2F;export 语法。</p>
<p><strong>ES Modules</strong>在2015年被加入到JavaScript规范中，到2020年，在<strong>大多数网络浏览器和JavaScript运行时中都有广泛的支持</strong>。</p>
<p>为了突出重点，本手册将涵盖ES Modules及其流行的前驱CommonJS <code>module.exports =</code> 语法。</p>
<h3 id="9-1-如何定义JavaScript模块"><a href="#9-1-如何定义JavaScript模块" class="headerlink" title="9.1 如何定义JavaScript模块"></a>9.1 如何定义JavaScript模块</h3><p>在TypeScript中，就像在ECMAScript 2015中一样，任何包含顶级<code>import</code>或<code>export</code>的文件都被认为是 一个模块。</p>
<p>相反，<strong>一个没有任何顶级导入或导出声明的文件被视为一个脚本</strong>，<strong>其内容可在全局范围内使用（因此也可用于模块）</strong>。</p>
<p><strong>模块在自己的范围内执行，而不是在全局范围内</strong>。这意味着在模块中声明的变量、函数、类等在模块外是不可见的，除非它们被明确地用某种导出形式导出。相反，要使用从不同模块导出的变量、函数、类、接口等，必须使用导入的形式将其导入。</p>
<h3 id="9-2-非模块"><a href="#9-2-非模块" class="headerlink" title="9.2 非模块"></a>9.2 非模块</h3><p>在我们开始之前，重要的是要了解TypeScript认为什么才是模块。JavaScript规范声明，任何没有<code>export</code> 或顶层 await(top-level await)的JavaScript文件都应该被认为是一个脚本而不是一个模块。</p>
<p>顶层await该特性可以让 ES 模块对外表现为一个 <code>async</code> 函数，允许 ES 模块去 <code>await</code> 数据并阻塞其它导入这些数据的模块。只有在数据确定并准备好的时候，导入数据的模块才可以执行相应的代码。</p>
<p>在一个脚本文件中，变量和类型被声明为在共享的全局范围内，并且假定你会使用<code>outFile</code>编译器选项将多个输入文件加入一个输出文件，或者在你的HTML中使用多个 <code>&lt;script&gt;</code>标签来加载这些文件（顺序正确!）。</p>
<p>如果你有一个目前没有任何导入或导出的文件，但你希望被当作一个模块来处理，请添加这一行：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这将改变该文件，使其成为一个什么都不输出的模块。无论你的模块目标是什么，这个语法都有效。</p>
<h3 id="9-3-TypeScript中的模块"><a href="#9-3-TypeScript中的模块" class="headerlink" title="9.3 TypeScript中的模块"></a>9.3 TypeScript中的模块</h3><p>在TypeScript中编写基于模块的代码时，有三个主要方面需要考虑：</p>
<ul>
<li><strong>语法</strong>：我想用什么语法来导入和导出东西？</li>
<li><strong>模块解析</strong>：模块名称（或路径）和磁盘上的文件之间是什么关系？</li>
<li><strong>模块输出目标</strong>：我编译出来的JavaScript模块应该是什么样子的？</li>
</ul>
<h4 id="9-3-1-ES模块语法"><a href="#9-3-1-ES模块语法" class="headerlink" title="9.3.1 ES模块语法"></a>9.3.1 ES模块语法</h4><p>一个文件可以通过 <code>export default</code> 声明一个主要出口：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @filename: hello.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">helloWorld</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过以下方式导入：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hello <span class="keyword">from</span> <span class="string">&quot;./hello.js&quot;</span>;</span><br><span class="line"><span class="title function_">hello</span>();</span><br></pre></td></tr></table></figure>

<p>除了默认的导出，你还可以通过省略 <code>default</code> 的 <code>export</code> ，实现有一个以上的变量和函数的导出。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @filename: maths.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> squareTwo = <span class="number">1.41</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> phi = <span class="number">1.61</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">RandomNumberGenerator</span> &#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">absolute</span>(<span class="params">num: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="keyword">return</span> num * -<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些可以通过 <code>import</code> 语法在另一个文件中使用:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; pi, phi, absolute &#125; <span class="keyword">from</span> <span class="string">&quot;./maths.js&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pi);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// const absPhi: number</span></span><br><span class="line"><span class="keyword">const</span> absPhi = <span class="title function_">absolute</span>(phi);</span><br></pre></td></tr></table></figure>

<h4 id="9-3-2-额外的导入语法"><a href="#9-3-2-额外的导入语法" class="headerlink" title="9.3.2 额外的导入语法"></a>9.3.2 额外的导入语法</h4><p>可以使用 <code>import &#123;old as new&#125;</code> 这样的格式来重命名一个导入:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; pi <span class="keyword">as</span> π &#125; <span class="keyword">from</span> <span class="string">&quot;./maths.js&quot;</span>;</span><br><span class="line"><span class="comment">// (alias)</span></span><br><span class="line"><span class="keyword">var</span> π: <span class="built_in">number</span></span><br><span class="line"><span class="comment">// import π</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(π);</span><br></pre></td></tr></table></figure>

<p>你可以将上述语法混合并匹配到一个单一的<code>import</code>中:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @filename: maths.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">RandomNumberGenerator</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// @filename: app.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">RNGen</span>, &#123; pi <span class="keyword">as</span> π &#125; <span class="keyword">from</span> <span class="string">&quot;./maths.js&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// (alias) class RNGen</span></span><br><span class="line"><span class="comment">// import RNGen</span></span><br><span class="line"><span class="title class_">RNGen</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// (alias) const π: 3.14</span></span><br><span class="line"><span class="comment">// import π</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(π);</span><br></pre></td></tr></table></figure>

<p>你可以把所有导出的对象，用 <code>* as name</code> ，把它们放到一个命名空间：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @filename: app.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> math <span class="keyword">from</span> <span class="string">&quot;./maths.js&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="property">pi</span>);</span><br><span class="line"><span class="comment">// const positivePhi: number</span></span><br><span class="line"><span class="keyword">const</span> positivePhi = math.<span class="title function_">absolute</span>(math.<span class="property">phi</span>);</span><br></pre></td></tr></table></figure>

<p>你可以通过 <code>import &quot;./file &quot;</code> 导入一个文件，而不把任何变量纳入你的当前模块:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @filename: app.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./maths.js&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;3.14&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在这种情况下， <code>import</code> 没有任何作用。然而， <code>maths.ts</code> 中的所有代码都被解析了，这可能引发影响其他对象的副作用。</p>
<h4 id="9-3-3-TypeScript特定的ES模块语法"><a href="#9-3-3-TypeScript特定的ES模块语法" class="headerlink" title="9.3.3 TypeScript特定的ES模块语法"></a>9.3.3 TypeScript特定的ES模块语法</h4><p>类型可以使用与JavaScript值相同的语法进行导出和导入。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @filename: animal.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Cat</span> = &#123; <span class="attr">breed</span>: <span class="built_in">string</span>; <span class="attr">yearOfBirth</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="attr">breeds</span>: <span class="built_in">string</span>[];</span><br><span class="line">    <span class="attr">yearOfBirth</span>: <span class="built_in">number</span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @filename: app.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Cat</span>, <span class="title class_">Dog</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./animal.js&quot;</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Animals</span> = <span class="title class_">Cat</span> | <span class="title class_">Dog</span>;</span><br></pre></td></tr></table></figure>

<p>TypeScript用两个概念扩展了 import 语法，用于声明一个类型的导入。</p>
<ul>
<li><code>import type</code></li>
</ul>
<p>这是一个导入语句，只能导入类型：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @filename: animal.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Cat</span> = &#123; <span class="attr">breed</span>: <span class="built_in">string</span>; <span class="attr">yearOfBirth</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Dog</span> = &#123; <span class="attr">breeds</span>: <span class="built_in">string</span>[]; <span class="attr">yearOfBirth</span>: <span class="built_in">number</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createCatName</span> = (<span class="params"></span>) =&gt; <span class="string">&quot;fluffy&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// @filename: valid.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; <span class="title class_">Cat</span>, <span class="title class_">Dog</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./animal.js&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Animals</span> = <span class="title class_">Cat</span> | <span class="title class_">Dog</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// @filename: app.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; createCatName &#125; <span class="keyword">from</span> <span class="string">&quot;./animal.js&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="title function_">createCatName</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li>内联类型导入</li>
</ul>
<p>TypeScript 4.5还允许以type为前缀的单个导入，以表明导入的引用是一个类型：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @filename: app.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; createCatName, <span class="keyword">type</span> <span class="title class_">Cat</span>, <span class="keyword">type</span> <span class="title class_">Dog</span> &#125; <span class="keyword">from</span> <span class="string">&quot;./animal.js&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Animals</span> = <span class="title class_">Cat</span> | <span class="title class_">Dog</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="title function_">createCatName</span>();</span><br></pre></td></tr></table></figure>

<h4 id="9-3-4-ES模块语法与CommonJS行为"><a href="#9-3-4-ES模块语法与CommonJS行为" class="headerlink" title="9.3.4 ES模块语法与CommonJS行为"></a>9.3.4 ES模块语法与CommonJS行为</h4><p>TypeScript有ES Module语法，它直接与CommonJS和AMD的 <code>require</code> 相关联。使用ES Module的<code>import</code> 在大多数情况下与这些环境的 <code>require</code> 相同，但这种语法确保你在TypeScript文件中与CommonJS的输出有1对1的匹配：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> code = fs.<span class="title function_">readFileSync</span>(<span class="string">&quot;hello.ts&quot;</span>, <span class="string">&quot;utf8&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="9-4-CommonJS-语法"><a href="#9-4-CommonJS-语法" class="headerlink" title="9.4 CommonJS 语法"></a>9.4 CommonJS 语法</h3><p>CommonJS是npm上大多数模块的交付格式。即使你使用上面的ES模块语法进行编写，对CommonJS语法的工作方式有一个简单的了解也会帮助你更容易地进行调试。</p>
<h4 id="9-4-1-导出"><a href="#9-4-1-导出" class="headerlink" title="9.4.1 导出"></a>9.4.1 导出</h4><p>标识符是通过在一个全局调用的 <code>module</code> 上设置 <code>exports</code> 属性来导出的。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">absolute</span>(<span class="params">num: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">0</span>) <span class="keyword">return</span> num * -<span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">pi</span>: <span class="number">3.14</span>,</span><br><span class="line">    <span class="attr">squareTwo</span>: <span class="number">1.41</span>,</span><br><span class="line">    <span class="attr">phi</span>: <span class="number">1.61</span>,</span><br><span class="line">    absolute,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>然后这些文件可以通过 <code>require</code> 语句导入：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maths = <span class="built_in">require</span>(<span class="string">&quot;maths&quot;</span>);</span><br><span class="line"><span class="comment">// pi: any</span></span><br><span class="line">maths.<span class="property">pi</span>;</span><br></pre></td></tr></table></figure>

<p>或者你可以使用JavaScript中的析构功能来简化一下：</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; squareTwo &#125; = <span class="built_in">require</span>(<span class="string">&quot;maths&quot;</span>);</span><br><span class="line"><span class="comment">// const squareTwo: any</span></span><br><span class="line">squareTwo;</span><br></pre></td></tr></table></figure>

<h4 id="9-4-2-CommonJS和ES模块的互操作性"><a href="#9-4-2-CommonJS和ES模块的互操作性" class="headerlink" title="9.4.2 CommonJS和ES模块的互操作性"></a>9.4.2 CommonJS和ES模块的互操作性</h4><p>关于默认导入和模块命名空间对象导入之间的区别，CommonJS和ES Modules之间存在着功能上的不匹配。</p>
<p>这个后面章节会详细介绍。</p>
<h4 id="9-5-TypeScript的模块解析选项"><a href="#9-5-TypeScript的模块解析选项" class="headerlink" title="9.5 TypeScript的模块解析选项"></a>9.5 TypeScript的模块解析选项</h4><p>模块解析是指从 <code>import</code> 或 <code>require</code> 语句中获取一个字符串，并确定该字符串所指的文件的过程。</p>
<p>TypeScript包括两种解析策略。经典和Node。当编译器选项 <code>module</code> 不是 <code>commonjs</code> 时，经典策略是默认的，是为了向后兼容。Node策略复制了Node.js在CommonJS模式下的工作方式，对 .ts 和 .d.ts 有额外的检查。</p>
<p>在TypeScript中，有许多TSConfig标志影响模块策略：<code>moduleResolution</code> , <code>baseUrl</code> , <code>paths</code> , <code>rootDirs</code> 。</p>
<p>关于这些策略如何工作的全部细节，你可以参考《<a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/module-resolution.html">模块解析</a>》。</p>
<h3 id="9-6-TypeScript的模块输出选项"><a href="#9-6-TypeScript的模块输出选项" class="headerlink" title="9.6 TypeScript的模块输出选项"></a>9.6 TypeScript的模块输出选项</h3><p>有两个选项会影响JavaScript输出：</p>
<ul>
<li><code>target</code>, 它决定了哪些JS功能被降级（转换为在旧的JavaScript运行时运行），哪些保持不变</li>
<li><code>module</code>, 它决定了哪些代码用于模块之间的相互作用。</li>
</ul>
<p>你使用的 <code>target</code> 是由你期望运行TypeScript代码的JavaScript运行时中的可用功能决定的。这可能是：你支持的最古老的网络浏览器，你期望运行的最低版本的Node.js，或者可能来自于你的运行时的独特约束——比如<code>Electron</code>.</p>
<p>所有模块之间的通信都是通过模块加载器进行的，编译器选项 <code>module</code> 决定使用哪一个。在运行时，模块加载器负责在执行一个模块之前定位和执行该模块的所有依赖项.</p>
<p>例如，这里是一个使用ES模块语法的TypeScript文件，展示了 <code>module</code> 的一些不同选项:</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; valueOfPi &#125; <span class="keyword">from</span> <span class="string">&quot;./constants.js&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> twoPi = valueOfPi * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ES2020</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; valueOfPi &#125; <span class="keyword">from</span> <span class="string">&quot;./constants.js&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> twoPi = valueOfPi * <span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>CommonJS</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">twoPi</span> = <span class="built_in">void</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> constants_js_1 = <span class="built_in">require</span>(<span class="string">&quot;./constants.js&quot;</span>);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">twoPi</span> = constants_js_1.<span class="property">valueOfPi</span> * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>UMD</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params">factory</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">module</span> === <span class="string">&quot;object&quot;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="variable language_">module</span>.<span class="property">exports</span> === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> v = <span class="title function_">factory</span>(<span class="built_in">require</span>, <span class="built_in">exports</span>);</span><br><span class="line">        <span class="keyword">if</span> (v !== <span class="literal">undefined</span>) <span class="variable language_">module</span>.<span class="property">exports</span> = v;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">&quot;function&quot;</span> &amp;&amp; define.<span class="property">amd</span>) &#123;</span><br><span class="line">        <span class="title function_">define</span>([<span class="string">&quot;require&quot;</span>, <span class="string">&quot;exports&quot;</span>, <span class="string">&quot;./constants.js&quot;</span>], factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(<span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span></span>) &#123;</span><br><span class="line">    <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="built_in">exports</span>.<span class="property">twoPi</span> = <span class="built_in">void</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> constants_js_1 = <span class="built_in">require</span>(<span class="string">&quot;./constants.js&quot;</span>);</span><br><span class="line">	<span class="built_in">exports</span>.<span class="property">twoPi</span> = constants_js_1.<span class="property">valueOfPi</span> * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意，ES2020实际上与原来的index.ts相同。</p>
</blockquote>
<p>你可以在TSConfig 模块参考中看到所有可用的选项以及它们发出的JavaScript代码是什么样子。</p>
<h3 id="9-7-TypeScript-命名空间"><a href="#9-7-TypeScript-命名空间" class="headerlink" title="9.7 TypeScript 命名空间"></a>9.7 TypeScript 命名空间</h3><p>TypeScript有自己的模块格式，称为 <code>命名空间(namespaces)</code> ，这比ES模块标准要早。这种语法对于创建复杂的定义文件有很多有用的功能，并且在 DefinitelyTyped中仍然被积极使用。虽然没有被废弃，但命名空间中的大部分功能都存在于ES Modules中，我们建议你使用它来与JavaScript的方向保持一致。 你可以在<code>namespaces参考页</code>中了解更多关于命名空间的信息。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">小u</div><div class="post-copyright__author_desc">热爱可抵岁月漫长</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2023/10/01/codenotes/front_end/ts/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2023/10/01/codenotes/front_end/ts/')">一文搞懂TypeScript</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2023/10/01/codenotes/front_end/ts/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=一文搞懂TypeScript&amp;url=http://example.com/2023/10/01/codenotes/front_end/ts/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>前端<span class="tagsPageCount">10</span></a><a class="post-meta__box__tags" href="/tags/Ts/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Ts<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/01/codenotes/front_end/dy/HC2/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">HTML/CSS项目实战(小米商城)</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/01/codenotes/front_end/HTML/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">HTML</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/10/01/codenotes/book/front/" title="前端书籍推荐"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">前端书籍推荐</div></div></a></div><div><a href="/2023/10/01/codenotes/front_end/2023ts/" title="都2023年了你还不学ts？"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">都2023年了你还不学ts？</div></div></a></div><div><a href="/2023/10/01/codenotes/front_end/WebApi/" title="WebApi"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">WebApi</div></div></a></div><div><a href="/2023/10/01/codenotes/front_end/HTML/" title="HTML"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">HTML</div></div></a></div><div><a href="/2023/10/01/projects/zatan/8/3/" title="vertical-align什么时候用并且有效"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">vertical-align什么时候用并且有效</div></div></a></div><div><a href="/2023/10/01/projects/zatan/7/3/" title="css中margin和padding的区别"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">css中margin和padding的区别</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" ait="status"/></div></div><div class="author-info__description">Java,java,springboot,mysql,redis,教程,git,软件,编程,开发,互联网,Java 基础,Java 教程,Java程序员进阶之路,Java 入门,Vue,前端,算法</div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎来看我的博客 博客主地址：http://blog.xiaou61.top/  备用地址：https://newblog.guoyaxue.top/</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E7%AB%A0-TypeScript%E5%88%9D%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">TypeScript学习第一章:TypeScript初识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-TypeScript%E5%AD%A6%E4%B9%A0%E5%88%9D%E8%A7%81"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 TypeScript学习初见</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-TypeScript%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 TypeScript介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-JS-%E3%80%81TS-%E5%92%8C-ES%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 JS 、TS 和 ES之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-TS%E7%9A%84%E7%AB%9E%E4%BA%89%E8%80%85%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 TS的竞争者有哪些?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ESLint"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. ESLint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-TSlint"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. TSlint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-CoffeeScript"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. CoffeeScript</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Flow"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.Flow</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8TypeScript"><span class="toc-number">2.</span> <span class="toc-text">TypeScript学习第二章:为什么使用TypeScript?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%8F%91%E7%8E%B0%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 发现问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 静态类型检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%9D%9E%E5%BC%82%E5%B8%B8%E6%95%85%E9%9A%9C"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 非异常故障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 使用工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E4%BC%98%E5%8C%96%E7%BC%96%E8%AF%91"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 优化编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%98%BE%E5%BC%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 显式类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E9%99%8D%E7%BA%A7%E7%BC%96%E8%AF%91"><span class="toc-number">2.7.</span> <span class="toc-text">2.7 降级编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.8.</span> <span class="toc-text">2.8 严格模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">TypeScript学习第三章: 常用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%9F%BA%E5%85%83%E7%B1%BB%E5%9E%8Bstring-number-%E5%92%8C-boolean"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 基元类型string number 和 boolean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%95%B0%E7%BB%84"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-any"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 any</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%8F%98%E9%87%8F%E4%B8%8A%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%A7%A3%E9%87%8A"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 变量上的类型解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.</span> <span class="toc-text">3.5 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.6.</span> <span class="toc-text">3.6 对象类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.7.</span> <span class="toc-text">3.7 联合类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">3.8.</span> <span class="toc-text">3.8 类型别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.9.</span> <span class="toc-text">3.9 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-10-%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80-as"><span class="toc-number">3.10.</span> <span class="toc-text">3.10 类型断言 as</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-11-%E6%96%87%E5%AD%97%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.11.</span> <span class="toc-text">3.11 文字类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E5%AD%97%E6%8E%A8%E7%90%86"><span class="toc-number">3.11.1.</span> <span class="toc-text">文字推理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-12-null%E5%92%8Cundefined"><span class="toc-number">3.12.</span> <span class="toc-text">3.12 null和undefined</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-13-%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.13.</span> <span class="toc-text">3.13 枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-14-%E4%B8%8D%E5%A4%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8E%9F%E8%AF%AD"><span class="toc-number">3.14.</span> <span class="toc-text">3.14 不太常见的原语</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E7%BC%A9%E5%B0%8F"><span class="toc-number">4.</span> <span class="toc-text">TypeScript学习第四章: 类型缩小</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-typeof%E7%B1%BB%E5%9E%8B%E5%AE%88%E5%8D%AB"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 typeof类型守卫</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%9C%9F%E5%80%BC%E7%BC%A9%E5%B0%8F"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 真值缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%AD%89%E5%80%BC%E7%BC%A9%E5%B0%8F"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 等值缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-in%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%BC%A9%E5%B0%8F"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 in操作符缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-instanceof%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%BC%A9%E5%B0%8F"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 instanceof操作符缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E5%88%86%E9%85%8D%E7%BC%A9%E5%B0%8F"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 分配缩小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%88%86%E6%9E%90"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 控制流分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%B0%93%E8%AF%8D"><span class="toc-number">4.8.</span> <span class="toc-text">4.8 使用类型谓词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-%E5%8F%97%E6%AD%A7%E8%A7%86%E7%9A%84unions"><span class="toc-number">4.9.</span> <span class="toc-text">4.9 受歧视的unions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-never%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%A9%B7%E5%B0%BD%E6%80%A7%E6%A3%80%E6%9F%A5"><span class="toc-number">4.10.</span> <span class="toc-text">4.10 never类型与穷尽性检查</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">TypeScript学习第五章: 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 函数类型表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E8%B0%83%E7%94%A8%E7%AD%BE%E5%90%8D-%E5%B1%9E%E6%80%A7%E7%AD%BE%E5%90%8D"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 调用签名: 属性签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%9E%84%E9%80%A0%E7%AD%BE%E5%90%8D-new-params-%E2%80%A6-Ctor"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 构造签名 new (params, …): Ctor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%B3%9B%E5%9E%8B%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 泛型函数&lt;Type&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1 类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.4.2.</span> <span class="toc-text">5.4.2 限制条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-%E4%BD%BF%E7%94%A8%E5%8F%97%E9%99%90%E5%80%BC"><span class="toc-number">5.4.3.</span> <span class="toc-text">5.4.3 使用受限值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-4-%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">5.4.4.</span> <span class="toc-text">5.4.4 指定类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-5-%E7%BC%96%E5%86%99%E4%BC%98%E7%A7%80%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%86%E5%88%99"><span class="toc-number">5.4.5.</span> <span class="toc-text">5.4.5 编写优秀通用函数的准则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 可选参数 ?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-1-%E5%9B%9E%E8%B0%83%E4%B8%AD%E7%9A%84%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-number">5.5.1.</span> <span class="toc-text">5.5.1 回调中的可选参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD-%E9%87%8D%E8%BD%BD%E7%AD%BE%E5%90%8D"><span class="toc-number">5.6.</span> <span class="toc-text">5.6 函数重载: 重载签名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-1-%E9%87%8D%E8%BD%BD%E7%AD%BE%E5%90%8D%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%AD%BE%E5%90%8D"><span class="toc-number">5.6.1.</span> <span class="toc-text">5.6.1 重载签名和实现签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-2-%E7%BC%96%E5%86%99%E5%A5%BD%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">5.6.2.</span> <span class="toc-text">5.6.2 编写好的重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-3-%E5%87%BD%E6%95%B0%E5%86%85This%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">5.6.3.</span> <span class="toc-text">5.6.3 函数内This的声明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.7.</span> <span class="toc-text">5.7 需要了解的其他类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-1-void"><span class="toc-number">5.7.1.</span> <span class="toc-text">5.7.1 void</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-2-object"><span class="toc-number">5.7.2.</span> <span class="toc-text">5.7.2 object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-3-unknown"><span class="toc-number">5.7.3.</span> <span class="toc-text">5.7.3 unknown</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-4-never"><span class="toc-number">5.7.4.</span> <span class="toc-text">5.7.4 never</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-5-Function"><span class="toc-number">5.7.5.</span> <span class="toc-text">5.7.5 Function</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-%E5%87%BD%E6%95%B0%E5%B1%95%E5%BC%80%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.8.</span> <span class="toc-text">5.8 函数展开运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-1-%E5%BD%A2%E5%8F%82%E5%B1%95%E5%BC%80-Rest-Parameters"><span class="toc-number">5.8.1.</span> <span class="toc-text">5.8.1 形参展开(Rest Parameters)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-2-%E5%AE%9E%E5%8F%82%E5%B1%95%E5%BC%80-Rest-Arguments"><span class="toc-number">5.8.2.</span> <span class="toc-text">5.8.2 实参展开(Rest Arguments)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%84"><span class="toc-number">5.9.</span> <span class="toc-text">5.9 参数解构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-10-%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%AF%E5%88%86%E9%85%8D%E6%80%A7-%E8%BF%94%E5%9B%9Evoid%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.10.</span> <span class="toc-text">5.10 函数的可分配性: 返回void类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">TypeScript学习第六章: 对象类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9%E5%99%A8"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 属性修改器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 可选属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 只读属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 索引签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 扩展类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.6.</span> <span class="toc-text">6.6 交叉类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E4%BA%A4%E5%8F%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.7.</span> <span class="toc-text">6.7 接口与交叉类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-8-%E6%B3%9B%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.8.</span> <span class="toc-text">6.8 泛型对象类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.9.</span> <span class="toc-text">6.9 数组类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-%E5%8F%AA%E8%AF%BB%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.10.</span> <span class="toc-text">6.10 只读数组类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-11-%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.11.</span> <span class="toc-text">6.11 元组类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-12-%E5%8F%AA%E8%AF%BB%E5%85%83%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.12.</span> <span class="toc-text">6.12 只读元组类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E6%93%8D%E7%BA%B5"><span class="toc-number">7.</span> <span class="toc-text">TypeScript学习第七章: 类型操纵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-0-%E4%BB%8E%E7%B1%BB%E5%9E%8B%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.1.</span> <span class="toc-text">7.0 从类型中创建类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%B3%9B%E5%9E%8B"><span class="toc-number">7.2.</span> <span class="toc-text">7.1 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-Hello-World"><span class="toc-number">7.2.1.</span> <span class="toc-text">7.1.1 Hello World</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2-%E4%BD%BF%E7%94%A8%E9%80%9A%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">7.2.2.</span> <span class="toc-text">7.1.2 使用通用类型变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-3-%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.2.3.</span> <span class="toc-text">7.1.3 泛型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-4-%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">7.2.4.</span> <span class="toc-text">7.1.4 泛型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-5-%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">7.2.5.</span> <span class="toc-text">7.1.5 泛型约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-6-%E5%9C%A8%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">7.2.6.</span> <span class="toc-text">7.1.6 在泛型约束中使用类型参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-7-%E5%9C%A8%E6%B3%9B%E5%9E%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.2.7.</span> <span class="toc-text">7.1.7 在泛型中使用类类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-keyOf%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">7.3.</span> <span class="toc-text">7.2 keyOf类型操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-typeof%E7%B1%BB%E5%9E%8B%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">7.4.</span> <span class="toc-text">7.3 typeof类型操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E7%B4%A2%E5%BC%95%E8%AE%BF%E9%97%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.5.</span> <span class="toc-text">7.4 索引访问类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.6.</span> <span class="toc-text">7.5 条件类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-1-%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">7.6.1.</span> <span class="toc-text">7.5.1 条件类型约束</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-2-%E5%9C%A8%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%86%85%E8%BF%9B%E8%A1%8C%E6%8E%A8%E7%90%86"><span class="toc-number">7.6.2.</span> <span class="toc-text">7.5.2 在条件类型内进行推理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-3-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9D%A1%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.6.3.</span> <span class="toc-text">7.5.3 分布式条件类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.7.</span> <span class="toc-text">7.6 映射类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-1-%E6%98%A0%E5%B0%84%E4%BF%AE%E6%94%B9%E5%99%A8"><span class="toc-number">7.7.1.</span> <span class="toc-text">7.6.1 映射修改器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-2-%E9%80%9A%E8%BF%87-as-%E5%81%9Akey%E9%87%8D%E6%98%A0%E5%B0%84"><span class="toc-number">7.7.2.</span> <span class="toc-text">7.6.2 通过 as 做key重映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-3-%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%8E%A2%E7%B4%A2"><span class="toc-number">7.7.3.</span> <span class="toc-text">7.6.3 进一步探索</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">TypeScript学习第八章: 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 类成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">8.1.1.</span> <span class="toc-text">8.1.1 类属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-readonly"><span class="toc-number">8.1.2.</span> <span class="toc-text">8.1.2 readonly</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-3-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">8.1.3.</span> <span class="toc-text">8.1.3 构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Super-%E8%B0%83%E7%94%A8"><span class="toc-number">8.1.3.1.</span> <span class="toc-text">Super 调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-4-%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.4.</span> <span class="toc-text">8.1.4 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-5-Getters-Setters"><span class="toc-number">8.1.5.</span> <span class="toc-text">8.1.5 Getters&#x2F; Setters</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-6-%E7%B4%A2%E5%BC%95%E7%AD%BE%E5%90%8D"><span class="toc-number">8.1.6.</span> <span class="toc-text">8.1.6 索引签名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E7%B1%BB%E7%BB%A7%E6%89%BF"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 类继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-implements%E5%AD%90%E5%8F%A5"><span class="toc-number">8.2.1.</span> <span class="toc-text">8.2.1 implements子句</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.2.1.1.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-extends%E5%AD%90%E5%8F%A5"><span class="toc-number">8.2.2.</span> <span class="toc-text">8.2.2 extends子句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-3-%E9%87%8D%E5%86%99%E6%96%B9%E6%B3%95-%E9%81%B5%E5%AE%88%E5%9F%BA%E7%B1%BB%E5%A5%91%E7%BA%A6"><span class="toc-number">8.2.3.</span> <span class="toc-text">8.2.3 重写方法(遵守基类契约)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-4-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">8.2.4.</span> <span class="toc-text">8.2.4 初始化顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-5-%E7%BB%A7%E6%89%BF%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.2.5.</span> <span class="toc-text">8.2.5 继承内置类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">8.3.</span> <span class="toc-text">8.3 成员的可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1-public"><span class="toc-number">8.3.1.</span> <span class="toc-text">8.3.1 public</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-protected"><span class="toc-number">8.3.2.</span> <span class="toc-text">8.3.2 protected</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-3-private"><span class="toc-number">8.3.3.</span> <span class="toc-text">8.2.3 private</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">8.4.</span> <span class="toc-text">8.4 静态成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-1-%E7%89%B9%E6%AE%8A%E9%9D%99%E6%80%81%E5%90%8D%E7%A7%B0"><span class="toc-number">8.4.1.</span> <span class="toc-text">8.4.1 特殊静态名称</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E9%9D%99%E6%80%81%E7%B1%BB%EF%BC%9F"><span class="toc-number">8.4.2.</span> <span class="toc-text">8.4.2 为什么没有静态类？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E7%B1%BB%E9%87%8C%E7%9A%84static%E5%8C%BA%E5%9D%97"><span class="toc-number">8.5.</span> <span class="toc-text">8.5 类里的static区块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">8.6.</span> <span class="toc-text">8.6 泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-%E7%B1%BB%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84this"><span class="toc-number">8.7.</span> <span class="toc-text">8.7 类运行时的this</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">8.7.1.</span> <span class="toc-text">1. 箭头函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-this%E5%8F%82%E6%95%B0"><span class="toc-number">8.7.2.</span> <span class="toc-text">2. this参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-this%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.8.</span> <span class="toc-text">8.8 this类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-9-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%9E%8B%E5%AE%88%E5%8D%AB%E7%9A%84this%EF%BC%88%EF%BC%9F%EF%BC%9F%EF%BC%9F%E4%B8%8D%E5%A4%AA%E4%BC%9A%EF%BC%89"><span class="toc-number">8.9.</span> <span class="toc-text">8.9 基于类型守卫的this（？？？不太会）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-10-%E5%8F%82%E6%95%B0%E5%B1%9E%E6%80%A7%EF%BC%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BD%AC%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">8.10.</span> <span class="toc-text">8.10 参数属性，构造函数参数转类属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-11-%E7%B1%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">8.11.</span> <span class="toc-text">8.11 类表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-12-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98"><span class="toc-number">8.12.</span> <span class="toc-text">8.12 抽象类和成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-13-%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">8.13.</span> <span class="toc-text">8.13 类之间的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%9A%E6%A8%A1%E5%9D%97"><span class="toc-number">9.</span> <span class="toc-text">TypeScript学习第九章：模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89JavaScript%E6%A8%A1%E5%9D%97"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 如何定义JavaScript模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E9%9D%9E%E6%A8%A1%E5%9D%97"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 非模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-TypeScript%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97"><span class="toc-number">9.3.</span> <span class="toc-text">9.3 TypeScript中的模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-1-ES%E6%A8%A1%E5%9D%97%E8%AF%AD%E6%B3%95"><span class="toc-number">9.3.1.</span> <span class="toc-text">9.3.1 ES模块语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-%E9%A2%9D%E5%A4%96%E7%9A%84%E5%AF%BC%E5%85%A5%E8%AF%AD%E6%B3%95"><span class="toc-number">9.3.2.</span> <span class="toc-text">9.3.2 额外的导入语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-3-TypeScript%E7%89%B9%E5%AE%9A%E7%9A%84ES%E6%A8%A1%E5%9D%97%E8%AF%AD%E6%B3%95"><span class="toc-number">9.3.3.</span> <span class="toc-text">9.3.3 TypeScript特定的ES模块语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-4-ES%E6%A8%A1%E5%9D%97%E8%AF%AD%E6%B3%95%E4%B8%8ECommonJS%E8%A1%8C%E4%B8%BA"><span class="toc-number">9.3.4.</span> <span class="toc-text">9.3.4 ES模块语法与CommonJS行为</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-CommonJS-%E8%AF%AD%E6%B3%95"><span class="toc-number">9.4.</span> <span class="toc-text">9.4 CommonJS 语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-1-%E5%AF%BC%E5%87%BA"><span class="toc-number">9.4.1.</span> <span class="toc-text">9.4.1 导出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2-CommonJS%E5%92%8CES%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7"><span class="toc-number">9.4.2.</span> <span class="toc-text">9.4.2 CommonJS和ES模块的互操作性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-TypeScript%E7%9A%84%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90%E9%80%89%E9%A1%B9"><span class="toc-number">9.4.3.</span> <span class="toc-text">9.5 TypeScript的模块解析选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-TypeScript%E7%9A%84%E6%A8%A1%E5%9D%97%E8%BE%93%E5%87%BA%E9%80%89%E9%A1%B9"><span class="toc-number">9.5.</span> <span class="toc-text">9.6 TypeScript的模块输出选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-TypeScript-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">9.6.</span> <span class="toc-text">9.7 TypeScript 命名空间</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/27/" title="再见 MyBatis-Plus ！">再见 MyBatis-Plus ！</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/26/" title="“人尽皆知”的单例模式">“人尽皆知”的单例模式</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/29/" title="阿里的同事，写的代码真 TMD 优雅！">阿里的同事，写的代码真 TMD 优雅！</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/28/" title="别再用 BeanUtils 了，这款 PO VO DTO 转换神器不香么？">别再用 BeanUtils 了，这款 PO VO DTO 转换神器不香么？</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/30/" title="MyBatis过时了吗？">MyBatis过时了吗？</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="小u" target="_blank">小u</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">238</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">39</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">50</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://mydocs.guoyaxue.top/" title="旧版博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="旧版博客"/><span class="back-menu-item-text">旧版博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://pan.xiaou61.top/#/" title="免费网盘"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="免费网盘"/><span class="back-menu-item-text">免费网盘</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://cloud.xiaou61.top/" title="云盘(自用)"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="云盘(自用)"/><span class="back-menu-item-text">云盘(自用)</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://wpzc.xiaou61.top/" title="云盘转存"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="云盘转存"/><span class="back-menu-item-text">云盘转存</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://love.xiaou61.top/#/" title="关于我们(My girlFriend)"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="关于我们(My girlFriend)"/><span class="back-menu-item-text">关于我们(My girlFriend)</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">娱乐项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://fxq.xiaou61.top/#/" title="飞行棋"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="飞行棋"/><span class="back-menu-item-text">飞行棋</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/game/sqnwmai803/" title="谁去拿外卖"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="谁去拿外卖"/><span class="back-menu-item-text">谁去拿外卖</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/desktop.html" title="win12网页版"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/icon/logo.svg" alt="win12网页版"/><span class="back-menu-item-text">win12网页版</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://game.xiaou61.top/" title="在线游戏"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="在线游戏"/><span class="back-menu-item-text">在线游戏</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 开往</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><span> 开往</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>3</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JVM/" style="font-size: 0.88rem;">JVM<sup>22</sup></a><a href="/tags/Nginx/" style="font-size: 0.88rem;">Nginx<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>1</sup></a><a href="/tags/Ts/" style="font-size: 0.88rem;">Ts<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size: 0.88rem;">TypeScript<sup>1</sup></a><a href="/tags/WebApi/" style="font-size: 0.88rem;">WebApi<sup>1</sup></a><a href="/tags/coder1v5/" style="font-size: 0.88rem;">coder1v5<sup>2</sup></a><a href="/tags/css/" style="font-size: 0.88rem;">css<sup>3</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>12</sup></a><a href="/tags/javaSE/" style="font-size: 0.88rem;">javaSE<sup>3</sup></a><a href="/tags/javaWeb/" style="font-size: 0.88rem;">javaWeb<sup>2</sup></a><a href="/tags/js%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">js逆向<sup>1</sup></a><a href="/tags/leetcode/" style="font-size: 0.88rem;">leetcode<sup>3</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>8</sup></a><a href="/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/" style="font-size: 0.88rem;">书籍推荐<sup>2</sup></a><a href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%90%AC%E8%BF%90/" style="font-size: 0.88rem;">公众号搬运<sup>35</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 0.88rem;">前端<sup>10</sup></a><a href="/tags/%E5%8A%9E%E5%85%AC/" style="font-size: 0.88rem;">办公<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 0.88rem;">后端<sup>8</sup></a><a href="/tags/%E5%A4%A9%E6%B6%AF%E8%AE%BA%E5%9D%9B/" style="font-size: 0.88rem;">天涯论坛<sup>1</sup></a><a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 0.88rem;">导航<sup>1</sup></a><a href="/tags/%E5%B0%B1%E4%B8%9A/" style="font-size: 0.88rem;">就业<sup>16</sup></a><a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 0.88rem;">微信<sup>1</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/" style="font-size: 0.88rem;">技术杂谈<sup>51</sup></a><a href="/tags/%E6%8E%98%E9%87%91/" style="font-size: 0.88rem;">掘金<sup>14</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 0.88rem;">杂项<sup>1</sup></a><a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 0.88rem;">测试<sup>1</sup></a><a href="/tags/%E6%B8%A1%E4%B8%80%E5%A4%A7%E5%B8%88%E8%AF%BE/" style="font-size: 0.88rem;">渡一大师课<sup>3</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 0.88rem;">爬虫<sup>1</sup></a><a href="/tags/%E7%9B%AE%E5%BD%95/" style="font-size: 0.88rem;">目录<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>4</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 0.88rem;">虚拟机<sup>12</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>6</sup></a><a href="/tags/%E8%B7%AF%E9%A3%9E%E5%AD%A6%E9%99%A2/" style="font-size: 0.88rem;">路飞学院<sup>3</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">面向对象<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>51</sup></a><a href="/tags/%E9%A3%9E%E8%A1%8C%E6%A3%8B/" style="font-size: 0.88rem;">飞行棋<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="7409599794" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>