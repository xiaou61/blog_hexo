<!DOCTYPE html><html class="hide-aside" lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>WebApi | 小u的博客</title><meta name="keywords" content="前端,WebApi"><meta name="author" content="小u"><meta name="copyright" content="小u"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="WebApi"><meta name="application-name" content="WebApi"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="WebApi"><meta property="og:url" content="http://example.com/2023/10/01/codenotes/front_end/WebApi/index.html"><meta property="og:site_name" content="小u的博客"><meta property="og:description" content="WebApi这个只作为一个了解就可以了 Canvas API概述&amp;lt;canvas&amp;gt;元素用于生成图像。它本身就像一个画布，JavaScript 通过操作它的 API，在上面生成图像。它的底层是一个个像素，基本上&amp;lt;canvas&amp;gt;是一个可以用 JavaScript 操作的位图（bit"><meta property="og:locale" content="en"><meta property="og:image" content="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png"><meta property="article:author" content="小u"><meta property="article:tag" content="Java,java,springboot,mysql,redis,教程,git,软件,编程,开发,互联网,Java 基础,Java 教程,Java程序员进阶之路,Java 入门,Vue,前端,算法"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png"><meta name="description" content="WebApi这个只作为一个了解就可以了 Canvas API概述&amp;lt;canvas&amp;gt;元素用于生成图像。它本身就像一个画布，JavaScript 通过操作它的 API，在上面生成图像。它的底层是一个个像素，基本上&amp;lt;canvas&amp;gt;是一个可以用 JavaScript 操作的位图（bit"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2023/10/01/codenotes/front_end/WebApi/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//hm.baidu.com"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1433b93d16cca6b366bdf23126c0c200";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"tianli","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"784b999ee9b2f0689c5a","Referer":"https://mydocs-1305448902.cos-website.ap-nanjing.myqcloud.com/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: 小u","link":"Link: ","source":"Source: 小u的博客","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小u的博客',
  title: 'WebApi',
  postAI: '',
  pageFillDescription: 'WebApi, Canvas API, 概述, Canvas API：绘制图形, 路径, 线型, 矩形, 弧线, 文本, 渐变色和图像填充, 阴影, Canvas API：图像处理, CanvasRenderingContext2D.drawImage(), 像素读写, CanvasRenderingContext2D.save()CanvasRenderingContext2D.restore(), CanvasRenderingContext2D.canvas, 图像变换, ltcanvasgt 元素的方法, HTMLCanvasElement.toDataURL(), HTMLCanvasElement.toBlob(), Canvas 使用实例, 动画效果, 像素处理, 参考链接, 剪贴板操作 Clipboard API 教程, 简介, Document.execCommand() 方法, 异步 Clipboard API, Clipboard 对象, Clipboard.readText(), Clipboard.read(), Clipboard.writeText(), Clipboard.write(), copy 事件cut 事件, paste 事件, 参考链接, Fetch API 教程, 基本用法, Response 对象：处理 HTTP 回应, Response 对象的同步属性, 判断请求是否成功, Response.headers 属性, 读取内容的方法, Response.clone(), Response.body 属性, fetch()的第二个参数：定制 HTTP 请求, fetch()配置对象的完整 API, 取消fetch()请求, 参考链接, FontFace API, Geolocation API, Geolocation 对象, Geolocation.getCurrentPosition(), Geolocation.watchPosition(), Geolocation.clearWatch(), Coordinates 对象, 参考链接, IntersectionObserver, 简介, IntersectionObserver.observe(), callback 参数, IntersectionObserverEntry 对象, Option 对象, 实例, 惰性加载（lazy load）, 无限滚动, 视频自动播放, 参考链接, Intl.RelativeTimeFormat, 基本用法, Intl.RelativeTimeFormat.prototype.format(), Intl.RelativeTimeFormat.prototype.formatToParts(), 参考链接, Offline 应用, Page Lifecycle API, 生命周期阶段, 常见场景, 事件, focus 事件, blur 事件, visibilitychange 事件, freeze 事件, resume 事件, pageshow 事件, pagehide 事件, beforeunload 事件, unload 事件, 获取当前阶段, document.wasDiscarded, 参考链接, Page Visibility API, 简介, document.visibilityState, document.hidden, visibilitychange 事件, 页面卸载, 参考链接, Point lock API, Server-Sent Events, 简介, 与 WebSocket 的比较, 客户端 API, EventSource 对象, readyState 属性, url 属性, withCredentials 属性, onopen 属性, onmessage 属性, onerror 属性, 自定义事件, close() 方法, 服务器实现, 数据格式, data 字段, id 字段, event 字段, retry 字段, Node 服务器实例, 参考链接, Service Worker, 含义, 使用步骤, 登记, 安装, 激活, Service Worker 与网页的通信, 参考链接, SVG 图像, 概述, 语法, ltsvggt标签, ltcirclegt标签, ltlinegt标签, ltpolylinegt标签, ltrectgt标签, ltellipsegt标签, ltpolygongt标签, ltpathgt标签, lttextgt标签, ltusegt标签, ltggt标签, ltdefsgt标签, ltpatterngt标签, ltimagegt标签, ltanimategt标签, ltanimateTransformgt标签, JavaScript 操作, DOM 操作, 获取 SVG DOM, 读取 SVG 源码, SVG 图像转为 Canvas 图像, 实例：折线图, 参考链接, Web Share API, 概述, 接口细节, 分享文件, 参考链接, Web Audio API, 基本用法, context.createBuffer(), 过滤器, Web Components, 概述, Custom Element, 简介, 生命周期方法, 自定义属性和方法, window.customElements.whenDefined(), 回调函数, Custom Element 的子元素, lttemplategt标签, 基本用法, document.importNode(), Shadow DOM, HTML Import, 基本操作, 脚本的执行, Web Component的封装, Polymer.js, 直接使用的组件, 安装, 自定义组件, 组件的使用方法, 参考链接, WebSocket, 简介, WebSocket 握手, 客户端的简单示例, 客户端 API, 构造函数 WebSocket, webSocket.readyState, webSocket.onopen, webSocket.onclose, webSocket.onmessage, webSocket.send(), webSocket.bufferedAmount, webSocket.onerror, WebSocket 服务器, 参考链接这个只作为一个了解就可以了概述元素用于生成图像它本身就像一个画布通过操作它的在上面生成图像它的底层是一个个像素基本上是一个可以用操作的位图它与图像的区别在于是脚本调用各种方法生成图像则是一个文件通过各种子元素生成图像使用之前需要在网页里面新建一个元素您的浏览器不支持如果浏览器不支持这个就会显示标签中间的文字您的浏览器不支持每个元素都有一个对应的对象上下文对象就定义在这个对象上面上面代码中元素节点对象的方法返回的就是对象注意需要方法指定参数表示该节点生成的平面图像如果参数是就表示用于生成的立体图案这部分属于按照用途分成两大部分绘制图形和图像处理绘制图形画布提供了一个作图的平面空间该空间的每个点都有自己的坐标原点位于图像左上角轴的正向是原点向右轴的正向是原点向下路径以下方法和属性用来绘制路径开始绘制路径结束路径返回到当前路径的起始点会从当前点到起始点绘制一条直线如果图形已经封闭或者只有一个点那么此方法不会产生任何效果设置路径的起点即将一个新路径的起始点移动到坐标使用直线从当前点连接到坐标在路径内部填充颜色默认为黑色路径线条着色默认为黑色指定路径填充的颜色和样式默认为黑色指定路径线条的颜色和样式默认为黑色上面代码只是确定了路径的形状画布上还看不出来因为没有颜色所以还需要着色或者上面代码中这两个方法都可以使得路径可见在路径内部填充颜色使之变成一个实心的图形只对路径线条着色这两个方法默认都是使用黑色可以使用和属性指定其他颜色或者上面代码将填充和线条的颜色指定为红色线型以下的方法和属性控制线条的视觉特征指定线条的宽度默认为指定线条末端的样式有三个可能的值默认值末端为矩形末端为圆形末端为突出的矩形矩形宽度不变高度为线条宽度的一半指定线段交点的样式有三个可能的值交点为扇形交点为三角形底边默认值交点为菱形指定交点菱形的长度默认为该属性只在属性的值等于时有效返回一个数组表示虚线里面线段和间距的长度数组用于指定虚线里面线段和间距的长度上面代码中线条的宽度为线条的末端和交点都改成圆角并且设置为虚线矩形以下方法用来绘制矩形绘制矩形路径填充一个矩形绘制矩形边框指定矩形区域的像素都变成透明上面四个方法的格式都一样都接受四个参数分别是矩形左上角的横坐标和纵坐标矩形的宽和高方法用于绘制矩形路径上面代码绘制一个正方形左上角坐标为宽和高都为用来向一个矩形区域填充颜色上面代码绘制一个绿色的正方形左上角坐标为宽和高都为用来绘制一个矩形区域的边框上面代码绘制一个绿色的空心正方形左上角坐标为宽和高都为用于擦除指定矩形区域的像素颜色等同于把早先的绘制效果都去除上面代码先绘制一个的正方形然后在它的内部擦除的区域等同于形成了一个像素宽度的边框弧线以下方法用于绘制弧形通过指定圆心和半径绘制弧形通过指定两根切线和半径绘制弧形主要用来绘制圆形或扇形格式实例方法的和参数是圆心坐标是半径和则是扇形的起始角度和终止角度以弧度表示表示做图时应该逆时针画还是顺时针画这个参数用来控制扇形的方向比如上半圆还是下半圆下面是绘制实心圆形的例子上面代码绘制了一个半径起始角度为终止角度为的完整的圆绘制空心半圆的例子方法主要用来绘制圆弧需要给出两个点的坐标当前点与第一个点形成一条直线第一个点与第二个点形成另一条直线然后画出与这两根直线相切的弧线上面代码中有个参数前两个参数是第一个点的坐标第三个参数和第四个参数是第二个点的坐标第五个参数是半径然后与形成一条直线然后与形成第二条直线弧线就是与这两根直线相切的部分文本以下方法和属性用于绘制文本在指定位置绘制实心字符在指定位置绘制空心字符返回一个对象指定字型大小和字体默认值为文本的对齐方式默认值为文本的方向默认值为文本的垂直位置默认值为方法用来在指定位置绘制实心字符该方法接受四个参数所要填充的字符串文字起点的横坐标单位像素文字起点的纵坐标单位像素文本的最大像素宽度该参数可选如果省略则表示宽度没有限制如果文本实际长度超过这个参数指定的值那么浏览器将尝试用较小的字体填充上面代码在位置写入字符串注意方法不支持文本断行所有文本一定出现在一行内如果要生成多行文本只有调用多次方法方法用来添加空心字符它的参数与一致上面这两种方法绘制的文本默认都是大小字体属性可以改变字体设置该属性的值是一个字符串使用的属性即可属性用来指定文本的对齐方式它可以取以下几个值左对齐右对齐居中默认值起点对齐从左到右的文本为左对齐从右到左的文本为右对齐结尾对齐从左到右的文本为右对齐从右到左的文本为左对齐属性指定文本的方向默认值为表示继承或的设置其他值包括从左到右和从右到左属性指定文本的垂直位置可以取以下值上部对齐字母的基线是整体上移悬挂对齐字母的上沿在一根直线上适用于印度文和藏文中部对齐字母的中线在一根直线上默认值表示字母位于字母表的正常位置四线格的第三根线下沿对齐字母的下沿在一根直线上使用于东亚文字底部对齐字母的基线下移对于英文字母这个设置与没有差异方法接受一个字符串作为参数返回一个对象可以从这个对象上面获取参数字符串的信息目前主要是文本渲染后的宽度上面代码中大小的字符串渲染后宽度为放大到以后宽度为渐变色和图像填充以下方法用于设置渐变效果和图像填充效果定义线性渐变样式定义辐射渐变样式定义图像填充样式方法按照给定直线生成线性渐变的样式方法接受四个参数和是起点的横坐标和纵坐标和是终点的横坐标和纵坐标通过不同的坐标值可以生成从上至下从左到右的渐变等等该方法的返回值是一个对象该对象只有一个方向用来指定渐变点的颜色方法接受两个参数第一个参数是到之间的一个位置量表示起点表示终点第二个参数是一个字符串表示颜色上面代码中定义了渐变样式以后将这个样式指定给属性然后就会生成以这个样式填充的矩形区域方法定义一个辐射渐变需要指定两个圆方法接受六个参数和是辐射起始的圆的圆心坐标是起始圆的半径和是辐射终止的圆的圆心坐标是终止圆的半径该方法的返回值也是一个对象上面代码中生成辐射样式以后用这个样式填充一个矩形方法定义一个图像填充样式在指定方向上不断重复该图像填充指定的区域该方法接受两个参数第一个参数是图像数据它可以是元素也可以是另一个元素或者一个表示图像的对象第二个参数是一个字符串有四个可能的值分别是双向重复水平重复垂直重复不重复如果第二个参数是空字符串或则等同于该方法的返回值是一个对象上面代码中图像加载成功以后使用生成图像样式然后使用这个样式填充指定区域阴影以下属性用于设置阴影阴影的模糊程度默认为阴影的颜色默认为阴影的水平位移默认为阴影的垂直位移默认为下面是一个例子图像处理允许将图像文件写入画布做法是读取图片后使用方法将这张图片放上画布有三种使用格式各个参数的含义如下图像元素图像内部的横坐标用于映射到画布的放置点上图像内部的纵坐标用于映射到画布的放置点上图像在画布上的宽度会产生缩放效果如果未指定则图像不会缩放按照实际大小占据画布的宽度图像在画布上的高度会产生缩放效果如果未指定则图像不会缩放按照实际大小占据画布的高度画布内部的横坐标用于放置图像的左上角画布内部的纵坐标用于放置图像的右上角图像在画布内部的宽度会产生缩放效果图像在画布内部的高度会产生缩放效果下面是最简单的使用场景将图像放在画布上两者左上角对齐上面代码将一个图像放入画布这时图像将是原始大小如果画布小于图像就会只显示出图像左上角正好等于画布大小的那一块如果要显示完整的图片可以用图像的宽和高设置成画布的宽和高上面代码中元素的大小设置成图像的本来大小就能保证完整展示图像由于图像的本来大小只有图像加载成功以后才能拿到因此调整画布的大小必须放在这个监听函数里面像素读写以下三个方法与像素读写相关将画布读取成一个对象将对象写入画布生成对象方法用来读取的内容返回一个对象包含了每个像素的信息方法接受四个参数和是读取区域的左上角坐标和是读取区域的宽度和高度如果想要读取整个区域可以写成下面这样方法返回的是一个对象该对象有三个属性一个一维数组该数组的值依次是每个像素的红绿蓝通道值每个值的范围是因此该数组的长度等于图像的像素宽度图像的像素高度这个数组不仅可读而且可写因此通过操作这个数组就可以达到操作图像的目的浮点数表示的像素宽度浮点数表示的像素高度方法将对象的像素绘制在画布上该方法有两种使用格式该方法有如下参数包含像素信息的对象元素内部的横坐标用于放置图像的左上角元素内部的纵坐标用于放置图像的左上角图像内部的横坐标用于作为放置到的矩形区域的左上角的横坐标默认为图像内部的纵坐标用于作为放置到的矩形区域的左上角的纵坐标默认为放置到的矩形区域的宽度默认为图像的宽度放置到的矩形区域的高度默认为图像的高度下面是将对象绘制到的例子方法用于生成一个空的对象所有像素都是透明的黑色即每个值都是该方法有两种使用格式方法的参数如下对象的宽度单位为像素对象的高度单位为像素一个现有的对象返回值将是这个对象的拷贝上面代码中是一个的像素区域其中每个像素都是透明的黑色方法用于将画布的当前样式保存到堆栈相当于在内存之中产生一个样式快照上面代码中会为画布的默认样式产生一个快照方法将画布的样式恢复到上一个保存的快照如果没有已保存的快照则不产生任何效果上下文环境方法用于恢复到上一次保存的上下文环境上面代码画一个矩形矩形的填充色本来设为绿色但是方法撤销了这个设置将样式恢复上一次保存的状态即默认样式所以实际的填充色是黑色默认颜色属性指向当前对象所在的元素该属性只读图像变换以下方法用于图像变换图像旋转图像缩放图像平移通过一个变换矩阵完成图像变换取消前面的图像变换方法用于图像旋转它接受一个弧度值作为参数表示顺时针旋转的度数上面代码会显示一个顺时针倾斜度的矩形注意方法必须在方法之前调用否则是不起作用的旋转中心点始终是画布左上角的原点如果要更改中心点需要使用方法移动画布方法用于缩放图像它接受两个参数分别是轴方向的缩放因子和轴方向的缩放因子默认情况下一个单位就是一个像素缩放因子可以缩放单位比如缩放因子表示将大小缩小为原来的缩放因子表示放大十倍上面代码中原来的矩形是缩放后展示出来是如果缩放因子为就表示图像没有任何缩放如果为则表示方向翻转为水平翻转表示垂直翻转上面代码会显示一个水平倒转的高度放大倍的注意负向缩放本质是坐标翻转所针对的坐标轴就是画布左上角原点的坐标轴方法用于平移图像它接受两个参数分别是轴和轴移动的距离单位像素方法接受一个变换矩阵的六个元素作为参数完成缩放旋转移动和倾斜等变形它的使用格式如下水平缩放默认值单位倍数水平倾斜默认值单位弧度垂直倾斜默认值单位弧度垂直缩放默认值单位倍数水平位移默认值单位像素垂直位移默认值单位像素下面是一个例子上面代码中原始图形是的矩形结果缩放成的矩形并且左上角从移动到注意多个方法具有叠加效果方法取消前面的图形变换将画布恢复到该方法指定的状态该方法的参数与方法完全一致上面代码中第一个方法绘制的矩形左上角从平移到方法取消了这个变换已绘制的图形不受影响将画布恢复到默认状态变换矩形所以第二个矩形的左上角回到元素的方法除了对象提供的方法元素本身也有自己的方法元素的方法可以将数据转为格式的图像方法接受两个参数字符串表示图像的格式默认为另一个可用的值是浏览器还可以使用浮点数到之间表示和图像的质量系数默认值为该方法的返回值是一个格式的字符串上面的代码将元素转化成上面代码将元素转成高画质中画质低画质三种图像方法用于将图像转成一个对象默认类型是它的使用格式如下格式示例方法可以接受三个参数回调函数它接受生成的对象作为参数字符串图像的类型默认是浮点数到之间表示图像的质量只对和类型的图像有效注意该方法没有返回值下面的例子将图像复制成图像使用完毕释放对象使用实例动画效果通过改变坐标很容易在画布元素上产生动画效果上面代码会产生一个小圆点每隔毫秒就向右下方移动的效果函数的一开始之所以要将画布重新渲染黑色底色是为了抹去上一步的小圆点在这个例子的基础上通过设置圆心坐标可以产生各种运动轨迹下面是先上升后下降的例子上面代码中坐标始终增大表示持续向右运动坐标先变小然后在重力作用下不断增大表示先上升后下降像素处理通过方法和方法可以处理每个像素进而操作图像内容因此可以改写图像下面是图像处理的通用写法上面代码中是一个处理像素的函数以下是几种常见的灰度效果灰度图就是取红绿蓝三个像素值的算术平均值这实际上将图像转成了黑白形式上面代码中是红色值是绿色值是蓝色值是通道值转成灰度的算法就是将红绿蓝三个值相加后除以再将结果写回数组复古效果复古效果是将红绿蓝三种值分别取这三个值的某种加权平均值使得图像有一种古旧的效果红色蒙版效果红色蒙版指的是让图像呈现一种偏红的效果算法是将红色通道设为红绿蓝三个值的平均值而将绿色通道和蓝色通道都设为红色通道取平均值绿色通道和蓝色通道都设为亮度效果亮度效果是指让图像变得更亮或更暗算法将红色通道绿色通道蓝色通道同时加上一个正值或负值反转效果反转效果是指图片呈现一种色彩颠倒的效果算法为红绿蓝通道都取各自的相反值原值参考链接剪贴板操作教程简介浏览器允许脚本读写剪贴板自动复制或粘贴内容一般来说脚本不应该改动用户的剪贴板以免不符合用户的预期但是有些时候这样做确实能够带来方便比如一键复制功能用户点击一下按钮指定的内容就自动进入剪贴板目前一共有三种方法可以实现剪贴板操作方法异步的事件和事件本文逐一介绍这三种方法方法是操作剪贴板的传统方法各种浏览器都支持它支持复制剪切和粘贴这三个操作复制剪切粘贴复制操作复制时先选中文本然后调用选中的文本就会进入剪贴板上面示例中脚本先选中输入框里面的文字然后将其复制到剪贴板注意复制操作最好放在事件监听函数里面由用户触发比如用户点击按钮如果脚本自主执行某些浏览器可能会报错粘贴操作粘贴时调用就会将剪贴板里面的内容输出到当前的焦点元素中缺点方法虽然方便但是有一些缺点首先它只能将选中的内容复制到剪贴板无法向剪贴板任意写入内容其次它是同步操作如果复制粘贴大量数据页面会出现卡顿有些浏览器还会跳出提示框要求用户许可这时在用户做出选择前页面会失去响应为了解决这些问题浏览器厂商提出了异步的异步是下一代的剪贴板操作方法比传统的方法更强大更合理它的所有操作都是异步的返回对象不会造成页面卡顿而且它可以将任意内容比如图片放入剪贴板属性返回对象所有操作都通过这个对象进行如果属性返回就说明当前浏览器不支持这个由于用户可能把敏感数据比如密码放在剪贴板允许脚本任意读取会产生安全风险所以这个的安全限制比较多首先浏览器规定只有协议的页面才能使用这个不过开发环境允许使用非加密协议其次调用时需要明确获得用户的许可权限的具体实现使用了跟剪贴板相关的有两个权限写权限和读权限写权限自动授予脚本而读权限必须用户明确同意给予也就是说写入剪贴板脚本可以自动完成但是读取剪贴板时浏览器会弹出一个对话框询问用户是否同意读取另外需要注意的是脚本读取的总是当前页面的剪贴板这带来的一个问题是如果把相关的代码粘贴到开发者工具中直接运行可能会报错因为这时的当前页面是开发者工具的窗口而不是网页页面如果你把上面的代码粘贴到开发者工具里面运行就会报错因为代码运行的时候开发者工具窗口是当前页这个页面不存在依赖的接口一个解决方法就是相关代码放到里面延迟运行在调用函数之前快速点击浏览器的页面窗口将其变成当前页上面代码粘贴到开发者工具运行后快速点击一下网页的页面窗口使其变为当前页这样就不会报错了对象对象提供了四个方法用来读写剪贴板它们都是异步方法返回对象方法用于复制剪贴板里面的文本数据上面示例中用户点击页面后就会输出剪贴板里面的文本注意浏览器这时会跳出一个对话框询问用户是否同意脚本读取剪贴板如果用户不同意脚本就会报错这时可以使用结构处理报错方法用于复制剪贴板里面的数据可以是文本数据也可以是二进制数据比如图片该方法需要用户明确给予许可该方法返回一个对象一旦该对象的状态变为就可以获得一个数组每个数组成员都是对象的实例对象表示一个单独的剪贴项每个剪贴项都拥有属性和方法属性返回一个数组里面的成员是该剪贴项可用的类型比如某个剪贴项可以用格式粘贴也可以用纯文本格式粘贴那么它就有两个类型和方法用于读取剪贴项的数据返回一个对象该方法接受剪贴项的类型作为参数返回该类型的数据该参数是必需的否则会报错方法用于将文本内容写入剪贴板上面示例是用户在网页点击后脚本向剪贴板写入文本数据该方法不需要用户许可但是最好也放在里面防止报错方法用于将任意数据写入剪贴板可以是文本数据也可以是二进制数据该方法接受一个实例作为参数表示写入剪贴板的数据上面示例中脚本向剪贴板写入了一张图片注意浏览器目前只支持写入格式的图片是浏览器原生提供的构造函数用来生成实例它接受一个对象作为参数该对象的键名是数据的类型键值就是数据本身下面的例子是将同一个剪贴项的多种格式的值写入剪贴板一种是文本数据另一种是二进制数据供不同的场合粘贴使用事件事件用户向剪贴板放入数据时将触发事件下面的示例是将用户放入剪贴板的文本转为大写上面示例中事件对象的属性包含了剪贴板数据它是一个对象有以下属性和方法修改剪贴板数据需要指定数据类型获取剪贴板数据需要指定数据类型清除剪贴板数据可以指定数据类型如果不指定类型将清除所有类型的数据一个类似数组的对象包含了所有剪贴项不过通常只有一个剪贴项下面的示例是拦截用户的复制操作将指定内容放入剪贴板上面示例中先使用取消了剪贴板的默认操作然后由脚本接管复制操作事件则是在用户进行剪切操作时触发它的处理跟事件完全一样也是从属性拿到剪切的数据事件用户使用剪贴板数据进行粘贴操作时会触发事件下面的示例是拦截粘贴操作由脚本将剪贴板里面的数据取出来参考链接教程是的升级版用于在脚本里面发出请求浏览器原生提供这个对象本章详细介绍它的用法基本用法的功能与基本相同但有三个主要的差异使用不使用回调函数因此大大简化了写法写起来更简洁采用模块化设计分散在多个对象上对象对象对象更合理一些相比之下的设计并不是很好输入输出状态都在同一个接口管理容易写出非常混乱的代码通过数据流对象处理数据可以分块读取有利于提高网站性能表现减少内存占用对于请求大文件或者网速慢的场景相当有用对象不支持数据流所有的数据必须放在缓存里不支持分块读取必须等待全部拿到后再一次性吐出来在用法上接受一个字符串作为参数默认向该网址发出请求返回一个对象它的基本用法如下下面是一个例子从服务器获取数据上面示例中接收到的是一个对象是一个异步操作取出所有内容并将其转为对象可以使用语法改写使得语义更清晰上面示例中语句必须放在里面这样才能捕捉异步操作中可能发生的错误后文都采用的写法不使用的写法对象处理回应对象的同步属性请求成功以后得到的是一个对象它对应服务器的回应前面说过包含的数据通过接口异步读取但是它还包含一些同步属性对应回应的标头信息可以立即读取上面示例中和就是的同步属性可以立即读取标头信息属性有下面这些属性返回一个布尔值表示请求是否成功对应请求的状态码到对应其他的状态码属性返回一个数字表示回应的状态码例如表示成功请求属性返回一个字符串表示回应的状态信息例如请求成功以后服务器返回属性返回请求的如果存在跳转该属性返回的是最终属性返回请求的类型可能的值如下普通请求即同源请求跨源请求网络错误主要用于如果请求的属性设为就会返回这个值详见请求部分表示发出的是简单的跨源请求类似表单的那种跨源请求如果请求的属性设为就会返回这个值详见请求部分属性返回一个布尔值表示请求是否发生过跳转判断请求是否成功发出请求以后有一个很重要的注意点只有网络错误或者无法连接时才会报错其他情况都不会报错而是认为请求成功这就是说即使服务器返回的状态码是或也不会报错即不会变为状态只有通过属性得到回应的真实状态码才能判断请求是否成功请看下面的例子上面示例中属性只有等于才能认定请求成功这里不用考虑网址跳转状态码为因为会将跳转的状态码自动转为另一种方法是判断是否为请求成功请求失败属性对象还有一个属性指向一个对象对应回应的所有标头对象可以使用循环进行遍历或者对象提供了以下方法用来操作标头根据指定的键名返回键值返回一个布尔值表示是否包含某个标头将指定的键名设置为新的键值如果该键名不存在则会添加添加标头删除标头返回一个遍历器可以依次遍历所有键名返回一个遍历器可以依次遍历所有键值返回一个遍历器可以依次遍历所有键值对依次遍历标头每个标头都会执行一次参数函数上面的有些方法可以修改标头那是因为继承自接口对于回应来说修改标头意义不大况且很多标头是只读的浏览器不允许修改这些方法中最常用的是用于读取某个标头的值和方法用来分别遍历标头的键名和键值键名键值方法也可以遍历所有的键值和键名读取内容的方法对象根据服务器返回的不同类型的数据提供了不同的读取方法得到文本字符串得到对象得到二进制对象得到表单对象得到二进制对象上面个读取方法都是异步的返回的都是对象必须等到异步操作结束才能得到服务器返回的完整数据可以用于获取文本数据比如文件主要用于获取服务器返回的数据前面已经举过例子了主要用在里面拦截用户提交的表单修改某些数据以后再提交给服务器用于获取二进制文件上面示例读取图片文件显示在网页上主要用于获取流媒体文件上面示例是获取音频文件然后在线播放的例子对象只能读取一次读取完就没了这意味着前一节的五个读取方法只能使用一个否则会报错报错上面示例先使用了就把读完了后面再调用就没有内容可读了所以报错对象提供方法创建对象的副本实现多次读取上面示例中复制了一份对象然后将同一张图片读取了两次对象还有一个方法用于将结果重定向到指定的该方法一般只用在里面这里就不介绍了属性属性是对象暴露出的底层接口返回一个对象供用户操作它可以用来分块读取内容应用之一就是显示下载的进度上面示例中方法返回一个遍历器这个遍历器的方法每次返回一个对象表示本次读取的内容块这个对象的属性是一个布尔值用来判断有没有读完属性是一个数组表示内容块的内容而属性是当前块的大小的第二个参数定制请求的第一个参数是还可以接受第二个参数作为配置对象定制发出的请求上面命令的就是第二个参数请求的方法标头数据体都在这个对象里面设置下面是一些示例请求上面示例中配置对象用到了三个属性请求的方法都在这个属性设置一个对象用来定制请求的标头请求的数据体注意有些标头不能通过属性设置比如等等它们是由浏览器自动生成无法修改提交数据上面示例中标头要设成因为默认发送的是纯文本的默认值是提交表单文件上传如果表单里面有文件选择器可以用前一个例子的写法上传的文件包含在整个表单里面一起提交另一种方法是用脚本添加文件构造出一个表单进行上传请看下面的例子上传二进制文件时不用修改标头的浏览器会自动设置直接上传二进制数据也可以直接上传二进制数据将或数据放在属性里面配置对象的完整第二个参数的完整如下请求的底层用的是对象的接口参数完全一样因此上面的也是的这些属性里面前面已经给过示例了下面是其他属性的介绍属性指定如何处理缓存可能的取值如下默认值先在缓存里面寻找匹配的请求直接请求远程服务器并且不更新缓存直接请求远程服务器并且更新缓存将服务器资源跟本地缓存进行比较有新的版本才使用服务器资源否则使用缓存缓存优先只有不存在缓存的情况下才请求远程服务器只检查缓存如果缓存里面不存在将返回错误属性指定请求的模式可能的取值如下默认值允许跨源请求只允许同源请求请求方法只限于和并且只能使用有限的几个简单标头不能添加跨源的复杂标头相当于提交表单加载脚本加载图片等传统的跨源请求方法属性指定是否发送可能的取值如下默认值同源请求时发送跨源请求时不发送不管同源请求还是跨源请求一律发送一律不发送跨源请求发送需要将属性设为属性指定一个实例用于取消请求详见下一节属性用于页面卸载时告诉浏览器在后台保持连接继续发送数据一个典型的场景就是用户离开网页时脚本向服务器提交一些用户行为的统计信息这时如果不用属性数据可能无法发送因为浏览器已经把页面卸载了属性指定跳转的处理方法可能的取值如下默认值跟随跳转如果发生跳转就报错不跟随跳转但是属性会指向新的属性会变为由开发者自己决定后续如何处理跳转属性指定一个哈希值用于检查回应传回的数据是否等于这个预先设定的哈希值比如下载文件时检查文件的哈希值是否相符确保没有被篡改属性用于设定请求的标头这个属性可以为任意字符串也可以设为空字符串即不发送标头属性用于设定标头的规则可能的取值如下默认值总是发送标头除非从页面请求资源时不发送不发送标头标头只包含域名不包含完整的路径同源请求标头包含完整的路径跨源请求只包含域名跨源请求不发送同源请求发送标头只包含域名页面请求资源时不发送标头同源请求时标头包含完整路径跨源请求时只包含域名页面请求资源时不发送该标头不管什么情况总是发送标头取消请求请求发送以后如果中途想要取消需要使用对象取消上面示例中首先新建实例然后发送请求配置对象的属性必须指定接收实例发送的信号方法用于发出取消信号这时会触发事件这个事件可以监听也可以通过属性判断取消信号是否已经发出下面是一个秒后自动取消请求的例子参考链接用来控制字体加载这个提供一个构造函数返回一个字体对象构造函数接受三个参数字符串表示字体名写法与的的属性相同字体文件的必须包括的方法或者是一个字体的对象对象用来定制字体文件该参数可选返回的是一个字体对象这个对象包含字体信息注意这时字体文件还没有开始加载字体对象包含以下属性字符串表示字体的名字等同于的属性字符串指定字体加载期间如何展示等同于的属性它有五个可能的值由浏览器决定字体加载期间前秒会显示不出内容然后只要还没完成加载就一直显示后备字体前毫秒显示不出内容后秒显示后备字体然后只要字体还没完成加载就一直显示后备字体前毫秒显示不出内容然后只要字体还没有完成加载就一直显示后备字体只要字体没有完成加载就一直显示后备字体字符串等同于的属性字符串等同于的属性字符串等同于的属性字符串等同于对象的同名属性字符串等同于对象的同名属性字符串等同于对象的同名属性字符串表示字体的加载状态有四个可能的值该属性只读返回一个对象字体加载成功或失败会导致该状态改变该属性只读字体对象的方法只有一个该方法会真正开始加载字体它返回一个对象状态由字体加载的结果决定网页可以开始使用该字体用于获取用户的地理位置由于该功能涉及用户隐私所以浏览器会提示用户是否同意给出地理位置用户可能会拒绝另外这个只能在环境使用浏览器通过属性提供该对象属性返回一个对象该对象具有以下三个方法返回一个对象表示用户的当前位置指定一个监听函数每当用户的位置发生变化就执行该监听函数取消方法指定的监听函数方法用于获取用户的位置该方法接受三个参数用户同意给出位置时的回调函数它的参数是一个对象用户拒绝给出位置时的回调函数它的参数是一个对象该参数可选参数对象该参数可选对象有两个属性返回一个对象表示当前位置的坐标返回一个对象代表当前时间戳对象主要有两个属性整数表示发生错误的原因表示无权限有可能是用户拒绝授权表示无法获得位置可能设备有故障表示超时字符串表示错误的描述参数对象可以指定三个属性布尔值是否返回高精度结果如果设为可能导致响应时间变慢或移动设备的功耗增加反之如果设为设备可以更快速地响应默认值为正整数表示等待查询的最长时间单位为毫秒默认值为正整数表示可接受的缓存最长时间单位为毫秒如果设为表示不返回缓存值必须查询当前的实际位置如果设为必须返回缓存值不管缓存了多少时间默认值为下面是一个例子经度纬度误差米对象指定一个监听函数每当用户的位置发生变化就是自动执行这个函数该方法接受三个参数监听成功的回调函数该函数的参数为一个对象该参数可选表示监听失败的回调函数该函数的参数是一个对象该参数可选表示监听的参数配置对象该方法返回一个整数值表示监听函数的编号该整数用来供方法取消监听下面是一个例子恭喜你已经到达了指定位置方法用来取消方法指定的监听函数它的参数是返回的监听函数的编号使用方法的例子见上一节对象对象是地理位置的坐标接口属性返回的就是这个对象它有以下属性全部为只读属性浮点数表示纬度浮点数表示经度浮点数表示海拔单位米如果不可得返回浮点数表示经度和纬度的精度单位米浮点数表示海拔的精度单位米返回浮点数表示设备的速度单位米秒如果不可得返回浮点数表示设备前进的方向单位度方向按照顺时针北方是度东方是度西方是度如果为属性返回如果设备无法提供方向信息该属性返回下面是一个例子纬度经度参考链接网页开发时常常需要了解某个元素是否进入了视口即用户能不能看到它上图的绿色方块不断滚动顶部会提示它的可见性传统的实现方法是监听到事件后调用目标元素绿色方块的方法得到它对应于视口左上角的坐标再判断是否在视口之内这种方法的缺点是由于事件密集发生计算量很大容易造成性能问题可以自动观察元素是否可见已经支持由于可见的本质是目标元素与视口产生一个交叉区所以这个叫做交叉观察器简介的用法简单来说就是两行上面代码中是浏览器原生提供的构造函数接受两个参数是可见性变化时的回调函数是配置对象该参数可选的返回值是一个观察器实例实例的方法可以指定观察哪个节点开始观察停止观察关闭观察器上面代码中的参数是一个节点对象如果要观察多个节点就要多次调用这个方法注意是异步的不随着目标元素的滚动同步触发规格写明的实现应该采用即只有线程空闲下来才会执行观察器这意味着这个观察器的优先级非常低只在其他任务执行完浏览器有了空闲才会执行实例的方法用来启动对一个元素的观察该方法接受两个参数回调函数和配置对象参数目标元素的可见性变化时就会调用观察器的回调函数会触发两次一次是目标元素刚刚进入视口开始可见另一次是完全离开视口开始不可见上面代码中回调函数采用的是箭头函数的写法函数的参数是一个数组每个成员都是一个对象详见下文举例来说如果同时有两个被观察的对象的可见性发生变化数组就会有两个成员对象对象提供目标元素的信息一共有六个属性每个属性的含义如下可见性发生变化的时间是一个高精度时间戳单位为毫秒被观察的目标元素是一个节点对象容器元素的矩形区域的信息方法的返回值如果没有容器元素即直接相对于视口滚动则返回目标元素的矩形区域的信息目标元素与视口或容器元素的交叉区域的信息目标元素的可见比例即占的比例完全可见时为完全不可见时小于等于上图中灰色的水平方框代表视口深红色的区域代表四个被观察的目标元素它们各自的图中都已经注明我写了一个演示对象注意这个只能在运行对象构造函数的第二个参数是一个配置对象它可以设置以下属性属性属性决定了什么时候触发回调函数即元素进入视口或者容器元素多少比例时执行回调函数它是一个数组每个成员都是一个门槛值默认为即交叉比例达到时触发回调函数如果属性是当元素进入视口时触发回调函数如果值为则当元素进入和是触发回调函数用户可以自定义这个数组比如上例的就表示当目标元素可见时会触发回调函数属性属性不仅可以观察元素相对于视口的可见性还可以观察元素相对于其所在容器的可见性容器内滚动也会影响目标元素的可见性参见本文开始时的那张示意图支持容器内滚动属性指定目标元素所在的容器节点注意容器元素必须是目标元素的祖先节点上面代码中除了属性还有属性该属性用来扩展或缩小这个矩形的大小从而影响交叉区域的大小它的写法类似于的属性比如依次表示和四个方向的值上例的表示容器的下边缘向上收缩像素导致页面向下滚动时目标元素的顶部进入可视区域像素以后才会触发回调函数这样设置以后不管是窗口滚动或者容器内滚动只要目标元素可见性变化都会触发观察器实例惰性加载有时我们希望某些静态资源比如图片只有用户向下滚动它们进入视口时才加载这样可以节省带宽提高网页性能这就叫做惰性加载有了实现起来就很容易了图像的代码可以写成下面这样上面代码中图像默认显示一个占位符属性是惰性加载的真正图像上面代码中只有图像开始可见时才会加载真正的图像文件无限滚动无限滚动指的是随着网页滚动到底部不断加载新的内容到页面它的实现也很简单如果不可见就返回开始观察无限滚动时最好像上例那样页面底部有一个页尾栏又称上例是一旦页尾栏可见就表示用户到达了页面底部从而加载新的条目放在页尾栏前面否则就需要每一次页面加入新内容时都调用方法对新增内容的底部建立观察视频自动播放下面是一个视频元素希望它完全进入视口的时候自动播放离开视口的时候自动暂停下面是代码上面代码中的第二个参数是配置对象它的属性等于即目标元素完全可见时触发回调函数参考链接很多日期库支持显示相对时间比如昨天五分钟前两个月之前等等由于不同的语言日期显示的格式和相关词语都不同造成这些库的体积非常大现在浏览器提供内置的可以不使用这些库直接显示相对时间基本用法是一个构造函数接受一个语言代码作为参数返回一个相对时间的实例对象如果省略参数则默认传入当前运行时的语言代码上面代码指定使用英语显示相对时间下面是使用西班牙语显示相对时间的例子还可以接受一个配置对象作为第二个参数用来精确指定相对时间实例的行为配置对象共有下面这些属性表示返回字符串的风格可能的值有默认值比如比如比如对于一部分语言来说风格和风格是类似的表示匹配语言参数的算法可能的值有默认值和表示返回字符串是数字显示还是文字显示可能的值有默认值总是文字显示和自动转换下面的配置对象传入的都是默认值其他值其他值其他值上面代码中显示的是而不是显示的是而不是这是因为默认情况下相对时间显示的是数值形式而不是文字形式改变这个行为可以把配置对象的属性改成相对时间实例对象的方法接受两个参数依次为时间间隔的数值和单位其中单位是一个字符串可以接受以下八个值相对时间实例对象的方法的参数跟方法一样但是返回的是一个数组用来精确控制相对时间的每个部分返回数组的每个成员都是一个对象拥有两个属性字符串表示输出值的类型字符串表示输出的内容如果输出内容表示一个数值即属性不是那么还会有属性表示数值的单位参考链接应用应用不仅可以在浏览器缓存资源文件脚本图片等还可以把应用本身储存到浏览器缓存的资源文件必须在线使用只有先从服务器加载网页然后才能使用本地缓存但是应用一旦储存就可以离线使用另外用户常规性地清除浏览器缓存并不会清除储存的应用除非用户显式地卸载或删除它们为了开启离线储存必须创建一个文件该文件列出了所有需要储存的文件文件的第一行必须是然后每一行列出一个需要储存的文件它们的位置都是相对于文件的位置空行会被忽略以开头的行是注释也会被忽略这个文件的后缀名一般是它的类型必须是如果服务器将其设为其他类型就不会被浏览器缓存编写完这个文件以后要将元素的属性指向它浏览器加载这个网页的时候就会读取这个文件离线储存这个网页和相关的资源如果一个应用有多个网页需要离线储存那么每个网页都应该将属性指向这个文件一旦被储存以后加载该网页的时候就会从缓存里面加载这时只有文件里面列出的文件会被加载其他文件不会如果这时浏览器在线浏览器就会去检查文件是否有新版本如果有新版本就会重新储存和更新该文件列出的资源最方便的办法是在文件里面用注释列出版本号如果需要删除离线储存只要删除文件让其返回状态码即可离线储存更新完成会触发浏览器的事件可以对这个事件指定监听函数新版本下载完成是否需要重新加载脚本可以注册和事件的监听函数通过属性判断浏览器是否在线从而进行数据同步每次浏览器加载一个具有属性的网页浏览器就会触发一个事件然后去加载文件如果应用已经储存并且文件没有变化那么触发事件如果应用已经储存并且文件有变化那么触发事件浏览器重新下载所有离线资源下载过程中触发事件下载结束触发事件如果应用没有储存下载结束将触发事件如果离线无法检查文件浏览器会触发一个事件如果浏览器在线而且应用已经储存但是文件返回浏览器触发事件将储存的应用移除所有这些事件都是可以取消的监听函数可以返回取消这些事件的默认动作属性返回离线储存的状态和最新的系统可以随时自主地停止后台进程及时释放系统资源也就是说网页可能随时被系统丢弃掉以前的浏览器完全没有考虑到这种情况导致开发者根本没有办法监听到系统丢弃页面为了解决这个问题新制定了一个统一了网页从诞生到卸载的行为模式并且定义了新的事件允许开发者响应网页状态的各种转换有了这个开发者就可以预测网页下一步的状态从而进行各种针对性的处理支持这个对于老式浏览器可以使用谷歌开发的兼容库生命周期阶段网页的生命周期分成六个阶段每个时刻只可能处于其中一个阶段阶段在阶段网页处于可见状态且拥有输入焦点阶段在阶段网页可见但没有输入焦点无法接受输入更新比如动画仍然在执行该阶段只可能发生在桌面同时有多个窗口的情况阶段在阶段用户的桌面被其他窗口占据网页不可见但尚未冻结更新不再执行阶段在阶段由于用户主动关闭窗口或者在同一个窗口前往其他页面导致当前页面开始被浏览器卸载并从内存中清除注意这个阶段总是在阶段之后发生也就是说用户主动离开当前页面总是先进入阶段再进入阶段这个阶段会导致网页卸载任何新任务都不会在这个阶段启动并且如果运行时间太长正在进行的任务可能会被终止阶段如果网页处于阶段的时间过久用户又不关闭网页浏览器就有可能冻结网页使其进入阶段不过也有可能处于可见状态的页面长时间没有操作也会进入阶段这个阶段的特征是网页不会再被分配计算资源定时器回调函数网络请求操作都不会执行不过正在运行的任务会执行完浏览器可能会允许阶段的页面周期性复苏一小段时间短暂变回状态允许一小部分任务执行阶段如果网页长时间处于阶段用户又不唤醒页面那么就会进入阶段即浏览器自动卸载网页清除该网页的内存占用不过阶段的网页如果长时间没有互动也可能直接进入阶段这一般是在用户没有介入的情况下由系统强制执行任何类型的新任务或代码都不能在此阶段执行因为这时通常处在资源限制的状况下网页被浏览器自动以后它的窗口还是在的如果用户重新访问这个页浏览器将会重新向服务器发出请求再一次重新加载网页回到阶段常见场景以下是几个常见场景的网页生命周期变化用户打开网页后又切换到其他但只过了一会又回到网页网页由变成又变回用户打开网页后又切换到其他并且长时候使用后者导致系统自动丢弃网页网页由变成再变成最后用户打开网页后又切换到其他然后从任务管理器里面将浏览器进程清除网页由变成然后系统丢弃了某个里面的页面后用户重新打开这个网页由变成事件生命周期的各个阶段都有自己的事件以供开发者指定监听函数这些事件里面只有两个是新定义的事件和事件其它都是现有的注意网页的生命周期事件是在所有帧触发不管是底层的帧还是内嵌的帧也就是说内嵌的网页跟顶层网页一样都会同时监听到下面的事件事件事件在页面获得输入焦点时触发比如网页从阶段变为阶段事件事件在页面失去输入焦点时触发比如网页从阶段变为阶段事件事件在网页可见状态发生变化时触发一般发生在以下几种场景用户隐藏页面切换最小化浏览器页面由阶段变成阶段用户重新访问隐藏的页面页面由阶段变成阶段用户关闭页面页面会先进入阶段然后进入阶段可以通过属性指定这个事件的回调函数事件事件在网页进入阶段时触发可以通过属性指定在进入阶段时调用的回调函数或者这个事件的监听函数最长只能运行毫秒并且只能复用已经打开的网络连接不能发起新的网络请求注意从阶段进入阶段不会触发任何事件无法指定回调函数只能在进入阶段时指定回调函数事件事件在网页离开阶段变为阶段时触发属性指的是页面离开阶段进入可用状态时调用的回调函数或者事件事件在用户加载网页时触发这时有可能是全新的页面加载也可能是从缓存中获取的页面如果是从缓存中获取则该事件对象的属性为否则为这个事件的名字有点误导它跟页面的可见性其实毫无关系只跟浏览器的记录的变化有关事件事件在用户离开当前网页进入另一个网页时触发它的前提是浏览器的记录必须发生变化跟网页是否可见无关如果浏览器能够将当前页面添加到缓存以供稍后重用则事件对象的属性为如果为如果页面添加到了缓存则页面进入状态否则进入状态事件事件在窗口或文档即将卸载时触发该事件发生时文档仍然可见此时卸载仍可取消经过这个事件网页进入状态事件事件在页面正在卸载时触发经过这个事件网页进入状态获取当前阶段如果网页处于或阶段可以通过下面的代码获得网页当前的状态如果网页处于和状态由于定时器代码不会执行只能通过事件监听判断状态进入阶段可以监听事件进入阶段可以监听事件如果某个选项卡处于阶段就随时有可能被系统丢弃进入阶段如果后来用户再次点击该选项卡浏览器会重新加载该页面这时开发者可以通过判断属性了解先前的网页是否被丢弃了该网页已经不是原来的状态了曾经被浏览器丢弃过恢复以前的状态同时对象上会新增和两个属性用来恢复丢弃前的状态参考链接简介有时候开发者需要知道用户正在离开页面常用的方法是监听下面三个事件但是这些事件在手机上可能不会触发页面就直接关闭了因为手机系统可以将一个进程直接转入后台然后杀死用户点击了一条系统通知切换到另一个用户进入任务切换窗口切换到另一个用户点击了按钮切换回主屏幕操作系统自动切换到另一个比如收到一个电话上面这些情况都会导致手机将浏览器进程切换到后台然后为了节省资源可能就会杀死浏览器进程以前页面被系统切换以及系统清除浏览器进程是无法监听到的开发者想要指定任何一种页面卸载情况下都会执行的代码也是无法做到的为了解决这个问题就诞生了不管手机或桌面电脑所有情况下这个都会监听到页面的可见性发生变化这个新的的意义在于通过监听网页的可见性可以预判网页的卸载还可以用来节省资源减缓电能的消耗比如一旦用户不看网页下面这些网页行为都是可以暂停的对服务器的轮询网页动画正在播放的音频或视频这个主要在对象上新增了一个属性该属性返回一个字符串表示页面当前的可见性状态共有三个可能的值页面彻底不可见页面至少一部分可见页面即将或正在渲染处于不可见状态其中状态和状态是所有浏览器都必须支持的状态只在支持预渲染的浏览器上才会出现比如浏览器就有预渲染功能可以在用户不可见的状态下预先把页面渲染出来等到用户要浏览的时候直接展示渲染好的网页只要页面可见哪怕只露出一个角属性就返回只有以下四种情况才会返回浏览器最小化浏览器没有最小化但是当前页面切换成了背景页浏览器将要卸载页面操作系统触发锁屏屏幕可以看到上面四种场景涵盖了页面可能被卸载的所有情况也就是说页面卸载之前属性一定会变成事实上这也是设计这个的主要目的另外早期版本的这个属性还有第四个值表示页面即将卸载现在已经被废弃了注意属性只针对顶层窗口内嵌的页面的属性由顶层窗口决定使用属性隐藏页面比如并不会影响内嵌页面的可见性由于历史原因这个还定义了属性该属性只读返回一个布尔值表示当前页面是否可见当属性返回时属性返回其他情况下都返回该属性只是出于历史原因而保留的只要有可能都应该使用属性而不是使用这个属性事件只要属性发生变化就会触发事件因此可以通过监听这个事件通过方法或属性跟踪页面可见性的变化用户离开了当前页面页面不可见用户打开或回到页面页面可见上面代码是的最基本用法可以监听可见性变化下面是另一个例子一旦页面不可见就暂停视频播放页面卸载下面专门讨论一下如何正确监听页面卸载页面卸载可以分成三种情况页面可见时用户关闭页或浏览器窗口页面可见时用户在当前窗口前往另一个页面页面不可见时用户或系统关闭浏览器窗口这三种情况都会触发事件前两种情况该事件在用户离开页面时触发最后一种情况该事件在页面从可见状态变为不可见状态时触发由此可见事件比事件更可靠所有情况下都会触发从变为因此可以只监听这个事件运行页面卸载时需要运行的代码不用监听后面那三个事件甚至可以这样说事件在任何情况下都不必监听事件只有一种适用场景就是用户修改了表单没有提交就离开当前页面另一方面指定了这两个事件的监听函数浏览器就不会缓存当前页面参考链接不用释放按钮就锁定鼠标简介服务器向客户端推送数据有很多解决方案除了轮询和还提供了以下简称一般来说协议只能客户端向服务器发起请求服务器不能主动向客户端推送但是有一种特殊情况就是服务器向客户端声明接下来要发送的是流信息也就是说发送的不是一次性的数据包而是一个数据流会连续不断地发送过来这时客户端不会关闭连接会一直等着服务器发过来的新的数据流本质上这种通信就是以流信息的方式完成一次用时很长的下载就是利用这种机制使用流信息向浏览器推送信息它基于协议目前除了其他浏览器都支持与的比较与作用相似都是建立浏览器与服务器之间的通信渠道然后服务器向浏览器推送信息总体来说更强大和灵活因为它是全双工通道可以双向通信是单向通道只能服务器向浏览器发送因为本质上就是下载如果浏览器向服务器发送信息就变成了另一次请求但是也有自己的优点使用协议现有的服务器软件都支持是一个独立协议属于轻量级使用简单协议相对复杂默认支持断线重连需要自己实现断线重连一般只用来传送文本二进制数据需要编码后传送默认支持传送二进制数据支持自定义发送的消息类型因此两者各有特点适合不同的场合客户端对象的客户端部署在对象上下面的代码可以检测浏览器是否支持使用时浏览器首先生成一个实例向服务器发起连接上面的可以与当前网址同域也可以跨域跨域时可以指定第二个参数打开属性表示是否一起发送属性实例的属性表明连接的当前状态该属性只读可以取以下值相当于常量表示连接还未建立或者断线正在重连相当于常量表示连接已经建立可以接受数据相当于常量表示连接已断且不会重连属性实例的属性返回连接的网址该属性只读属性实例的属性返回一个布尔值表示当前实例是否开启的该属性只读默认是属性连接一旦建立就会触发事件可以在属性定义回调函数另一种写法属性客户端收到服务器发来的数据就会触发事件可以在属性定义回调函数另一种写法上面代码中参数对象有如下属性服务器端传回的数据文本格式服务器的域名部分即协议域名和端口表示消息的来源数据的编号由服务器端发送如果没有编号这个属性为空属性如果发生通信错误比如连接中断就会触发事件可以在属性定义回调函数另一种写法自定义事件默认情况下服务器发来的数据总是触发浏览器实例的事件开发者还可以自定义事件这种情况下发送回来的数据不会触发事件上面代码中浏览器对的事件进行监听如何实现服务器发送事件请看下文方法方法用于关闭连接服务器实现数据格式服务器向浏览器发送的数据必须是编码的文本具有如下的头信息上面三行之中第一行的必须指定类型为每一次发送的信息由若干个组成每个之间用分隔每个内部由若干行组成每一行都是如下格式上面的可以取四个值此外还可以有冒号开头的行表示注释通常服务器每隔一段时间就会向浏览器发送一个注释保持连接不中断下面是一个例子字段数据内容用字段表示如果数据很长可以分成多行最后一行用结尾前面行都用结尾下面是一个发送数据的例子字段数据标识符用字段表示相当于每一条数据的编号浏览器用属性读取这个值一旦连接断线浏览器会发送一个头里面包含一个特殊的头信息将这个值发送回来用来帮助服务器端重建连接因此这个头信息可以被视为一种同步机制字段字段表示自定义的事件类型默认是事件浏览器可以用监听该事件上面的代码创造了三条信息第一条的名字是触发浏览器的事件第二条未取名表示默认类型触发浏览器的事件第三条是触发浏览器的事件下面是另一个例子字段服务器可以用字段指定浏览器重新发起连接的时间间隔两种情况会导致浏览器重新发起连接一种是时间间隔到期二是由于网络错误等原因导致连接出错服务器实例要求服务器与浏览器保持连接对于不同的服务器软件来说所消耗的资源是不一样的服务器每个连接就是一个线程如果要维持大量连接势必要消耗大量资源则是所有连接都使用同一个线程因此消耗的资源会小得多但是这要求每个连接不能包含很耗时的操作比如磁盘的读写下面是的服务器实例参考链接含义首先是一个运行在后台的线程然后它会长期运行充当一个服务很适合那些不需要网页或用户互动的功能它的最常见用途就是拦截和处理网络请求是一个后台运行的脚本充当一个代理服务器拦截用户发出的网络请求比如加载脚本和图片可以修改用户的请求或者直接向用户发出回应不用联系服务器这使得用户可以在离线情况下使用网络应用它还可以在本地缓存资源文件直接从缓存加载文件因此可以加快访问速度上面代码确认浏览器支持以后会注册一个为了节省内存在不使用的时候是休眠的它也不会保存数据所以重新启动的时候为了拿到数据最好把数据放在里面是事件驱动的下面是拦截请求的例子不能直接操作使用步骤登记使用的第一步就是告诉浏览器需要注册一个脚本注册成功注册失败上面代码的就是需要浏览器注册的脚本注意这个脚本必须与当前网址同域不支持跨域脚本另外必须是从协议加载的默认情况下只对根目录生效如果要改变生效范围可以运行下面的代码安装一旦登记成功接下来都是脚本的工作下面的代码都是写在脚本里面的登记后就会触发事件脚本需要监听这个事件安装完成方法为事件完成后指定回调函数激活安装完成后就会等待激活与网页的通信上面代码中监听事件然后向客户端发送一条信息客户端需要部署消息监听代码参考链接图像概述是一种基于语法的图像格式全称是可缩放矢量图其他图像格式都是基于像素处理的则是属于对图像的形状描述所以它本质上是文本文件体积较小且不管放大多少倍都不会失真文件可以直接插入网页成为的一部分然后用和进行操作上面是代码直接插入网页的例子代码也可以写在一个独立文件中然后用等标签插入网页也可以使用文件文件还可以转为编码然后作为写入网页语法标签代码都放在顶层标签之中下面是一个例子的属性和属性指定了图像在元素中所占据的宽度和高度除了相对单位也可以采用绝对单位单位像素如果不指定这两个属性图像的大小默认为像素宽像素高如果只想展示图像的一部分就要指定属性属性的值有四个数字分别是左上角的横坐标和纵坐标视口的宽度和高度上面代码中图像是像素宽像素高属性指定视口从这个点开始所以实际看到的是右下角的四分之一圆注意视口必须适配所在的空间上面代码中视口的大小是由于图像的大小是所以视口会放大去适配图像的大小即放大了四倍如果不指定属性和属性只指定属性则相当于只给定图像的长宽比这时图像的大小默认是所在的元素的大小标签标签代表圆形上面的代码定义了三个圆标签的属性分别为横坐标纵坐标和半径单位为像素坐标都是相对于画布的左上角原点属性用来指定对应的类的属性与网页元素有所不同填充色描边色边框宽度标签标签用来绘制直线上面代码中标签的属性和属性表示线段起点的横坐标和纵坐标属性和属性表示线段终点的横坐标和纵坐标属性表示线段的样式标签标签用于绘制一根折线的属性指定了每个端点的坐标横坐标与纵坐标之间与逗号分隔点与点之间用空格分隔标签标签用于绘制矩形的属性和属性指定了矩形左上角端点的横坐标和纵坐标属性和属性指定了矩形的宽度和高度单位像素标签标签用于绘制椭圆的属性和属性指定了椭圆中心的横坐标和纵坐标单位像素属性和属性指定了椭圆横向轴和纵向轴的半径单位像素标签标签用于绘制多边形的属性指定了每个端点的坐标横坐标与纵坐标之间与逗号分隔点与点之间用空格分隔标签标签用于制路径的属性表示绘制顺序它的值是一个长字符串每个字母表示一个绘制动作后面跟着坐标移动到画直线到闭合路径标签标签用于绘制文本的属性和属性表示文本区块基线起点的横坐标和纵坐标文字的样式可以用或属性指定标签标签用于复制一个形状的属性指定所要复制的节点属性和属性是左上角的坐标另外还可以指定和坐标标签标签用于将多个形状组成一个组方便复用圆形标签标签用于自定义形状它内部的代码不会显示仅供引用圆形标签标签用于自定义一个形状该形状可以被引用来平铺一个区域上面代码中标签将一个圆形定义为模式表示的宽度和长度是实际的像素值然后指定这个模式去填充下面的矩形标签标签用于插入图片文件上面代码中的属性表示图像的来源标签标签用于产生动画效果上面代码中矩形会不断移动产生动画效果的属性含义如下发生动画效果的属性名单次动画的初始值单次动画的结束值单次动画的持续时间动画的循环模式可以在多个属性上面定义动画标签标签对的属性不起作用如果需要变形就要使用标签上面代码中的效果为旋转这时和属性值有三个数字第一个数字是角度值第二个值和第三个值是旋转中心的坐标表示开始时角度为围绕开始旋转表示结束时角度为围绕旋转操作操作如果代码直接写在网页之中它就成为网页的一部分可以直接用操作上面代码插入网页之后就可以用定制样式然后可以用代码操作上面代码指定如果点击图形就改写元素的属性获取使用标签插入文件可以获取注意如果使用标签插入文件就无法获取读取源码由于文件就是一段文本因此可以通过读取代码的方式读取源码使用实例的方法获取元素的代码图像转为图像首先需要新建一个对象将图像指定到该对象的属性然后当图像加载完成后再将它绘制到元素实例折线图下面将一张数据表格画成折线图上面的图形可以画成一个坐标系作为横轴作为纵轴四行数据画成一个数据点参考链接概述网页内容如果要分享到其他应用通常要自己实现分享接口逐一给出目标应用的连接方式这样很麻烦也对网页性能有一定影响就是为了解决这个问题而提出的允许网页调用操作系统的分享接口实质是与本机的应用程序交换信息的一种方式这个不仅可以改善网页性能而且不限制分享目标的数量和类型社交媒体应用电子邮件即时消息以及本地系统安装的且接受分享的应用都会出现在系统的分享弹窗这对手机网页尤其有用另外使用这个接口只需要一个分享按钮而传统的网页分享有多个分享目标就有多少个分享按钮目前桌面的浏览器手机的安卓浏览器和浏览器支持这个这个要求网站必须启用协议但是本地开发可以使用协议另外这个不能直接调用只能用来响应用户的操作比如事件接口细节该接口部署在可以用下面的代码检查本机是否支持该接口支持不支持是一个函数方法接受一个配置对象作为参数我正在看配置对象有三个属性都是可选的但至少必须指定一个分享文档的标题分享的分享的内容一般来说是当前网页的网址是当前网页的标题可以采用下面的写法获取的返回值是一个对象这个方法调用之后会立刻弹出系统的分享弹窗用户操作完毕之后对象就会变为状态由于返回值是对象所以也可以使用命令分享文件这个还可以分享文件先使用方法判断一下目标文件是否可以分享因为不是所有文件都允许分享的目前图像视频音频和文本文件可以分享上面代码中方法的参数对象就是方法的参数对象这里的关键是属性它的值是一个实例对象方法返回一个布尔值如果为就可以使用方法分享文件了参考链接用于操作声音这个可以让网页发出声音基本用法浏览器原生提供对象该对象用于生成一个声音的上下文与扬声器相连然后获取音源文件将其在内存中解码就可以播放声音了播放声音方法生成一个内存的操作视图用于存放数据方法接受三个参数整数表示声道创建单声道的声音该值为整数表示声音数组的长度浮点数表示取样率即一秒取样多少次和这两个参数决定了声音的长度比如如果取样率是每秒取样次声音数组长度是那么播放的声音是秒长度接着使用方法取出一个声道上面代码中的参数表示取出第一个声道下一步将声音数组放入这个声道是一个声音数组是该数组的长度最后使用方法生成一个声音节点生成一个声音节点将声音数组的内存对象放入这个节点将声音上下文与节点连接开始播放声音默认情况下播放一次后就将停止播放如果需要循环播放可以将节点对象的属性设为过滤器原生提供了一些过滤器用来处理声音首先使用方法建立过滤器实例然后通过属性指定过滤器的类型目前过滤器有以下这些类型然后指定过滤器的频率属性最后过滤器实例连接节点实例就可以生效了概述各种网站往往需要一些相同的模块比如日历调色板等等这种模块就被称为组件就是浏览器原生的组件规范采用组件开发有很多优点有利于代码复用组件是模块化编程思想的体现可以跨平台跨框架使用构建部署和与其他元素互动都有统一做法使用非常容易加载或卸载组件只要添加或删除一行代码就可以了开发和定制很方便组件开发不需要使用框架只要用原生的语法就可以了开发好的组件往往留出接口供使用者设置常见属性比如上面代码的属性就是用来设置对话框的标题组件提供了封装的方法实现了与同一页面上其他代码的隔离未来的网站开发可以像搭积木一样把组件合在一起就组成了一个网站这种前景是非常诱人的不是单一的规范而是一系列的技术组成以下是它的四个构成使用时并不一定上面四种都要用到其中和比较重要和只起到辅助作用简介标准定义的网页元素有时并不符合我们的需要这时浏览器允许用户自定义网页元素这就叫做简单说它就是用户自定义的网页元素是技术的核心举例来说你可以自定义一个叫做的网页元素注意自定义网页元素的标签名必须含有连字符一个或多个连字符都可以这是因为浏览器内置的的元素标签名都不含有连字符这样可以做到有效区分下面的代码先定义一个自定义元素的类上面代码有几个注意点自定义元素类的基类是当然也可以根据需要基于的子类比如构造函数内部定义了所谓指的是这部分的代码和样式不直接暴露给用户类可以定义生命周期方法比如然后方法用来登记自定义元素与这个类之间的映射登记以后页面上的每一个元素都是一个类的实例只要浏览器解析到元素就会运行的构造函数注意如果没有登记就使用浏览器会认为这是一个不认识的元素会当做空的元素处理方法定义了以后可以使用方法获取该元素的构造方法这使得除了直接插入网页也能使用脚本插入网页如果你想扩展现有的元素比如也是可以的登记的时候需要提供扩展的元素使用的时候为元素加上属性就可以了生命周期方法提供一些生命周期方法上面代码中方法就是元素的生命周期方法每次该元素插入就会自动执行该方法插入时调用这可能不止一次发生比如元素被移除后又重新添加类的设置应该尽量放到这个方法里面执行因为这时各种属性和子元素都可用移出时执行添加删除更新或替换属性时调用元素创建或升级时也会调用注意只有加入的属性才会执行这个方法自定义元素移动到新的时调用比如执行时下面是一个例子上面代码中属性用来指定白名单里面的属性上例是属性只要这个属性的值发生变化就会自动调用方法使用上面这个类的方法如下方法主要用于外部传入的属性就像上面例子中生命周期方法调用的顺序如下即早于执行这是因为相当于调整配置应该在插入之前完成下面的例子能够更明显地看出这一点在插入前修改的颜色自定义属性和方法允许自定义属性或方法上面代码中就是的自定义方法使用方法如下自定义属性可以使用的所有语法因此也可以设置取值器和赋值器上面代码中的取值器和赋值器可用于这样的用法方法在一个被方法定义以后执行用于升级一个元素如果某个属性值发生变化时需要做出反应可以将它放入数组回调函数自定义元素的原型有一些属性用来指定回调函数在特定事件发生时触发实例生成时触发实例插入文档时触发实例从文档移除时触发实例的属性发生改变时添加移除更新触发下面是一个例子利用回调函数可以方便地在自定义元素中插入语句上面代码定义了回调函数生成实例时该函数运行插入如下的语句的子元素用户使用时候可以在内部放置子元素提供用来引用内部内容下面的是一个用户在里面放置了子元素内部的模板如下最终合成的代码如下标签基本用法标签表示组件的代码模板内部就是正常的代码浏览器不会将这些代码加入下面的代码会将模板内部的代码插入注意模板内部的代码只能插入一次如果第二次执行上面的代码就会报错如果需要多次插入模板可以复制内部代码然后再插入上面代码中方法的参数表示复制包含所有子节点接受插入的元素叫做宿主元素在之中可以对宿主元素设置样式方法用于克隆外部文档的节点上面例子是将窗口之中的节点克隆进入当前文档注意克隆节点之后还必须用方法将其加入当前文档否则不会显示换个角度说这意味着插入外部文档节点之前必须用方法先将这个节点准备好方法接受两个参数第一个参数是外部文档的节点第二个参数是一个布尔值表示是否连同子节点一起克隆默认为大多数情况下必须显式地将第二个参数设为所谓指的是浏览器将模板样式表属性码等封装成一个独立的元素外部的设置无法影响到其内部而内部的设置也不会影响到外部与浏览器处理原生网页元素比如元素的方式很像最大的好处有两个一是可以向用户隐藏细节直接提供组件二是可以封装内部样式表不会影响到外部内部有一个它就是接入外部的根元素上面代码中包含但是方法无法看到它而且页面的样式也影响不到它表示开发者工具里面可以看到内部的并与之互动将不允许的使用者与内部代码互动内部通过指定属性或使用元素指定代码内部可以通过向根添加或来设置样式上面代码添加的样式只会影响内的元素的样式内部表示这个根元素比如默认是行内元素下面代码可以改成块级元素注意外部样式会覆盖掉的设置比如下面的样式会覆盖利用的自定义属性可以为可以被覆盖的默认样式下面是外部样式是然后内部可以指定默认样式用于用户没有指定颜色的情况下面的例子是为加上独立的模板张三上面代码是一个元素和模板接下来就是要把模板应用到元素上基本操作长久以来网页可以加载外部的样式表脚本图片多媒体却无法方便地加载其他网页和都只能提供部分的解决方案且有很大的局限就是为了解决加载外部网页这个问题而提出来的下面代码用于测试当前浏览器是否支持支持不支持用于将外部的文档加载进当前文档我们可以将组件的封装在一个文件里然后使用下面的代码插入需要使用该组件的网页上面代码在网页中插入一个对话框组件该组建封装在文件注意文件中的样式和脚本都对所插入的整个网页有效假定网页通过加载了网页即是一个组件那么网页的样式表和脚本对网页也有效准确得说只有标签中的样式对网页有效标签加载的样式表对网页无效所以可以把多个样式表和脚本都放在网页中都从那里加载这对大型的框架是很方便的加载方法如果与不在同一个域那么所在的域必须打开必须打开除了用标签也可以用调用元素完成加载成功时会在元素上触发事件加载失败时比如错误会触发事件可以对这两个事件指定回调函数上面代码中和函数的定义必须在元素的前面因为浏览器元素遇到元素时立刻解析并加载外部网页同步操作如果这时没有对这两个函数定义就会报错是同步加载会阻塞当前网页的渲染这主要是为了样式表的考虑因为外部网页的样式表对当前网页也有效如果想避免这一点可以为元素加上属性当然这也意味着如果外部网页定义了组件就不能立即使用了必须等完成才能使用但是不会阻塞当前网页的解析和脚本执行即阻塞渲染这意味着在加载的同时主页面的脚本会继续执行最后支持多重加载即被加载的网页同时又加载其他网页如果这些网页都重复加载同一个外部脚本浏览器只会抓取并执行一次该脚本比如网页加载了网页它们各自都需要加载浏览器只会加载一次脚本的执行外部网页的内容并不会自动显示在当前网页中它只是储存在浏览器中等到被调用的时候才加载进入当前网页为了加载网页网页必须用操作获取加载的内容具体来说就是使用元素的属性来获取加载的内容这一点与完全不同发生以下情况时属性为浏览器不支持元素没有声明元素没有被加入元素已经从中移除对方域名没有打开下面代码用于从加载的外部网页选取为的元素然后将其克隆后加入当前网页的当前网页可以获取外部网页反过来也一样外部网页中的脚本不仅可以获取本身的还可以获取元素所在的当前网页的以下代码位于被加载的外部网页指向被加载的指向主文档的将子页面的样式表添加主文档上面代码将所加载的外部网页的样式表添加进当前网页被加载的外部网页的脚本是直接在当前网页的上下文执行因为它的指的是当前网页的而且它定义的函数可以被当前网页的脚本直接引用的封装对于来说的一个重要应用是在所加载的网页中自动登记定义并登记指向被加载的网页定义并登记上面代码定义并登记了两个元素和在主页面使用这两个元素非常简单不难想到这意味着使得变得可分享了其他人只要拷贝就可以在自己的页面中使用了是非常新的技术为了让老式浏览器也能使用推出了一个函数库这个库不仅可以帮助开发者定义自己的网页元素还提供许多预先制作好的组件可以直接使用直接使用的组件提供的组件可以直接插入网页比如下面的再比如在网页中插入一个时钟可以直接使用下面的标签自定义标签与其他标签的用法完全相同也可以使用指定它的样式安装如果使用安装至少需要安装和这两个核心部分你还可以安装所有预先定义的界面组件还可以只安装单个组件这时组件根目录下的会指明该组件的依赖的模块这些模块会被自动安装自定义组件下面是一个最简单的自定义组件的例子上面代码定义了组件它分成三个部分命令命令表示载入核心模块标签标签定义了组件的名称注意组件名称中必须包含连字符它还可以使用属性表示组件基于某种网页元素标签标签定义了网页元素的模板组件的使用方法在调用组件的网页中首先加载库和组件文件然后分成两种情况如果组件不基于任何现有的网页元素即定义的时候没有使用属性则可以直接使用组件这时网页上就会显示一行字如果组件是基于现有的网页元素则必须在该种元素上使用属性指定组件参考链接是一种网络通信协议很多高级功能都需要它初次接触的人都会问同样的问题我们已经有了协议为什么还需要另一个协议它能带来什么好处答案很简单因为协议有一个缺陷通信只能由客户端发起举例来说我们想了解今天的天气只能是客户端向服务器发出请求服务器返回查询结果协议做不到服务器主动向客户端推送信息协议的这种单向请求的特点注定了如果服务器有连续的状态变化客户端要获知就非常麻烦我们只能使用轮询每隔一段时候就发出一个询问了解服务器有没有新的信息最典型的场景就是聊天室轮询的效率低非常浪费资源因为必须不停连接或者连接始终打开因此工程师们一直在思考有没有更好的方法就是这样发明的简介协议在年诞生年成为国际标准所有浏览器都已经支持了它的最大特点就是服务器可以主动向客户端推送信息客户端也可以主动向服务器发送信息是真正的双向平等对话属于服务器推送技术的一种允许服务器端与客户端进行全双工的通信举例来说协议有点像发电子邮件发出后必须等待对方回信则是像打电话服务器端和客户端可以同时向对方发送数据它们之间存着一条持续打开的数据通道其他特点包括建立在协议之上服务器端的实现比较容易与协议有着良好的兼容性默认端口也是和并且握手阶段采用协议因此握手时不容易屏蔽能通过各种代理服务器数据格式比较轻量性能开销小通信高效可以发送文本也可以发送二进制数据没有同源限制客户端可以与任意服务器通信完全可以取代协议标识符是如果加密则为对应协议服务器网址就是握手浏览器发出的握手请求类似于下面的样子上面的头信息之中有一个头是协议规定字段表示将通信协议从转向该字段指定的协议字段表示浏览器通知服务器如果可以的话就升级到协议字段用于提供请求发出的域名供服务器验证是否许可的范围内服务器也可以不验证则是用于握手协议的密钥是编码的字节随机字符串服务器的回应如下上面代码中服务器同样用字段通知浏览器需要改变协议字段是服务器在浏览器提供的字符串后面添加标准规定的字符串然后再取的哈希值浏览器将对这个值进行验证以证明确实是目标服务器回应了请求字段表示进行通信的网址完成握手以后协议就在协议之上开始传送数据客户端的简单示例的用法相当简单下面是一个网页脚本的例子基本上一眼就能明白客户端浏览器对协议的处理无非就是三件事建立连接和断开连接发送数据和接收数据处理错误构造函数对象作为一个构造函数用于新建实例执行上面语句之后客户端就会与服务器进行连接属性返回实例对象的当前状态共有四种值为表示正在连接值为表示连接成功可以通信了值为表示连接正在关闭值为表示连接已经关闭或者打开连接失败下面是一个示例实例对象的属性用于指定连接成功后的回调函数如果要指定多个回调函数可以使用方法实例对象的属性用于指定连接关闭后的回调函数实例对象的属性用于指定收到服务器数据后的回调函数处理数据处理数据注意服务器数据可能是文本也可能是二进制数据对象或对象除了动态判断收到的数据类型也可以使用属性显式指定收到的二进制数据类型收到的是数据收到的是数据实例对象的方法用于向服务器发送数据发送文本的例子发送对象的例子发送对象的例子实例对象的属性表示还有多少字节的二进制数据没有发送出去它可以用来判断发送是否结束发送完毕发送还没结束实例对象的属性用于指定报错时的回调函数服务器协议需要服务器支持各种服务器的实现可以查看维基百科的列表常用的实现有以下三种具体的用法请查看它们的文档本教程不详细介绍了参考链接',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-07 14:15:15',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://mydocs.guoyaxue.top/" title="旧版博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="旧版博客"/><span class="back-menu-item-text">旧版博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://pan.xiaou61.top/#/" title="免费网盘"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="免费网盘"/><span class="back-menu-item-text">免费网盘</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://cloud.xiaou61.top/" title="云盘(自用)"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="云盘(自用)"/><span class="back-menu-item-text">云盘(自用)</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://wpzc.xiaou61.top/" title="云盘转存"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="云盘转存"/><span class="back-menu-item-text">云盘转存</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://love.xiaou61.top/#/" title="关于我们(My girlFriend)"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="关于我们(My girlFriend)"/><span class="back-menu-item-text">关于我们(My girlFriend)</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">娱乐项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://fxq.xiaou61.top/#/" title="飞行棋"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="飞行棋"/><span class="back-menu-item-text">飞行棋</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/game/sqnwmai803/" title="谁去拿外卖"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="谁去拿外卖"/><span class="back-menu-item-text">谁去拿外卖</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/desktop.html" title="win12网页版"><img class="back-menu-item-icon" src="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/icon/logo.svg" alt="win12网页版"/><span class="back-menu-item-text">win12网页版</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://game.xiaou61.top/" title="在线游戏"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="在线游戏"/><span class="back-menu-item-text">在线游戏</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">小u的博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 开往</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><span> 开往</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>3</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JVM/" style="font-size: 1.05rem;">JVM<sup>22</sup></a><a href="/tags/Nginx/" style="font-size: 1.05rem;">Nginx<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>1</sup></a><a href="/tags/Ts/" style="font-size: 1.05rem;">Ts<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size: 1.05rem;">TypeScript<sup>1</sup></a><a href="/tags/WebApi/" style="font-size: 1.05rem;">WebApi<sup>1</sup></a><a href="/tags/coder1v5/" style="font-size: 1.05rem;">coder1v5<sup>2</sup></a><a href="/tags/css/" style="font-size: 1.05rem;">css<sup>3</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>12</sup></a><a href="/tags/javaSE/" style="font-size: 1.05rem;">javaSE<sup>3</sup></a><a href="/tags/javaWeb/" style="font-size: 1.05rem;">javaWeb<sup>2</sup></a><a href="/tags/js%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">js逆向<sup>1</sup></a><a href="/tags/leetcode/" style="font-size: 1.05rem;">leetcode<sup>3</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>8</sup></a><a href="/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/" style="font-size: 1.05rem;">书籍推荐<sup>2</sup></a><a href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%90%AC%E8%BF%90/" style="font-size: 1.05rem;">公众号搬运<sup>35</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 1.05rem;">前端<sup>10</sup></a><a href="/tags/%E5%8A%9E%E5%85%AC/" style="font-size: 1.05rem;">办公<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 1.05rem;">后端<sup>8</sup></a><a href="/tags/%E5%A4%A9%E6%B6%AF%E8%AE%BA%E5%9D%9B/" style="font-size: 1.05rem;">天涯论坛<sup>1</sup></a><a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 1.05rem;">导航<sup>1</sup></a><a href="/tags/%E5%B0%B1%E4%B8%9A/" style="font-size: 1.05rem;">就业<sup>16</sup></a><a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 1.05rem;">微信<sup>1</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/" style="font-size: 1.05rem;">技术杂谈<sup>51</sup></a><a href="/tags/%E6%8E%98%E9%87%91/" style="font-size: 1.05rem;">掘金<sup>14</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 1.05rem;">杂项<sup>1</sup></a><a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 1.05rem;">测试<sup>1</sup></a><a href="/tags/%E6%B8%A1%E4%B8%80%E5%A4%A7%E5%B8%88%E8%AF%BE/" style="font-size: 1.05rem;">渡一大师课<sup>3</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 1.05rem;">爬虫<sup>1</sup></a><a href="/tags/%E7%9B%AE%E5%BD%95/" style="font-size: 1.05rem;">目录<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>4</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 1.05rem;">虚拟机<sup>12</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>6</sup></a><a href="/tags/%E8%B7%AF%E9%A3%9E%E5%AD%A6%E9%99%A2/" style="font-size: 1.05rem;">路飞学院<sup>3</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">面向对象<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>51</sup></a><a href="/tags/%E9%A3%9E%E8%A1%8C%E6%A3%8B/" style="font-size: 1.05rem;">飞行棋<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">234</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">September 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">May 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/WebApi/" itemprop="url">WebApi</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/WebApi/%E5%89%8D%E7%AB%AF/" itemprop="url">前端</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>前端</span></a><a class="article-meta__tags" href="/tags/WebApi/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>WebApi</span></a></span></div></div><h1 class="post-title" itemprop="name headline">WebApi</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-09-30T23:34:06.275Z" title="Created 2023-10-01 07:34:06">2023-10-01</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-08-07T06:15:15.414Z" title="Updated 2023-08-07 14:15:15">2023-08-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为邯郸"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>邯郸</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2023/10/01/codenotes/front_end/WebApi/"><header><a class="post-meta-categories" href="/categories/WebApi/" itemprop="url">WebApi</a><a class="post-meta-categories" href="/categories/WebApi/%E5%89%8D%E7%AB%AF/" itemprop="url">前端</a><a href="/tags/%E5%89%8D%E7%AB%AF/" tabindex="-1" itemprop="url">前端</a><a href="/tags/WebApi/" tabindex="-1" itemprop="url">WebApi</a><h1 id="CrawlerTitle" itemprop="name headline">WebApi</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小u</span><time itemprop="dateCreated datePublished" datetime="2023-09-30T23:34:06.275Z" title="Created 2023-10-01 07:34:06">2023-10-01</time><time itemprop="dateCreated datePublished" datetime="2023-08-07T06:15:15.414Z" title="Updated 2023-08-07 14:15:15">2023-08-07</time></header><h2 id="WebApi"><a href="#WebApi" class="headerlink" title="WebApi"></a>WebApi</h2><p>这个只作为一个了解就可以了</p>
<h2 id="Canvas-API"><a href="#Canvas-API" class="headerlink" title="Canvas API"></a>Canvas API</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>&lt;canvas&gt;</code>元素用于生成图像。它本身就像一个画布，JavaScript 通过操作它的 API，在上面生成图像。它的底层是一个个像素，基本上<code>&lt;canvas&gt;</code>是一个可以用 JavaScript 操作的位图（bitmap）。</p>
<p>它与 SVG 图像的区别在于，<code>&lt;canvas&gt;</code>是脚本调用各种方法生成图像，SVG 则是一个 XML 文件，通过各种子元素生成图像。</p>
<p>使用 Canvas API 之前，需要在网页里面新建一个<code>&lt;canvas&gt;</code>元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;250&quot;</span>&gt;</span></span><br><span class="line">  您的浏览器不支持 Canvas</span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果浏览器不支持这个 API，就会显示<code>&lt;canvas&gt;</code>标签中间的文字：“您的浏览器不支持 Canvas”。</p>
<p>每个<code>&lt;canvas&gt;</code>元素都有一个对应的<code>CanvasRenderingContext2D</code>对象（上下文对象）。Canvas API 就定义在这个对象上面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>&lt;canvas&gt;</code>元素节点对象的<code>getContext()</code>方法，返回的就是<code>CanvasRenderingContext2D</code>对象。</p>
<p>注意，Canvas API 需要<code>getContext</code>方法指定参数<code>2d</code>，表示该<code>&lt;canvas&gt;</code>节点生成 2D 的平面图像。如果参数是<code>webgl</code>，就表示用于生成 3D 的立体图案，这部分属于 WebGL API。</p>
<p>按照用途，Canvas API 分成两大部分：绘制图形和图像处理。</p>
<h3 id="Canvas-API：绘制图形"><a href="#Canvas-API：绘制图形" class="headerlink" title="Canvas API：绘制图形"></a>Canvas API：绘制图形</h3><p>Canvas 画布提供了一个作图的平面空间，该空间的每个点都有自己的坐标。原点<code>(0, 0)</code>位于图像左上角，<code>x</code>轴的正向是原点向右，<code>y</code>轴的正向是原点向下。</p>
<h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>以下方法和属性用来绘制路径。</p>
<ul>
<li><code>CanvasRenderingContext2D.beginPath()</code>：开始绘制路径。</li>
<li><code>CanvasRenderingContext2D.closePath()</code>：结束路径，返回到当前路径的起始点，会从当前点到起始点绘制一条直线。如果图形已经封闭，或者只有一个点，那么此方法不会产生任何效果。</li>
<li><code>CanvasRenderingContext2D.moveTo()</code>：设置路径的起点，即将一个新路径的起始点移动到<code>(x，y)</code>坐标。</li>
<li><code>CanvasRenderingContext2D.lineTo()</code>：使用直线从当前点连接到<code>(x, y)</code>坐标。</li>
<li><code>CanvasRenderingContext2D.fill()</code>：在路径内部填充颜色（默认为黑色）。</li>
<li><code>CanvasRenderingContext2D.stroke()</code>：路径线条着色（默认为黑色）。</li>
<li><code>CanvasRenderingContext2D.fillStyle</code>：指定路径填充的颜色和样式（默认为黑色）。</li>
<li><code>CanvasRenderingContext2D.strokeStyle</code>：指定路径线条的颜色和样式（默认为黑色）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx.<span class="title function_">moveTo</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.<span class="title function_">lineTo</span>(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">ctx.<span class="title function_">lineTo</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码只是确定了路径的形状，画布上还看不出来，因为没有颜色。所以还需要着色。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">fill</span>()</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">ctx.<span class="title function_">stroke</span>()</span><br></pre></td></tr></table></figure>

<p>上面代码中，这两个方法都可以使得路径可见。<code>fill()</code>在路径内部填充颜色，使之变成一个实心的图形；<code>stroke()</code>只对路径线条着色。</p>
<p>这两个方法默认都是使用黑色，可以使用<code>fillStyle</code>和<code>strokeStyle</code>属性指定其他颜色。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">ctx.<span class="title function_">fill</span>();</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">ctx.<span class="property">strokeStyle</span> = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码将填充和线条的颜色指定为红色。</p>
<h4 id="线型"><a href="#线型" class="headerlink" title="线型"></a>线型</h4><p>以下的方法和属性控制线条的视觉特征。</p>
<ul>
<li><code>CanvasRenderingContext2D.lineWidth</code>：指定线条的宽度，默认为1.0。</li>
<li><code>CanvasRenderingContext2D.lineCap</code>：指定线条末端的样式，有三个可能的值：<code>butt</code>（默认值，末端为矩形）、<code>round</code>（末端为圆形）、<code>square</code>（末端为突出的矩形，矩形宽度不变，高度为线条宽度的一半）。</li>
<li><code>CanvasRenderingContext2D.lineJoin</code>：指定线段交点的样式，有三个可能的值：<code>round</code>（交点为扇形）、<code>bevel</code>（交点为三角形底边）、<code>miter</code>（默认值，交点为菱形)。</li>
<li><code>CanvasRenderingContext2D.miterLimit</code>：指定交点菱形的长度，默认为10。该属性只在<code>lineJoin</code>属性的值等于<code>miter</code>时有效。</li>
<li><code>CanvasRenderingContext2D.getLineDash()</code>：返回一个数组，表示虚线里面线段和间距的长度。</li>
<li><code>CanvasRenderingContext2D.setLineDash()</code>：数组，用于指定虚线里面线段和间距的长度。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx.<span class="title function_">moveTo</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.<span class="title function_">lineTo</span>(<span class="number">200</span>, <span class="number">200</span>);</span><br><span class="line">ctx.<span class="title function_">lineTo</span>(<span class="number">100</span>, <span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">lineWidth</span> = <span class="number">3</span>;</span><br><span class="line">ctx.<span class="property">lineCap</span> = <span class="string">&#x27;round&#x27;</span>;</span><br><span class="line">ctx.<span class="property">lineJoin</span> = <span class="string">&#x27;round&#x27;</span>;</span><br><span class="line">ctx.<span class="title function_">setLineDash</span>([<span class="number">15</span>, <span class="number">5</span>]);</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，线条的宽度为3，线条的末端和交点都改成圆角，并且设置为虚线。</p>
<h4 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h4><p>以下方法用来绘制矩形。</p>
<ul>
<li><code>CanvasRenderingContext2D.rect()</code>：绘制矩形路径。</li>
<li><code>CanvasRenderingContext2D.fillRect()</code>：填充一个矩形。</li>
<li><code>CanvasRenderingContext2D.strokeRect()</code>：绘制矩形边框。</li>
<li><code>CanvasRenderingContext2D.clearRect()</code>：指定矩形区域的像素都变成透明。</li>
</ul>
<p>上面四个方法的格式都一样，都接受四个参数，分别是矩形左上角的横坐标和纵坐标、矩形的宽和高。</p>
<p><code>CanvasRenderingContext2D.rect()</code>方法用于绘制矩形路径。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">rect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.<span class="title function_">fill</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码绘制一个正方形，左上角坐标为<code>(10, 10)</code>，宽和高都为100。</p>
<p><code>CanvasRenderingContext2D.fillRect()</code>用来向一个矩形区域填充颜色。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码绘制一个绿色的正方形，左上角坐标为<code>(10, 10)</code>，宽和高都为100。</p>
<p><code>CanvasRenderingContext2D.strokeRect()</code>用来绘制一个矩形区域的边框。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">strokeStyle</span> = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">ctx.<span class="title function_">strokeRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码绘制一个绿色的空心正方形，左上角坐标为<code>(10, 10)</code>，宽和高都为100。</p>
<p><code>CanvasRenderingContext2D.clearRect()</code>用于擦除指定矩形区域的像素颜色，等同于把早先的绘制效果都去除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">ctx.<span class="title function_">clearRect</span>(<span class="number">15</span>, <span class="number">15</span>, <span class="number">90</span>, <span class="number">90</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码先绘制一个 100 x 100 的正方形，然后在它的内部擦除 90 x 90 的区域，等同于形成了一个5像素宽度的边框。</p>
<h4 id="弧线"><a href="#弧线" class="headerlink" title="弧线"></a>弧线</h4><p>以下方法用于绘制弧形。</p>
<ul>
<li><code>CanvasRenderingContext2D.arc()</code>：通过指定圆心和半径绘制弧形。</li>
<li><code>CanvasRenderingContext2D.arcTo()</code>：通过指定两根切线和半径绘制弧形。</li>
</ul>
<p><code>CanvasRenderingContext2D.arc()</code>主要用来绘制圆形或扇形。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line">ctx.<span class="title function_">arc</span>(x, y, radius, startAngle, endAngle, anticlockwise)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例</span></span><br><span class="line">ctx.<span class="title function_">arc</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span> * <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p><code>arc()</code>方法的<code>x</code>和<code>y</code>参数是圆心坐标，<code>radius</code>是半径，<code>startAngle</code>和<code>endAngle</code>则是扇形的起始角度和终止角度（以弧度表示），<code>anticlockwise</code>表示做图时应该逆时针画（<code>true</code>）还是顺时针画（<code>false</code>），这个参数用来控制扇形的方向（比如上半圆还是下半圆）。</p>
<p>下面是绘制实心圆形的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx.<span class="title function_">arc</span>(<span class="number">60</span>, <span class="number">60</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span>, <span class="literal">true</span>); </span><br><span class="line">ctx.<span class="title function_">fill</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码绘制了一个半径50，起始角度为0，终止角度为 2 * PI 的完整的圆。</p>
<p>绘制空心半圆的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx.<span class="title function_">moveTo</span>(<span class="number">50</span>, <span class="number">20</span>);</span><br><span class="line">ctx.<span class="title function_">arc</span>(<span class="number">100</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span>, <span class="literal">false</span>);</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br></pre></td></tr></table></figure>

<p><code>CanvasRenderingContext2D.arcTo()</code>方法主要用来绘制圆弧，需要给出两个点的坐标，当前点与第一个点形成一条直线，第一个点与第二个点形成另一条直线，然后画出与这两根直线相切的弧线。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">ctx.<span class="title function_">moveTo</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">ctx.<span class="title function_">arcTo</span>(<span class="number">50</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">25</span>);</span><br><span class="line">ctx.<span class="title function_">lineTo</span>(<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">ctx.<span class="title function_">stroke</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>arcTo()</code>有5个参数，前两个参数是第一个点的坐标，第三个参数和第四个参数是第二个点的坐标，第五个参数是半径。然后，<code>(0, 0)</code>与<code>(50, 50)</code>形成一条直线，然后<code>(50, 50)</code>与<code>(100, 0)</code>形成第二条直线。弧线就是与这两根直线相切的部分。</p>
<h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><p>以下方法和属性用于绘制文本。</p>
<ul>
<li><code>CanvasRenderingContext2D.fillText()</code>：在指定位置绘制实心字符。</li>
<li><code>CanvasRenderingContext2D.strokeText()</code>：在指定位置绘制空心字符。</li>
<li><code>CanvasRenderingContext2D.measureText()</code>：返回一个 TextMetrics 对象。</li>
<li><code>CanvasRenderingContext2D.font</code>：指定字型大小和字体，默认值为<code>10px sans-serif</code>。</li>
<li><code>CanvasRenderingContext2D.textAlign</code>：文本的对齐方式，默认值为<code>start</code>。</li>
<li><code>CanvasRenderingContext2D.direction</code>：文本的方向，默认值为<code>inherit</code>。</li>
<li><code>CanvasRenderingContext2D.textBaseline</code>：文本的垂直位置，默认值为<code>alphabetic</code>。</li>
</ul>
<p><code>fillText()</code>方法用来在指定位置绘制实心字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">CanvasRenderingContext2D</span>.<span class="title function_">fillText</span>(text, x, y [, maxWidth])</span><br></pre></td></tr></table></figure>

<p>该方法接受四个参数。</p>
<ul>
<li><code>text</code>：所要填充的字符串。</li>
<li><code>x</code>：文字起点的横坐标，单位像素。</li>
<li><code>y</code>：文字起点的纵坐标，单位像素。</li>
<li><code>maxWidth</code>：文本的最大像素宽度。该参数可选，如果省略，则表示宽度没有限制。如果文本实际长度超过这个参数指定的值，那么浏览器将尝试用较小的字体填充。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">fillText</span>(<span class="string">&#x27;Hello world&#x27;</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码在<code>(50, 50)</code>位置写入字符串<code>Hello world</code>。</p>
<p>注意，<code>fillText()</code>方法不支持文本断行，所有文本一定出现在一行内。如果要生成多行文本，只有调用多次<code>fillText()</code>方法。</p>
<p><code>strokeText()</code>方法用来添加空心字符，它的参数与<code>fillText()</code>一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">strokeText</span>(<span class="string">&#x27;Hello world&#x27;</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p>上面这两种方法绘制的文本，默认都是<code>10px</code>大小、<code>sans-serif</code>字体，<code>font</code>属性可以改变字体设置。该属性的值是一个字符串，使用 CSS 的<code>font</code>属性即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">font</span> = <span class="string">&#x27;Bold 20px Arial&#x27;</span>;</span><br><span class="line">ctx.<span class="title function_">fillText</span>(<span class="string">&#x27;Hello world&#x27;</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p><code>textAlign</code>属性用来指定文本的对齐方式。它可以取以下几个值。</p>
<ul>
<li><code>left</code>：左对齐</li>
<li><code>right</code>：右对齐</li>
<li><code>center</code>：居中</li>
<li><code>start</code>：默认值，起点对齐（从左到右的文本为左对齐，从右到左的文本为右对齐）。</li>
<li><code>end</code>：结尾对齐（从左到右的文本为右对齐，从右到左的文本为左对齐）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">font</span> = <span class="string">&#x27;Bold 20px Arial&#x27;</span>;</span><br><span class="line">ctx.<span class="property">textAlign</span> = <span class="string">&#x27;center&#x27;</span>;</span><br><span class="line">ctx.<span class="title function_">fillText</span>(<span class="string">&#x27;Hello world&#x27;</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>

<p><code>direction</code>属性指定文本的方向，默认值为<code>inherit</code>，表示继承<code>&lt;canvas&gt;</code>或<code>document</code>的设置。其他值包括<code>ltr</code>（从左到右）和<code>rtl</code>（从右到左）。</p>
<p><code>textBaseline</code>属性指定文本的垂直位置，可以取以下值。</p>
<ul>
<li><code>top</code>：上部对齐（字母的基线是整体上移）。</li>
<li><code>hanging</code>：悬挂对齐（字母的上沿在一根直线上），适用于印度文和藏文。</li>
<li><code>middle</code>：中部对齐（字母的中线在一根直线上）。</li>
<li><code>alphabetic</code>：默认值，表示字母位于字母表的正常位置（四线格的第三根线）。</li>
<li><code>ideographic</code>：下沿对齐（字母的下沿在一根直线上），使用于东亚文字。</li>
<li><code>bottom</code>：底部对齐（字母的基线下移）。对于英文字母，这个设置与<code>ideographic</code>没有差异。</li>
</ul>
<p><code>measureText()</code>方法接受一个字符串作为参数，返回一个 TextMetrics 对象，可以从这个对象上面获取参数字符串的信息，目前主要是文本渲染后的宽度（<code>width</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> text1 = ctx.<span class="title function_">measureText</span>(<span class="string">&#x27;Hello world&#x27;</span>);</span><br><span class="line">text1.<span class="property">width</span> <span class="comment">// 49.46</span></span><br><span class="line"></span><br><span class="line">ctx.<span class="property">font</span> = <span class="string">&#x27;Bold 20px Arial&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> text2 = ctx.<span class="title function_">measureText</span>(<span class="string">&#x27;Hello world&#x27;</span>);</span><br><span class="line">text2.<span class="property">width</span> <span class="comment">// 107.78</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>10px</code>大小的字符串<code>Hello world</code>，渲染后宽度为<code>49.46</code>。放大到<code>20px</code>以后，宽度为<code>107.78</code>。</p>
<h4 id="渐变色和图像填充"><a href="#渐变色和图像填充" class="headerlink" title="渐变色和图像填充"></a>渐变色和图像填充</h4><p>以下方法用于设置渐变效果和图像填充效果。</p>
<ul>
<li><code>CanvasRenderingContext2D.createLinearGradient()</code>：定义线性渐变样式。</li>
<li><code>CanvasRenderingContext2D.createRadialGradient()</code>：定义辐射渐变样式。</li>
<li><code>CanvasRenderingContext2D.createPattern()</code>：定义图像填充样式。</li>
</ul>
<p><code>createLinearGradient()</code>方法按照给定直线，生成线性渐变的样式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">createLinearGradient</span>(x0, y0, x1, y1)</span><br></pre></td></tr></table></figure>

<p><code>ctx.createLinearGradient(x0, y0, x1, y1)</code>方法接受四个参数：<code>x0</code>和<code>y0</code>是起点的横坐标和纵坐标，<code>x1</code>和<code>y1</code>是终点的横坐标和纵坐标。通过不同的坐标值，可以生成从上至下、从左到右的渐变等等。</p>
<p>该方法的返回值是一个<code>CanvasGradient</code>对象，该对象只有一个<code>addColorStop()</code>方向，用来指定渐变点的颜色。<code>addColorStop()</code>方法接受两个参数，第一个参数是0到1之间的一个位置量，0表示起点，1表示终点，第二个参数是一个字符串，表示 CSS 颜色。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gradient = ctx.<span class="title function_">createLinearGradient</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">0</span>);</span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&#x27;green&#x27;</span>);</span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&#x27;white&#x27;</span>);</span><br><span class="line">ctx.<span class="property">fillStyle</span> = gradient;</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">200</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，定义了渐变样式<code>gradient</code>以后，将这个样式指定给<code>fillStyle</code>属性，然后<code>fillRect()</code>就会生成以这个样式填充的矩形区域。</p>
<p><code>createRadialGradient()</code>方法定义一个辐射渐变，需要指定两个圆。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">createRadialGradient</span>(x0, y0, r0, x1, y1, r1)</span><br></pre></td></tr></table></figure>

<p><code>createRadialGradient()</code>方法接受六个参数，<code>x0</code>和<code>y0</code>是辐射起始的圆的圆心坐标，<code>r0</code>是起始圆的半径，<code>x1</code>和<code>y1</code>是辐射终止的圆的圆心坐标，<code>r1</code>是终止圆的半径。</p>
<p>该方法的返回值也是一个<code>CanvasGradient</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gradient = ctx.<span class="title function_">createRadialGradient</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">0</span>, <span class="string">&#x27;white&#x27;</span>);</span><br><span class="line">gradient.<span class="title function_">addColorStop</span>(<span class="number">1</span>, <span class="string">&#x27;green&#x27;</span>);</span><br><span class="line">ctx.<span class="property">fillStyle</span> = gradient;</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，生成辐射样式以后，用这个样式填充一个矩形。</p>
<p><code>createPattern()</code>方法定义一个图像填充样式，在指定方向上不断重复该图像，填充指定的区域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">createPattern</span>(image, repetition)</span><br></pre></td></tr></table></figure>

<p>该方法接受两个参数，第一个参数是图像数据，它可以是<code>&lt;img&gt;</code>元素，也可以是另一个<code>&lt;canvas&gt;</code>元素，或者一个表示图像的 Blob 对象。第二个参数是一个字符串，有四个可能的值，分别是<code>repeat</code>（双向重复）、<code>repeat-x</code>(水平重复)、<code>repeat-y</code>(垂直重复)、<code>no-repeat</code>(不重复)。如果第二个参数是空字符串或<code>null</code>，则等同于<code>null</code>。</p>
<p>该方法的返回值是一个<code>CanvasPattern</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&#x27;https://example.com/pattern.png&#x27;</span>;</span><br><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"> </span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> pattern = ctx.<span class="title function_">createPattern</span>(img, <span class="string">&#x27;repeat&#x27;</span>);</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = pattern;</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">400</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，图像加载成功以后，使用<code>createPattern()</code>生成图像样式，然后使用这个样式填充指定区域。</p>
<h4 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h4><p>以下属性用于设置阴影。</p>
<ul>
<li><code>CanvasRenderingContext2D.shadowBlur</code>：阴影的模糊程度，默认为<code>0</code>。</li>
<li><code>CanvasRenderingContext2D.shadowColor</code>：阴影的颜色，默认为<code>black</code>。</li>
<li><code>CanvasRenderingContext2D.shadowOffsetX</code>：阴影的水平位移，默认为<code>0</code>。</li>
<li><code>CanvasRenderingContext2D.shadowOffsetY</code>：阴影的垂直位移，默认为<code>0</code>。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">shadowOffsetX</span> = <span class="number">10</span>;</span><br><span class="line">ctx.<span class="property">shadowOffsetY</span> = <span class="number">10</span>;</span><br><span class="line">ctx.<span class="property">shadowBlur</span> = <span class="number">5</span>;</span><br><span class="line">ctx.<span class="property">shadowColor</span> = <span class="string">&#x27;rgba(0,0,0,0.5)&#x27;</span>;</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Canvas-API：图像处理"><a href="#Canvas-API：图像处理" class="headerlink" title="Canvas API：图像处理"></a>Canvas API：图像处理</h3><h4 id="CanvasRenderingContext2D-drawImage"><a href="#CanvasRenderingContext2D-drawImage" class="headerlink" title="CanvasRenderingContext2D.drawImage()"></a>CanvasRenderingContext2D.drawImage()</h4><p>Canvas API 允许将图像文件写入画布，做法是读取图片后，使用<code>drawImage()</code>方法将这张图片放上画布。</p>
<p><code>CanvasRenderingContext2D.drawImage()</code>有三种使用格式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">drawImage</span>(image, dx, dy);</span><br><span class="line">ctx.<span class="title function_">drawImage</span>(image, dx, dy, dWidth, dHeight);</span><br><span class="line">ctx.<span class="title function_">drawImage</span>(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);</span><br></pre></td></tr></table></figure>

<p>各个参数的含义如下。</p>
<ul>
<li>image：图像元素</li>
<li>sx：图像内部的横坐标，用于映射到画布的放置点上。</li>
<li>sy：图像内部的纵坐标，用于映射到画布的放置点上。</li>
<li>sWidth：图像在画布上的宽度，会产生缩放效果。如果未指定，则图像不会缩放，按照实际大小占据画布的宽度。</li>
<li>sHeight：图像在画布上的高度，会产生缩放效果。如果未指定，则图像不会缩放，按照实际大小占据画布的高度。</li>
<li>dx：画布内部的横坐标，用于放置图像的左上角</li>
<li>dy：画布内部的纵坐标，用于放置图像的右上角</li>
<li>dWidth：图像在画布内部的宽度，会产生缩放效果。</li>
<li>dHeight：图像在画布内部的高度，会产生缩放效果。</li>
</ul>
<p>下面是最简单的使用场景，将图像放在画布上，两者左上角对齐。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">img.<span class="property">src</span> = <span class="string">&#x27;image.png&#x27;</span>;</span><br><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  ctx.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码将一个 PNG 图像放入画布。这时，图像将是原始大小，如果画布小于图像，就会只显示出图像左上角，正好等于画布大小的那一块。</p>
<p>如果要显示完整的图片，可以用图像的宽和高，设置成画布的宽和高。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>(<span class="number">60</span>, <span class="number">45</span>);</span><br><span class="line">image.<span class="property">onload</span> = drawImageActualSize;</span><br><span class="line">image.<span class="property">src</span> = <span class="string">&#x27;https://example.com/image.jpg&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">drawImageActualSize</span>(<span class="params"></span>) &#123;</span><br><span class="line">  canvas.<span class="property">width</span> = <span class="variable language_">this</span>.<span class="property">naturalWidth</span>;</span><br><span class="line">  canvas.<span class="property">height</span> = <span class="variable language_">this</span>.<span class="property">naturalHeight</span>;</span><br><span class="line">  ctx.<span class="title function_">drawImage</span>(<span class="variable language_">this</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="variable language_">this</span>.<span class="property">naturalWidth</span>, <span class="variable language_">this</span>.<span class="property">naturalHeight</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>&lt;canvas&gt;</code>元素的大小设置成图像的本来大小，就能保证完整展示图像。由于图像的本来大小，只有图像加载成功以后才能拿到，因此调整画布的大小，必须放在<code>image.onload</code>这个监听函数里面。</p>
<h4 id="像素读写"><a href="#像素读写" class="headerlink" title="像素读写"></a>像素读写</h4><p>以下三个方法与像素读写相关。</p>
<ul>
<li><code>CanvasRenderingContext2D.getImageData()</code>：将画布读取成一个 ImageData 对象</li>
<li><code>CanvasRenderingContext2D.putImageData()</code>：将 ImageData 对象写入画布</li>
<li><code>CanvasRenderingContext2D.createImageData()</code>：生成 ImageData 对象</li>
</ul>
<p><strong>（1）getImageData()</strong></p>
<p><code>CanvasRenderingContext2D.getImageData()</code>方法用来读取<code>&lt;canvas&gt;</code>的内容，返回一个 ImageData 对象，包含了每个像素的信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">getImageData</span>(sx, sy, sw, sh)</span><br></pre></td></tr></table></figure>

<p><code>getImageData()</code>方法接受四个参数。<code>sx</code>和<code>sy</code>是读取区域的左上角坐标，<code>sw</code>和<code>sh</code>是读取区域的宽度和高度。如果想要读取整个<code>&lt;canvas&gt;</code>区域，可以写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> imageData = ctx.<span class="title function_">getImageData</span>(<span class="number">0</span>, <span class="number">0</span>, canvas.<span class="property">width</span>, canvas.<span class="property">height</span>);</span><br></pre></td></tr></table></figure>

<p><code>getImageData()</code>方法返回的是一个<code>ImageData</code>对象。该对象有三个属性。</p>
<ul>
<li>ImageData.data：一个一维数组。该数组的值，依次是每个像素的红、绿、蓝、alpha 通道值（每个值的范围是 0～255），因此该数组的长度等于<code>图像的像素宽度 x 图像的像素高度 x 4</code>。这个数组不仅可读，而且可写，因此通过操作这个数组，就可以达到操作图像的目的。</li>
<li>ImageData.width：浮点数，表示 ImageData 的像素宽度。</li>
<li>ImageData.height：浮点数，表示 ImageData 的像素高度。</li>
</ul>
<p><strong>（2）putImageData()</strong></p>
<p><code>CanvasRenderingContext2D.putImageData()</code>方法将<code>ImageData</code>对象的像素绘制在<code>&lt;canvas&gt;</code>画布上。该方法有两种使用格式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">putImageData</span>(imagedata, dx, dy)</span><br><span class="line">ctx.<span class="title function_">putImageData</span>(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight)</span><br></pre></td></tr></table></figure>

<p>该方法有如下参数。</p>
<ul>
<li>imagedata：包含像素信息的 ImageData 对象。</li>
<li>dx：<code>&lt;canvas&gt;</code>元素内部的横坐标，用于放置 ImageData 图像的左上角。</li>
<li>dy：<code>&lt;canvas&gt;</code>元素内部的纵坐标，用于放置 ImageData 图像的左上角。</li>
<li>dirtyX：ImageData 图像内部的横坐标，用于作为放置到<code>&lt;canvas&gt;</code>的矩形区域的左上角的横坐标，默认为0。</li>
<li>dirtyY：ImageData 图像内部的纵坐标，用于作为放置到<code>&lt;canvas&gt;</code>的矩形区域的左上角的纵坐标，默认为0。</li>
<li>dirtyWidth：放置到<code>&lt;canvas&gt;</code>的矩形区域的宽度，默认为 ImageData 图像的宽度。</li>
<li>dirtyHeight：放置到<code>&lt;canvas&gt;</code>的矩形区域的高度，默认为 ImageData 图像的高度。</li>
</ul>
<p>下面是将 ImageData 对象绘制到<code>&lt;canvas&gt;</code>的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">putImageData</span>(imageData, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>（3）createImageData()</strong></p>
<p><code>CanvasRenderingContext2D.createImageData()</code>方法用于生成一个空的<code>ImageData</code>对象，所有像素都是透明的黑色（即每个值都是<code>0</code>）。该方法有两种使用格式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">createImageData</span>(width, height)</span><br><span class="line">ctx.<span class="title function_">createImageData</span>(imagedata)</span><br></pre></td></tr></table></figure>

<p><code>createImageData()</code>方法的参数如下。</p>
<ul>
<li>width：ImageData 对象的宽度，单位为像素。</li>
<li>height：ImageData 对象的高度，单位为像素。</li>
<li>imagedata：一个现有的 ImageData 对象，返回值将是这个对象的拷贝。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> imageData = ctx.<span class="title function_">createImageData</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>imageData</code>是一个 100 x 100 的像素区域，其中每个像素都是透明的黑色。</p>
<h4 id="CanvasRenderingContext2D-save-，CanvasRenderingContext2D-restore"><a href="#CanvasRenderingContext2D-save-，CanvasRenderingContext2D-restore" class="headerlink" title="CanvasRenderingContext2D.save()，CanvasRenderingContext2D.restore()"></a>CanvasRenderingContext2D.save()，CanvasRenderingContext2D.restore()</h4><p><code>CanvasRenderingContext2D.save()</code>方法用于将画布的当前样式保存到堆栈，相当于在内存之中产生一个样式快照。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">save</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>save()</code>会为画布的默认样式产生一个快照。</p>
<p><code>CanvasRenderingContext2D.restore()</code>方法将画布的样式恢复到上一个保存的快照，如果没有已保存的快照，则不产生任何效果。</p>
<p>上下文环境，restore方法用于恢复到上一次保存的上下文环境。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">save</span>();</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">ctx.<span class="title function_">restore</span>();</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码画一个矩形。矩形的填充色本来设为绿色，但是<code>restore()</code>方法撤销了这个设置，将样式恢复上一次保存的状态（即默认样式），所以实际的填充色是黑色（默认颜色）。</p>
<h4 id="CanvasRenderingContext2D-canvas"><a href="#CanvasRenderingContext2D-canvas" class="headerlink" title="CanvasRenderingContext2D.canvas"></a>CanvasRenderingContext2D.canvas</h4><p><code>CanvasRenderingContext2D.canvas</code>属性指向当前<code>CanvasRenderingContext2D</code>对象所在的<code>&lt;canvas&gt;</code>元素。该属性只读。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="property">canvas</span> === canvas <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="图像变换"><a href="#图像变换" class="headerlink" title="图像变换"></a>图像变换</h4><p>以下方法用于图像变换。</p>
<ul>
<li><code>CanvasRenderingContext2D.rotate()</code>：图像旋转</li>
<li><code>CanvasRenderingContext2D.scale()</code>：图像缩放</li>
<li><code>CanvasRenderingContext2D.translate()</code>：图像平移</li>
<li><code>CanvasRenderingContext2D.transform()</code>：通过一个变换矩阵完成图像变换</li>
<li><code>CanvasRenderingContext2D.setTransform()</code>：取消前面的图像变换</li>
</ul>
<p><strong>（1）rotate()</strong></p>
<p><code>CanvasRenderingContext2D.rotate()</code>方法用于图像旋转。它接受一个弧度值作为参数，表示顺时针旋转的度数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">rotate</span>(<span class="number">45</span> * <span class="title class_">Math</span>.<span class="property">PI</span> / <span class="number">180</span>);</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">70</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码会显示一个顺时针倾斜45度的矩形。注意，<code>rotate()</code>方法必须在<code>fillRect()</code>方法之前调用，否则是不起作用的。</p>
<p>旋转中心点始终是画布左上角的原点。如果要更改中心点，需要使用<code>translate()</code>方法移动画布。</p>
<p><strong>（2）scale()</strong></p>
<p><code>CanvasRenderingContext2D.scale()</code>方法用于缩放图像。它接受两个参数，分别是<code>x</code>轴方向的缩放因子和<code>y</code>轴方向的缩放因子。默认情况下，一个单位就是一个像素，缩放因子可以缩放单位，比如缩放因子<code>0.5</code>表示将大小缩小为原来的50%，缩放因子<code>10</code>表示放大十倍。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">scale</span>(<span class="number">10</span>, <span class="number">3</span>);</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，原来的矩形是 10 x 10，缩放后展示出来是 100 x 30。</p>
<p>如果缩放因子为1，就表示图像没有任何缩放。如果为-1，则表示方向翻转。<code>ctx.scale(-1, 1)</code>为水平翻转，<code>ctx.scale(1, -1)</code>表示垂直翻转。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">scale</span>(<span class="number">1</span>, -<span class="number">2</span>);</span><br><span class="line">ctx.<span class="property">font</span> = <span class="string">&quot;16px serif&quot;</span>;</span><br><span class="line">ctx.<span class="title function_">fillText</span>(<span class="string">&#x27;Hello world!&#x27;</span>, <span class="number">20</span>, -<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码会显示一个水平倒转的、高度放大2倍的<code>Hello World!</code>。</p>
<p>注意，负向缩放本质是坐标翻转，所针对的坐标轴就是画布左上角原点的坐标轴。</p>
<p><strong>（3）translate()</strong></p>
<p><code>CanvasRenderingContext2D.translate()</code>方法用于平移图像。它接受两个参数，分别是 x 轴和 y 轴移动的距离（单位像素）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">translate</span>(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p><strong>（4）transform()</strong></p>
<p><code>CanvasRenderingContext2D.transform()</code>方法接受一个变换矩阵的六个元素作为参数，完成缩放、旋转、移动和倾斜等变形。</p>
<p>它的使用格式如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ctx.<span class="title function_">transform</span>(a, b, c, d, e, f);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a:水平缩放(默认值1，单位倍数)</span></span><br><span class="line"><span class="comment">b:水平倾斜(默认值0，单位弧度)</span></span><br><span class="line"><span class="comment">c:垂直倾斜(默认值0，单位弧度)</span></span><br><span class="line"><span class="comment">d:垂直缩放(默认值1，单位倍数)</span></span><br><span class="line"><span class="comment">e:水平位移(默认值0，单位像素)</span></span><br><span class="line"><span class="comment">f:垂直位移(默认值0，单位像素)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">transform</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，原始图形是 100 x 100 的矩形，结果缩放成 200 x 100 的矩形，并且左上角从<code>(0, 0)</code>移动到<code>(50, 50)</code>。</p>
<p>注意，多个<code>transform()</code>方法具有叠加效果。</p>
<p><strong>（5）setTransform()</strong></p>
<p><code>CanvasRenderingContext2D.setTransform()</code>方法取消前面的图形变换，将画布恢复到该方法指定的状态。该方法的参数与<code>transform()</code>方法完全一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">translate</span>(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">ctx.<span class="title function_">setTransform</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个<code>fillRect()</code>方法绘制的矩形，左上角从<code>(0, 0)</code>平移到<code>(50, 50)</code>。<code>setTransform()</code>方法取消了这个变换（已绘制的图形不受影响），将画布恢复到默认状态（变换矩形<code>1, 0, 0, 1, 0, 0</code>），所以第二个矩形的左上角回到<code>(0, 0)</code>。</p>
<h3 id="元素的方法"><a href="#元素的方法" class="headerlink" title="&lt;canvas&gt; 元素的方法"></a><code>&lt;canvas&gt;</code> 元素的方法</h3><p>除了<code>CanvasRenderingContext2D</code>对象提供的方法，<code>&lt;canvas&gt;</code>元素本身也有自己的方法。</p>
<h4 id="HTMLCanvasElement-toDataURL"><a href="#HTMLCanvasElement-toDataURL" class="headerlink" title="HTMLCanvasElement.toDataURL()"></a>HTMLCanvasElement.toDataURL()</h4><p><code>&lt;canvas&gt;</code>元素的<code>toDataURL()</code>方法，可以将 Canvas 数据转为 Data URI 格式的图像。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">canvas.<span class="title function_">toDataURL</span>(type, quality)</span><br></pre></td></tr></table></figure>

<p><code>toDataURL()</code>方法接受两个参数。</p>
<ul>
<li>type：字符串，表示图像的格式。默认为<code>image/png</code>，另一个可用的值是<code>image/jpeg</code>，Chrome 浏览器还可以使用<code>image/webp</code>。</li>
<li>quality：浮点数，0到1之间，表示 JPEG 和 WebP 图像的质量系数，默认值为0.92。</li>
</ul>
<p>该方法的返回值是一个 Data URI 格式的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">convertCanvasToImage</span>(<span class="params">canvas</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> image = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line">  image.<span class="property">src</span> = canvas.<span class="title function_">toDataURL</span>(<span class="string">&#x27;image/png&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码将<code>&lt;canvas&gt;</code>元素，转化成PNG Data URI。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fullQuality = canvas.<span class="title function_">toDataURL</span>(<span class="string">&#x27;image/jpeg&#x27;</span>, <span class="number">0.9</span>);</span><br><span class="line"><span class="keyword">var</span> mediumQuality = canvas.<span class="title function_">toDataURL</span>(<span class="string">&#x27;image/jpeg&#x27;</span>, <span class="number">0.6</span>);</span><br><span class="line"><span class="keyword">var</span> lowQuality = canvas.<span class="title function_">toDataURL</span>(<span class="string">&#x27;image/jpeg&#x27;</span>, <span class="number">0.3</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码将<code>&lt;canvas&gt;</code>元素转成高画质、中画质、低画质三种 JPEG 图像。</p>
<h4 id="HTMLCanvasElement-toBlob"><a href="#HTMLCanvasElement-toBlob" class="headerlink" title="HTMLCanvasElement.toBlob()"></a>HTMLCanvasElement.toBlob()</h4><p><code>HTMLCanvasElement.toBlob()</code>方法用于将<code>&lt;canvas&gt;</code>图像转成一个 Blob 对象，默认类型是<code>image/png</code>。它的使用格式如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line">canvas.<span class="title function_">toBlob</span>(callback, mimeType, quality)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line">canvas.<span class="title function_">toBlob</span>(<span class="keyword">function</span> (<span class="params">blob</span>) &#123;...&#125;, <span class="string">&#x27;image/jpeg&#x27;</span>, <span class="number">0.95</span>)</span><br></pre></td></tr></table></figure>

<p><code>toBlob()</code>方法可以接受三个参数。</p>
<ul>
<li>callback：回调函数。它接受生成的 Blob 对象作为参数。</li>
<li>mimeType：字符串，图像的 MIMEType 类型，默认是<code>image/png</code>。</li>
<li>quality：浮点数，0到1之间，表示图像的质量，只对<code>image/jpeg</code>和<code>image/webp</code>类型的图像有效。</li>
</ul>
<p>注意，该方法没有返回值。</p>
<p>下面的例子将<code>&lt;canvas&gt;</code>图像复制成<code>&lt;img&gt;</code>图像。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">blobToImg</span>(<span class="params">blob</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> newImg = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> url = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob);</span><br><span class="line"></span><br><span class="line">  newImg.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 使用完毕，释放 URL 对象</span></span><br><span class="line">    <span class="variable constant_">URL</span>.<span class="title function_">revokeObjectURL</span>(url);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  newImg.<span class="property">src</span> = url;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(newImg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">canvas.<span class="title function_">toBlob</span>(blobToImg);</span><br></pre></td></tr></table></figure>

<h3 id="Canvas-使用实例"><a href="#Canvas-使用实例" class="headerlink" title="Canvas 使用实例"></a>Canvas 使用实例</h3><h4 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h4><p>通过改变坐标，很容易在画布 Canvas 元素上产生动画效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myCanvas&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> posX = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> posY = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;black&#x27;</span>;</span><br><span class="line">  ctx.<span class="title function_">fillRect</span>(<span class="number">0</span>, <span class="number">0</span>, canvas.<span class="property">width</span>, canvas.<span class="property">height</span>);</span><br><span class="line"></span><br><span class="line">  posX += <span class="number">1</span>;</span><br><span class="line">  posY += <span class="number">0.25</span>;</span><br><span class="line"></span><br><span class="line">  ctx.<span class="title function_">beginPath</span>();</span><br><span class="line">  ctx.<span class="property">fillStyle</span> = <span class="string">&#x27;white&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  ctx.<span class="title function_">arc</span>(posX, posY, <span class="number">10</span>, <span class="number">0</span>, <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">  ctx.<span class="title function_">closePath</span>();</span><br><span class="line">  ctx.<span class="title function_">fill</span>();</span><br><span class="line">&#125;, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码会产生一个小圆点，每隔30毫秒就向右下方移动的效果。<code>setInterval()</code>函数的一开始，之所以要将画布重新渲染黑色底色，是为了抹去上一步的小圆点。</p>
<p>在这个例子的基础上，通过设置圆心坐标，可以产生各种运动轨迹。下面是先上升后下降的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vx = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> vy = -<span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> gravity = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  posX += vx;</span><br><span class="line">  posY += vy;</span><br><span class="line">  vy += gravity;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>x</code>坐标始终增大，表示持续向右运动。<code>y</code>坐标先变小，然后在重力作用下，不断增大，表示先上升后下降。</p>
<h4 id="像素处理"><a href="#像素处理" class="headerlink" title="像素处理"></a>像素处理</h4><p>通过<code>getImageData()</code>方法和<code>putImageData()</code>方法，可以处理每个像素，进而操作图像内容，因此可以改写图像。</p>
<p>下面是图像处理的通用写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (canvas.<span class="property">width</span> &gt; <span class="number">0</span> &amp;&amp; canvas.<span class="property">height</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> imageData = context.<span class="title function_">getImageData</span>(<span class="number">0</span>, <span class="number">0</span>, canvas.<span class="property">width</span>, canvas.<span class="property">height</span>);</span><br><span class="line">  <span class="title function_">filter</span>(imageData);</span><br><span class="line">  context.<span class="title function_">putImageData</span>(imageData, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>filter</code>是一个处理像素的函数。以下是几种常见的<code>filter</code>。</p>
<p><strong>（1）灰度效果</strong></p>
<p>灰度图（grayscale）就是取红、绿、蓝三个像素值的算术平均值，这实际上将图像转成了黑白形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">grayscale = <span class="keyword">function</span> (<span class="params">pixels</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> d = pixels.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; d.<span class="property">length</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> r = d[i];</span><br><span class="line">    <span class="keyword">var</span> g = d[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> b = d[i + <span class="number">2</span>];</span><br><span class="line">    d[i] = d[i + <span class="number">1</span>] = d[i + <span class="number">2</span>] = (r + g + b) / <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pixels;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>d[i]</code>是红色值，<code>d[i+1]</code>是绿色值，<code>d[i+2]</code>是蓝色值，<code>d[i+3]</code>是 alpha 通道值。转成灰度的算法，就是将红、绿、蓝三个值相加后除以3，再将结果写回数组。</p>
<p><strong>（2）复古效果</strong></p>
<p>复古效果（sepia）是将红、绿、蓝三种值，分别取这三个值的某种加权平均值，使得图像有一种古旧的效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sepia = <span class="keyword">function</span> (<span class="params">pixels</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> d = pixels.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; d.<span class="property">length</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> r = d[i];</span><br><span class="line">      <span class="keyword">var</span> g = d[i + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">var</span> b = d[i + <span class="number">2</span>];</span><br><span class="line">      d[i]     = (r * <span class="number">0.393</span>) + (g * <span class="number">0.769</span>) + (b * <span class="number">0.189</span>); <span class="comment">// red</span></span><br><span class="line">      d[i + <span class="number">1</span>] = (r * <span class="number">0.349</span>) + (g * <span class="number">0.686</span>) + (b * <span class="number">0.168</span>); <span class="comment">// green</span></span><br><span class="line">      d[i + <span class="number">2</span>] = (r * <span class="number">0.272</span>) + (g * <span class="number">0.534</span>) + (b * <span class="number">0.131</span>); <span class="comment">// blue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pixels;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（3）红色蒙版效果</strong></p>
<p>红色蒙版指的是，让图像呈现一种偏红的效果。算法是将红色通道设为红、绿、蓝三个值的平均值，而将绿色通道和蓝色通道都设为0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> red = <span class="keyword">function</span> (<span class="params">pixels</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> d = pixels.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; d.<span class="property">length</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> r = d[i];</span><br><span class="line">    <span class="keyword">var</span> g = d[i + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">var</span> b = d[i + <span class="number">2</span>];</span><br><span class="line">    d[i] = (r + g + b)/<span class="number">3</span>;        <span class="comment">// 红色通道取平均值</span></span><br><span class="line">    d[i + <span class="number">1</span>] = d[i + <span class="number">2</span>] = <span class="number">0</span>; <span class="comment">// 绿色通道和蓝色通道都设为0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pixels;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（4）亮度效果</strong></p>
<p>亮度效果（brightness）是指让图像变得更亮或更暗。算法将红色通道、绿色通道、蓝色通道，同时加上一个正值或负值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> brightness = <span class="keyword">function</span> (<span class="params">pixels, delta</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> d = pixels.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; d.<span class="property">length</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    d[i] += delta;     <span class="comment">// red</span></span><br><span class="line">    d[i + <span class="number">1</span>] += delta; <span class="comment">// green</span></span><br><span class="line">    d[i + <span class="number">2</span>] += delta; <span class="comment">// blue</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pixels;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（5）反转效果</strong></p>
<p>反转效果（invert）是指图片呈现一种色彩颠倒的效果。算法为红、绿、蓝通道都取各自的相反值（<code>255 - 原值</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">invert = <span class="keyword">function</span> (<span class="params">pixels</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> d = pixels.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; d.<span class="property">length</span>; i += <span class="number">4</span>) &#123;</span><br><span class="line">    d[i] = <span class="number">255</span> - d[i];</span><br><span class="line">    d[i + <span class="number">1</span>] = <span class="number">255</span> - d[i + <span class="number">1</span>];</span><br><span class="line">    d[i + <span class="number">2</span>] = <span class="number">255</span> - d[i + <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pixels;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li>David Walsh, <a target="_blank" rel="noopener" href="http://davidwalsh.name/convert-canvas-image">JavaScript Canvas Image Conversion</a></li>
<li>Matt West, <a target="_blank" rel="noopener" href="http://blog.teamtreehouse.com/getting-started-with-the-canvas-api">Getting Started With The Canvas API</a></li>
<li>John Robinson, <a target="_blank" rel="noopener" href="http://www.storminthecastle.com/2013/04/06/how-you-can-do-cool-image-effects-using-html5-canvas/">How You Can Do Cool Image Effects Using HTML5 Canvas</a></li>
<li>Ivaylo Gerchev, <a target="_blank" rel="noopener" href="http://www.sitepoint.com/html5-canvas-tutorial-introduction/">HTML5 Canvas Tutorial: An Introduction</a></li>
<li>Donovan Hutchinson, <a target="_blank" rel="noopener" href="http://hop.ie/blog/particles/">Particles in canvas</a></li>
</ul>
<h2 id="剪贴板操作-Clipboard-API-教程"><a href="#剪贴板操作-Clipboard-API-教程" class="headerlink" title="剪贴板操作 Clipboard API 教程"></a>剪贴板操作 Clipboard API 教程</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>浏览器允许 JavaScript 脚本读写剪贴板，自动复制或粘贴内容。</p>
<p>一般来说，脚本不应该改动用户的剪贴板，以免不符合用户的预期。但是，有些时候这样做确实能够带来方便，比如“一键复制”功能，用户点击一下按钮，指定的内容就自动进入剪贴板。</p>
<p>目前，一共有三种方法可以实现剪贴板操作。</p>
<ul>
<li><code>Document.execCommand()</code>方法</li>
<li>异步的 Clipboard API</li>
<li><code>copy</code>事件和<code>paste</code>事件</li>
</ul>
<p>本文逐一介绍这三种方法。</p>
<h3 id="Document-execCommand-方法"><a href="#Document-execCommand-方法" class="headerlink" title="Document.execCommand() 方法"></a>Document.execCommand() 方法</h3><p><code>Document.execCommand()</code>是操作剪贴板的传统方法，各种浏览器都支持。</p>
<p>它支持复制、剪切和粘贴这三个操作。</p>
<ul>
<li><code>document.execCommand(&#39;copy&#39;)</code>（复制）</li>
<li><code>document.execCommand(&#39;cut&#39;)</code>（剪切）</li>
<li><code>document.execCommand(&#39;paste&#39;)</code>（粘贴）</li>
</ul>
<p>（1）复制操作</p>
<p>复制时，先选中文本，然后调用<code>document.execCommand(&#39;copy&#39;)</code>，选中的文本就会进入剪贴板。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inputElement = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;##input&#x27;</span>);</span><br><span class="line">inputElement.<span class="title function_">select</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">execCommand</span>(<span class="string">&#x27;copy&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面示例中，脚本先选中输入框<code>inputElement</code>里面的文字（<code>inputElement.select()</code>），然后<code>document.execCommand(&#39;copy&#39;)</code>将其复制到剪贴板。</p>
<p>注意，复制操作最好放在事件监听函数里面，由用户触发（比如用户点击按钮）。如果脚本自主执行，某些浏览器可能会报错。</p>
<p>（2）粘贴操作</p>
<p>粘贴时，调用<code>document.execCommand(&#39;paste&#39;)</code>，就会将剪贴板里面的内容，输出到当前的焦点元素中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pasteText = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;##output&#x27;</span>);</span><br><span class="line">pasteText.<span class="title function_">focus</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">execCommand</span>(<span class="string">&#x27;paste&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>（3）缺点</p>
<p><code>Document.execCommand()</code>方法虽然方便，但是有一些缺点。</p>
<p>首先，它只能将选中的内容复制到剪贴板，无法向剪贴板任意写入内容。</p>
<p>其次，它是同步操作，如果复制&#x2F;粘贴大量数据，页面会出现卡顿。有些浏览器还会跳出提示框，要求用户许可，这时在用户做出选择前，页面会失去响应。</p>
<p>为了解决这些问题，浏览器厂商提出了异步的 Clipboard API。</p>
<h3 id="异步-Clipboard-API"><a href="#异步-Clipboard-API" class="headerlink" title="异步 Clipboard API"></a>异步 Clipboard API</h3><p>Clipboard API 是下一代的剪贴板操作方法，比传统的<code>document.execCommand()</code>方法更强大、更合理。</p>
<p>它的所有操作都是异步的，返回 Promise 对象，不会造成页面卡顿。而且，它可以将任意内容（比如图片）放入剪贴板。</p>
<p><code>navigator.clipboard</code>属性返回 Clipboard 对象，所有操作都通过这个对象进行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clipboardObj = navigator.<span class="property">clipboard</span>;</span><br></pre></td></tr></table></figure>

<p>如果<code>navigator.clipboard</code>属性返回<code>undefined</code>，就说明当前浏览器不支持这个 API。</p>
<p>由于用户可能把敏感数据（比如密码）放在剪贴板，允许脚本任意读取会产生安全风险，所以这个 API 的安全限制比较多。</p>
<p>首先，Chrome 浏览器规定，只有 HTTPS 协议的页面才能使用这个 API。不过，开发环境（<code>localhost</code>）允许使用非加密协议。</p>
<p>其次，调用时需要明确获得用户的许可。权限的具体实现使用了 Permissions API，跟剪贴板相关的有两个权限：<code>clipboard-write</code>（写权限）和<code>clipboard-read</code>（读权限）。“写权限”自动授予脚本，而“读权限”必须用户明确同意给予。也就是说，写入剪贴板，脚本可以自动完成，但是读取剪贴板时，浏览器会弹出一个对话框，询问用户是否同意读取。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071415498.jpg"></p>
<p>另外，需要注意的是，脚本读取的总是当前页面的剪贴板。这带来的一个问题是，如果把相关的代码粘贴到开发者工具中直接运行，可能会报错，因为这时的当前页面是开发者工具的窗口，而不是网页页面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> text = <span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">readText</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>如果你把上面的代码，粘贴到开发者工具里面运行，就会报错。因为代码运行的时候，开发者工具窗口是当前页，这个页面不存在 Clipboard API 依赖的 DOM 接口。一个解决方法就是，相关代码放到<code>setTimeout()</code>里面延迟运行，在调用函数之前快速点击浏览器的页面窗口，将其变成当前页。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> text = <span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">readText</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码粘贴到开发者工具运行后，快速点击一下网页的页面窗口，使其变为当前页，这样就不会报错了。</p>
<h3 id="Clipboard-对象"><a href="#Clipboard-对象" class="headerlink" title="Clipboard 对象"></a>Clipboard 对象</h3><p>Clipboard 对象提供了四个方法，用来读写剪贴板。它们都是异步方法，返回 Promise 对象。</p>
<h4 id="Clipboard-readText"><a href="#Clipboard-readText" class="headerlink" title="Clipboard.readText()"></a>Clipboard.readText()</h4><p><code>Clipboard.readText()</code>方法用于复制剪贴板里面的文本数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="keyword">async</span> (e) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> text = <span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">readText</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面示例中，用户点击页面后，就会输出剪贴板里面的文本。注意，浏览器这时会跳出一个对话框，询问用户是否同意脚本读取剪贴板。</p>
<p>如果用户不同意，脚本就会报错。这时，可以使用<code>try...catch</code>结构，处理报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getClipboardContents</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> text = <span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">readText</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Pasted content: &#x27;</span>, text);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Failed to read clipboard contents: &#x27;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Clipboard-read"><a href="#Clipboard-read" class="headerlink" title="Clipboard.read()"></a>Clipboard.read()</h4><p><code>Clipboard.read()</code>方法用于复制剪贴板里面的数据，可以是文本数据，也可以是二进制数据（比如图片）。该方法需要用户明确给予许可。</p>
<p>该方法返回一个 Promise 对象。一旦该对象的状态变为 resolved，就可以获得一个数组，每个数组成员都是 ClipboardItem 对象的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getClipboardContents</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> clipboardItems = <span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> clipboardItem <span class="keyword">of</span> clipboardItems) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> type <span class="keyword">of</span> clipboardItem.<span class="property">types</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> blob = <span class="keyword">await</span> clipboardItem.<span class="title function_">getType</span>(type);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(blob));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err.<span class="property">name</span>, err.<span class="property">message</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ClipboardItem 对象表示一个单独的剪贴项，每个剪贴项都拥有<code>ClipboardItem.types</code>属性和<code>ClipboardItem.getType()</code>方法。</p>
<p><code>ClipboardItem.types</code>属性返回一个数组，里面的成员是该剪贴项可用的 MIME 类型，比如某个剪贴项可以用 HTML 格式粘贴，也可以用纯文本格式粘贴，那么它就有两个 MIME 类型（<code>text/html</code>和<code>text/plain</code>）。</p>
<p><code>ClipboardItem.getType(type)</code>方法用于读取剪贴项的数据，返回一个 Promise 对象。该方法接受剪贴项的 MIME 类型作为参数，返回该类型的数据，该参数是必需的，否则会报错。</p>
<h4 id="Clipboard-writeText"><a href="#Clipboard-writeText" class="headerlink" title="Clipboard.writeText()"></a>Clipboard.writeText()</h4><p><code>Clipboard.writeText()</code>方法用于将文本内容写入剪贴板。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="keyword">async</span> (e) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">writeText</span>(<span class="string">&#x27;Yo&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面示例是用户在网页点击后，脚本向剪贴板写入文本数据。</p>
<p>该方法不需要用户许可，但是最好也放在<code>try...catch</code>里面防止报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">copyPageUrl</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">writeText</span>(location.<span class="property">href</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Page URL copied to clipboard&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Failed to copy: &#x27;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Clipboard-write"><a href="#Clipboard-write" class="headerlink" title="Clipboard.write()"></a>Clipboard.write()</h4><p><code>Clipboard.write()</code>方法用于将任意数据写入剪贴板，可以是文本数据，也可以是二进制数据。</p>
<p>该方法接受一个 ClipboardItem 实例作为参数，表示写入剪贴板的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> imgURL = <span class="string">&#x27;https://dummyimage.com/300.png&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetch</span>(imgURL);</span><br><span class="line">  <span class="keyword">const</span> blob = <span class="keyword">await</span> data.<span class="title function_">blob</span>();</span><br><span class="line">  <span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">write</span>([</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ClipboardItem</span>(&#123;</span><br><span class="line">      [blob.<span class="property">type</span>]: blob</span><br><span class="line">    &#125;)</span><br><span class="line">  ]);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Image copied.&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(err.<span class="property">name</span>, err.<span class="property">message</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，脚本向剪贴板写入了一张图片。注意，Chrome 浏览器目前只支持写入 PNG 格式的图片。</p>
<p><code>ClipboardItem()</code>是浏览器原生提供的构造函数，用来生成<code>ClipboardItem</code>实例，它接受一个对象作为参数，该对象的键名是数据的 MIME 类型，键值就是数据本身。</p>
<p>下面的例子是将同一个剪贴项的多种格式的值，写入剪贴板，一种是文本数据，另一种是二进制数据，供不同的场合粘贴使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">copy</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> image = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;kitten.png&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> text = <span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="string">&#x27;Cute sleeping kitten&#x27;</span>], &#123;<span class="attr">type</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;);</span><br><span class="line">  <span class="keyword">const</span> item = <span class="keyword">new</span> <span class="title class_">ClipboardItem</span>(&#123;</span><br><span class="line">    <span class="string">&#x27;text/plain&#x27;</span>: text,</span><br><span class="line">    <span class="string">&#x27;image/png&#x27;</span>: image</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">write</span>([item]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="copy-事件，cut-事件"><a href="#copy-事件，cut-事件" class="headerlink" title="copy 事件，cut 事件"></a>copy 事件，cut 事件</h3><p>用户向剪贴板放入数据时，将触发<code>copy</code>事件。</p>
<p>下面的示例是将用户放入剪贴板的文本，转为大写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.source&#x27;</span>);</span><br><span class="line"></span><br><span class="line">source.<span class="title function_">addEventListener</span>(<span class="string">&#x27;copy&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> selection = <span class="variable language_">document</span>.<span class="title function_">getSelection</span>();</span><br><span class="line">  event.<span class="property">clipboardData</span>.<span class="title function_">setData</span>(<span class="string">&#x27;text/plain&#x27;</span>, selection.<span class="title function_">toString</span>().<span class="title function_">toUpperCase</span>());</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面示例中，事件对象的<code>clipboardData</code>属性包含了剪贴板数据。它是一个对象，有以下属性和方法。</p>
<ul>
<li><code>Event.clipboardData.setData(type, data)</code>：修改剪贴板数据，需要指定数据类型。</li>
<li><code>Event.clipboardData.getData(type)</code>：获取剪贴板数据，需要指定数据类型。</li>
<li><code>Event.clipboardData.clearData([type])</code>：清除剪贴板数据，可以指定数据类型。如果不指定类型，将清除所有类型的数据。</li>
<li><code>Event.clipboardData.items</code>：一个类似数组的对象，包含了所有剪贴项，不过通常只有一个剪贴项。</li>
</ul>
<p>下面的示例是拦截用户的复制操作，将指定内容放入剪贴板。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clipboardItems = [];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;copy&#x27;</span>, <span class="keyword">async</span> (e) =&gt; &#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> clipboardItems = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> e.<span class="property">clipboardData</span>.<span class="property">items</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!item.<span class="property">type</span>.<span class="title function_">startsWith</span>(<span class="string">&#x27;image/&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      clipboardItems.<span class="title function_">push</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClipboardItem</span>(&#123;</span><br><span class="line">          [item.<span class="property">type</span>]: item,</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">write</span>(clipboardItems);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Image copied.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err.<span class="property">name</span>, err.<span class="property">message</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面示例中，先使用<code>e.preventDefault()</code>取消了剪贴板的默认操作，然后由脚本接管复制操作。</p>
<p><code>cut</code>事件则是在用户进行剪切操作时触发，它的处理跟<code>copy</code>事件完全一样，也是从<code>Event.clipboardData</code>属性拿到剪切的数据。</p>
<h3 id="paste-事件"><a href="#paste-事件" class="headerlink" title="paste 事件"></a>paste 事件</h3><p>用户使用剪贴板数据，进行粘贴操作时，会触发<code>paste</code>事件。</p>
<p>下面的示例是拦截粘贴操作，由脚本将剪贴板里面的数据取出来。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;paste&#x27;</span>, <span class="keyword">async</span> (e) =&gt; &#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="keyword">const</span> text = <span class="keyword">await</span> navigator.<span class="property">clipboard</span>.<span class="title function_">readText</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Pasted text: &#x27;</span>, text);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="参考链接-1"><a href="#参考链接-1" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://web.dev/async-clipboard/">Unblocking clipboard access</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Interact_with_the_clipboard">Interact with the clipboard</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.tomayac.com/2020/03/20/multi-mime-type-copying-with-the-async-clipboard-api/">Multi-MIME Type Copying with the Async Clipboard API</a></li>
</ul>
<h2 id="Fetch-API-教程"><a href="#Fetch-API-教程" class="headerlink" title="Fetch API 教程"></a>Fetch API 教程</h2><p><code>fetch()</code>是 XMLHttpRequest 的升级版，用于在 JavaScript 脚本里面发出 HTTP 请求。</p>
<p>浏览器原生提供这个对象。本章详细介绍它的用法。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>fetch()</code>的功能与 XMLHttpRequest 基本相同，但有三个主要的差异。</p>
<p>（1）<code>fetch()</code>使用 Promise，不使用回调函数，因此大大简化了写法，写起来更简洁。</p>
<p>（2）<code>fetch()</code>采用模块化设计，API 分散在多个对象上（Response 对象、Request 对象、Headers 对象），更合理一些；相比之下，XMLHttpRequest 的 API 设计并不是很好，输入、输出、状态都在同一个接口管理，容易写出非常混乱的代码。</p>
<p>（3）<code>fetch()</code>通过数据流（Stream 对象）处理数据，可以分块读取，有利于提高网站性能表现，减少内存占用，对于请求大文件或者网速慢的场景相当有用。XMLHTTPRequest 对象不支持数据流，所有的数据必须放在缓存里，不支持分块读取，必须等待全部拿到后，再一次性吐出来。</p>
<p>在用法上，<code>fetch()</code>接受一个 URL 字符串作为参数，默认向该网址发出 GET 请求，返回一个 Promise 对象。它的基本用法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url)</span><br><span class="line">  .<span class="title function_">then</span>(...)</span><br><span class="line">  .<span class="title function_">catch</span>(...)</span><br></pre></td></tr></table></figure>

<p>下面是一个例子，从服务器获取 JSON 数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://api.github.com/users/ruanyf&#x27;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">json</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(json))</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request Failed&#x27;</span>, err)); </span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>fetch()</code>接收到的<code>response</code>是一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Streams_API">Stream 对象</a>，<code>response.json()</code>是一个异步操作，取出所有内容，并将其转为 JSON 对象。</p>
<p>Promise 可以使用 await 语法改写，使得语义更清晰。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">&#x27;https://api.github.com/users/ruanyf&#x27;</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Request Failed&#x27;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>await</code>语句必须放在<code>try...catch</code>里面，这样才能捕捉异步操作中可能发生的错误。</p>
<p>后文都采用<code>await</code>的写法，不使用<code>.then()</code>的写法。</p>
<h3 id="Response-对象：处理-HTTP-回应"><a href="#Response-对象：处理-HTTP-回应" class="headerlink" title="Response 对象：处理 HTTP 回应"></a>Response 对象：处理 HTTP 回应</h3><h4 id="Response-对象的同步属性"><a href="#Response-对象的同步属性" class="headerlink" title="Response 对象的同步属性"></a>Response 对象的同步属性</h4><p><code>fetch()</code>请求成功以后，得到的是一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Response">Response 对象</a>。它对应服务器的 HTTP 回应。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br></pre></td></tr></table></figure>

<p>前面说过，Response 包含的数据通过 Stream 接口异步读取，但是它还包含一些同步属性，对应 HTTP 回应的标头信息（Headers），可以立即读取。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchText</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/readme.txt&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">status</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(response.<span class="property">statusText</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>response.status</code>和<code>response.statusText</code>就是 Response 的同步属性，可以立即读取。</p>
<p>标头信息属性有下面这些。</p>
<p><strong>Response.ok</strong></p>
<p><code>Response.ok</code>属性返回一个布尔值，表示请求是否成功，<code>true</code>对应 HTTP 请求的状态码 200 到 299，<code>false</code>对应其他的状态码。</p>
<p><strong>Response.status</strong></p>
<p><code>Response.status</code>属性返回一个数字，表示 HTTP 回应的状态码（例如200，表示成功请求）。</p>
<p><strong>Response.statusText</strong></p>
<p><code>Response.statusText</code>属性返回一个字符串，表示 HTTP 回应的状态信息（例如请求成功以后，服务器返回“OK”）。</p>
<p><strong>Response.url</strong></p>
<p><code>Response.url</code>属性返回请求的 URL。如果 URL 存在跳转，该属性返回的是最终 URL。</p>
<p><strong>Response.type</strong></p>
<p><code>Response.type</code>属性返回请求的类型。可能的值如下：</p>
<ul>
<li><code>basic</code>：普通请求，即同源请求。</li>
<li><code>cors</code>：跨源请求。</li>
<li><code>error</code>：网络错误，主要用于 Service Worker。</li>
<li><code>opaque</code>：如果<code>fetch()</code>请求的<code>type</code>属性设为<code>no-cors</code>，就会返回这个值，详见请求部分。表示发出的是简单的跨源请求，类似<code>&lt;form&gt;</code>表单的那种跨源请求。</li>
<li><code>opaqueredirect</code>：如果<code>fetch()</code>请求的<code>redirect</code>属性设为<code>manual</code>，就会返回这个值，详见请求部分。</li>
</ul>
<p><strong>Response.redirected</strong></p>
<p><code>Response.redirected</code>属性返回一个布尔值，表示请求是否发生过跳转。</p>
<h4 id="判断请求是否成功"><a href="#判断请求是否成功" class="headerlink" title="判断请求是否成功"></a>判断请求是否成功</h4><p><code>fetch()</code>发出请求以后，有一个很重要的注意点：只有网络错误，或者无法连接时，<code>fetch()</code>才会报错，其他情况都不会报错，而是认为请求成功。</p>
<p>这就是说，即使服务器返回的状态码是 4xx 或 5xx，<code>fetch()</code>也不会报错（即 Promise 不会变为 <code>rejected</code>状态）。</p>
<p>只有通过<code>Response.status</code>属性，得到 HTTP 回应的真实状态码，才能判断请求是否成功。请看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchText</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/readme.txt&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (response.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; response.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> response.<span class="title function_">text</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(response.<span class="property">statusText</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>response.status</code>属性只有等于 2xx （200~299），才能认定请求成功。这里不用考虑网址跳转（状态码为 3xx），因为<code>fetch()</code>会将跳转的状态码自动转为 200。</p>
<p>另一种方法是判断<code>response.ok</code>是否为<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (response.<span class="property">ok</span>) &#123;</span><br><span class="line">  <span class="comment">// 请求成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 请求失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Response-headers-属性"><a href="#Response-headers-属性" class="headerlink" title="Response.headers 属性"></a>Response.headers 属性</h4><p>Response 对象还有一个<code>Response.headers</code>属性，指向一个 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Headers">Headers 对象</a>，对应 HTTP 回应的所有标头。</p>
<p>Headers 对象可以使用<code>for...of</code>循环进行遍历。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> response.<span class="property">headers</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> : <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> response.<span class="property">headers</span>.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> : <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Headers 对象提供了以下方法，用来操作标头。</p>
<blockquote>
<ul>
<li><code>Headers.get()</code>：根据指定的键名，返回键值。</li>
<li><code>Headers.has()</code>： 返回一个布尔值，表示是否包含某个标头。</li>
<li><code>Headers.set()</code>：将指定的键名设置为新的键值，如果该键名不存在则会添加。</li>
<li><code>Headers.append()</code>：添加标头。</li>
<li><code>Headers.delete()</code>：删除标头。</li>
<li><code>Headers.keys()</code>：返回一个遍历器，可以依次遍历所有键名。</li>
<li><code>Headers.values()</code>：返回一个遍历器，可以依次遍历所有键值。</li>
<li><code>Headers.entries()</code>：返回一个遍历器，可以依次遍历所有键值对（<code>[key, value]</code>）。</li>
<li><code>Headers.forEach()</code>：依次遍历标头，每个标头都会执行一次参数函数。</li>
</ul>
</blockquote>
<p>上面的有些方法可以修改标头，那是因为继承自 Headers 接口。对于 HTTP 回应来说，修改标头意义不大，况且很多标头是只读的，浏览器不允许修改。</p>
<p>这些方法中，最常用的是<code>response.headers.get()</code>，用于读取某个标头的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> response =  <span class="keyword">await</span>  <span class="title function_">fetch</span>(url);</span><br><span class="line">response.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&#x27;Content-Type&#x27;</span>)</span><br><span class="line"><span class="comment">// application/json; charset=utf-8</span></span><br></pre></td></tr></table></figure>

<p><code>Headers.keys()</code>和<code>Headers.values()</code>方法用来分别遍历标头的键名和键值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键名</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> myHeaders.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 键值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> myHeaders.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Headers.forEach()</code>方法也可以遍历所有的键值和键名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">response.<span class="property">headers</span>.<span class="title function_">forEach</span>(</span><br><span class="line">  <span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(key, <span class="string">&#x27;:&#x27;</span>, value)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="读取内容的方法"><a href="#读取内容的方法" class="headerlink" title="读取内容的方法"></a>读取内容的方法</h4><p><code>Response</code>对象根据服务器返回的不同类型的数据，提供了不同的读取方法。</p>
<blockquote>
<ul>
<li><code>response.text()</code>：得到文本字符串。</li>
<li><code>response.json()</code>：得到 JSON 对象。</li>
<li><code>response.blob()</code>：得到二进制 Blob 对象。</li>
<li><code>response.formData()</code>：得到 FormData 表单对象。</li>
<li><code>response.arrayBuffer()</code>：得到二进制 ArrayBuffer 对象。</li>
</ul>
</blockquote>
<p>上面5个读取方法都是异步的，返回的都是 Promise 对象。必须等到异步操作结束，才能得到服务器返回的完整数据。</p>
<p><strong>response.text()</strong></p>
<p><code>response.text()</code>可以用于获取文本数据，比如 HTML 文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/users.html&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> body = <span class="keyword">await</span> response.<span class="title function_">text</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = body</span><br></pre></td></tr></table></figure>

<p><strong>response.json()</strong></p>
<p><code>response.json()</code>主要用于获取服务器返回的 JSON 数据，前面已经举过例子了。</p>
<p><strong>response.formData()</strong></p>
<p><code>response.formData()</code>主要用在 Service Worker 里面，拦截用户提交的表单，修改某些数据以后，再提交给服务器。</p>
<p><strong>response.blob()</strong></p>
<p><code>response.blob()</code>用于获取二进制文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;flower.jpg&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> myBlob = <span class="keyword">await</span> response.<span class="title function_">blob</span>();</span><br><span class="line"><span class="keyword">const</span> objectURL = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(myBlob);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myImage = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">myImage.<span class="property">src</span> = objectURL;</span><br></pre></td></tr></table></figure>

<p>上面示例读取图片文件<code>flower.jpg</code>，显示在网页上。</p>
<p><strong>response.arrayBuffer()</strong></p>
<p><code>response.arrayBuffer()</code>主要用于获取流媒体文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> audioCtx = <span class="keyword">new</span> <span class="variable language_">window</span>.<span class="title class_">AudioContext</span>();</span><br><span class="line"><span class="keyword">const</span> source = audioCtx.<span class="title function_">createBufferSource</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;song.ogg&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> buffer = <span class="keyword">await</span> response.<span class="title function_">arrayBuffer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decodeData = <span class="keyword">await</span> audioCtx.<span class="title function_">decodeAudioData</span>(buffer);</span><br><span class="line">source.<span class="property">buffer</span> = buffer;</span><br><span class="line">source.<span class="title function_">connect</span>(audioCtx.<span class="property">destination</span>);</span><br><span class="line">source.<span class="property">loop</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>上面示例是<code>response.arrayBuffer()</code>获取音频文件<code>song.ogg</code>，然后在线播放的例子。</p>
<h4 id="Response-clone"><a href="#Response-clone" class="headerlink" title="Response.clone()"></a>Response.clone()</h4><p>Stream 对象只能读取一次，读取完就没了。这意味着，前一节的五个读取方法，只能使用一个，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text =  <span class="keyword">await</span> response.<span class="title function_">text</span>();</span><br><span class="line"><span class="keyword">let</span> json =  <span class="keyword">await</span> response.<span class="title function_">json</span>();  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面示例先使用了<code>response.text()</code>，就把 Stream 读完了。后面再调用<code>response.json()</code>，就没有内容可读了，所以报错。</p>
<p>Response 对象提供<code>Response.clone()</code>方法，创建<code>Response</code>对象的副本，实现多次读取。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response1 = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;flowers.jpg&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> response2 = response1.<span class="title function_">clone</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myBlob1 = <span class="keyword">await</span> response1.<span class="title function_">blob</span>();</span><br><span class="line"><span class="keyword">const</span> myBlob2 = <span class="keyword">await</span> response2.<span class="title function_">blob</span>();</span><br><span class="line"></span><br><span class="line">image1.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(myBlob1);</span><br><span class="line">image2.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(myBlob2);</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>response.clone()</code>复制了一份 Response 对象，然后将同一张图片读取了两次。</p>
<p>Response 对象还有一个<code>Response.redirect()</code>方法，用于将 Response 结果重定向到指定的 URL。该方法一般只用在 Service Worker 里面，这里就不介绍了。</p>
<h4 id="Response-body-属性"><a href="#Response-body-属性" class="headerlink" title="Response.body 属性"></a>Response.body 属性</h4><p><code>Response.body</code>属性是 Response 对象暴露出的底层接口，返回一个 ReadableStream 对象，供用户操作。</p>
<p>它可以用来分块读取内容，应用之一就是显示下载的进度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;flower.jpg&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> reader = response.<span class="property">body</span>.<span class="title function_">getReader</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;done, value&#125; = <span class="keyword">await</span> reader.<span class="title function_">read</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (done) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Received <span class="subst">$&#123;value.length&#125;</span> bytes`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，<code>response.body.getReader()</code>方法返回一个遍历器。这个遍历器的<code>read()</code>方法每次返回一个对象，表示本次读取的内容块。</p>
<p>这个对象的<code>done</code>属性是一个布尔值，用来判断有没有读完；<code>value</code>属性是一个 arrayBuffer 数组，表示内容块的内容，而<code>value.length</code>属性是当前块的大小。</p>
<h3 id="fetch-的第二个参数：定制-HTTP-请求"><a href="#fetch-的第二个参数：定制-HTTP-请求" class="headerlink" title="fetch()的第二个参数：定制 HTTP 请求"></a><code>fetch()</code>的第二个参数：定制 HTTP 请求</h3><p><code>fetch()</code>的第一个参数是 URL，还可以接受第二个参数，作为配置对象，定制发出的 HTTP 请求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(url, optionObj)</span><br></pre></td></tr></table></figure>

<p>上面命令的<code>optionObj</code>就是第二个参数。</p>
<p>HTTP 请求的方法、标头、数据体都在这个对象里面设置。下面是一些示例。</p>
<p><strong>（1）POST 请求</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-type&quot;</span>: <span class="string">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="string">&#x27;foo=bar&amp;lorem=ipsum&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> json = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br></pre></td></tr></table></figure>

<p>上面示例中，配置对象用到了三个属性。</p>
<blockquote>
<ul>
<li><code>method</code>：HTTP 请求的方法，<code>POST</code>、<code>DELETE</code>、<code>PUT</code>都在这个属性设置。</li>
<li><code>headers</code>：一个对象，用来定制 HTTP 请求的标头。</li>
<li><code>body</code>：POST 请求的数据体。</li>
</ul>
</blockquote>
<p>注意，有些标头不能通过<code>headers</code>属性设置，比如<code>Content-Length</code>、<code>Cookie</code>、<code>Host</code>等等。它们是由浏览器自动生成，无法修改。</p>
<p><strong>（2）提交 JSON 数据</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user =  &#123; <span class="attr">name</span>:  <span class="string">&#x27;John&#x27;</span>, <span class="attr">surname</span>:  <span class="string">&#x27;Smith&#x27;</span>  &#125;;</span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/article/fetch/post/user&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">   <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(user) </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面示例中，标头<code>Content-Type</code>要设成<code>&#39;application/json;charset=utf-8&#39;</code>。因为默认发送的是纯文本，<code>Content-Type</code>的默认值是<code>&#39;text/plain;charset=UTF-8&#39;</code>。</p>
<p><strong>（3）提交表单</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> form = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;form&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/users&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: <span class="keyword">new</span> <span class="title class_">FormData</span>(form)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>（4）文件上传</strong></p>
<p>如果表单里面有文件选择器，可以用前一个例子的写法，上传的文件包含在整个表单里面，一起提交。</p>
<p>另一种方法是用脚本添加文件，构造出一个表单，进行上传，请看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[type=&quot;file&quot;]&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = <span class="keyword">new</span> <span class="title class_">FormData</span>();</span><br><span class="line">data.<span class="title function_">append</span>(<span class="string">&#x27;file&#x27;</span>, input.<span class="property">files</span>[<span class="number">0</span>]);</span><br><span class="line">data.<span class="title function_">append</span>(<span class="string">&#x27;user&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/avatars&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: data</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上传二进制文件时，不用修改标头的<code>Content-Type</code>，浏览器会自动设置。</p>
<p><strong>（5）直接上传二进制数据</strong></p>
<p><code>fetch()</code>也可以直接上传二进制数据，将 Blob 或 arrayBuffer 数据放在<code>body</code>属性里面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> blob = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span></span><br><span class="line">  canvasElem.<span class="title function_">toBlob</span>(resolve,  <span class="string">&#x27;image/png&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/article/fetch/post/image&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>:  <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">body</span>: blob</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="fetch-配置对象的完整-API"><a href="#fetch-配置对象的完整-API" class="headerlink" title="fetch()配置对象的完整 API"></a><code>fetch()</code>配置对象的完整 API</h3><p><code>fetch()</code>第二个参数的完整 API 如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> response = <span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain;charset=UTF-8&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">referrer</span>: <span class="string">&quot;about:client&quot;</span>,</span><br><span class="line">  <span class="attr">referrerPolicy</span>: <span class="string">&quot;no-referrer-when-downgrade&quot;</span>,</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;cors&quot;</span>,</span><br><span class="line">  <span class="attr">credentials</span>: <span class="string">&quot;same-origin&quot;</span>,</span><br><span class="line">  <span class="attr">cache</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">  <span class="attr">redirect</span>: <span class="string">&quot;follow&quot;</span>,</span><br><span class="line">  <span class="attr">integrity</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">keepalive</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">signal</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>fetch()</code>请求的底层用的是 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Request/Request">Request() 对象</a>的接口，参数完全一样，因此上面的 API 也是<code>Request()</code>的 API。</p>
<p>这些属性里面，<code>headers</code>、<code>body</code>、<code>method</code>前面已经给过示例了，下面是其他属性的介绍。</p>
<p><strong>cache</strong></p>
<p><code>cache</code>属性指定如何处理缓存。可能的取值如下：</p>
<ul>
<li><code>default</code>：默认值，先在缓存里面寻找匹配的请求。</li>
<li><code>no-store</code>：直接请求远程服务器，并且不更新缓存。</li>
<li><code>reload</code>：直接请求远程服务器，并且更新缓存。</li>
<li><code>no-cache</code>：将服务器资源跟本地缓存进行比较，有新的版本才使用服务器资源，否则使用缓存。</li>
<li><code>force-cache</code>：缓存优先，只有不存在缓存的情况下，才请求远程服务器。</li>
<li><code>only-if-cached</code>：只检查缓存，如果缓存里面不存在，将返回504错误。</li>
</ul>
<p><strong>mode</strong></p>
<p><code>mode</code>属性指定请求的模式。可能的取值如下：</p>
<ul>
<li><code>cors</code>：默认值，允许跨源请求。</li>
<li><code>same-origin</code>：只允许同源请求。</li>
<li><code>no-cors</code>：请求方法只限于 GET、POST 和 HEAD，并且只能使用有限的几个简单标头，不能添加跨源的复杂标头，相当于提交表单、<code>&lt;script&gt;</code>加载脚本、<code>&lt;img&gt;</code>加载图片等传统的跨源请求方法。</li>
</ul>
<p><strong>credentials</strong></p>
<p><code>credentials</code>属性指定是否发送 Cookie。可能的取值如下：</p>
<ul>
<li><code>same-origin</code>：默认值，同源请求时发送 Cookie，跨源请求时不发送。</li>
<li><code>include</code>：不管同源请求，还是跨源请求，一律发送 Cookie。</li>
<li><code>omit</code>：一律不发送。</li>
</ul>
<p>跨源请求发送 Cookie，需要将<code>credentials</code>属性设为<code>include</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://another.com&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">credentials</span>: <span class="string">&quot;include&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>signal</strong></p>
<p><code>signal</code>属性指定一个 AbortSignal 实例，用于取消<code>fetch()</code>请求，详见下一节。</p>
<p><strong>keepalive</strong></p>
<p><code>keepalive</code>属性用于页面卸载时，告诉浏览器在后台保持连接，继续发送数据。</p>
<p>一个典型的场景就是，用户离开网页时，脚本向服务器提交一些用户行为的统计信息。这时，如果不用<code>keepalive</code>属性，数据可能无法发送，因为浏览器已经把页面卸载了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onunload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="string">&#x27;/analytics&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">      <span class="attr">some</span>: <span class="string">&#x27;data&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="attr">keepalive</span>: <span class="literal">true</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>redirect</strong></p>
<p><code>redirect</code>属性指定 HTTP 跳转的处理方法。可能的取值如下：</p>
<ul>
<li><code>follow</code>：默认值，<code>fetch()</code>跟随 HTTP 跳转。</li>
<li><code>error</code>：如果发生跳转，<code>fetch()</code>就报错。</li>
<li><code>manual</code>：<code>fetch()</code>不跟随 HTTP 跳转，但是<code>response.url</code>属性会指向新的 URL，<code>response.redirected</code>属性会变为<code>true</code>，由开发者自己决定后续如何处理跳转。</li>
</ul>
<p><strong>integrity</strong></p>
<p><code>integrity</code>属性指定一个哈希值，用于检查 HTTP 回应传回的数据是否等于这个预先设定的哈希值。</p>
<p>比如，下载文件时，检查文件的 SHA-256 哈希值是否相符，确保没有被篡改。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;http://site.com/file&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">integrity</span>: <span class="string">&#x27;sha256-abcdef&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>referrer</strong></p>
<p><code>referrer</code>属性用于设定<code>fetch()</code>请求的<code>referer</code>标头。</p>
<p>这个属性可以为任意字符串，也可以设为空字符串（即不发送<code>referer</code>标头）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;/page&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">referrer</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>referrerPolicy</strong></p>
<p><code>referrerPolicy</code>属性用于设定<code>Referer</code>标头的规则。可能的取值如下：</p>
<ul>
<li><code>no-referrer-when-downgrade</code>：默认值，总是发送<code>Referer</code>标头，除非从 HTTPS 页面请求 HTTP 资源时不发送。</li>
<li><code>no-referrer</code>：不发送<code>Referer</code>标头。</li>
<li><code>origin</code>：<code>Referer</code>标头只包含域名，不包含完整的路径。</li>
<li><code>origin-when-cross-origin</code>：同源请求<code>Referer</code>标头包含完整的路径，跨源请求只包含域名。</li>
<li><code>same-origin</code>：跨源请求不发送<code>Referer</code>，同源请求发送。</li>
<li><code>strict-origin</code>：<code>Referer</code>标头只包含域名，HTTPS 页面请求 HTTP 资源时不发送<code>Referer</code>标头。</li>
<li><code>strict-origin-when-cross-origin</code>：同源请求时<code>Referer</code>标头包含完整路径，跨源请求时只包含域名，HTTPS 页面请求 HTTP 资源时不发送该标头。</li>
<li><code>unsafe-url</code>：不管什么情况，总是发送<code>Referer</code>标头。</li>
</ul>
<h3 id="取消fetch-请求"><a href="#取消fetch-请求" class="headerlink" title="取消fetch()请求"></a>取消<code>fetch()</code>请求</h3><p><code>fetch()</code>请求发送以后，如果中途想要取消，需要使用<code>AbortController</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="keyword">let</span> signal = controller.<span class="property">signal</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(url, &#123;</span><br><span class="line">  <span class="attr">signal</span>: controller.<span class="property">signal</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">signal.<span class="title function_">addEventListener</span>(<span class="string">&#x27;abort&#x27;</span>,</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;abort!&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">controller.<span class="title function_">abort</span>(); <span class="comment">// 取消</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(signal.<span class="property">aborted</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面示例中，首先新建 AbortController 实例，然后发送<code>fetch()</code>请求，配置对象的<code>signal</code>属性必须指定接收 AbortController 实例发送的信号<code>controller.signal</code>。</p>
<p><code>controller.abort()</code>方法用于发出取消信号。这时会触发<code>abort</code>事件，这个事件可以监听，也可以通过<code>controller.signal.aborted</code>属性判断取消信号是否已经发出。</p>
<p>下面是一个1秒后自动取消请求的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> controller.<span class="title function_">abort</span>(), <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/long-operation&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">signal</span>: controller.<span class="property">signal</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err.<span class="property">name</span> == <span class="string">&#x27;AbortError&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Aborted!&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考链接-2"><a href="#参考链接-2" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://javascript.info/fetch">Network requests: Fetch</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/node-fetch/node-fetch">node-fetch</a></li>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/web/updates/2015/03/introduction-to-fetch">Introduction to fetch()</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">Using Fetch</a></li>
<li><a target="_blank" rel="noopener" href="https://developerhowto.com/2019/09/14/javascript-fetch-api/">Javascript Fetch API: The XMLHttpRequest evolution</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sitepen.com/blog/2017/10/02/a-guide-to-faster-web-app-io-and-data-operations-with-streams/">A Guide to Faster Web App I&#x2F;O and Data Operations with Streams</a></li>
</ul>
<h2 id="FontFace-API"><a href="#FontFace-API" class="headerlink" title="FontFace API"></a>FontFace API</h2><p>FontFace API 用来控制字体加载。</p>
<p>这个 API 提供一个构造函数<code>FontFace()</code>，返回一个字体对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">FontFace</span>(family, source, descriptors)</span><br></pre></td></tr></table></figure>

<p><code>FontFace()</code>构造函数接受三个参数。</p>
<ul>
<li><code>family</code>：字符串，表示字体名，写法与 CSS 的<code>@font-face</code>的<code>font-family</code>属性相同。</li>
<li><code>source</code>：字体文件的 URL（必须包括 CSS 的<code>url()</code>方法），或者是一个字体的 ArrayBuffer 对象。</li>
<li><code>descriptors</code>：对象，用来定制字体文件。该参数可选。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fontFace = <span class="keyword">new</span> <span class="title class_">FontFace</span>(</span><br><span class="line">  <span class="string">&#x27;Roboto&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;url(https://fonts.example.com/roboto.woff2)&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">fontFace.<span class="property">family</span> <span class="comment">// &quot;Roboto&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>FontFace()</code>返回的是一个字体对象，这个对象包含字体信息。注意，这时字体文件还没有开始加载。</p>
<p>字体对象包含以下属性。</p>
<ul>
<li><code>FontFace.family</code>：字符串，表示字体的名字，等同于 CSS 的<code>font-family</code>属性。</li>
<li><code>FontFace.display</code>：字符串，指定字体加载期间如何展示，等同于 CSS 的<code>font-display</code>属性。它有五个可能的值：<code>auto</code>（由浏览器决定）、<code>block</code>（字体加载期间，前3秒会显示不出内容，然后只要还没完成加载，就一直显示后备字体）、<code>fallback</code>（前100毫秒显示不出内容，后3秒显示后备字体，然后只要字体还没完成加载，就一直显示后备字体）、<code>optional</code>（前100毫秒显示不出内容，然后只要字体还没有完成加载，就一直显示后备字体），<code>swap</code>（只要字体没有完成加载，就一直显示后备字体）。</li>
<li><code>FontFace.style</code>：字符串，等同于 CSS 的<code>font-style</code>属性。</li>
<li><code>FontFace.weight</code>：字符串，等同于 CSS 的<code>font-weight</code>属性。</li>
<li><code>FontFace.stretch</code>：字符串，等同于 CSS 的<code>font-strentch</code>属性。</li>
<li><code>FontFace.unicodeRange</code>：字符串，等同于<code>descriptors</code>对象的同名属性。</li>
<li><code>FontFace.variant</code>：字符串，等同于<code>descriptors</code>对象的同名属性。</li>
<li><code>FontFace.featureSettings</code>：字符串，等同于<code>descriptors</code>对象的同名属性。</li>
<li><code>FontFace.status</code>：字符串，表示字体的加载状态，有四个可能的值：<code>unloaded</code>、<code>loading</code>、<code>loaded</code>、<code>error</code>。该属性只读。</li>
<li><code>FontFace.loaded</code>：返回一个 Promise 对象，字体加载成功或失败，会导致该 Promise 状态改变。该属性只读。</li>
</ul>
<p>字体对象的方法，只有一个<code>FontFace.load()</code>，该方法会真正开始加载字体。它返回一个 Promise 对象，状态由字体加载的结果决定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title class_">FontFace</span>(<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;url(x)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">f.<span class="title function_">load</span>().<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 网页可以开始使用该字体</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Geolocation-API"><a href="#Geolocation-API" class="headerlink" title="Geolocation API"></a>Geolocation API</h2><p>Geolocation API 用于获取用户的地理位置。</p>
<p>由于该功能涉及用户隐私，所以浏览器会提示用户，是否同意给出地理位置，用户可能会拒绝。另外，这个 API 只能在 HTTPS 环境使用。</p>
<p>浏览器通过<code>navigator.geolocation</code>属性提供该 API。</p>
<h3 id="Geolocation-对象"><a href="#Geolocation-对象" class="headerlink" title="Geolocation 对象"></a>Geolocation 对象</h3><p><code>navigator.geolocation</code>属性返回一个 Geolocation 对象。该对象具有以下三个方法。</p>
<ul>
<li><code>Geolocation.getCurrentPosition()</code>：返回一个 Position 对象，表示用户的当前位置。</li>
<li><code>Geolocation.watchPosition()</code>：指定一个监听函数，每当用户的位置发生变化，就执行该监听函数。</li>
<li><code>Geolocation.clearWatch()</code>：取消<code>watchPosition()</code>方法指定的监听函数。</li>
</ul>
<h4 id="Geolocation-getCurrentPosition"><a href="#Geolocation-getCurrentPosition" class="headerlink" title="Geolocation.getCurrentPosition()"></a>Geolocation.getCurrentPosition()</h4><p><code>Geolocation.getCurrentPosition()</code>方法用于获取用户的位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">geolocation</span>.<span class="title function_">getCurrentPosition</span>(success, error, options)</span><br></pre></td></tr></table></figure>

<p>该方法接受三个参数。</p>
<ul>
<li><code>success</code>：用户同意给出位置时的回调函数，它的参数是一个 Position 对象。</li>
<li><code>error</code>：用户拒绝给出位置时的回调函数，它的参数是一个 PositionError 对象。该参数可选。</li>
<li><code>options</code>：参数对象，该参数可选。</li>
</ul>
<p>Position 对象有两个属性。</p>
<ul>
<li><code>Position.coords</code>：返回一个 Coordinates 对象，表示当前位置的坐标。</li>
<li><code>Position.timestamp</code>：返回一个对象，代表当前时间戳。</li>
</ul>
<p>PositionError 对象主要有两个属性。</p>
<ul>
<li><code>PositionError.code</code>：整数，表示发生错误的原因。<code>1</code>表示无权限，有可能是用户拒绝授权；<code>2</code>表示无法获得位置，可能设备有故障；<code>3</code>表示超时。</li>
<li><code>PositionError.message</code>：字符串，表示错误的描述。</li>
</ul>
<p>参数对象<code>option</code>可以指定三个属性。</p>
<ul>
<li><code>enableHighAccuracy</code>：布尔值，是否返回高精度结果。如果设为<code>true</code>，可能导致响应时间变慢或（移动设备的）功耗增加；反之，如果设为<code>false</code>，设备可以更快速地响应。默认值为<code>false</code>。</li>
<li><code>timeout</code>：正整数，表示等待查询的最长时间，单位为毫秒。默认值为<code>Infinity</code>。</li>
<li><code>maximumAge</code>：正整数，表示可接受的缓存最长时间，单位为毫秒。如果设为<code>0</code>，表示不返回缓存值，必须查询当前的实际位置；如果设为<code>Infinity</code>，必须返回缓存值，不管缓存了多少时间。默认值为<code>0</code>。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="attr">enableHighAccuracy</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span>,</span><br><span class="line">  <span class="attr">maximumAge</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">success</span>(<span class="params">pos</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> crd = pos.<span class="property">coords</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`经度：<span class="subst">$&#123;crd.latitude&#125;</span>`</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`纬度：<span class="subst">$&#123;crd.longitude&#125;</span>`</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`误差：<span class="subst">$&#123;crd.accuracy&#125;</span> 米`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">`ERROR(<span class="subst">$&#123;err.code&#125;</span>): <span class="subst">$&#123;err.message&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">navigator.<span class="property">geolocation</span>.<span class="title function_">getCurrentPosition</span>(success, error, options);</span><br></pre></td></tr></table></figure>

<h4 id="Geolocation-watchPosition"><a href="#Geolocation-watchPosition" class="headerlink" title="Geolocation.watchPosition()"></a>Geolocation.watchPosition()</h4><p><code>Geolocation.watchPosition()</code>对象指定一个监听函数，每当用户的位置发生变化，就是自动执行这个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">geolocation</span>.<span class="title function_">watchPosition</span>(success[, error[, options]])</span><br></pre></td></tr></table></figure>

<p>该方法接受三个参数。</p>
<ul>
<li><code>success</code>：监听成功的回调函数，该函数的参数为一个 Position 对象。</li>
<li><code>error</code>：该参数可选，表示监听失败的回调函数，该函数的参数是一个 PositionError 对象。</li>
<li><code>options</code>：该参数可选，表示监听的参数配置对象。</li>
</ul>
<p>该方法返回一个整数值，表示监听函数的编号。该整数用来供<code>Geolocation.clearWatch()</code>方法取消监听。</p>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> target = &#123;</span><br><span class="line">  latitude : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">longitude</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  <span class="attr">enableHighAccuracy</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">5000</span>,</span><br><span class="line">  <span class="attr">maximumAge</span>: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">success</span>(<span class="params">pos</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> crd = pos.<span class="property">coords</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (target.<span class="property">latitude</span> === crd.<span class="property">latitude</span> &amp;&amp; target.<span class="property">longitude</span> === crd.<span class="property">longitude</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;恭喜，你已经到达了指定位置。&#x27;</span>);</span><br><span class="line">    navigator.<span class="property">geolocation</span>.<span class="title function_">clearWatch</span>(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">error</span>(<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;ERROR(&#x27;</span> + err.<span class="property">code</span> + <span class="string">&#x27;): &#x27;</span> + err.<span class="property">message</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id = navigator.<span class="property">geolocation</span>.<span class="title function_">watchPosition</span>(success, error, options);</span><br></pre></td></tr></table></figure>

<h4 id="Geolocation-clearWatch"><a href="#Geolocation-clearWatch" class="headerlink" title="Geolocation.clearWatch()"></a>Geolocation.clearWatch()</h4><p><code>Geolocation.clearWatch()</code>方法用来取消<code>watchPosition()</code>方法指定的监听函数。它的参数是<code>watchPosition()</code>返回的监听函数的编号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">geolocation</span>.<span class="title function_">clearWatch</span>(id);</span><br></pre></td></tr></table></figure>

<p>使用方法的例子见上一节。</p>
<h3 id="Coordinates-对象"><a href="#Coordinates-对象" class="headerlink" title="Coordinates 对象"></a>Coordinates 对象</h3><p>Coordinates 对象是地理位置的坐标接口，<code>Position.coords</code>属性返回的就是这个对象。</p>
<p>它有以下属性，全部为只读属性。</p>
<ul>
<li><code>Coordinates.latitude</code>：浮点数，表示纬度。</li>
<li><code>Coordinates.longitude</code>：浮点数，表示经度。</li>
<li><code>Coordinates.altitude</code>：浮点数，表示海拔（单位：米）。如果不可得，返回<code>null</code>。</li>
<li><code>Coordinates.accuracy</code>：浮点数，表示经度和纬度的精度（单位：米）。</li>
<li><code>Coordinates.altitudeAccuracy</code>：浮点数，表示海拔的精度（单位：米）。返回<code>null</code>。</li>
<li><code>Coordinates.speed</code>：浮点数，表示设备的速度（单位：米&#x2F;秒）。如果不可得，返回<code>null</code>。</li>
<li><code>Coordinates.heading</code>：浮点数，表示设备前进的方向（单位：度）。方向按照顺时针，北方是0度，东方是90度，西方是270度。如果<code>Coordinates.speed</code>为0，<code>heading</code>属性返回<code>NaN</code>。如果设备无法提供方向信息，该属性返回<code>null</code>。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">geolocation</span>.<span class="title function_">getCurrentPosition</span>( <span class="keyword">function</span> (<span class="params">position</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> lat = position.<span class="property">coords</span>.<span class="property">latitude</span>;</span><br><span class="line">  <span class="keyword">let</span> long = position.<span class="property">coords</span>.<span class="property">longitude</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`纬度：<span class="subst">$&#123;lat.toFixed(<span class="number">2</span>)&#125;</span>`</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`经度：<span class="subst">$&#123;long.toFixed(<span class="number">2</span>)&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="参考链接-3"><a href="#参考链接-3" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API">Geolocation API</a>, by MDN</li>
</ul>
<h2 id="IntersectionObserver"><a href="#IntersectionObserver" class="headerlink" title="IntersectionObserver"></a>IntersectionObserver</h2><p>网页开发时，常常需要了解某个元素是否进入了“视口”（viewport），即用户能不能看到它。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071415512.gif"></p>
<p>上图的绿色方块不断滚动，顶部会提示它的可见性。</p>
<p>传统的实现方法是，监听到<code>scroll</code>事件后，调用目标元素（绿色方块）的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en/docs/Web/API/Element/getBoundingClientRect"><code>getBoundingClientRect()</code></a>方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于<code>scroll</code>事件密集发生，计算量很大，容易造成<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html">性能问题</a>。</p>
<p><a target="_blank" rel="noopener" href="https://wicg.github.io/IntersectionObserver/">IntersectionObserver API</a>，可以自动“观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做“交叉观察器”（intersection oberserver）。</p>
<h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>IntersectionObserver API 的用法，简单来说就是两行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(callback, options);</span><br><span class="line">observer.<span class="title function_">observe</span>(target);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>IntersectionObserver</code>是浏览器原生提供的构造函数，接受两个参数：<code>callback</code>是可见性变化时的回调函数，<code>option</code>是配置对象（该参数可选）。</p>
<p><code>IntersectionObserver()</code>的返回值是一个观察器实例。实例的<code>observe()</code>方法可以指定观察哪个 DOM 节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始观察</span></span><br><span class="line">observer.<span class="title function_">observe</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;example&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止观察</span></span><br><span class="line">observer.<span class="title function_">unobserve</span>(element);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭观察器</span></span><br><span class="line">observer.<span class="title function_">disconnect</span>();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>observe()</code>的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">observer.<span class="title function_">observe</span>(elementA);</span><br><span class="line">observer.<span class="title function_">observe</span>(elementB);</span><br></pre></td></tr></table></figure>

<p>注意，IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。规格写明，<code>IntersectionObserver</code>的实现，应该采用<code>requestIdleCallback()</code>，即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。</p>
<h3 id="IntersectionObserver-observe"><a href="#IntersectionObserver-observe" class="headerlink" title="IntersectionObserver.observe()"></a>IntersectionObserver.observe()</h3><p>IntersectionObserver 实例的<code>observe()</code>方法用来启动对一个 DOM 元素的观察。该方法接受两个参数：回调函数<code>callback</code>和配置对象<code>options</code>。</p>
<h4 id="callback-参数"><a href="#callback-参数" class="headerlink" title="callback 参数"></a>callback 参数</h4><p>目标元素的可见性变化时，就会调用观察器的回调函数<code>callback</code>。</p>
<p><code>callback</code>会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(</span><br><span class="line">  <span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(entries);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，回调函数采用的是<a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/##docs/function##%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0">箭头函数</a>的写法。<code>callback</code>函数的参数（<code>entries</code>）是一个数组，每个成员都是一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry"><code>IntersectionObserverEntry</code></a>对象（详见下文）。举例来说，如果同时有两个被观察的对象的可见性发生变化，<code>entries</code>数组就会有两个成员。</p>
<h4 id="IntersectionObserverEntry-对象"><a href="#IntersectionObserverEntry-对象" class="headerlink" title="IntersectionObserverEntry 对象"></a>IntersectionObserverEntry 对象</h4><p><code>IntersectionObserverEntry</code>对象提供目标元素的信息，一共有六个属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">time</span>: <span class="number">3893.92</span>,</span><br><span class="line">  <span class="attr">rootBounds</span>: <span class="title class_">ClientRect</span> &#123;</span><br><span class="line">    <span class="attr">bottom</span>: <span class="number">920</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">1024</span>,</span><br><span class="line">    <span class="attr">left</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">right</span>: <span class="number">1024</span>,</span><br><span class="line">    <span class="attr">top</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="number">920</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">boundingClientRect</span>: <span class="title class_">ClientRect</span> &#123;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">intersectionRect</span>: <span class="title class_">ClientRect</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">intersectionRatio</span>: <span class="number">0.54</span>,</span><br><span class="line">  <span class="attr">target</span>: element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个属性的含义如下。</p>
<blockquote>
<ul>
<li><code>time</code>：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒</li>
<li><code>target</code>：被观察的目标元素，是一个 DOM 节点对象</li>
<li><code>rootBounds</code>：容器元素的矩形区域的信息，<code>getBoundingClientRect()</code>方法的返回值，如果没有容器元素（即直接相对于视口滚动），则返回<code>null</code></li>
<li><code>boundingClientRect</code>：目标元素的矩形区域的信息</li>
<li><code>intersectionRect</code>：目标元素与视口（或容器元素）的交叉区域的信息</li>
<li><code>intersectionRatio</code>：目标元素的可见比例，即<code>intersectionRect</code>占<code>boundingClientRect</code>的比例，完全可见时为<code>1</code>，完全不可见时小于等于<code>0</code></li>
</ul>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071415501.png"></p>
<p>上图中，灰色的水平方框代表视口，深红色的区域代表四个被观察的目标元素。它们各自的<code>intersectionRatio</code>图中都已经注明。</p>
<p>我写了一个 <a target="_blank" rel="noopener" href="http://jsbin.com/canuze/edit?js,console,output">Demo</a>，演示<code>IntersectionObserverEntry</code>对象。注意，这个 Demo 只能在 Chrome 51+ 运行。</p>
<h4 id="Option-对象"><a href="#Option-对象" class="headerlink" title="Option 对象"></a>Option 对象</h4><p><code>IntersectionObserver</code>构造函数的第二个参数是一个配置对象。它可以设置以下属性。</p>
<p><strong>（1）threshold 属性</strong></p>
<p><code>threshold</code>属性决定了什么时候触发回调函数，即元素进入视口（或者容器元素）多少比例时，执行回调函数。它是一个数组，每个成员都是一个门槛值，默认为<code>[0]</code>，即交叉比例（<code>intersectionRatio</code>）达到<code>0</code>时触发回调函数。</p>
<p>如果<code>threshold</code>属性是0.5，当元素进入视口50%时，触发回调函数。如果值为<code>[0.3, 0.6]</code>，则当元素进入30％和60％是触发回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(</span><br><span class="line">  <span class="function"><span class="params">entries</span> =&gt;</span> &#123;<span class="comment">/* … */</span>&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">threshold</span>: [<span class="number">0</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>用户可以自定义这个数组。比如，上例的<code>[0, 0.25, 0.5, 0.75, 1]</code>就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071415506.gif"></p>
<p><strong>（2）root 属性，rootMargin 属性</strong></p>
<p><code>IntersectionObserver</code>不仅可以观察元素相对于视口的可见性，还可以观察元素相对于其所在容器的可见性。容器内滚动也会影响目标元素的可见性，参见本文开始时的那张示意图。</p>
<p>IntersectionObserver API 支持容器内滚动。<code>root</code>属性指定目标元素所在的容器节点。注意，容器元素必须是目标元素的祖先节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> opts = &#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.container&#x27;</span>),</span><br><span class="line">  <span class="attr">rootMargin</span>: <span class="string">&#x27;0px 0px -200px 0px&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(</span><br><span class="line">  callback,</span><br><span class="line">  opts</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，除了<code>root</code>属性，还有<a target="_blank" rel="noopener" href="https://wicg.github.io/IntersectionObserver/##dom-intersectionobserverinit-rootmargin"><code>rootMargin</code></a>属性。该属性用来扩展或缩小<code>rootBounds</code>这个矩形的大小，从而影响<code>intersectionRect</code>交叉区域的大小。它的写法类似于 CSS 的<code>margin</code>属性，比如<code>0px 0px 0px 0px</code>，依次表示 top、right、bottom 和 left 四个方向的值。</p>
<p>上例的<code>0px 0px -200px 0px</code>，表示容器的下边缘向上收缩200像素，导致页面向下滚动时，目标元素的顶部进入可视区域200像素以后，才会触发回调函数。</p>
<p>这样设置以后，不管是窗口滚动或者容器内滚动，只要目标元素可见性变化，都会触发观察器。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="惰性加载（lazy-load）"><a href="#惰性加载（lazy-load）" class="headerlink" title="惰性加载（lazy load）"></a>惰性加载（lazy load）</h4><p>有时，我们希望某些静态资源（比如图片），只有用户向下滚动，它们进入视口时才加载，这样可以节省带宽，提高网页性能。这就叫做“惰性加载”。</p>
<p>有了 IntersectionObserver API，实现起来就很容易了。图像的 HTML 代码可以写成下面这样。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;placeholder.png&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;img-1.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;placeholder.png&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;img-2.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;placeholder.png&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;img-3.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，图像默认显示一个占位符，<code>data-src</code>属性是惰性加载的真正图像。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">query</span>(<span class="params">selector</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(selector));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(</span><br><span class="line">  <span class="keyword">function</span>(<span class="params">entries</span>) &#123;</span><br><span class="line">    entries.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">entry</span>) &#123;</span><br><span class="line">      entry.<span class="property">target</span>.<span class="property">src</span> = entry.<span class="property">target</span>.<span class="property">dataset</span>.<span class="property">src</span>;</span><br><span class="line">      observer.<span class="title function_">unobserve</span>(entry.<span class="property">target</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title function_">query</span>(<span class="string">&#x27;.lazy-loaded&#x27;</span>).<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">  observer.<span class="title function_">observe</span>(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，只有图像开始可见时，才会加载真正的图像文件。</p>
<h4 id="无限滚动"><a href="#无限滚动" class="headerlink" title="无限滚动"></a>无限滚动</h4><p>无限滚动（infinite scroll）指的是，随着网页滚动到底部，不断加载新的内容到页面，它的实现也很简单。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intersectionObserver = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(</span><br><span class="line">  <span class="keyword">function</span> (<span class="params">entries</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果不可见，就返回</span></span><br><span class="line">    <span class="keyword">if</span> (entries[<span class="number">0</span>].<span class="property">intersectionRatio</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="title function_">loadItems</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Loaded new items&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始观察</span></span><br><span class="line">intersectionObserver.<span class="title function_">observe</span>(</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.scrollerFooter&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>无限滚动时，最好像上例那样，页面底部有一个页尾栏（又称<a href="sentinels">sentinels</a>，上例是<code>.scrollerFooter</code>）。一旦页尾栏可见，就表示用户到达了页面底部，从而加载新的条目放在页尾栏前面。否则就需要每一次页面加入新内容时，都调用<code>observe()</code>方法，对新增内容的底部建立观察。</p>
<h4 id="视频自动播放"><a href="#视频自动播放" class="headerlink" title="视频自动播放"></a>视频自动播放</h4><p>下面是一个视频元素，希望它完全进入视口的时候自动播放，离开视口的时候自动暂停。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;foo.mp4&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>下面是 JS 代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> video = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;video&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> isPaused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observer = <span class="keyword">new</span> <span class="title class_">IntersectionObserver</span>(<span class="function">(<span class="params">entries, observer</span>) =&gt;</span> &#123;</span><br><span class="line">  entries.<span class="title function_">forEach</span>(<span class="function"><span class="params">entry</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (entry.<span class="property">intersectionRatio</span> != <span class="number">1</span>  &amp;&amp; !video.<span class="property">paused</span>) &#123;</span><br><span class="line">      video.<span class="title function_">pause</span>();</span><br><span class="line">      isPaused = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPaused) &#123;</span><br><span class="line">      video.<span class="title function_">play</span>();</span><br><span class="line">      isPaused=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, &#123;<span class="attr">threshold</span>: <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">observer.<span class="title function_">observe</span>(video);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>IntersectionObserver()</code>的第二个参数是配置对象，它的<code>threshold</code>属性等于<code>1</code>，即目标元素完全可见时触发回调函数。</p>
<h3 id="参考链接-4"><a href="#参考链接-4" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/web/updates/2016/04/intersectionobserver">IntersectionObserver’s Coming into View</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/WICG/IntersectionObserver/blob/gh-pages/explainer.md">Intersection Observers Explained</a></li>
<li><a target="_blank" rel="noopener" href="https://css-tricks.com/a-few-functional-uses-for-intersection-observer-to-know-when-an-element-is-in-view/">A Few Functional Uses for Intersection Observer to Know When an Element is in View</a>, Preethi</li>
</ul>
<h2 id="Intl-RelativeTimeFormat"><a href="#Intl-RelativeTimeFormat" class="headerlink" title="Intl.RelativeTimeFormat"></a>Intl.RelativeTimeFormat</h2><p>很多日期库支持显示相对时间，比如“昨天”、“五分钟前”、“两个月之前”等等。由于不同的语言，日期显示的格式和相关词语都不同，造成这些库的体积非常大。</p>
<p>现在，浏览器提供内置的 Intl.RelativeTimeFormat API，可以不使用这些库，直接显示相对时间。</p>
<h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>Intl.RelativeTimeFormat()</code>是一个构造函数，接受一个语言代码作为参数，返回一个相对时间的实例对象。如果省略参数，则默认传入当前运行时的语言代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rtf = <span class="keyword">new</span> <span class="title class_">Intl</span>.<span class="title class_">RelativeTimeFormat</span>(<span class="string">&#x27;en&#x27;</span>);</span><br><span class="line"></span><br><span class="line">rtf.<span class="title function_">format</span>(<span class="number">3.14</span>, <span class="string">&#x27;second&#x27;</span>) <span class="comment">// &quot;in 3.14 seconds&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(-<span class="number">15</span>, <span class="string">&#x27;minute&#x27;</span>) <span class="comment">// &quot;15 minutes ago&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(<span class="number">8</span>, <span class="string">&#x27;hour&#x27;</span>) <span class="comment">// &quot;in 8 hours&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(-<span class="number">2</span>, <span class="string">&#x27;day&#x27;</span>) <span class="comment">// &quot;2 days ago&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(<span class="number">3</span>, <span class="string">&#x27;week&#x27;</span>) <span class="comment">// &quot;in 3 weeks&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(-<span class="number">5</span>, <span class="string">&#x27;month&#x27;</span>) <span class="comment">// &quot;5 months ago&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(<span class="number">2</span>, <span class="string">&#x27;quarter&#x27;</span>) <span class="comment">// &quot;in 2 quarters&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(-<span class="number">42</span>, <span class="string">&#x27;year&#x27;</span>) <span class="comment">// &quot;42 years ago&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码指定使用英语显示相对时间。</p>
<p>下面是使用西班牙语显示相对时间的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rtf = <span class="keyword">new</span> <span class="title class_">Intl</span>.<span class="title class_">RelativeTimeFormat</span>(<span class="string">&#x27;es&#x27;</span>);</span><br><span class="line"></span><br><span class="line">rtf.<span class="title function_">format</span>(<span class="number">3.14</span>, <span class="string">&#x27;second&#x27;</span>) <span class="comment">// &quot;dentro de 3,14 segundos&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(-<span class="number">15</span>, <span class="string">&#x27;minute&#x27;</span>) <span class="comment">// &quot;hace 15 minutos&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(<span class="number">8</span>, <span class="string">&#x27;hour&#x27;</span>) <span class="comment">// &quot;dentro de 8 horas&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(-<span class="number">2</span>, <span class="string">&#x27;day&#x27;</span>) <span class="comment">// &quot;hace 2 días&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(<span class="number">3</span>, <span class="string">&#x27;week&#x27;</span>) <span class="comment">// &quot;dentro de 3 semanas&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(-<span class="number">5</span>, <span class="string">&#x27;month&#x27;</span>) <span class="comment">// &quot;hace 5 meses&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(<span class="number">2</span>, <span class="string">&#x27;quarter&#x27;</span>) <span class="comment">// &quot;dentro de 2 trimestres&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(-<span class="number">42</span>, <span class="string">&#x27;year&#x27;</span>) <span class="comment">// &quot;hace 42 años&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>Intl.RelativeTimeFormat()</code>还可以接受一个配置对象，作为第二个参数，用来精确指定相对时间实例的行为。配置对象共有下面这些属性。</p>
<ul>
<li>options.style：表示返回字符串的风格，可能的值有<code>long</code>（默认值，比如“in 1 month”）、<code>short</code>（比如“in 1 mo.”）、<code>narrow</code>（比如“in 1 mo.”）。对于一部分语言来说，<code>narrow</code>风格和<code>short</code>风格是类似的。</li>
<li>options.localeMatcher：表示匹配语言参数的算法，可能的值有<code>best fit</code>（默认值）和<code>lookup</code>。</li>
<li>options.numeric：表示返回字符串是数字显示，还是文字显示，可能的值有<code>always</code>（默认值，总是文字显示）和<code>auto</code>（自动转换）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的配置对象，传入的都是默认值</span></span><br><span class="line"><span class="keyword">const</span> rtf = <span class="keyword">new</span> <span class="title class_">Intl</span>.<span class="title class_">RelativeTimeFormat</span>(<span class="string">&#x27;en&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">localeMatcher</span>: <span class="string">&#x27;best fit&#x27;</span>, <span class="comment">// 其他值：&#x27;lookup&#x27;</span></span><br><span class="line">  <span class="attr">style</span>: <span class="string">&#x27;long&#x27;</span>, <span class="comment">// 其他值：&#x27;short&#x27; or &#x27;narrow&#x27;</span></span><br><span class="line">  <span class="attr">numeric</span>: <span class="string">&#x27;always&#x27;</span>, <span class="comment">// 其他值：&#x27;auto&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, let’s try some special cases!</span></span><br><span class="line"></span><br><span class="line">rtf.<span class="title function_">format</span>(-<span class="number">1</span>, <span class="string">&#x27;day&#x27;</span>) <span class="comment">// &quot;1 day ago&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(<span class="number">0</span>, <span class="string">&#x27;day&#x27;</span>) <span class="comment">// &quot;in 0 days&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(<span class="number">1</span>, <span class="string">&#x27;day&#x27;</span>) <span class="comment">// &quot;in 1 day&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(-<span class="number">1</span>, <span class="string">&#x27;week&#x27;</span>) <span class="comment">// &quot;1 week ago&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(<span class="number">0</span>, <span class="string">&#x27;week&#x27;</span>) <span class="comment">// &quot;in 0 weeks&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(<span class="number">1</span>, <span class="string">&#x27;week&#x27;</span>) <span class="comment">// &quot;in 1 week&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，显示的是“1 day ago”，而不是“yesterday”；显示的是“in 0 weeks”，而不是“this week”。这是因为默认情况下，相对时间显示的是数值形式，而不是文字形式。</p>
<p>改变这个行为，可以把配置对象的<code>numeric</code>属性改成<code>auto</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rtf = <span class="keyword">new</span> <span class="title class_">Intl</span>.<span class="title class_">RelativeTimeFormat</span>(<span class="string">&#x27;en&#x27;</span>, &#123; <span class="attr">numeric</span>: <span class="string">&#x27;auto&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">rtf.<span class="title function_">format</span>(-<span class="number">1</span>, <span class="string">&#x27;day&#x27;</span>) <span class="comment">// &quot;yesterday&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(<span class="number">0</span>, <span class="string">&#x27;day&#x27;</span>) <span class="comment">// &quot;today&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(<span class="number">1</span>, <span class="string">&#x27;day&#x27;</span>) <span class="comment">// &quot;tomorrow&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(-<span class="number">1</span>, <span class="string">&#x27;week&#x27;</span>) <span class="comment">// &quot;last week&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(<span class="number">0</span>, <span class="string">&#x27;week&#x27;</span>) <span class="comment">// &quot;this week&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(<span class="number">1</span>, <span class="string">&#x27;week&#x27;</span>) <span class="comment">// &quot;next week&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Intl-RelativeTimeFormat-prototype-format"><a href="#Intl-RelativeTimeFormat-prototype-format" class="headerlink" title="Intl.RelativeTimeFormat.prototype.format()"></a>Intl.RelativeTimeFormat.prototype.format()</h3><p>相对时间实例对象的<code>format</code>方法，接受两个参数，依次为时间间隔的数值和单位。其中，“单位”是一个字符串，可以接受以下八个值。</p>
<ul>
<li>year</li>
<li>quarter</li>
<li>month</li>
<li>week</li>
<li>day</li>
<li>hour</li>
<li>minute</li>
<li>second</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rtf = <span class="keyword">new</span> <span class="title class_">Intl</span>.<span class="title class_">RelativeTimeFormat</span>(<span class="string">&#x27;en&#x27;</span>);</span><br><span class="line">rtf.<span class="title function_">format</span>(-<span class="number">1</span>, <span class="string">&quot;day&quot;</span>) <span class="comment">// &quot;yesterday&quot;</span></span><br><span class="line">rtf.<span class="title function_">format</span>(<span class="number">2.15</span>, <span class="string">&quot;day&quot;</span>) <span class="comment">// &quot;in 2.15 days</span></span><br></pre></td></tr></table></figure>

<h3 id="Intl-RelativeTimeFormat-prototype-formatToParts"><a href="#Intl-RelativeTimeFormat-prototype-formatToParts" class="headerlink" title="Intl.RelativeTimeFormat.prototype.formatToParts()"></a>Intl.RelativeTimeFormat.prototype.formatToParts()</h3><p>相对时间实例对象的<code>formatToParts()</code>方法的参数跟<code>format()</code>方法一样，但是返回的是一个数组，用来精确控制相对时间的每个部分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rtf = <span class="keyword">new</span> <span class="title class_">Intl</span>.<span class="title class_">RelativeTimeFormat</span>(<span class="string">&#x27;en&#x27;</span>, &#123; <span class="attr">numeric</span>: <span class="string">&#x27;auto&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">rtf.<span class="title function_">format</span>(-<span class="number">1</span>, <span class="string">&#x27;day&#x27;</span>) </span><br><span class="line"><span class="comment">// &quot;yesterday&quot;</span></span><br><span class="line">rtf.<span class="title function_">formatToParts</span>(-<span class="number">1</span>, <span class="string">&#x27;day&#x27;</span>);</span><br><span class="line"><span class="comment">// [&#123; type: &quot;literal&quot;, value: &quot;yesterday&quot; &#125;]</span></span><br><span class="line"></span><br><span class="line">rtf.<span class="title function_">format</span>(<span class="number">3</span>, <span class="string">&#x27;week&#x27;</span>);</span><br><span class="line"><span class="comment">// &quot;in 3 weeks&quot;</span></span><br><span class="line">rtf.<span class="title function_">formatToParts</span>(<span class="number">3</span>, <span class="string">&#x27;week&#x27;</span>);</span><br><span class="line"><span class="comment">// [</span></span><br><span class="line"><span class="comment">//   &#123; type: &#x27;literal&#x27;, value: &#x27;in &#x27; &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; type: &#x27;integer&#x27;, value: &#x27;3&#x27;, unit: &#x27;week&#x27; &#125;,</span></span><br><span class="line"><span class="comment">//   &#123; type: &#x27;literal&#x27;, value: &#x27; weeks&#x27; &#125;</span></span><br><span class="line"><span class="comment">// ]</span></span><br></pre></td></tr></table></figure>

<p>返回数组的每个成员都是一个对象，拥有两个属性。</p>
<ul>
<li>type：字符串，表示输出值的类型。</li>
<li>value：字符串，表示输出的内容。</li>
<li>unit：如果输出内容表示一个数值（即<code>type</code>属性不是<code>literal</code>），那么还会有<code>unit</code>属性，表示数值的单位。</li>
</ul>
<h3 id="参考链接-5"><a href="#参考链接-5" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/web/updates/2018/10/intl-relativetimeformat">The Intl.RelativeTimeFormat API</a>, Mathias Bynens</li>
<li><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-intl-relative-time##api">Intl.RelativeTimeFormat API Specification</a>, TC39</li>
</ul>
<h2 id="Offline-应用"><a href="#Offline-应用" class="headerlink" title="Offline 应用"></a>Offline 应用</h2><p>Web 应用不仅可以在浏览器缓存资源文件（HTML、CSS、JS 脚本、图片等），还可以把应用本身储存到浏览器。</p>
<p>缓存的资源文件必须在线使用，只有先从服务器加载网页，然后才能使用本地缓存；但是，应用一旦储存，就可以离线使用。另外，用户常规性地清除浏览器缓存，并不会清除储存的应用，除非用户显式地卸载或删除它们。</p>
<p>为了开启离线储存，必须创建一个 manifest 文件。该文件列出了所有需要储存的文件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">myapp.html</span><br><span class="line">myapp.js</span><br><span class="line">myapp.css</span><br><span class="line">/images/front_end/background.png</span><br></pre></td></tr></table></figure>

<p>Manifest 文件的第一行必须是<code>CACHE MANIFEST</code>。然后，每一行列出一个需要储存的文件，它们的位置都是相对于 Manifest 文件的位置。空行会被忽略，以<code>##</code>开头的行是注释，也会被忽略。</p>
<p>这个文件的后缀名一般是<code>.appcache</code>。它的 MIME 类型必须是<code>text/cache-manifest</code>，如果服务器将其设为其他类型，就不会被浏览器缓存。</p>
<p>编写完这个文件以后，要将<code>&lt;html&gt;</code>元素的<code>manifest</code>属性指向它。浏览器加载这个网页的时候，就会读取这个 Manifest 文件，离线储存这个网页和相关的资源。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">&quot;myapp.appcache&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>...<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>...<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果一个 Web 应用有多个网页需要离线储存，那么每个网页都应该将<code>manifest</code>属性指向这个文件。一旦被储存，以后加载该网页的时候，就会从缓存里面加载。这时，只有 Manifest 文件里面列出的文件会被加载，其他文件不会。如果这时浏览器在线，浏览器就会去检查 Manifest 文件是否有新版本，如果有新版本，就会重新储存和更新该文件列出的资源。最方便的办法是在 Manifest 文件里面用注释列出版本号。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">## MyApp version 1</span><br><span class="line">MyApp.html</span><br><span class="line">MyApp.js</span><br></pre></td></tr></table></figure>

<p>如果需要删除离线储存，只要删除 Manifest 文件，让其返回 404 状态码即可。</p>
<p>离线储存更新完成，会触发浏览器的<code>updateready</code>事件，可以对这个事件指定监听函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">applicationCache</span>.<span class="property">onupdateready</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> reload = <span class="title function_">confirm</span>(<span class="string">&#x27;新版本下载完成。是否需要重新加载？&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (reload) location.<span class="title function_">reload</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>脚本可以注册<code>online</code>和<code>offline</code>事件的监听函数，通过<code>navigator.onLine</code>属性，判断浏览器是否在线从而进行数据同步。</p>
<p>每次浏览器加载一个具有<code>manifest</code>属性的网页，浏览器就会触发一个<code>checking</code>事件，然后去加载 Manifest 文件。</p>
<ul>
<li>如果应用已经储存，并且 Manifest 文件没有变化，那么触发<code>noupdate</code>事件。</li>
<li>如果应用已经储存，并且 Manifest 文件有变化，那么触发<code>downloading</code>事件，浏览器重新下载所有离线资源。下载过程中，触发<code>progress</code>事件，下载结束触发<code>updateready</code>事件。</li>
<li>如果应用没有储存，下载结束将触发<code>cached</code>事件。</li>
<li>如果离线，无法检查 Manifest 文件，浏览器会触发一个<code>error</code>事件。</li>
<li>如果浏览器在线，而且应用已经储存，但是 Manifest 文件返回 404，浏览器触发<code>obsolete</code>事件，将储存的应用移除。</li>
</ul>
<p>所有这些事件都是可以取消的。监听函数可以返回<code>false</code>，取消这些事件的默认动作。</p>
<p><code>applicationCache. status</code>属性返回离线储存的状态。</p>
<ul>
<li>ApplicationCache.UNCACHED (0)<br>This application does not have a manifest attribute: it is not cached.</li>
<li>ApplicationCache.IDLE (1)<br>The manifest has been checked and this application is cached and up to date.</li>
<li>ApplicationCache.CHECKING (2)<br>The browser is checking the manifest file.</li>
<li>ApplicationCache.DOWNLOADING (3)<br>The browser is downloading and caching files listed in the manifest.</li>
<li>ApplicationCache.UPDATEREADY (4)<br>A new version of the application has been downloaded and cached.</li>
<li>ApplicationCache.OBSOLETE (5)<br>The manifest no longer exists and the cache will be deleted.</li>
</ul>
<h2 id="Page-Lifecycle-API"><a href="#Page-Lifecycle-API" class="headerlink" title="Page Lifecycle API"></a>Page Lifecycle API</h2><p>Android、iOS 和最新的 Windows 系统可以随时自主地停止后台进程，及时释放系统资源。也就是说，网页可能随时被系统丢弃掉。以前的浏览器 API 完全没有考虑到这种情况，导致开发者根本没有办法监听到系统丢弃页面。</p>
<p>为了解决这个问题，W3C 新制定了一个 Page Lifecycle API，统一了网页从诞生到卸载的行为模式，并且定义了新的事件，允许开发者响应网页状态的各种转换。</p>
<p>有了这个 API，开发者就可以预测网页下一步的状态，从而进行各种针对性的处理。Chrome 68 支持这个 API，对于老式浏览器可以使用谷歌开发的兼容库 <a target="_blank" rel="noopener" href="https://github.com/GoogleChromeLabs/page-lifecycle">PageLifecycle.js</a>。</p>
<h3 id="生命周期阶段"><a href="#生命周期阶段" class="headerlink" title="生命周期阶段"></a>生命周期阶段</h3><p>网页的生命周期分成六个阶段，每个时刻只可能处于其中一个阶段。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071415532.png"></p>
<p><strong>（1）Active 阶段</strong></p>
<p>在 Active 阶段，网页处于可见状态，且拥有输入焦点。</p>
<p><strong>（2）Passive 阶段</strong></p>
<p>在 Passive 阶段，网页可见，但没有输入焦点，无法接受输入。UI 更新（比如动画）仍然在执行。该阶段只可能发生在桌面同时有多个窗口的情况。</p>
<p><strong>（3）Hidden 阶段</strong></p>
<p>在 Hidden 阶段，用户的桌面被其他窗口占据，网页不可见，但尚未冻结。UI 更新不再执行。</p>
<p><strong>（4）Terminated 阶段</strong></p>
<p>在 Terminated 阶段，由于用户主动关闭窗口，或者在同一个窗口前往其他页面，导致当前页面开始被浏览器卸载并从内存中清除。注意，这个阶段总是在 Hidden 阶段之后发生，也就是说，用户主动离开当前页面，总是先进入 Hidden 阶段，再进入 Terminated 阶段。</p>
<p>这个阶段会导致网页卸载，任何新任务都不会在这个阶段启动，并且如果运行时间太长，正在进行的任务可能会被终止。</p>
<p><strong>（5）Frozen 阶段</strong></p>
<p>如果网页处于 Hidden 阶段的时间过久，用户又不关闭网页，浏览器就有可能冻结网页，使其进入 Frozen 阶段。不过，也有可能，处于可见状态的页面长时间没有操作，也会进入 Frozen 阶段。</p>
<p>这个阶段的特征是，网页不会再被分配 CPU 计算资源。定时器、回调函数、网络请求、DOM 操作都不会执行，不过正在运行的任务会执行完。浏览器可能会允许 Frozen 阶段的页面，周期性复苏一小段时间，短暂变回 Hidden 状态，允许一小部分任务执行。</p>
<p><strong>（6）Discarded 阶段</strong></p>
<p>如果网页长时间处于 Frozen 阶段，用户又不唤醒页面，那么就会进入 Discarded 阶段，即浏览器自动卸载网页，清除该网页的内存占用。不过，Passive 阶段的网页如果长时间没有互动，也可能直接进入 Discarded 阶段。</p>
<p>这一般是在用户没有介入的情况下，由系统强制执行。任何类型的新任务或 JavaScript 代码，都不能在此阶段执行，因为这时通常处在资源限制的状况下。</p>
<p>网页被浏览器自动 Discarded 以后，它的 Tab 窗口还是在的。如果用户重新访问这个 Tab 页，浏览器将会重新向服务器发出请求，再一次重新加载网页，回到 Active 阶段。</p>
<h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><p>以下是几个常见场景的网页生命周期变化。</p>
<p>（1）用户打开网页后，又切换到其他 App，但只过了一会又回到网页。</p>
<p>网页由 Active 变成 Hidden，又变回 Active。</p>
<p>（2）用户打开网页后，又切换到其他 App，并且长时候使用后者，导致系统自动丢弃网页。</p>
<p>网页由 Active 变成 Hidden，再变成 Frozen，最后 Discarded。</p>
<p>（3）用户打开网页后，又切换到其他 App，然后从任务管理器里面将浏览器进程清除。</p>
<p>网页由 Active 变成 Hidden，然后 Terminated。</p>
<p>（4）系统丢弃了某个 Tab 里面的页面后，用户重新打开这个 Tab。</p>
<p>网页由 Discarded 变成 Active。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>生命周期的各个阶段都有自己的事件，以供开发者指定监听函数。这些事件里面，只有两个是新定义的（<code>freeze</code>事件和<code>resume</code>事件），其它都是现有的。</p>
<p>注意，网页的生命周期事件是在所有帧（frame）触发，不管是底层的帧，还是内嵌的帧。也就是说，内嵌的<code>&lt;iframe&gt;</code>网页跟顶层网页一样，都会同时监听到下面的事件。</p>
<h4 id="focus-事件"><a href="#focus-事件" class="headerlink" title="focus 事件"></a>focus 事件</h4><p><code>focus</code>事件在页面获得输入焦点时触发，比如网页从 Passive 阶段变为 Active 阶段。</p>
<h4 id="blur-事件"><a href="#blur-事件" class="headerlink" title="blur 事件"></a>blur 事件</h4><p><code>blur</code>事件在页面失去输入焦点时触发，比如网页从 Active 阶段变为 Passive 阶段。</p>
<h4 id="visibilitychange-事件"><a href="#visibilitychange-事件" class="headerlink" title="visibilitychange 事件"></a>visibilitychange 事件</h4><p><code>visibilitychange</code>事件在网页可见状态发生变化时触发，一般发生在以下几种场景。</p>
<blockquote>
<ul>
<li>用户隐藏页面（切换 Tab、最小化浏览器），页面由 Active 阶段变成 Hidden 阶段。</li>
<li>用户重新访问隐藏的页面，页面由 Hidden 阶段变成 Active 阶段。</li>
<li>用户关闭页面，页面会先进入 Hidden 阶段，然后进入 Terminated 阶段。</li>
</ul>
</blockquote>
<p>可以通过<code>document.onvisibilitychange</code>属性指定这个事件的回调函数。</p>
<h4 id="freeze-事件"><a href="#freeze-事件" class="headerlink" title="freeze 事件"></a>freeze 事件</h4><p><code>freeze</code>事件在网页进入 Frozen 阶段时触发。</p>
<p>可以通过<code>document.onfreeze</code>属性指定在进入 Frozen 阶段时调用的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleFreeze</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// Handle transition to FROZEN</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;freeze&#x27;</span>, handleFreeze);</span><br><span class="line"></span><br><span class="line">## 或者</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">onfreeze</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; … &#125;</span><br></pre></td></tr></table></figure>

<p>这个事件的监听函数，最长只能运行500毫秒。并且只能复用已经打开的网络连接，不能发起新的网络请求。</p>
<p>注意，从 Frozen 阶段进入 Discarded 阶段，不会触发任何事件，无法指定回调函数，只能在进入 Frozen 阶段时指定回调函数。</p>
<h4 id="resume-事件"><a href="#resume-事件" class="headerlink" title="resume 事件"></a>resume 事件</h4><p><code>resume</code>事件在网页离开 Frozen 阶段，变为 Active &#x2F; Passive &#x2F; Hidden 阶段时触发。</p>
<p><code>document.onresume</code>属性指的是页面离开 Frozen 阶段、进入可用状态时调用的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleResume</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// handle state transition FROZEN -&gt; ACTIVE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resume&quot;</span>, handleResume);</span><br><span class="line"></span><br><span class="line">## 或者</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">onresume</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; … &#125;</span><br></pre></td></tr></table></figure>

<h4 id="pageshow-事件"><a href="#pageshow-事件" class="headerlink" title="pageshow 事件"></a>pageshow 事件</h4><p><code>pageshow</code>事件在用户加载网页时触发。这时，有可能是全新的页面加载，也可能是从缓存中获取的页面。如果是从缓存中获取，则该事件对象的<code>event.persisted</code>属性为<code>true</code>，否则为<code>false</code>。</p>
<p>这个事件的名字有点误导，它跟页面的可见性其实毫无关系，只跟浏览器的 History 记录的变化有关。</p>
<h4 id="pagehide-事件"><a href="#pagehide-事件" class="headerlink" title="pagehide 事件"></a>pagehide 事件</h4><p><code>pagehide</code>事件在用户离开当前网页、进入另一个网页时触发。它的前提是浏览器的 History 记录必须发生变化，跟网页是否可见无关。</p>
<p>如果浏览器能够将当前页面添加到缓存以供稍后重用，则事件对象的<code>event.persisted</code>属性为<code>true</code>。 如果为<code>true</code>。如果页面添加到了缓存，则页面进入 Frozen 状态，否则进入 Terminatied 状态。</p>
<h4 id="beforeunload-事件"><a href="#beforeunload-事件" class="headerlink" title="beforeunload 事件"></a>beforeunload 事件</h4><p><code>beforeunload</code>事件在窗口或文档即将卸载时触发。该事件发生时，文档仍然可见，此时卸载仍可取消。经过这个事件，网页进入 Terminated 状态。</p>
<h4 id="unload-事件"><a href="#unload-事件" class="headerlink" title="unload 事件"></a>unload 事件</h4><p><code>unload</code>事件在页面正在卸载时触发。经过这个事件，网页进入 Terminated 状态。</p>
<h3 id="获取当前阶段"><a href="#获取当前阶段" class="headerlink" title="获取当前阶段"></a>获取当前阶段</h3><p>如果网页处于 Active、Passive 或 Hidden 阶段，可以通过下面的代码，获得网页当前的状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getState</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">visibilityState</span> === <span class="string">&#x27;hidden&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hidden&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="title function_">hasFocus</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;active&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;passive&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果网页处于 Frozen 和 Terminated 状态，由于定时器代码不会执行，只能通过事件监听判断状态。进入 Frozen 阶段，可以监听<code>freeze</code>事件；进入 Terminated 阶段，可以监听<code>pagehide</code>事件。</p>
<h3 id="document-wasDiscarded"><a href="#document-wasDiscarded" class="headerlink" title="document.wasDiscarded"></a>document.wasDiscarded</h3><p>如果某个选项卡处于 Frozen 阶段，就随时有可能被系统丢弃，进入 Discarded 阶段。如果后来用户再次点击该选项卡，浏览器会重新加载该页面。</p>
<p>这时，开发者可以通过判断<code>document.wasDiscarded</code>属性，了解先前的网页是否被丢弃了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">wasDiscarded</span>) &#123;</span><br><span class="line">    <span class="comment">// 该网页已经不是原来的状态了，曾经被浏览器丢弃过</span></span><br><span class="line">    <span class="comment">// 恢复以前的状态</span></span><br><span class="line">    <span class="title function_">getPersistedState</span>(self.<span class="property">discardedClientId</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，<code>window</code>对象上会新增<code>window.clientId</code>和<code>window.discardedClientId</code>两个属性，用来恢复丢弃前的状态。</p>
<h3 id="参考链接-6"><a href="#参考链接-6" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/web/updates/2018/07/page-lifecycle-api">Page Lifecycle API</a>, Philip Walton</li>
<li><a target="_blank" rel="noopener" href="https://github.com/WICG/page-lifecycle">Lifecycle API for Web Pages</a>, W3C</li>
<li><a target="_blank" rel="noopener" href="https://wicg.github.io/page-lifecycle/spec.html">Page Lifecycle 1 Editor’s Draft</a>, W3C</li>
</ul>
<h2 id="Page-Visibility-API"><a href="#Page-Visibility-API" class="headerlink" title="Page Visibility API"></a>Page Visibility API</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>有时候，开发者需要知道，用户正在离开页面。常用的方法是监听下面三个事件。</p>
<blockquote>
<ul>
<li><code>pagehide</code></li>
<li><code>beforeunload</code></li>
<li><code>unload</code></li>
</ul>
</blockquote>
<p>但是，这些事件在手机上可能不会触发，页面就直接关闭了。因为手机系统可以将一个进程直接转入后台，然后杀死。</p>
<blockquote>
<ul>
<li>用户点击了一条系统通知，切换到另一个 App。</li>
<li>用户进入任务切换窗口，切换到另一个 App。</li>
<li>用户点击了 Home 按钮，切换回主屏幕。</li>
<li>操作系统自动切换到另一个 App（比如，收到一个电话）。</li>
</ul>
</blockquote>
<p>上面这些情况，都会导致手机将浏览器进程切换到后台，然后为了节省资源，可能就会杀死浏览器进程。</p>
<p>以前，页面被系统切换，以及系统清除浏览器进程，是无法监听到的。开发者想要指定，任何一种页面卸载情况下都会执行的代码，也是无法做到的。为了解决这个问题，就诞生了 Page Visibility API。不管手机或桌面电脑，所有情况下，这个 API 都会监听到页面的可见性发生变化。</p>
<p>这个新的 API 的意义在于，通过监听网页的可见性，可以预判网页的卸载，还可以用来节省资源，减缓电能的消耗。比如，一旦用户不看网页，下面这些网页行为都是可以暂停的。</p>
<blockquote>
<ul>
<li>对服务器的轮询</li>
<li>网页动画</li>
<li>正在播放的音频或视频</li>
</ul>
</blockquote>
<h3 id="document-visibilityState"><a href="#document-visibilityState" class="headerlink" title="document.visibilityState"></a>document.visibilityState</h3><p>这个 API 主要在<code>document</code>对象上，新增了一个<code>document.visibilityState</code>属性。该属性返回一个字符串，表示页面当前的可见性状态，共有三个可能的值。</p>
<blockquote>
<ul>
<li><code>hidden</code>：页面彻底不可见。</li>
<li><code>visible</code>：页面至少一部分可见。</li>
<li><code>prerender</code>：页面即将或正在渲染，处于不可见状态。</li>
</ul>
</blockquote>
<p>其中，<code>hidden</code>状态和<code>visible</code>状态是所有浏览器都必须支持的。<code>prerender</code>状态只在支持“预渲染”的浏览器上才会出现，比如 Chrome 浏览器就有预渲染功能，可以在用户不可见的状态下，预先把页面渲染出来，等到用户要浏览的时候，直接展示渲染好的网页。</p>
<p>只要页面可见，哪怕只露出一个角，<code>document.visibilityState</code>属性就返回<code>visible</code>。只有以下四种情况，才会返回<code>hidden</code>。</p>
<blockquote>
<ul>
<li>浏览器最小化。</li>
<li>浏览器没有最小化，但是当前页面切换成了背景页。</li>
<li>浏览器将要卸载（unload）页面。</li>
<li>操作系统触发锁屏屏幕。</li>
</ul>
</blockquote>
<p>可以看到，上面四种场景涵盖了页面可能被卸载的所有情况。也就是说，页面卸载之前，<code>document.visibilityState</code>属性一定会变成<code>hidden</code>。事实上，这也是设计这个 API 的主要目的。</p>
<p>另外，早期版本的 API，这个属性还有第四个值<code>unloaded</code>，表示页面即将卸载，现在已经被废弃了。</p>
<p>注意，<code>document.visibilityState</code>属性只针对顶层窗口，内嵌的<code>&lt;iframe&gt;</code>页面的<code>document.visibilityState</code>属性由顶层窗口决定。使用 CSS 属性隐藏<code>&lt;iframe&gt;</code>页面（比如<code>display: none;</code>），并不会影响内嵌页面的可见性。</p>
<h3 id="document-hidden"><a href="#document-hidden" class="headerlink" title="document.hidden"></a>document.hidden</h3><p>由于历史原因，这个 API 还定义了<code>document.hidden</code>属性。该属性只读，返回一个布尔值，表示当前页面是否可见。</p>
<p>当<code>document.visibilityState</code>属性返回<code>visible</code>时，<code>document.hidden</code>属性返回<code>false</code>；其他情况下，都返回<code>true</code>。</p>
<p>该属性只是出于历史原因而保留的，只要有可能，都应该使用<code>document.visibilityState</code>属性，而不是使用这个属性。</p>
<h3 id="visibilitychange-事件-1"><a href="#visibilitychange-事件-1" class="headerlink" title="visibilitychange 事件"></a>visibilitychange 事件</h3><p>只要<code>document.visibilityState</code>属性发生变化，就会触发<code>visibilitychange</code>事件。因此，可以通过监听这个事件（通过<code>document.addEventListener()</code>方法或<code>document.onvisibilitychange</code>属性），跟踪页面可见性的变化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;visibilitychange&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 用户离开了当前页面</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">visibilityState</span> === <span class="string">&#x27;hidden&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;页面不可见&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户打开或回到页面</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">visibilityState</span> === <span class="string">&#x27;visible&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;页面可见&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码是 Page Visibility API 的最基本用法，可以监听可见性变化。</p>
<p>下面是另一个例子，一旦页面不可见，就暂停视频播放。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vidElem = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;video-demo&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;visibilitychange&#x27;</span>, startStopVideo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">startStopVideo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">visibilityState</span> === <span class="string">&#x27;hidden&#x27;</span>) &#123;</span><br><span class="line">        vidElem.<span class="title function_">pause</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">visibilityState</span> === <span class="string">&#x27;visible&#x27;</span>) &#123;</span><br><span class="line">        vidElem.<span class="title function_">play</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="页面卸载"><a href="#页面卸载" class="headerlink" title="页面卸载"></a>页面卸载</h3><p>下面专门讨论一下，如何正确监听页面卸载。</p>
<p>页面卸载可以分成三种情况。</p>
<blockquote>
<ul>
<li>页面可见时，用户关闭 Tab 页或浏览器窗口。</li>
<li>页面可见时，用户在当前窗口前往另一个页面。</li>
<li>页面不可见时，用户或系统关闭浏览器窗口。</li>
</ul>
</blockquote>
<p>这三种情况，都会触发<code>visibilitychange</code>事件。前两种情况，该事件在用户离开页面时触发；最后一种情况，该事件在页面从可见状态变为不可见状态时触发。</p>
<p>由此可见，<code>visibilitychange</code>事件比<code>pagehide</code>、<code>beforeunload</code>、<code>unload</code>事件更可靠，所有情况下都会触发（从<code>visible</code>变为<code>hidden</code>）。因此，可以只监听这个事件，运行页面卸载时需要运行的代码，不用监听后面那三个事件。</p>
<p>甚至可以这样说，<code>unload</code>事件在任何情况下都不必监听，<code>beforeunload</code>事件只有一种适用场景，就是用户修改了表单，没有提交就离开当前页面。另一方面，指定了这两个事件的监听函数，浏览器就不会缓存当前页面。</p>
<h3 id="参考链接-7"><a href="#参考链接-7" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://w3c.github.io/page-visibility/">Page Visibility Level 2</a>, W3C</li>
<li><a target="_blank" rel="noopener" href="http://davidwalsh.name/page-visibility">Page Visibility API</a>, David Walsh</li>
<li><a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/pagevisibility/intro/">Using the pageVisbility API</a>, Joe Marini</li>
<li><a target="_blank" rel="noopener" href="http://blogs.msdn.com/b/ie/archive/2011/07/08/using-pc-hardware-more-efficiently-in-html5-new-web-performance-apis-part-2.aspx">Using PC Hardware more efficiently in HTML5: New Web Performance APIs, Part 2</a>, Jatinder Mann</li>
<li><a target="_blank" rel="noopener" href="https://www.igvita.com/2015/11/20/dont-lose-user-and-app-state-use-page-visibility/">Don’t lose user and app state, use Page Visibility</a>, Ilya Grigorik</li>
</ul>
<h2 id="Point-lock-API"><a href="#Point-lock-API" class="headerlink" title="Point lock API"></a>Point lock API</h2><p>不用释放按钮，就锁定鼠标。</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API">https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API</a></p>
<h2 id="Server-Sent-Events"><a href="#Server-Sent-Events" class="headerlink" title="Server-Sent Events"></a>Server-Sent Events</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>服务器向客户端推送数据，有很多解决方案。除了“轮询” 和 WebSocket，HTML 5 还提供了 Server-Sent Events（以下简称 SSE）。</p>
<p>一般来说，HTTP 协议只能客户端向服务器发起请求，服务器不能主动向客户端推送。但是有一种特殊情况，就是服务器向客户端声明，接下来要发送的是流信息（streaming）。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流。本质上，这种通信就是以流信息的方式，完成一次用时很长的下载。</p>
<p>SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 HTTP 协议，目前除了 IE&#x2F;Edge，其他浏览器都支持。</p>
<h3 id="与-WebSocket-的比较"><a href="#与-WebSocket-的比较" class="headerlink" title="与 WebSocket 的比较"></a>与 WebSocket 的比较</h3><p>SSE 与 WebSocket 作用相似，都是建立浏览器与服务器之间的通信渠道，然后服务器向浏览器推送信息。</p>
<p>总体来说，WebSocket 更强大和灵活。因为它是全双工通道，可以双向通信；SSE 是单向通道，只能服务器向浏览器发送，因为 streaming 本质上就是下载。如果浏览器向服务器发送信息，就变成了另一次 HTTP 请求。</p>
<p>但是，SSE 也有自己的优点。</p>
<ul>
<li>SSE 使用 HTTP 协议，现有的服务器软件都支持。WebSocket 是一个独立协议。</li>
<li>SSE 属于轻量级，使用简单；WebSocket 协议相对复杂。</li>
<li>SSE 默认支持断线重连，WebSocket 需要自己实现断线重连。</li>
<li>SSE 一般只用来传送文本，二进制数据需要编码后传送，WebSocket 默认支持传送二进制数据。</li>
<li>SSE 支持自定义发送的消息类型。</li>
</ul>
<p>因此，两者各有特点，适合不同的场合。</p>
<h3 id="客户端-API"><a href="#客户端-API" class="headerlink" title="客户端 API"></a>客户端 API</h3><h4 id="EventSource-对象"><a href="#EventSource-对象" class="headerlink" title="EventSource 对象"></a>EventSource 对象</h4><p>SSE 的客户端 API 部署在<code>EventSource</code>对象上。下面的代码可以检测浏览器是否支持 SSE。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;EventSource&#x27;</span> <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 SSE 时，浏览器首先生成一个<code>EventSource</code>实例，向服务器发起连接。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> <span class="title class_">EventSource</span>(url);</span><br></pre></td></tr></table></figure>

<p>上面的<code>url</code>可以与当前网址同域，也可以跨域。跨域时，可以指定第二个参数，打开<code>withCredentials</code>属性，表示是否一起发送 Cookie。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> <span class="title class_">EventSource</span>(url, &#123; <span class="attr">withCredentials</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="readyState-属性"><a href="#readyState-属性" class="headerlink" title="readyState 属性"></a>readyState 属性</h4><p><code>EventSource</code>实例的<code>readyState</code>属性，表明连接的当前状态。该属性只读，可以取以下值。</p>
<ul>
<li>0：相当于常量<code>EventSource.CONNECTING</code>，表示连接还未建立，或者断线正在重连。</li>
<li>1：相当于常量<code>EventSource.OPEN</code>，表示连接已经建立，可以接受数据。</li>
<li>2：相当于常量<code>EventSource.CLOSED</code>，表示连接已断，且不会重连。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> source = <span class="keyword">new</span> <span class="title class_">EventSource</span>(url);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(source.<span class="property">readyState</span>);</span><br></pre></td></tr></table></figure>

<h4 id="url-属性"><a href="#url-属性" class="headerlink" title="url 属性"></a>url 属性</h4><p><code>EventSource</code>实例的<code>url</code>属性返回连接的网址，该属性只读。</p>
<h4 id="withCredentials-属性"><a href="#withCredentials-属性" class="headerlink" title="withCredentials 属性"></a>withCredentials 属性</h4><p><code>EventSource</code>实例的<code>withCredentials</code>属性返回一个布尔值，表示当前实例是否开启 CORS 的<code>withCredentials</code>。该属性只读，默认是<code>false</code>。</p>
<h4 id="onopen-属性"><a href="#onopen-属性" class="headerlink" title="onopen 属性"></a>onopen 属性</h4><p>连接一旦建立，就会触发<code>open</code>事件，可以在<code>onopen</code>属性定义回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">source.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line">source.<span class="title function_">addEventListener</span>(<span class="string">&#x27;open&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h4 id="onmessage-属性"><a href="#onmessage-属性" class="headerlink" title="onmessage 属性"></a>onmessage 属性</h4><p>客户端收到服务器发来的数据，就会触发<code>message</code>事件，可以在<code>onmessage</code>属性定义回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">source.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">var</span> origin = event.<span class="property">origin</span>;</span><br><span class="line">    <span class="keyword">var</span> lastEventId = event.<span class="property">lastEventId</span>;</span><br><span class="line">    <span class="comment">// handle message</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line">source.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">var</span> origin = event.<span class="property">origin</span>;</span><br><span class="line">    <span class="keyword">var</span> lastEventId = event.<span class="property">lastEventId</span>;</span><br><span class="line">    <span class="comment">// handle message</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，参数对象<code>event</code>有如下属性。</p>
<ul>
<li><code>data</code>：服务器端传回的数据（文本格式）。</li>
<li><code>origin</code>： 服务器 URL 的域名部分，即协议、域名和端口，表示消息的来源。</li>
<li><code>lastEventId</code>：数据的编号，由服务器端发送。如果没有编号，这个属性为空。</li>
</ul>
<h4 id="onerror-属性"><a href="#onerror-属性" class="headerlink" title="onerror 属性"></a>onerror 属性</h4><p>如果发生通信错误（比如连接中断），就会触发<code>error</code>事件，可以在<code>onerror</code>属性定义回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">source.<span class="property">onerror</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// handle error event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line">source.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// handle error event</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><p>默认情况下，服务器发来的数据，总是触发浏览器<code>EventSource</code>实例的<code>message</code>事件。开发者还可以自定义 SSE 事件，这种情况下，发送回来的数据不会触发<code>message</code>事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">source.<span class="title function_">addEventListener</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.<span class="property">data</span>;</span><br><span class="line">    <span class="keyword">var</span> origin = event.<span class="property">origin</span>;</span><br><span class="line">    <span class="keyword">var</span> lastEventId = event.<span class="property">lastEventId</span>;</span><br><span class="line">    <span class="comment">// handle message</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，浏览器对 SSE 的<code>foo</code>事件进行监听。如何实现服务器发送<code>foo</code>事件，请看下文。</p>
<h4 id="close-方法"><a href="#close-方法" class="headerlink" title="close() 方法"></a>close() 方法</h4><p><code>close</code>方法用于关闭 SSE 连接。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source.<span class="title function_">close</span>();</span><br></pre></td></tr></table></figure>

<h3 id="服务器实现"><a href="#服务器实现" class="headerlink" title="服务器实现"></a>服务器实现</h3><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>服务器向浏览器发送的 SSE 数据，必须是 UTF-8 编码的文本，具有如下的 HTTP 头信息。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/event-stream</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p>上面三行之中，第一行的<code>Content-Type</code>必须指定 MIME 类型为<code>event-steam</code>。</p>
<p>每一次发送的信息，由若干个<code>message</code>组成，每个<code>message</code>之间用<code>\n\n</code>分隔。每个<code>message</code>内部由若干行组成，每一行都是如下格式。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[field]: value\n</span><br></pre></td></tr></table></figure>

<p>上面的<code>field</code>可以取四个值。</p>
<ul>
<li>data</li>
<li>event</li>
<li>id</li>
<li>retry</li>
</ul>
<p>此外，还可以有冒号开头的行，表示注释。通常，服务器每隔一段时间就会向浏览器发送一个注释，保持连接不中断。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">: This is a comment</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">: this is a test stream\n\n</span><br><span class="line"></span><br><span class="line">data: some text\n\n</span><br><span class="line"></span><br><span class="line">data: another message\n</span><br><span class="line">data: with two lines \n\n</span><br></pre></td></tr></table></figure>

<h4 id="data-字段"><a href="#data-字段" class="headerlink" title="data 字段"></a>data 字段</h4><p>数据内容用<code>data</code>字段表示。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data:  message\n\n</span><br></pre></td></tr></table></figure>

<p>如果数据很长，可以分成多行，最后一行用<code>\n\n</code>结尾，前面行都用<code>\n</code>结尾。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data: begin message\n</span><br><span class="line">data: continue message\n\n</span><br></pre></td></tr></table></figure>

<p>下面是一个发送 JSON 数据的例子。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;\n</span><br><span class="line">data: &quot;foo&quot;: &quot;bar&quot;,\n</span><br><span class="line">data: &quot;baz&quot;, 555\n</span><br><span class="line">data: &#125;\n\n</span><br></pre></td></tr></table></figure>

<h4 id="id-字段"><a href="#id-字段" class="headerlink" title="id 字段"></a>id 字段</h4><p>数据标识符用<code>id</code>字段表示，相当于每一条数据的编号。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id: msg1\n</span><br><span class="line">data: message\n\n</span><br></pre></td></tr></table></figure>

<p>浏览器用<code>lastEventId</code>属性读取这个值。一旦连接断线，浏览器会发送一个 HTTP 头，里面包含一个特殊的<code>Last-Event-ID</code>头信息，将这个值发送回来，用来帮助服务器端重建连接。因此，这个头信息可以被视为一种同步机制。</p>
<h4 id="event-字段"><a href="#event-字段" class="headerlink" title="event 字段"></a>event 字段</h4><p><code>event</code>字段表示自定义的事件类型，默认是<code>message</code>事件。浏览器可以用<code>addEventListener()</code>监听该事件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">event: foo\n</span><br><span class="line">data: a foo event\n\n</span><br><span class="line"></span><br><span class="line">data: an unnamed event\n\n</span><br><span class="line"></span><br><span class="line">event: bar\n</span><br><span class="line">data: a bar event\n\n</span><br></pre></td></tr></table></figure>

<p>上面的代码创造了三条信息。第一条的名字是<code>foo</code>，触发浏览器的<code>foo</code>事件；第二条未取名，表示默认类型，触发浏览器的<code>message</code>事件；第三条是<code>bar</code>，触发浏览器的<code>bar</code>事件。</p>
<p>下面是另一个例子。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">event: userconnect</span><br><span class="line">data: &#123;&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:33:48&quot;&#125;</span><br><span class="line"></span><br><span class="line">event: usermessage</span><br><span class="line">data: &#123;&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:34:11&quot;, &quot;text&quot;: &quot;Hi everyone.&quot;&#125;</span><br><span class="line"></span><br><span class="line">event: userdisconnect</span><br><span class="line">data: &#123;&quot;username&quot;: &quot;bobby&quot;, &quot;time&quot;: &quot;02:34:23&quot;&#125;</span><br><span class="line"></span><br><span class="line">event: usermessage</span><br><span class="line">data: &#123;&quot;username&quot;: &quot;sean&quot;, &quot;time&quot;: &quot;02:34:36&quot;, &quot;text&quot;: &quot;Bye, bobby.&quot;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="retry-字段"><a href="#retry-字段" class="headerlink" title="retry 字段"></a>retry 字段</h4><p>服务器可以用<code>retry</code>字段，指定浏览器重新发起连接的时间间隔。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retry: 10000\n</span><br></pre></td></tr></table></figure>

<p>两种情况会导致浏览器重新发起连接：一种是时间间隔到期，二是由于网络错误等原因，导致连接出错。</p>
<h3 id="Node-服务器实例"><a href="#Node-服务器实例" class="headerlink" title="Node 服务器实例"></a>Node 服务器实例</h3><p>SSE 要求服务器与浏览器保持连接。对于不同的服务器软件来说，所消耗的资源是不一样的。Apache 服务器，每个连接就是一个线程，如果要维持大量连接，势必要消耗大量资源。Node 则是所有连接都使用同一个线程，因此消耗的资源会小得多，但是这要求每个连接不能包含很耗时的操作，比如磁盘的 IO 读写。</p>
<p>下面是 Node 的 SSE 服务器<a target="_blank" rel="noopener" href="http://cjihrig.com/blog/server-sent-events-in-node-js/">实例</a>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fileName = <span class="string">&quot;.&quot;</span> + req.<span class="property">url</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fileName === <span class="string">&quot;./stream&quot;</span>) &#123;</span><br><span class="line">        res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">            <span class="string">&quot;Content-Type&quot;</span>:<span class="string">&quot;text/event-stream&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Cache-Control&quot;</span>:<span class="string">&quot;no-cache&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Connection&quot;</span>:<span class="string">&quot;keep-alive&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Access-Control-Allow-Origin&quot;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">        &#125;);</span><br><span class="line">        res.<span class="title function_">write</span>(<span class="string">&quot;retry: 10000\n&quot;</span>);</span><br><span class="line">        res.<span class="title function_">write</span>(<span class="string">&quot;event: connecttime\n&quot;</span>);</span><br><span class="line">        res.<span class="title function_">write</span>(<span class="string">&quot;data: &quot;</span> + (<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">        res.<span class="title function_">write</span>(<span class="string">&quot;data: &quot;</span> + (<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        interval = <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            res.<span class="title function_">write</span>(<span class="string">&quot;data: &quot;</span> + (<span class="keyword">new</span> <span class="title class_">Date</span>()) + <span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        req.<span class="property">connection</span>.<span class="title function_">addListener</span>(<span class="string">&quot;close&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">        &#125;, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8844</span>, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="参考链接-8"><a href="#参考链接-8" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li>Colin Ihrig, <a target="_blank" rel="noopener" href="http://jspro.com/apis/implementing-push-technology-using-server-sent-events/">Implementing Push Technology Using Server-Sent Events</a></li>
<li>Colin Ihrig，<a target="_blank" rel="noopener" href="http://cjihrig.com/blog/the-server-side-of-server-sent-events/">The Server Side of Server-Sent Events</a></li>
<li>Eric Bidelman, <a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/eventsource/basics/">Stream Updates with Server-Sent Events</a></li>
<li>MDN，<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Server-sent_events/Using_server-sent_events">Using server-sent events</a></li>
<li>Segment.io, <a target="_blank" rel="noopener" href="https://segment.io/blog/2014-04-03-server-sent-events-the-simplest-realtime-browser-spec/">Server-Sent Events: The simplest realtime browser spec</a></li>
</ul>
<h2 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>Service Worker 首先是一个运行在后台的 Worker 线程，然后它会长期运行，充当一个服务，很适合那些不需要网页或用户互动的功能。它的最常见用途就是拦截和处理网络请求。</p>
<p>Service Worker 是一个后台运行的脚本，充当一个代理服务器，拦截用户发出的网络请求，比如加载脚本和图片。Service Worker 可以修改用户的请求，或者直接向用户发出回应，不用联系服务器，这使得用户可以在离线情况下使用网络应用。它还可以在本地缓存资源文件，直接从缓存加载文件，因此可以加快访问速度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;/service-worker.js&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码确认浏览器支持 Service Worker 以后，会注册一个 Service Worker。</p>
<p>为了节省内存，Service worker 在不使用的时候是休眠的。它也不会保存数据，所以重新启动的时候，为了拿到数据，最好把数据放在 IndexedDb 里面。</p>
<p>Service Worker 是事件驱动的。</p>
<p>下面是拦截请求的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;fetch&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.<span class="title function_">waitUntil</span>(</span><br><span class="line">    <span class="keyword">if</span> (event.<span class="property">request</span>.<span class="property">url</span>.<span class="title function_">includes</span>(<span class="params"><span class="string">&#x27;/product&#x27;</span></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> productId = event.<span class="property">data</span>.<span class="property">productId</span></span><br><span class="line">        <span class="keyword">let</span> productCount = <span class="title function_">getProductData</span>(productId)</span><br><span class="line">        indexedDB.<span class="title function_">open</span>(<span class="string">&#x27;store&#x27;</span>, <span class="number">1</span>, <span class="function">(<span class="params">db</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> productStore = db.<span class="title function_">createObjectStore</span>(<span class="string">&#x27;products&#x27;</span>, &#123; <span class="attr">keyPath</span>: <span class="string">&#x27;id&#x27;</span> &#125;)</span><br><span class="line">            productStore.<span class="title function_">put</span>(&#123; <span class="attr">id</span>: productId, <span class="attr">count</span>: ++productCount &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Service Worker 不能直接操作 DOM。</p>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><h4 id="登记"><a href="#登记" class="headerlink" title="登记"></a>登记</h4><p>使用 service worker 的第一步，就是告诉浏览器，需要注册一个 service worker 脚本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;sw.js&#x27;</span>.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&#x27;注册成功&#x27;</span>)</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;注册失败&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面代码的<code>sw.js</code>就是需要浏览器注册的 service worker 脚本。注意，这个脚本必须与当前网址同域，service worker 不支持跨域脚本。另外，<code>sw.js</code>必须是从 HTTPS 协议加载的。</p>
<p>默认情况下，Service worker 只对根目录<code>/</code>生效，如果要改变生效范围，可以运行下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(</span><br><span class="line">    <span class="string">&#x27;/service-worker.js&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">scope</span>: <span class="string">&#x27;/products/fashion&#x27;</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>一旦登记成功，接下来都是 service worker 脚本的工作。下面的代码都是写在 service worker 脚本里面的。</p>
<p>登记后，就会触发<code>install</code>事件。service worker 脚本需要监听这个事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;install&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    event.<span class="title function_">waitUntil</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&#x27;安装完成&#x27;</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>event.waitUntil()</code>方法为事件完成后指定回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;install&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable constant_">CACHE_NAME</span> = <span class="string">&#x27;xyz-cache&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> urlsToCache = [</span><br><span class="line">        <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/styles/main.css&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;/scripts/bundle.js&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">    event.<span class="title function_">waitUntil</span>(</span><br><span class="line">        caches.<span class="title function_">open</span>(<span class="variable constant_">CACHE_NAME</span>)</span><br><span class="line">            .<span class="property">then</span> (<span class="function"><span class="params">cache</span> =&gt;</span> cache.<span class="title function_">addAll</span>(urlsToCache))</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h4><p>安装完成后，service worker 就会等待激活。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;activate&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> cacheWhitelist = [<span class="string">&#x27;products-v2&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    event.<span class="title function_">waitUntil</span>(</span><br><span class="line">        caches.<span class="title function_">keys</span>().<span class="property">then</span> (<span class="function"><span class="params">cacheNames</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>(</span><br><span class="line">                cacheNames.<span class="title function_">map</span>( <span class="function"><span class="params">cacheName</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cacheWhitelist.<span class="title function_">indexOf</span>(cacheName) === -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> caches.<span class="title function_">delete</span>(cacheName)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            )</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Service-Worker-与网页的通信"><a href="#Service-Worker-与网页的通信" class="headerlink" title="Service Worker 与网页的通信"></a>Service Worker 与网页的通信</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;activate&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.<span class="title function_">waitUntil</span>(</span><br><span class="line">        self.<span class="property">clients</span>.<span class="title function_">matchAll</span>().<span class="property">then</span> ( <span class="function">(<span class="params">client</span>) =&gt;</span> &#123;</span><br><span class="line">            client.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line">                <span class="attr">msg</span>: <span class="string">&#x27;Hey, from service worker! I\&#x27;m listening to your fetch requests.&#x27;</span>,</span><br><span class="line">                <span class="attr">source</span>: <span class="string">&#x27;service-worker&#x27;</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面代码中，Service Worker 监听<code>activate</code>事件，然后向客户端发送一条信息。</p>
<p>客户端需要部署消息监听代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="property">source</span> == <span class="string">&#x27;service-worker&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">msg</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="参考链接-9"><a href="#参考链接-9" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://frontendian.co/service-workers">Service Workers</a>, by Ryan Miller</li>
</ul>
<h2 id="SVG-图像"><a href="#SVG-图像" class="headerlink" title="SVG 图像"></a>SVG 图像</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>SVG 是一种基于 XML 语法的图像格式，全称是可缩放矢量图（Scalable Vector Graphics）。其他图像格式都是基于像素处理的，SVG 则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真。</p>
<p>SVG 文件可以直接插入网页，成为 DOM 的一部分，然后用 JavaScript 和 CSS 进行操作。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">&quot;mysvg&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">viewBox</span>=<span class="string">&quot;0 0 800 600&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">preserveAspectRatio</span>=<span class="string">&quot;xMidYMid meet&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">&quot;mycircle&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;400&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;300&quot;</span> <span class="attr">r</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面是 SVG 代码直接插入网页的例子。</p>
<p>SVG 代码也可以写在一个独立文件中，然后用<code>&lt;img&gt;</code>、<code>&lt;object&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;iframe&gt;</code>等标签插入网页。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;circle.svg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">id</span>=<span class="string">&quot;object&quot;</span> <span class="attr">data</span>=<span class="string">&quot;circle.svg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">id</span>=<span class="string">&quot;embed&quot;</span> <span class="attr">src</span>=<span class="string">&quot;icon.svg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;image/svg+xml&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;icon.svg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS 也可以使用 SVG 文件。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.logo</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">icon.svg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SVG 文件还可以转为 BASE64 编码，然后作为 Data URI 写入网页。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;data:image/svg+xml;base64,[data]&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="标签"><a href="#标签" class="headerlink" title="&lt;svg&gt;标签"></a><code>&lt;svg&gt;</code>标签</h4><p>SVG 代码都放在顶层标签<code>&lt;svg&gt;</code>之中。下面是一个例子。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">&quot;mycircle&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;50&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;svg&gt;</code>的<code>width</code>属性和<code>height</code>属性，指定了 SVG 图像在 HTML 元素中所占据的宽度和高度。除了相对单位，也可以采用绝对单位（单位：像素）。如果不指定这两个属性，SVG 图像的大小默认为300像素（宽）x 150像素（高）。</p>
<p>如果只想展示 SVG 图像的一部分，就要指定<code>viewBox</code>属性。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;50 50 50 50&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">&quot;mycircle&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;50&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;viewBox&gt;</code>属性的值有四个数字，分别是左上角的横坐标和纵坐标、视口的宽度和高度。上面代码中，SVG 图像是100像素宽 x 100像素高，<code>viewBox</code>属性指定视口从<code>(50, 50)</code>这个点开始。所以，实际看到的是右下角的四分之一圆。</p>
<p>注意，视口必须适配所在的空间。上面代码中，视口的大小是 50 x 50，由于 SVG 图像的大小是 100 x 100，所以视口会放大去适配 SVG 图像的大小，即放大了四倍。</p>
<p>如果不指定<code>width</code>属性和<code>height</code>属性，只指定<code>viewBox</code>属性，则相当于只给定 SVG 图像的长宽比。这时，SVG 图像的大小默认是所在的 HTML 元素的大小。</p>
<h4 id="标签-1"><a href="#标签-1" class="headerlink" title="&lt;circle&gt;标签"></a><code>&lt;circle&gt;</code>标签</h4><p><code>&lt;circle&gt;</code>标签代表圆形。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;30&quot;</span>  <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;25&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;90&quot;</span>  <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;25&quot;</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;150&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;25&quot;</span> <span class="attr">class</span>=<span class="string">&quot;fancy&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的代码定义了三个圆。<code>&lt;circle&gt;</code>标签的<code>cx</code>、<code>cy</code>、<code>r</code>属性分别为横坐标、纵坐标和半径，单位为像素。坐标都是相对于<code>&lt;svg&gt;</code>画布的左上角原点。</p>
<p><code>class</code>属性用来指定对应的 CSS 类。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.red</span> &#123;</span><br><span class="line">    fill: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.fancy</span> &#123;</span><br><span class="line">    fill: none;</span><br><span class="line">    stroke: black;</span><br><span class="line">    stroke-<span class="attribute">width</span>: <span class="number">3pt</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SVG 的 CSS 属性与网页元素有所不同。</p>
<blockquote>
<ul>
<li>fill：填充色</li>
<li>stroke：描边色</li>
<li>stroke-width：边框宽度</li>
</ul>
</blockquote>
<h4 id="标签-2"><a href="#标签-2" class="headerlink" title="&lt;line&gt;标签"></a><code>&lt;line&gt;</code>标签</h4><p><code>&lt;line&gt;</code>标签用来绘制直线。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;0&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;200&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;0&quot;</span> <span class="attr">style</span>=<span class="string">&quot;stroke:rgb(0,0,0);stroke-width:5&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>&lt;line&gt;</code>标签的<code>x1</code>属性和<code>y1</code>属性，表示线段起点的横坐标和纵坐标；<code>x2</code>属性和<code>y2</code>属性，表示线段终点的横坐标和纵坐标；<code>style</code>属性表示线段的样式。</p>
<h4 id="标签-3"><a href="#标签-3" class="headerlink" title="&lt;polyline&gt;标签"></a><code>&lt;polyline&gt;</code>标签</h4><p><code>&lt;polyline&gt;</code>标签用于绘制一根折线。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polyline</span> <span class="attr">points</span>=<span class="string">&quot;3,3 30,28 3,53&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;black&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;polyline&gt;</code>的<code>points</code>属性指定了每个端点的坐标，横坐标与纵坐标之间与逗号分隔，点与点之间用空格分隔。</p>
<h4 id="标签-4"><a href="#标签-4" class="headerlink" title="&lt;rect&gt;标签"></a><code>&lt;rect&gt;</code>标签</h4><p><code>&lt;rect&gt;</code>标签用于绘制矩形。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">style</span>=<span class="string">&quot;stroke: ##70d5dd; fill: ##dd524b&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;rect&gt;</code>的<code>x</code>属性和<code>y</code>属性，指定了矩形左上角端点的横坐标和纵坐标；<code>width</code>属性和<code>height</code>属性指定了矩形的宽度和高度（单位像素）。</p>
<h4 id="标签-5"><a href="#标签-5" class="headerlink" title="&lt;ellipse&gt;标签"></a><code>&lt;ellipse&gt;</code>标签</h4><p><code>&lt;ellipse&gt;</code>标签用于绘制椭圆。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ellipse</span> <span class="attr">cx</span>=<span class="string">&quot;60&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;60&quot;</span> <span class="attr">ry</span>=<span class="string">&quot;40&quot;</span> <span class="attr">rx</span>=<span class="string">&quot;20&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;black&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;5&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;silver&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;ellipse&gt;</code>的<code>cx</code>属性和<code>cy</code>属性，指定了椭圆中心的横坐标和纵坐标（单位像素）；<code>rx</code>属性和<code>ry</code>属性，指定了椭圆横向轴和纵向轴的半径（单位像素）。</p>
<h4 id="标签-6"><a href="#标签-6" class="headerlink" title="&lt;polygon&gt;标签"></a><code>&lt;polygon&gt;</code>标签</h4><p><code>&lt;polygon&gt;</code>标签用于绘制多边形。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polygon</span> <span class="attr">fill</span>=<span class="string">&quot;green&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;orange&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;1&quot;</span> <span class="attr">points</span>=<span class="string">&quot;0,0 100,0 100,100 0,100 0,0&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;polygon&gt;</code>的<code>points</code>属性指定了每个端点的坐标，横坐标与纵坐标之间与逗号分隔，点与点之间用空格分隔。</p>
<h4 id="标签-7"><a href="#标签-7" class="headerlink" title="&lt;path&gt;标签"></a><code>&lt;path&gt;</code>标签</h4><p><code>&lt;path&gt;</code>标签用于制路径。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">  M 18,3</span></span></span><br><span class="line"><span class="string"><span class="tag">  L 46,3</span></span></span><br><span class="line"><span class="string"><span class="tag">  L 46,40</span></span></span><br><span class="line"><span class="string"><span class="tag">  L 61,40</span></span></span><br><span class="line"><span class="string"><span class="tag">  L 32,68</span></span></span><br><span class="line"><span class="string"><span class="tag">  L 3,40</span></span></span><br><span class="line"><span class="string"><span class="tag">  L 18,40</span></span></span><br><span class="line"><span class="string"><span class="tag">  Z</span></span></span><br><span class="line"><span class="string"><span class="tag">&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;path&gt;</code>的<code>d</code>属性表示绘制顺序，它的值是一个长字符串，每个字母表示一个绘制动作，后面跟着坐标。</p>
<blockquote>
<ul>
<li>M：移动到（moveto）</li>
<li>L：画直线到（lineto）</li>
<li>Z：闭合路径</li>
</ul>
</blockquote>
<h4 id="标签-8"><a href="#标签-8" class="headerlink" title="&lt;text&gt;标签"></a><code>&lt;text&gt;</code>标签</h4><p><code>&lt;text&gt;</code>标签用于绘制文本。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;180&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;50&quot;</span> <span class="attr">y</span>=<span class="string">&quot;25&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;text&gt;</code>的<code>x</code>属性和<code>y</code>属性，表示文本区块基线（baseline）起点的横坐标和纵坐标。文字的样式可以用<code>class</code>或<code>style</code>属性指定。</p>
<h4 id="标签-9"><a href="#标签-9" class="headerlink" title="&lt;use&gt;标签"></a><code>&lt;use&gt;</code>标签</h4><p><code>&lt;use&gt;</code>标签用于复制一个形状。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 30 10&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">&quot;myCircle&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;5&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;5&quot;</span> <span class="attr">r</span>=<span class="string">&quot;4&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;##myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;10&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;##myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;20&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;white&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;use&gt;</code>的<code>href</code>属性指定所要复制的节点，<code>x</code>属性和<code>y</code>属性是<code>&lt;use&gt;</code>左上角的坐标。另外，还可以指定<code>width</code>和<code>height</code>坐标。</p>
<h4 id="标签-10"><a href="#标签-10" class="headerlink" title="&lt;g&gt;标签"></a><code>&lt;g&gt;</code>标签</h4><p><code>&lt;g&gt;</code>标签用于将多个形状组成一个组（group），方便复用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">&quot;myCircle&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;25&quot;</span> <span class="attr">y</span>=<span class="string">&quot;20&quot;</span>&gt;</span>圆形<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;50&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;##myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;100&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;##myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;200&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;white&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="标签-11"><a href="#标签-11" class="headerlink" title="&lt;defs&gt;标签"></a><code>&lt;defs&gt;</code>标签</h4><p><code>&lt;defs&gt;</code>标签用于自定义形状，它内部的代码不会显示，仅供引用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">&quot;myCircle&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;25&quot;</span> <span class="attr">y</span>=<span class="string">&quot;20&quot;</span>&gt;</span>圆形<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">circle</span> <span class="attr">cx</span>=<span class="string">&quot;50&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;##myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;##myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;100&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">use</span> <span class="attr">href</span>=<span class="string">&quot;##myCircle&quot;</span> <span class="attr">x</span>=<span class="string">&quot;200&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;white&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;blue&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="标签-12"><a href="#标签-12" class="headerlink" title="&lt;pattern&gt;标签"></a><code>&lt;pattern&gt;</code>标签</h4><p><code>&lt;pattern&gt;</code>标签用于自定义一个形状，该形状可以被引用来平铺一个区域。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span> <span class="attr">id</span>=<span class="string">&quot;dots&quot;</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">patternUnits</span>=<span class="string">&quot;userSpaceOnUse&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">circle</span> <span class="attr">fill</span>=<span class="string">&quot;##bee9e8&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;50&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;50&quot;</span> <span class="attr">r</span>=<span class="string">&quot;35&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;url(##dots)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>&lt;pattern&gt;</code>标签将一个圆形定义为<code>dots</code>模式。<code>patternUnits=&quot;userSpaceOnUse&quot;</code>表示<code>&lt;pattern&gt;</code>的宽度和长度是实际的像素值。然后，指定这个模式去填充下面的矩形。</p>
<h4 id="标签-13"><a href="#标签-13" class="headerlink" title="&lt;image&gt;标签"></a><code>&lt;image&gt;</code>标签</h4><p><code>&lt;image&gt;</code>标签用于插入图片文件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 100 100&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">image</span> <span class="attr">xlink:href</span>=<span class="string">&quot;path/to/image.jpg&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">width</span>=<span class="string">&quot;50%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50%&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>&lt;image&gt;</code>的<code>xlink:href</code>属性表示图像的来源。</p>
<h4 id="标签-14"><a href="#标签-14" class="headerlink" title="&lt;animate&gt;标签"></a><code>&lt;animate&gt;</code>标签</h4><p><code>&lt;animate&gt;</code>标签用于产生动画效果。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500px&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;##feac5e&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">animate</span> <span class="attr">attributeName</span>=<span class="string">&quot;x&quot;</span> <span class="attr">from</span>=<span class="string">&quot;0&quot;</span> <span class="attr">to</span>=<span class="string">&quot;500&quot;</span> <span class="attr">dur</span>=<span class="string">&quot;2s&quot;</span> <span class="attr">repeatCount</span>=<span class="string">&quot;indefinite&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，矩形会不断移动，产生动画效果。</p>
<p><code>&lt;animate&gt;</code>的属性含义如下。</p>
<blockquote>
<ul>
<li>attributeName：发生动画效果的属性名。</li>
<li>from：单次动画的初始值。</li>
<li>to：单次动画的结束值。</li>
<li>dur：单次动画的持续时间。</li>
<li>repeatCount：动画的循环模式。</li>
</ul>
</blockquote>
<p>可以在多个属性上面定义动画。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animate</span> <span class="attr">attributeName</span>=<span class="string">&quot;x&quot;</span> <span class="attr">from</span>=<span class="string">&quot;0&quot;</span> <span class="attr">to</span>=<span class="string">&quot;500&quot;</span> <span class="attr">dur</span>=<span class="string">&quot;2s&quot;</span> <span class="attr">repeatCount</span>=<span class="string">&quot;indefinite&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">animate</span> <span class="attr">attributeName</span>=<span class="string">&quot;width&quot;</span> <span class="attr">to</span>=<span class="string">&quot;500&quot;</span> <span class="attr">dur</span>=<span class="string">&quot;2s&quot;</span> <span class="attr">repeatCount</span>=<span class="string">&quot;indefinite&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="标签-15"><a href="#标签-15" class="headerlink" title="&lt;animateTransform&gt;标签"></a><code>&lt;animateTransform&gt;</code>标签</h4><p><code>&lt;animate&gt;</code>标签对 CSS 的<code>transform</code>属性不起作用，如果需要变形，就要使用<code>&lt;animateTransform&gt;</code>标签。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;500px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;500px&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;250&quot;</span> <span class="attr">y</span>=<span class="string">&quot;250&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;##4bc0c8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">animateTransform</span> <span class="attr">attributeName</span>=<span class="string">&quot;transform&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rotate&quot;</span> <span class="attr">begin</span>=<span class="string">&quot;0s&quot;</span> <span class="attr">dur</span>=<span class="string">&quot;10s&quot;</span> <span class="attr">from</span>=<span class="string">&quot;0 200 200&quot;</span> <span class="attr">to</span>=<span class="string">&quot;360 400 400&quot;</span> <span class="attr">repeatCount</span>=<span class="string">&quot;indefinite&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>&lt;animateTransform&gt;</code>的效果为旋转（<code>rotate</code>），这时<code>from</code>和<code>to</code>属性值有三个数字，第一个数字是角度值，第二个值和第三个值是旋转中心的坐标。<code>from=&quot;0 200 200&quot;</code>表示开始时，角度为0，围绕<code>(200, 200)</code>开始旋转；<code>to=&quot;360 400 400&quot;</code>表示结束时，角度为360，围绕<code>(400, 400)</code>旋转。</p>
<h3 id="JavaScript-操作"><a href="#JavaScript-操作" class="headerlink" title="JavaScript 操作"></a>JavaScript 操作</h3><h4 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h4><p>如果 SVG 代码直接写在 HTML 网页之中，它就成为网页 DOM 的一部分，可以直接用 DOM 操作。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span></span></span><br><span class="line"><span class="tag">        <span class="attr">id</span>=<span class="string">&quot;mysvg&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">viewBox</span>=<span class="string">&quot;0 0 800 600&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">preserveAspectRatio</span>=<span class="string">&quot;xMidYMid meet&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">circle</span> <span class="attr">id</span>=<span class="string">&quot;mycircle&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;400&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;300&quot;</span> <span class="attr">r</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码插入网页之后，就可以用 CSS 定制样式。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">circle &#123;</span><br><span class="line">    stroke-<span class="attribute">width</span>: <span class="number">5</span>;</span><br><span class="line">    stroke: #<span class="number">#f00</span>;</span><br><span class="line">    fill: #<span class="number">#ff0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">circle<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    stroke: #<span class="number">#090</span>;</span><br><span class="line">    fill: #<span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，可以用 JavaScript 代码操作 SVG。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mycircle = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mycircle&#x27;</span>);</span><br><span class="line"></span><br><span class="line">mycircle.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;circle clicked - enlarging&#x27;</span>);</span><br><span class="line">    mycircle.<span class="title function_">setAttribute</span>(<span class="string">&#x27;r&#x27;</span>, <span class="number">60</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码指定，如果点击图形，就改写<code>circle</code>元素的<code>r</code>属性。</p>
<h4 id="获取-SVG-DOM"><a href="#获取-SVG-DOM" class="headerlink" title="获取 SVG DOM"></a>获取 SVG DOM</h4><p>使用<code>&lt;object&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;embed&gt;</code>标签插入 SVG 文件，可以获取 SVG DOM。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> svgObject = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;object&#x27;</span>).<span class="property">contentDocument</span>;</span><br><span class="line"><span class="keyword">var</span> svgIframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;iframe&#x27;</span>).<span class="property">contentDocument</span>;</span><br><span class="line"><span class="keyword">var</span> svgEmbed = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;embed&#x27;</span>).<span class="title function_">getSVGDocument</span>();</span><br></pre></td></tr></table></figure>

<p>注意，如果使用<code>&lt;img&gt;</code>标签插入 SVG 文件，就无法获取 SVG DOM。</p>
<h4 id="读取-SVG-源码"><a href="#读取-SVG-源码" class="headerlink" title="读取 SVG 源码"></a>读取 SVG 源码</h4><p>由于 SVG 文件就是一段 XML 文本，因此可以通过读取 XML 代码的方式，读取 SVG 源码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;svg-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">svg</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xmlns:xlink</span>=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">xml:space</span>=<span class="string">&quot;preserve&quot;</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;440&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- svg code --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用<code>XMLSerializer</code>实例的<code>serializeToString()</code>方法，获取 SVG 元素的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> svgString = <span class="keyword">new</span> <span class="title class_">XMLSerializer</span>()</span><br><span class="line">    .<span class="title function_">serializeToString</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;svg&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h4 id="SVG-图像转为-Canvas-图像"><a href="#SVG-图像转为-Canvas-图像" class="headerlink" title="SVG 图像转为 Canvas 图像"></a>SVG 图像转为 Canvas 图像</h4><p>首先，需要新建一个<code>Image</code>对象，将 SVG 图像指定到该<code>Image</code>对象的<code>src</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>();</span><br><span class="line"><span class="keyword">var</span> svg = <span class="keyword">new</span> <span class="title class_">Blob</span>([svgString], &#123;<span class="attr">type</span>: <span class="string">&quot;image/svg+xml;charset=utf-8&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="variable constant_">DOMURL</span> = self.<span class="property">URL</span> || self.<span class="property">webkitURL</span> || self;</span><br><span class="line"><span class="keyword">var</span> url = <span class="variable constant_">DOMURL</span>.<span class="title function_">createObjectURL</span>(svg);</span><br><span class="line"></span><br><span class="line">img.<span class="property">src</span> = url;</span><br></pre></td></tr></table></figure>

<p>然后，当图像加载完成后，再将它绘制到<code>&lt;canvas&gt;</code>元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;canvas&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.<span class="title function_">getContext</span>(<span class="string">&#x27;2d&#x27;</span>);</span><br><span class="line">    ctx.<span class="title function_">drawImage</span>(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="实例：折线图"><a href="#实例：折线图" class="headerlink" title="实例：折线图"></a>实例：折线图</h3><p>下面将一张数据表格画成折线图。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Date |Amount</span><br><span class="line">-----|------</span><br><span class="line">2014-01-01 | $10</span><br><span class="line">2014-02-01 | $20</span><br><span class="line">2014-03-01 | $40</span><br><span class="line">2014-04-01 | $80</span><br></pre></td></tr></table></figure>

<p>上面的图形，可以画成一个坐标系，<code>Date</code>作为横轴，<code>Amount</code>作为纵轴，四行数据画成一个数据点。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;350&quot;</span> <span class="attr">height</span>=<span class="string">&quot;160&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">g</span> <span class="attr">class</span>=<span class="string">&quot;layer&quot;</span> <span class="attr">transform</span>=<span class="string">&quot;translate(60,10)&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">r</span>=<span class="string">&quot;5&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;0&quot;</span>   <span class="attr">cy</span>=<span class="string">&quot;105&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">r</span>=<span class="string">&quot;5&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;90&quot;</span>  <span class="attr">cy</span>=<span class="string">&quot;90&quot;</span>  /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">r</span>=<span class="string">&quot;5&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;180&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;60&quot;</span>  /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">circle</span> <span class="attr">r</span>=<span class="string">&quot;5&quot;</span> <span class="attr">cx</span>=<span class="string">&quot;270&quot;</span> <span class="attr">cy</span>=<span class="string">&quot;0&quot;</span>   /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">g</span> <span class="attr">class</span>=<span class="string">&quot;y axis&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;0&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;120&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;-40&quot;</span> <span class="attr">y</span>=<span class="string">&quot;105&quot;</span> <span class="attr">dy</span>=<span class="string">&quot;5&quot;</span>&gt;</span>$10<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;-40&quot;</span> <span class="attr">y</span>=<span class="string">&quot;0&quot;</span>   <span class="attr">dy</span>=<span class="string">&quot;5&quot;</span>&gt;</span>$80<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">g</span> <span class="attr">class</span>=<span class="string">&quot;x axis&quot;</span> <span class="attr">transform</span>=<span class="string">&quot;translate(0, 120)&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">line</span> <span class="attr">x1</span>=<span class="string">&quot;0&quot;</span> <span class="attr">y1</span>=<span class="string">&quot;0&quot;</span> <span class="attr">x2</span>=<span class="string">&quot;270&quot;</span> <span class="attr">y2</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;-30&quot;</span>   <span class="attr">y</span>=<span class="string">&quot;20&quot;</span>&gt;</span>January 2014<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">text</span> <span class="attr">x</span>=<span class="string">&quot;240&quot;</span> <span class="attr">y</span>=<span class="string">&quot;20&quot;</span>&gt;</span>April<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="参考链接-10"><a href="#参考链接-10" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li>Jon McPartland, <a target="_blank" rel="noopener" href="http://bigbitecreative.com/introduction-svg-animation/">An introduction to SVG animation</a></li>
<li>Alexander Goedde, <a target="_blank" rel="noopener" href="http://tavendo.com/blog/post/super-vector-graphics/">SVG - Super Vector Graphics</a></li>
<li>Joseph Wegner, <a target="_blank" rel="noopener" href="http://flippinawesome.org/2014/02/03/learning-svg/">Learning SVG</a></li>
<li>biovisualize, <a target="_blank" rel="noopener" href="http://bl.ocks.org/biovisualize/8187844">Direct svg to canvas to png conversion</a></li>
<li>Tyler Sticka, <a target="_blank" rel="noopener" href="https://cloudfour.com/thinks/cropping-image-thumbnails-with-svg/">Cropping Image Thumbnails with SVG</a></li>
<li>Adi Purdila, <a target="_blank" rel="noopener" href="https://webdesign.tutsplus.com/tutorials/how-to-create-a-loader-icon-with-svg-animations--cms-31542">How to Create a Loader Icon With SVG Animations</a></li>
</ul>
<h2 id="Web-Share-API"><a href="#Web-Share-API" class="headerlink" title="Web Share API"></a>Web Share API</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>网页内容如果要分享到其他应用，通常要自己实现分享接口，逐一给出目标应用的连接方式。这样很麻烦，也对网页性能有一定影响。Web Share API 就是为了解决这个问题而提出的，允许网页调用操作系统的分享接口，实质是 Web App 与本机的应用程序交换信息的一种方式。</p>
<p>这个 API 不仅可以改善网页性能，而且不限制分享目标的数量和类型。社交媒体应用、电子邮件、即时消息、以及本地系统安装的、且接受分享的应用，都会出现在系统的分享弹窗，这对手机网页尤其有用。另外，使用这个接口只需要一个分享按钮，而传统的网页分享有多个分享目标，就有多少个分享按钮。</p>
<p>目前，桌面的 Safari 浏览器，手机的安卓 Chrome 浏览器和 iOS Safari 浏览器，支持这个 API。</p>
<p>这个 API 要求网站必须启用 HTTPS 协议，但是本地 Localhost 开发可以使用 HTTP 协议。另外，这个 API 不能直接调用，只能用来响应用户的操作（比如<code>click</code>事件）。</p>
<h3 id="接口细节"><a href="#接口细节" class="headerlink" title="接口细节"></a>接口细节</h3><p>该接口部署在<code>navigator.share</code>，可以用下面的代码检查本机是否支持该接口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.<span class="property">share</span>) &#123;</span><br><span class="line">    <span class="comment">// 支持</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不支持</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>navigator.share</code>是一个函数方法，接受一个配置对象作为参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="title function_">share</span>(&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;WebShare API Demo&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;https://codepen.io/ayoisaiah/pen/YbNazJ&#x27;</span>,</span><br><span class="line">    <span class="attr">text</span>: <span class="string">&#x27;我正在看《Web Share API》&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>配置对象有三个属性，都是可选的，但至少必须指定一个。</p>
<ul>
<li><code>title</code>：分享文档的标题。</li>
<li><code>url</code>：分享的 URL。</li>
<li><code>text</code>：分享的内容。</li>
</ul>
<p>一般来说，<code>url</code>是当前网页的网址，<code>title</code>是当前网页的标题，可以采用下面的写法获取。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> title = <span class="variable language_">document</span>.<span class="property">title</span>;</span><br><span class="line"><span class="keyword">const</span> url = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;link[rel=canonical]&#x27;</span>) ?</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;link[rel=canonical]&#x27;</span>).<span class="property">href</span> :</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">location</span>.<span class="property">href</span>;</span><br></pre></td></tr></table></figure>

<p><code>navigator.share</code>的返回值是一个 Promise 对象。这个方法调用之后，会立刻弹出系统的分享弹窗，用户操作完毕之后，Promise 对象就会变为<code>resolved</code>状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">navigator.<span class="title function_">share</span>(&#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;WebShare API Demo&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;https://codepen.io/ayoisaiah/pen/YbNazJ&#x27;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Thanks for sharing!&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Sharing error&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>由于返回值是 Promise 对象，所以也可以使用<code>await</code>命令。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shareButton.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> navigator.<span class="title function_">share</span>(&#123; <span class="attr">title</span>: <span class="string">&#x27;Example Page&#x27;</span>, <span class="attr">url</span>: <span class="string">&#x27;&#x27;</span> &#125;);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Data was shared successfully&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Share failed:&#x27;</span>, err.<span class="property">message</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="分享文件"><a href="#分享文件" class="headerlink" title="分享文件"></a>分享文件</h3><p>这个 API 还可以分享文件，先使用<code>navigator.canShare()</code>方法，判断一下目标文件是否可以分享。因为不是所有文件都允许分享的，目前图像，视频，音频和文本文件可以分享2。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.<span class="property">canShare</span> &amp;&amp; navigator.<span class="title function_">canShare</span>(&#123; <span class="attr">files</span>: filesArray &#125;)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>navigator.canShare()</code>方法的参数对象，就是<code>navigator.share()</code>方法的参数对象。这里的关键是<code>files</code>属性，它的值是一个<code>FileList</code>实例对象。</p>
<p><code>navigator.canShare()</code>方法返回一个布尔值，如果为<code>true</code>，就可以使用<code>navigator.share()</code>方法分享文件了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (navigator.<span class="property">canShare</span> &amp;&amp; navigator.<span class="title function_">canShare</span>(&#123; <span class="attr">files</span>: filesArray &#125;)) &#123;</span><br><span class="line">    navigator.<span class="title function_">share</span>(&#123;</span><br><span class="line">        <span class="attr">files</span>: filesArray,</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;Vacation Pictures&#x27;</span>,</span><br><span class="line">        <span class="attr">text</span>: <span class="string">&#x27;Photos from September 27 to October 14.&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">        .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Share was successful.&#x27;</span>))</span><br><span class="line">        .<span class="title function_">catch</span>(<span class="function">(<span class="params">error</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Sharing failed&#x27;</span>, error));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="参考链接-11"><a href="#参考链接-11" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://css-tricks.com/how-to-use-the-web-share-api/">How to Use the Web Share API</a>, Ayooluwa Isaiah</li>
<li><a target="_blank" rel="noopener" href="https://wicg.github.io/web-share/">Web Share API - Level 1</a>, W3C</li>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/web/updates/2016/09/navigator-share">Introducing the Web Share API</a>, Paul Kinlan, Sam Thorogood</li>
<li><a target="_blank" rel="noopener" href="https://web.dev/web-share/">Share like a native app with the Web Share API</a>, Joe Medley</li>
</ul>
<h2 id="Web-Audio-API"><a href="#Web-Audio-API" class="headerlink" title="Web Audio API"></a>Web Audio API</h2><p>Web Audio API 用于操作声音。这个 API 可以让网页发出声音。</p>
<h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h3><p>浏览器原生提供<code>AudioContext</code>对象，该对象用于生成一个声音的上下文，与扬声器相连。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> audioContext = <span class="keyword">new</span> <span class="title class_">AudioContext</span>();</span><br></pre></td></tr></table></figure>

<p>然后，获取音源文件，将其在内存中解码，就可以播放声音了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> context = <span class="keyword">new</span> <span class="title class_">AudioContext</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;sound.mp4&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">arrayBuffer</span>())</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">arrayBuffer</span> =&gt;</span> context.<span class="title function_">decodeAudioData</span>(arrayBuffer))</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">audioBuffer</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 播放声音</span></span><br><span class="line">        <span class="keyword">const</span> source = context.<span class="title function_">createBufferSource</span>();</span><br><span class="line">        source.<span class="property">buffer</span> = audioBuffer;</span><br><span class="line">        source.<span class="title function_">connect</span>(context.<span class="property">destination</span>);</span><br><span class="line">        source.<span class="title function_">start</span>();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="context-createBuffer"><a href="#context-createBuffer" class="headerlink" title="context.createBuffer()"></a>context.createBuffer()</h3><p><code>context.createBuffer()</code>方法生成一个内存的操作视图，用于存放数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer = audioContext.<span class="title function_">createBuffer</span>(channels, signalLength, sampleRate);</span><br></pre></td></tr></table></figure>

<p><code>createBuffer</code>方法接受三个参数。</p>
<ul>
<li>channels：整数，表示声道。创建单声道的声音，该值为 1。</li>
<li>signalLength：整数，表示声音数组的长度。</li>
<li>sampleRate：浮点数，表示取样率，即一秒取样多少次。</li>
</ul>
<p><code>signalLength</code>和<code>sampleRate</code>这两个参数决定了声音的长度。比如，如果取样率是<code>1/3000</code>（每秒取样3000次），声音数组长度是6000，那么播放的声音是2秒长度。</p>
<p>接着，使用<code>buffer.getChannelData</code>方法取出一个声道。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = buffer.<span class="title function_">getChannelData</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>buffer.getChannelData</code>的参数<code>0</code>表示取出第一个声道。</p>
<p>下一步，将声音数组放入这个声道。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = buffer.<span class="title function_">getChannelData</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// singal 是一个声音数组</span></span><br><span class="line"><span class="comment">// singalLengal 是该数组的长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; signalLength; i += <span class="number">1</span>) &#123;</span><br><span class="line">    data[i] = signal[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，使用<code>context.createBufferSource</code>方法生成一个声音节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个声音节点</span></span><br><span class="line"><span class="keyword">const</span> node = audioContext.<span class="title function_">createBufferSource</span>();</span><br><span class="line"><span class="comment">// 将声音数组的内存对象，放入这个节点</span></span><br><span class="line">node.<span class="property">buffer</span> = buffer;</span><br><span class="line"><span class="comment">// 将声音上下文与节点连接</span></span><br><span class="line">node.<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br><span class="line"><span class="comment">// 开始播放声音</span></span><br><span class="line">node.<span class="title function_">start</span>(audioContext.<span class="property">currentTime</span>);</span><br></pre></td></tr></table></figure>

<p>默认情况下，播放一次后就将停止播放。如果需要循环播放，可以将节点对象的<code>looping</code>属性设为<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.<span class="property">looping</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>Web Audio API 原生提供了一些过滤器（filter），用来处理声音。</p>
<p>首先，使用<code>context.createBiquadFilter</code>方法建立过滤器实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filter = audioContext.<span class="title function_">createBiquadFilter</span>();</span><br></pre></td></tr></table></figure>

<p>然后，通过<code>filter.type</code>属性指定过滤器的类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter.<span class="property">type</span> = <span class="string">&#x27;lowpass&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>目前，过滤器有以下这些类型。</p>
<ul>
<li>lowpass</li>
<li>highpass</li>
<li>bandpass</li>
<li>lowshelf</li>
<li>highshelf</li>
<li>peaking</li>
<li>notch</li>
<li>allpass</li>
</ul>
<p>然后指定过滤器的频率（frequency）属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter.<span class="property">frequency</span>.<span class="property">value</span> = frequency</span><br></pre></td></tr></table></figure>

<p>最后，过滤器实例连接节点实例，就可以生效了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sourceNode.<span class="title function_">connect</span>(filter);</span><br></pre></td></tr></table></figure>

<h2 id="Web-Components"><a href="#Web-Components" class="headerlink" title="Web Components"></a>Web Components</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>各种网站往往需要一些相同的模块，比如日历、调色板等等，这种模块就被称为“组件”（component）。Web Components 就是浏览器原生的组件规范。</p>
<p>采用组件开发，有很多优点。</p>
<p>（1）有利于代码复用。组件是模块化编程思想的体现，可以跨平台、跨框架使用，构建、部署和与其他 UI 元素互动都有统一做法。</p>
<p>（2）使用非常容易。加载或卸载组件，只要添加或删除一行代码就可以了。</p>
<p>（3）开发和定制很方便。组件开发不需要使用框架，只要用原生的语法就可以了。开发好的组件往往留出接口，供使用者设置常见属性，比如上面代码的<code>heading</code>属性，就是用来设置对话框的标题。</p>
<p>（4）组件提供了 HTML、CSS、JavaScript 封装的方法，实现了与同一页面上其他代码的隔离。</p>
<p>未来的网站开发，可以像搭积木一样，把组件合在一起，就组成了一个网站。这种前景是非常诱人的。</p>
<p>Web Components 不是单一的规范，而是一系列的技术组成，以下是它的四个构成。</p>
<ul>
<li>Custom Elements</li>
<li>Template</li>
<li>Shadow DOM</li>
<li>HTML Import</li>
</ul>
<p>使用时，并不一定上面四种 API 都要用到。其中，Custom Element 和 Shadow DOM 比较重要，Template 和 HTML Import 只起到辅助作用。</p>
<h3 id="Custom-Element"><a href="#Custom-Element" class="headerlink" title="Custom Element"></a>Custom Element</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>HTML 标准定义的网页元素，有时并不符合我们的需要，这时浏览器允许用户自定义网页元素，这就叫做 Custom Element。简单说，它就是用户自定义的网页元素，是 Web components 技术的核心。</p>
<p>举例来说，你可以自定义一个叫做<code>&lt;my-element&gt;</code>的网页元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-element</span>&gt;</span><span class="tag">&lt;/<span class="name">my-element</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意，自定义网页元素的标签名必须含有连字符<code>-</code>，一个或多个连字符都可以。这是因为浏览器内置的的 HTML 元素标签名，都不含有连字符，这样可以做到有效区分。</p>
<p>下面的代码先定义一个自定义元素的类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>( &#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125; );</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">shadowRoot</span>.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;style&gt;</span></span><br><span class="line"><span class="string">        /* scoped styles */</span></span><br><span class="line"><span class="string">      &lt;/style&gt;</span></span><br><span class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> <span class="title function_">observedAttributes</span>() &#123;</span><br><span class="line">        <span class="comment">// Return list of attributes to watch.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">attributeChangedCallback</span>(<span class="params"> name, oldValue, newValue </span>) &#123;</span><br><span class="line">        <span class="comment">// Run functionality when one of these attributes is changed.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">connectedCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// Run functionality when an instance of this element is inserted into the DOM.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">disconnectedCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// Run functionality when an instance of this element is removed from the DOM.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码有几个注意点。</p>
<ul>
<li>自定义元素类的基类是<code>HTMLElement</code>。当然也可以根据需要，基于<code>HTMLElement</code>的子类，比如<code>HTMLButtonElement</code>。</li>
<li>构造函数内部定义了 Shadow DOM。所谓<code>Shadow DOM</code>指的是，这部分的 HTML 代码和样式，不直接暴露给用户。</li>
<li>类可以定义生命周期方法，比如<code>connectedCallback()</code>。</li>
</ul>
<p>然后，<code>window.customElements.define()</code>方法，用来登记自定义元素与这个类之间的映射。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">customElements</span>.<span class="title function_">define</span>(<span class="string">&#x27;my-element&#x27;</span>, <span class="title class_">MyElement</span>);</span><br></pre></td></tr></table></figure>

<p>登记以后，页面上的每一个<code>&lt;my-element&gt;</code>元素都是一个<code>MyElement</code>类的实例。只要浏览器解析到<code>&lt;my-element&gt;</code>元素，就会运行<code>MyElement</code>的构造函数。</p>
<p>注意，如果没有登记就使用 Custom Element，浏览器会认为这是一个不认识的元素，会当做空的 div 元素处理。</p>
<p><code>window.customElements.define()</code>方法定义了 Custom Element 以后，可以使用<code>window.customeElements.get()</code>方法获取该元素的构造方法。这使得除了直接插入 HTML 网页，Custom Element 也能使用脚本插入网页。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">customElements</span>.<span class="title function_">define</span>(</span><br><span class="line">    <span class="string">&#x27;my-element&#x27;</span>,</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">HTMLElement</span> &#123;...&#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> el = <span class="variable language_">window</span>.<span class="property">customElements</span>.<span class="title function_">get</span>(<span class="string">&#x27;my-element&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> myElement = <span class="keyword">new</span> <span class="title function_">el</span>();</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(myElement);</span><br></pre></td></tr></table></figure>

<p>如果你想扩展现有的 HTML 元素（比如<code>&lt;button&gt;</code>）也是可以的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GreetingElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLButtonElement</span></span><br></pre></td></tr></table></figure>

<p>登记的时候，需要提供扩展的元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;hey-there&#x27;</span>, <span class="title class_">GreetingElement</span>, &#123; <span class="attr">extends</span>: <span class="string">&#x27;button&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>使用的时候，为元素加上<code>is</code>属性就可以了。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">is</span>=<span class="string">&quot;hey-there&quot;</span> <span class="attr">name</span>=<span class="string">&quot;World&quot;</span>&gt;</span>Howdy<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h4><p>Custom Element 提供一些生命周期方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">connectedCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// here the element has been inserted into the DOM</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>connectedCallback()</code>方法就是<code>MyElement</code>元素的生命周期方法。每次，该元素插入 DOM，就会自动执行该方法。</p>
<ul>
<li><code>connectedCallback()</code>：插入 DOM 时调用。这可能不止一次发生，比如元素被移除后又重新添加。类的设置应该尽量放到这个方法里面执行，因为这时各种属性和子元素都可用。</li>
<li><code>disconnectedCallback()</code>：移出 DOM 时执行。</li>
<li><code>attributeChangedCallback(attrName, oldVal, newVal)</code>：添加、删除、更新或替换属性时调用。元素创建或升级时，也会调用。注意：只有加入<code>observedAttributes</code>的属性才会执行这个方法。</li>
<li><code>adoptedCallback()</code>：自定义元素移动到新的 document 时调用，比如执行<code>document.adoptNode(element)</code>时。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GreetingElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name</span> = <span class="string">&#x27;Stranger&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">connectedCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">alert</span>(<span class="string">`Hello, <span class="subst">$&#123;<span class="variable language_">this</span>._name&#125;</span>!`</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">attributeChangedCallback</span>(<span class="params">attrName, oldValue, newValue</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (attrName === <span class="string">&#x27;name&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newValue) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">_name</span> = newValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">_name</span> = <span class="string">&#x27;Stranger&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">GreetingElement</span>.<span class="property">observedAttributes</span> = [<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;hey-there&#x27;</span>, <span class="title class_">GreetingElement</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>GreetingElement.observedAttributes</code>属性用来指定白名单里面的属性，上例是<code>name</code>属性。只要这个属性的值发生变化，就会自动调用<code>attributeChangedCallback</code>方法。</p>
<p>使用上面这个类的方法如下。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hey-there</span>&gt;</span>Greeting<span class="tag">&lt;/<span class="name">hey-there</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hey-there</span> <span class="attr">name</span>=<span class="string">&quot;Potch&quot;</span>&gt;</span>Personalized Greeting<span class="tag">&lt;/<span class="name">hey-there</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>attributeChangedCallback</code>方法主要用于外部传入的属性，就像上面例子中<code>name=&quot;Potch&quot;</code>。</p>
<p>生命周期方法调用的顺序如下：<code>constructor</code> -&gt; <code>attributeChangedCallback</code> -&gt; <code>connectedCallback</code>，即<code>attributeChangedCallback</code>早于<code>connectedCallback</code>执行。这是因为<code>attributeChangedCallback</code>相当于调整配置，应该在插入 DOM 之前完成。</p>
<p>下面的例子能够更明显地看出这一点，在插入 DOM 前修改 Custome Element 的颜色。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">container</span> = <span class="variable language_">this</span>.<span class="property">shadowRoot</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;##container&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">attributeChangedCallback</span>(<span class="params">attr, oldVal, newVal</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(attr === <span class="string">&#x27;disabled&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="title function_">hasAttribute</span>(<span class="params"><span class="string">&#x27;disabled&#x27;</span></span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;##808080&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;##ffffff&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="自定义属性和方法"><a href="#自定义属性和方法" class="headerlink" title="自定义属性和方法"></a>自定义属性和方法</h4><p>Custom Element 允许自定义属性或方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// do something in this method</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>doSomething()</code>就是<code>MyElement</code>的自定义方法，使用方法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;my-element&#x27;</span>);</span><br><span class="line">element.<span class="title function_">doSomething</span>();</span><br></pre></td></tr></table></figure>

<p>自定义属性可以使用 JavaScript class 的所有语法，因此也可以设置取值器和赋值器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">disabled</span>(<span class="params">isDisabled</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(isDisabled) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setAttribute</span>(<span class="string">&#x27;disabled&#x27;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">removeAttribute</span>(<span class="string">&#x27;disabled&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">disabled</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">hasAttribute</span>(<span class="string">&#x27;disabled&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中的取值器和赋值器，可用于<code>&lt;my-input name=&quot;name&quot; disabled&gt;</code>这样的用法。</p>
<h4 id="window-customElements-whenDefined"><a href="#window-customElements-whenDefined" class="headerlink" title="window.customElements.whenDefined()"></a>window.customElements.whenDefined()</h4><p><code>window.customElements.whenDefined()</code>方法在一个 Custom Element 被<code>customElements.define()</code>方法定义以后执行，用于“升级”一个元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">customElements</span>.<span class="title function_">whenDefined</span>(<span class="string">&#x27;my-element&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// my-element is now defined</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>如果某个属性值发生变化时，需要做出反应，可以将它放入<code>observedAttributes</code>数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">get</span> <span class="title function_">observedAttributes</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;disabled&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> shadowRoot = <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>(&#123;<span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span>&#125;);</span><br><span class="line">        shadowRoot.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;style&gt;</span></span><br><span class="line"><span class="string">        .disabled &#123;</span></span><br><span class="line"><span class="string">          opacity: 0.4;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &lt;/style&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">container</span> = <span class="variable language_">this</span>.<span class="title function_">shadowRoot</span>(<span class="string">&#x27;##container&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">attributeChangedCallback</span>(<span class="params">attr, oldVal, newVal</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(attr === <span class="string">&#x27;disabled&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">disabled</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;disabled&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">container</span>.<span class="property">classList</span>.<span class="title function_">remove</span>(<span class="string">&#x27;disabled&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>自定义元素的原型有一些属性，用来指定回调函数，在特定事件发生时触发。</p>
<ul>
<li><strong>createdCallback</strong>：实例生成时触发</li>
<li><strong>attachedCallback</strong>：实例插入HTML文档时触发</li>
<li><strong>detachedCallback</strong>：实例从HTML文档移除时触发</li>
<li>**attributeChangedCallback(attrName, oldVal, newVal)**：实例的属性发生改变时（添加、移除、更新）触发</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proto = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">HTMLElement</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line">proto.<span class="property">createdCallback</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;created&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;This is a my-demo element!&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">proto.<span class="property">attachedCallback</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;attached&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">XFoo</span> = <span class="variable language_">document</span>.<span class="title function_">registerElement</span>(<span class="string">&#x27;x-foo&#x27;</span>, &#123;<span class="attr">prototype</span>: proto&#125;);</span><br></pre></td></tr></table></figure>

<p>利用回调函数，可以方便地在自定义元素中插入HTML语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">XFooProto</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">HTMLElement</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">XFooProto</span>.<span class="property">createdCallback</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">innerHTML</span> = <span class="string">&quot;&lt;b&gt;I&#x27;m an x-foo-with-markup!&lt;/b&gt;&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">XFoo</span> = <span class="variable language_">document</span>.<span class="title function_">registerElement</span>(<span class="string">&#x27;x-foo-with-markup&#x27;</span>,</span><br><span class="line">    &#123;<span class="attr">prototype</span>: <span class="title class_">XFooProto</span>&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码定义了createdCallback回调函数，生成实例时，该函数运行，插入如下的HTML语句。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-foo-with-markup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">b</span>&gt;</span>I&#x27;m an x-foo-with-markup!<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">x-foo-with-markup</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Custom-Element-的子元素"><a href="#Custom-Element-的子元素" class="headerlink" title="Custom Element 的子元素"></a>Custom Element 的子元素</h4><p>用户使用 Custom Element 时候，可以在内部放置子元素。Custom Element 提供<code>&lt;slot&gt;</code>用来引用内部内容。</p>
<p>下面的<code>&lt;image-gallery&gt;</code>是一个 Custom Element。用户在里面放置了子元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">image-gallery</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;foo.jpg&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;bar.jpg&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">image-gallery</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;image-gallery&gt;</code>内部的模板如下。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;images&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;image&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最终合成的代码如下。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;images&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;foo.jpg&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;bar.jpg&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;image&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="标签-16"><a href="#标签-16" class="headerlink" title="&lt;template&gt;标签"></a><code>&lt;template&gt;</code>标签</h3><h4 id="基本用法-3"><a href="#基本用法-3" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>&lt;template&gt;</code>标签表示组件的 HTML 代码模板。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This won&#x27;t display!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&quot;this won&#x27;t alert!&quot;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;template&gt;</code>内部就是正常的 HTML 代码，浏览器不会将这些代码加入 DOM。</p>
<p>下面的代码会将模板内部的代码插入 DOM。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> template = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;template&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(template.<span class="property">content</span>);</span><br></pre></td></tr></table></figure>

<p>注意，模板内部的代码只能插入一次，如果第二次执行上面的代码就会报错。</p>
<p>如果需要多次插入模板，可以复制<code>&lt;template&gt;</code>内部代码，然后再插入。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(template.<span class="property">content</span>.<span class="title function_">cloneNode</span>(<span class="literal">true</span>));</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>cloneNode()</code>方法的参数<code>true</code>表示复制包含所有子节点。</p>
<p>接受<code>&lt;template&gt;</code>插入的元素，叫做宿主元素（host）。在<code>&lt;template&gt;</code>之中，可以对宿主元素设置样式。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-pseudo">:host</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: #<span class="number">#f8f8f8</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-pseudo">:host</span>(<span class="selector-pseudo">:hover</span>) &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background</span>: #<span class="number">#ccc</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="document-importNode"><a href="#document-importNode" class="headerlink" title="document.importNode()"></a>document.importNode()</h4><p>document.importNode方法用于克隆外部文档的DOM节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;iframe&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> oldNode = iframe.<span class="property">contentWindow</span>.<span class="property">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;myNode&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> newNode = <span class="variable language_">document</span>.importNode(oldNode, <span class="literal">true</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;container&quot;</span>).<span class="title function_">appendChild</span>(newNode);</span><br></pre></td></tr></table></figure>

<p>上面例子是将iframe窗口之中的节点oldNode，克隆进入当前文档。</p>
<p>注意，克隆节点之后，还必须用appendChild方法将其加入当前文档，否则不会显示。换个角度说，这意味着插入外部文档节点之前，必须用document.importNode方法先将这个节点准备好。</p>
<p>document.importNode方法接受两个参数，第一个参数是外部文档的DOM节点，第二个参数是一个布尔值，表示是否连同子节点一起克隆，默认为false。大多数情况下，必须显式地将第二个参数设为true。</p>
<h3 id="Shadow-DOM"><a href="#Shadow-DOM" class="headerlink" title="Shadow DOM"></a>Shadow DOM</h3><p>所谓 Shadow DOM 指的是，浏览器将模板、样式表、属性、JavaScript 码等，封装成一个独立的 DOM 元素。外部的设置无法影响到其内部，而内部的设置也不会影响到外部，与浏览器处理原生网页元素（比如<code>&lt;video&gt;</code>元素）的方式很像。</p>
<p>Shadow DOM 最大的好处有两个，一是可以向用户隐藏细节，直接提供组件，二是可以封装内部样式表，不会影响到外部。</p>
<p>Custom Element 内部有一个 Shadow Root。它就是接入外部 DOM 的根元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attachShadow() creates a shadow root.</span></span><br><span class="line"><span class="keyword">let</span> shadow = div.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;);</span><br><span class="line"><span class="keyword">let</span> inner = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">inner.<span class="title function_">appendChild</span>(<span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(<span class="string">&#x27;Hiding in the shadows&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// shadow root supports the normal appendChild method.</span></span><br><span class="line">shadow.<span class="title function_">appendChild</span>(inner);</span><br><span class="line">div.<span class="title function_">querySelector</span>(<span class="string">&#x27;b&#x27;</span>); <span class="comment">// empty</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>&lt;div&gt;</code>包含<code>&lt;b&gt;</code>，但是 DOM 方法无法看到它，而且页面的样式也影响不到它。</p>
<p><code>mode: &#39;open&#39;</code>表示开发者工具里面，可以看到 Custom HTML 内部的 DOM，并与之互动。<code>mode: closed</code>将不允许 Custom Element 的使用者与内部代码互动。</p>
<p>Shadow root 内部通过指定<code>innerHTML</code>属性或使用<code>&lt;template&gt;</code>元素，指定 HTML 代码。</p>
<p>Shadow DOM 内部可以通过向根添加<code>&lt;style&gt;</code>（或<code>&lt;link&gt;</code>）来设置样式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>);</span><br><span class="line">style.<span class="property">innerText</span> = <span class="string">&#x27;b &#123; font-weight: bolder; color: red; &#125;&#x27;</span>;</span><br><span class="line">shadowRoot.<span class="title function_">appendChild</span>(style);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inner = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">inner.<span class="property">innerHTML</span> = <span class="string">&quot;I&#x27;m bolder in the shadows&quot;</span>;</span><br><span class="line">shadowRoot.<span class="title function_">appendChild</span>(inner);</span><br></pre></td></tr></table></figure>

<p>上面代码添加的样式，只会影响 Shadow DOM 内的元素。</p>
<p>Custom Element 的 CSS 样式内部，<code>:root</code>表示这个根元素。比如，Custom Element 默认是行内元素，下面代码可以改成块级元素。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:host</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">:host</span>(<span class="selector-attr">[disabled]</span>) &#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，外部样式会覆盖掉<code>:host</code>的设置，比如下面的样式会覆盖<code>:host</code>。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my-element &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 CSS 的自定义属性，可以为 Custom Element 可以被覆盖的默认样式。下面是外部样式，<code>my-element</code>是 Custom Element。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my-element &#123;</span><br><span class="line">    <span class="attr">--background-color</span>: #<span class="number">#ff0000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，内部可以指定默认样式，用于用户没有指定颜色的情况。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:host</span> &#123;</span><br><span class="line">    <span class="attr">--background-color</span>: #<span class="number">#ffffff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="selector-id">#container</span> &#123;</span><br><span class="line">     <span class="attribute">background-color</span>: <span class="built_in">var</span>(--background-color);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>下面的例子是为 Shadow DOM 加上独立的模板。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;nameTag&quot;</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;nameTagTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.outer</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">2px</span> solid brown;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;boilerplate&quot;</span>&gt;</span></span><br><span class="line">            Hi! My name is</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">            Bob</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码是一个<code>div</code>元素和模板。接下来，就是要把模板应用到<code>div</code>元素上。</p>
<h3 id="HTML-Import"><a href="#HTML-Import" class="headerlink" title="HTML Import"></a>HTML Import</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><p>长久以来，网页可以加载外部的样式表、脚本、图片、多媒体，却无法方便地加载其他网页，iframe和ajax都只能提供部分的解决方案，且有很大的局限。HTML Import就是为了解决加载外部网页这个问题，而提出来的。</p>
<p>下面代码用于测试当前浏览器是否支持HTML Import。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">supportsImports</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;import&#x27;</span> <span class="keyword">in</span> <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;link&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">supportsImports</span>()) &#123;</span><br><span class="line">    <span class="comment">// 支持</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不支持</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>HTML Import用于将外部的HTML文档加载进当前文档。我们可以将组件的HTML、CSS、JavaScript封装在一个文件里，然后使用下面的代码插入需要使用该组件的网页。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;import&quot;</span> <span class="attr">href</span>=<span class="string">&quot;dialog.html&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码在网页中插入一个对话框组件，该组建封装在<code>dialog.html</code>文件。注意，dialog.html文件中的样式和JavaScript脚本，都对所插入的整个网页有效。</p>
<p>假定A网页通过HTML Import加载了B网页，即B是一个组件，那么B网页的样式表和脚本，对A网页也有效（准确得说，只有style标签中的样式对A网页有效，link标签加载的样式表对A网页无效）。所以可以把多个样式表和脚本，都放在B网页中，都从那里加载。这对大型的框架，是很方便的加载方法。</p>
<p>如果B与A不在同一个域，那么A所在的域必须打开CORS。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- example.com必须打开CORS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;import&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://example.com/elements.html&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了用link标签，也可以用JavaScript调用link元素，完成HTML Import。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> link = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;link&#x27;</span>);</span><br><span class="line">link.<span class="property">rel</span> = <span class="string">&#x27;import&#x27;</span>;</span><br><span class="line">link.<span class="property">href</span> = <span class="string">&#x27;file.html&#x27;</span></span><br><span class="line">link.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;...&#125;;</span><br><span class="line">link.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;...&#125;;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(link);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>HTML Import加载成功时，会在link元素上触发load事件，加载失败时（比如404错误）会触发error事件，可以对这两个事件指定回调函数。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">handleLoad</span>(<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Loaded import: &#x27;</span> + e.<span class="property">target</span>.<span class="property">href</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">handleError</span>(<span class="params">e</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Error loading import: &#x27;</span> + e.<span class="property">target</span>.<span class="property">href</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;import&quot;</span> <span class="attr">href</span>=<span class="string">&quot;file.html&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">onload</span>=<span class="string">&quot;handleLoad(event)&quot;</span> <span class="attr">onerror</span>=<span class="string">&quot;handleError(event)&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中，handleLoad和handleError函数的定义，必须在link元素的前面。因为浏览器元素遇到link元素时，立刻解析并加载外部网页（同步操作），如果这时没有对这两个函数定义，就会报错。</p>
<p>HTML Import是同步加载，会阻塞当前网页的渲染，这主要是为了样式表的考虑，因为外部网页的样式表对当前网页也有效。如果想避免这一点，可以为link元素加上async属性。当然，这也意味着，如果外部网页定义了组件，就不能立即使用了，必须等HTML Import完成，才能使用。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;import&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/path/to/import_that_takes_5secs.html&quot;</span> <span class="attr">async</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是，HTML Import不会阻塞当前网页的解析和脚本执行（即阻塞渲染）。这意味着在加载的同时，主页面的脚本会继续执行。</p>
<p>最后，HTML Import支持多重加载，即被加载的网页同时又加载其他网页。如果这些网页都重复加载同一个外部脚本，浏览器只会抓取并执行一次该脚本。比如，A网页加载了B网页，它们各自都需要加载jQuery，浏览器只会加载一次jQuery。</p>
<h4 id="脚本的执行"><a href="#脚本的执行" class="headerlink" title="脚本的执行"></a>脚本的执行</h4><p>外部网页的内容，并不会自动显示在当前网页中，它只是储存在浏览器中，等到被调用的时候才加载进入当前网页。为了加载网页网页，必须用DOM操作获取加载的内容。具体来说，就是使用link元素的import属性，来获取加载的内容。这一点与iframe完全不同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> content = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;link[rel=&quot;import&quot;]&#x27;</span>).<span class="property">import</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发生以下情况时，link.import属性为null。</p>
<ul>
<li>浏览器不支持HTML Import</li>
<li>link元素没有声明<code>rel=&quot;import&quot;</code></li>
<li>link元素没有被加入DOM</li>
<li>link元素已经从DOM中移除</li>
<li>对方域名没有打开CORS</li>
</ul>
<p>下面代码用于从加载的外部网页选取id为template的元素，然后将其克隆后加入当前网页的DOM。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = linkElement.<span class="property">import</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;##template&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(el.<span class="title function_">cloneNode</span>(<span class="literal">true</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当前网页可以获取外部网页，反过来也一样，外部网页中的脚本，不仅可以获取本身的DOM，还可以获取link元素所在的当前网页的DOM。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下代码位于被加载（import）的外部网页</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// importDoc指向被加载的DOM</span></span><br><span class="line"><span class="keyword">var</span> importDoc = <span class="variable language_">document</span>.<span class="property">currentScript</span>.<span class="property">ownerDocument</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mainDoc指向主文档的DOM</span></span><br><span class="line"><span class="keyword">var</span> mainDoc = <span class="variable language_">document</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将子页面的样式表添加主文档</span></span><br><span class="line"><span class="keyword">var</span> styles = importDoc.<span class="title function_">querySelector</span>(<span class="string">&#x27;link[rel=&quot;stylesheet&quot;]&#x27;</span>);</span><br><span class="line">mainDoc.<span class="property">head</span>.<span class="title function_">appendChild</span>(styles.<span class="title function_">cloneNode</span>(<span class="literal">true</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码将所加载的外部网页的样式表，添加进当前网页。</p>
<p>被加载的外部网页的脚本是直接在当前网页的上下文执行，因为它的<code>window.document</code>指的是当前网页的document，而且它定义的函数可以被当前网页的脚本直接引用。</p>
<h4 id="Web-Component的封装"><a href="#Web-Component的封装" class="headerlink" title="Web Component的封装"></a>Web Component的封装</h4><p>对于Web Component来说，HTML Import的一个重要应用是在所加载的网页中，自动登记Custom Element。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 定义并登记&lt;say-hi&gt;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> proto = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">HTMLElement</span>.<span class="property"><span class="keyword">prototype</span></span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    proto.<span class="property">createdCallback</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">this</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;Hello, &lt;b&gt;&#x27;</span> +</span></span><br><span class="line"><span class="language-javascript">                (<span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;name&#x27;</span>) || <span class="string">&#x27;?&#x27;</span>) + <span class="string">&#x27;&lt;/b&gt;&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">registerElement</span>(<span class="string">&#x27;say-hi&#x27;</span>, &#123;<span class="attr">prototype</span>: proto&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;t&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        ::content &gt; * &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>I&#x27;m a shadow-element using Shadow DOM!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">content</span>&gt;</span><span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> importDoc = <span class="variable language_">document</span>.<span class="property">currentScript</span>.<span class="property">ownerDocument</span>; <span class="comment">//指向被加载的网页</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 定义并登记&lt;shadow-element&gt;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> proto2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">HTMLElement</span>.<span class="property"><span class="keyword">prototype</span></span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        proto2.<span class="property">createdCallback</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> template = importDoc.<span class="title function_">querySelector</span>(<span class="string">&#x27;##t&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> clone = <span class="variable language_">document</span>.importNode(template.<span class="property">content</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> root = <span class="variable language_">this</span>.<span class="title function_">createShadowRoot</span>();</span></span><br><span class="line"><span class="language-javascript">            root.<span class="title function_">appendChild</span>(clone);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">registerElement</span>(<span class="string">&#x27;shadow-element&#x27;</span>, &#123;<span class="attr">prototype</span>: proto2&#125;);</span></span><br><span class="line"><span class="language-javascript">    &#125;)();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码定义并登记了两个元素：&lt;say-hi&gt;和&lt;shadow-element&gt;。在主页面使用这两个元素，非常简单。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;import&quot;</span> <span class="attr">href</span>=<span class="string">&quot;elements.html&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">say-hi</span> <span class="attr">name</span>=<span class="string">&quot;Eric&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">say-hi</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shadow-element</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>( I&#x27;m in the light dom )<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shadow-element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不难想到，这意味着HTML Import使得Web Component变得可分享了，其他人只要拷贝<code>elements.html</code>，就可以在自己的页面中使用了。</p>
<h3 id="Polymer-js"><a href="#Polymer-js" class="headerlink" title="Polymer.js"></a>Polymer.js</h3><p>Web Components是非常新的技术，为了让老式浏览器也能使用，Google推出了一个函数库<a target="_blank" rel="noopener" href="http://www.polymer-project.org/">Polymer.js</a>。这个库不仅可以帮助开发者，定义自己的网页元素，还提供许多预先制作好的组件，可以直接使用。</p>
<h4 id="直接使用的组件"><a href="#直接使用的组件" class="headerlink" title="直接使用的组件"></a>直接使用的组件</h4><p>Polymer.js提供的组件，可以直接插入网页，比如下面的google-map。。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;components/platform/platform.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;import&quot;</span> <span class="attr">href</span>=<span class="string">&quot;google-map.html&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">google-map</span> <span class="attr">lat</span>=<span class="string">&quot;37.790&quot;</span> <span class="attr">long</span>=<span class="string">&quot;-122.390&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">google-map</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再比如，在网页中插入一个时钟，可以直接使用下面的标签。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">polymer-ui-clock</span>&gt;</span><span class="tag">&lt;/<span class="name">polymer-ui-clock</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自定义标签与其他标签的用法完全相同，也可以使用CSS指定它的样式。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">polymer-ui-clock &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">320px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">320px</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&quot;../assets/glass.png&quot;</span>) no-repeat;</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">4px</span> solid <span class="built_in">rgba</span>(<span class="number">32</span>, <span class="number">32</span>, <span class="number">32</span>, <span class="number">0.3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>如果使用bower安装，至少需要安装platform和core components这两个核心部分。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bower install --save Polymer/platform</span><br><span class="line">bower install --save Polymer/polymer</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你还可以安装所有预先定义的界面组件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bower install Polymer/core-elements</span><br><span class="line">bower install Polymer/polymer-ui-elements</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还可以只安装单个组件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bower install Polymer/polymer-ui-accordion</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时，组件根目录下的bower.json，会指明该组件的依赖的模块，这些模块会被自动安装。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;polymer-ui-accordion&quot;</span>,</span><br><span class="line">        <span class="string">&quot;private&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;polymer&quot;</span>: <span class="string">&quot;Polymer/polymer##0.2.0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;polymer-selector&quot;</span>: <span class="string">&quot;Polymer/polymer-selector##0.2.0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;polymer-ui-collapsible&quot;</span>: <span class="string">&quot;Polymer/polymer-ui-collapsible##0.2.0&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h4><p>下面是一个最简单的自定义组件的例子。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;import&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../bower_components/polymer/polymer.html&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">polymer-element</span> <span class="attr">name</span>=<span class="string">&quot;lorem-element&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Lorem ipsum<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">polymer-element</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码定义了lorem-element组件。它分成三个部分。</p>
<p><strong>（1）import命令</strong></p>
<p>import命令表示载入核心模块</p>
<p><strong>（2）polymer-element标签</strong></p>
<p>polymer-element标签定义了组件的名称（注意，组件名称中必须包含连字符）。它还可以使用extends属性，表示组件基于某种网页元素。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">polymer-element</span> <span class="attr">name</span>=<span class="string">&quot;w3c-disclosure&quot;</span> <span class="attr">extends</span>=<span class="string">&quot;button&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>（3）template标签</strong></p>
<p>template标签定义了网页元素的模板。</p>
<h4 id="组件的使用方法"><a href="#组件的使用方法" class="headerlink" title="组件的使用方法"></a>组件的使用方法</h4><p>在调用组件的网页中，首先加载polymer.js库和组件文件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;components/platform/platform.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;import&quot;</span> <span class="attr">href</span>=<span class="string">&quot;w3c-disclosure.html&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，分成两种情况。如果组件不基于任何现有的HTML网页元素（即定义的时候没有使用extends属性），则可以直接使用组件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">lorem-element</span>&gt;</span><span class="tag">&lt;/<span class="name">lorem-element</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时网页上就会显示一行字“Lorem ipsum”。</p>
<p>如果组件是基于（extends）现有的网页元素，则必须在该种元素上使用is属性指定组件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button is=&quot;w3c-disclosure&quot;&gt;Expand section 1&lt;/button&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="参考链接-12"><a href="#参考链接-12" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://hacks.mozilla.org/2018/11/the-power-of-web-components/">The Power of Web Components</a>, Potch</li>
<li>Todd Motto, <a target="_blank" rel="noopener" href="http://toddmotto.com/web-components-concepts-shadow-dom-imports-templates-custom-elements/">Web Components and concepts, ShadowDOM, imports, templates, custom elements</a></li>
<li>Dominic Cooney, <a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/">Shadow DOM 101</a></li>
<li>Eric Bidelman, <a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/webcomponents/template/">HTML’s New Template Tag</a></li>
<li>Rey Bango, <a target="_blank" rel="noopener" href="http://code.tutsplus.com/tutorials/using-polymer-to-create-web-components--cms-20475">Using Polymer to Create Web Components</a></li>
<li>Cédric Trévisan, Building an Accessible Disclosure Button – using Web Components](<a target="_blank" rel="noopener" href="http://blog.paciellogroup.com/2014/06/accessible-disclosure-button-using-web-components/">http://blog.paciellogroup.com/2014/06/accessible-disclosure-button-using-web-components/</a>)</li>
<li>Eric Bidelman, <a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/webcomponents/customelements/">Custom Elements: defining new elements in HTML</a></li>
<li>Eric Bidelman, <a target="_blank" rel="noopener" href="http://www.html5rocks.com/en/tutorials/webcomponents/imports/">HTML Imports</a></li>
<li>TJ VanToll, <a target="_blank" rel="noopener" href="http://developer.telerik.com/featured/web-components-ready-production/">Why Web Components Are Ready For Production</a></li>
<li>Chris Bateman, <a target="_blank" rel="noopener" href="http://cbateman.com/blog/a-no-nonsense-guide-to-web-components-part-1-the-specs/">A No-Nonsense Guide to Web Components, Part 1: The Specs</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.usejournal.com/web-components-will-replace-your-frontend-framework-3b17a580831c">Web Components will replace your frontend framework</a>, Danny Moerkerke</li>
<li><a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/web-components/customelements##extend">Custom Elements v1: Reusable Web Components</a>, Eric Bidelman</li>
</ul>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket 是一种网络通信协议，很多高级功能都需要它。</p>
<p>初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？</p>
<p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。HTTP 协议的这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用“轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p>
<p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p>
<h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p>
<p>它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。WebSocket 允许服务器端与客户端进行全双工（full-duplex）的通信。举例来说，HTTP 协议有点像发电子邮件，发出后必须等待对方回信；WebSocket 则是像打电话，服务器端和客户端可以同时向对方发送数据，它们之间存着一条持续打开的数据通道。</p>
<p>其他特点包括：</p>
<p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p>
<p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p>
<p>（3）数据格式比较轻量，性能开销小，通信高效。</p>
<p>（4）可以发送文本，也可以发送二进制数据。</p>
<p>（5）没有同源限制，客户端可以与任意服务器通信，完全可以取代 Ajax。</p>
<p>（6）协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>，对应 HTTPS 协议），服务器网址就是 URL。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure>

<h3 id="WebSocket-握手"><a href="#WebSocket-握手" class="headerlink" title="WebSocket 握手"></a>WebSocket 握手</h3><p>浏览器发出的 WebSocket 握手请求类似于下面的样子：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>null</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span><span class="punctuation">: </span>sN9cRrP/n9NdMgdcy2VJFQ==</span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span><span class="punctuation">: </span>13</span><br></pre></td></tr></table></figure>

<p>上面的头信息之中，有一个 HTTP 头是<code>Upgrade</code>。HTTP1.1 协议规定，<code>Upgrade</code>字段表示将通信协议从<code>HTTP/1.1</code>转向该字段指定的协议。<code>Connection</code>字段表示浏览器通知服务器，如果可以的话，就升级到 WebSocket 协议。<code>Origin</code>字段用于提供请求发出的域名，供服务器验证是否许可的范围内（服务器也可以不验证）。<code>Sec-WebSocket-Key</code>则是用于握手协议的密钥，是 Base64 编码的16字节随机字符串。</p>
<p>服务器的 WebSocket 回应如下。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>fFBooB7FAkLlXgRSz0BT3v4hq5s=</span><br><span class="line"><span class="attribute">Sec-WebSocket-Origin</span><span class="punctuation">: </span>null</span><br><span class="line"><span class="attribute">Sec-WebSocket-Location</span><span class="punctuation">: </span>ws://example.com/</span><br></pre></td></tr></table></figure>

<p>上面代码中，服务器同样用<code>Connection</code>字段通知浏览器，需要改变协议。<code>Sec-WebSocket-Accept</code>字段是服务器在浏览器提供的<code>Sec-WebSocket-Key</code>字符串后面，添加 <a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc6455">RFC6456</a> 标准规定的“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”字符串，然后再取 SHA-1 的哈希值。浏览器将对这个值进行验证，以证明确实是目标服务器回应了 WebSocket 请求。<code>Sec-WebSocket-Location</code>字段表示进行通信的 WebSocket 网址。</p>
<p>完成握手以后，WebSocket 协议就在 TCP 协议之上，开始传送数据。</p>
<h3 id="客户端的简单示例"><a href="#客户端的简单示例" class="headerlink" title="客户端的简单示例"></a>客户端的简单示例</h3><p>WebSocket 的用法相当简单。</p>
<p>下面是一个网页脚本的例子，基本上一眼就能明白。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;wss://echo.websocket.org&#x27;</span>);</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connection open ...&#x27;</span>);</span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">&#x27;Hello WebSockets!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received Message: &#x27;</span> + evt.<span class="property">data</span>);</span><br><span class="line">    ws.<span class="title function_">close</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Connection closed.&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="客户端-API-1"><a href="#客户端-API-1" class="headerlink" title="客户端 API"></a>客户端 API</h3><p>浏览器对 WebSocket 协议的处理，无非就是三件事。</p>
<ul>
<li>建立连接和断开连接</li>
<li>发送数据和接收数据</li>
<li>处理错误</li>
</ul>
<h4 id="构造函数-WebSocket"><a href="#构造函数-WebSocket" class="headerlink" title="构造函数 WebSocket"></a>构造函数 WebSocket</h4><p><code>WebSocket</code>对象作为一个构造函数，用于新建<code>WebSocket</code>实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="string">&#x27;ws://localhost:8080&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>执行上面语句之后，客户端就会与服务器进行连接。</p>
<h4 id="webSocket-readyState"><a href="#webSocket-readyState" class="headerlink" title="webSocket.readyState"></a>webSocket.readyState</h4><p><code>readyState</code>属性返回实例对象的当前状态，共有四种。</p>
<ul>
<li>CONNECTING：值为0，表示正在连接。</li>
<li>OPEN：值为1，表示连接成功，可以通信了。</li>
<li>CLOSING：值为2，表示连接正在关闭。</li>
<li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li>
</ul>
<p>下面是一个示例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ws.<span class="property">readyState</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">WebSocket</span>.<span class="property">CONNECTING</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">WebSocket</span>.<span class="property">CLOSING</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">WebSocket</span>.<span class="property">CLOSED</span>:</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="comment">// this never happens</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="webSocket-onopen"><a href="#webSocket-onopen" class="headerlink" title="webSocket.onopen"></a>webSocket.onopen</h4><p>实例对象的<code>onopen</code>属性，用于指定连接成功后的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onopen</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">&#x27;Hello Server!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要指定多个回调函数，可以使用<code>addEventListener</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="title function_">addEventListener</span>(<span class="string">&#x27;open&#x27;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    ws.<span class="title function_">send</span>(<span class="string">&#x27;Hello Server!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="webSocket-onclose"><a href="#webSocket-onclose" class="headerlink" title="webSocket.onclose"></a>webSocket.onclose</h4><p>实例对象的<code>onclose</code>属性，用于指定连接关闭后的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> code = event.<span class="property">code</span>;</span><br><span class="line">    <span class="keyword">var</span> reason = event.<span class="property">reason</span>;</span><br><span class="line">    <span class="keyword">var</span> wasClean = event.<span class="property">wasClean</span>;</span><br><span class="line">    <span class="comment">// handle close event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">addEventListener</span>(<span class="string">&quot;close&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> code = event.<span class="property">code</span>;</span><br><span class="line">    <span class="keyword">var</span> reason = event.<span class="property">reason</span>;</span><br><span class="line">    <span class="keyword">var</span> wasClean = event.<span class="property">wasClean</span>;</span><br><span class="line">    <span class="comment">// handle close event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="webSocket-onmessage"><a href="#webSocket-onmessage" class="headerlink" title="webSocket.onmessage"></a>webSocket.onmessage</h4><p>实例对象的<code>onmessage</code>属性，用于指定收到服务器数据后的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.<span class="property">data</span>;</span><br><span class="line">    <span class="comment">// 处理数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> data = event.<span class="property">data</span>;</span><br><span class="line">    <span class="comment">// 处理数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意，服务器数据可能是文本，也可能是二进制数据（<code>blob</code>对象或<code>Arraybuffer</code>对象）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(typeOf event.<span class="property">data</span> === <span class="title class_">String</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Received data string&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(event.<span class="property">data</span> <span class="keyword">instanceof</span> <span class="title class_">ArrayBuffer</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> buffer = event.<span class="property">data</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Received arraybuffer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了动态判断收到的数据类型，也可以使用<code>binaryType</code>属性，显式指定收到的二进制数据类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 收到的是 blob 数据</span></span><br><span class="line">ws.<span class="property">binaryType</span> = <span class="string">&quot;blob&quot;</span>;</span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>.<span class="property">size</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到的是 ArrayBuffer 数据</span></span><br><span class="line">ws.<span class="property">binaryType</span> = <span class="string">&quot;arraybuffer&quot;</span>;</span><br><span class="line">ws.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">data</span>.<span class="property">byteLength</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="webSocket-send"><a href="#webSocket-send" class="headerlink" title="webSocket.send()"></a>webSocket.send()</h4><p>实例对象的<code>send()</code>方法用于向服务器发送数据。</p>
<p>发送文本的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.<span class="title function_">send</span>(<span class="string">&#x27;your message&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>发送 Blob 对象的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="variable language_">document</span></span><br><span class="line">    .<span class="title function_">querySelector</span>(<span class="string">&#x27;input[type=&quot;file&quot;]&#x27;</span>)</span><br><span class="line">    .<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">ws.<span class="title function_">send</span>(file);</span><br></pre></td></tr></table></figure>

<p>发送 ArrayBuffer 对象的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sending canvas ImageData as ArrayBuffer</span></span><br><span class="line"><span class="keyword">var</span> img = canvas_context.<span class="title function_">getImageData</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>);</span><br><span class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(img.<span class="property">data</span>.<span class="property">length</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; img.<span class="property">data</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    binary[i] = img.<span class="property">data</span>[i];</span><br><span class="line">&#125;</span><br><span class="line">ws.<span class="title function_">send</span>(binary.<span class="property">buffer</span>);</span><br></pre></td></tr></table></figure>

<h4 id="webSocket-bufferedAmount"><a href="#webSocket-bufferedAmount" class="headerlink" title="webSocket.bufferedAmount"></a>webSocket.bufferedAmount</h4><p>实例对象的<code>bufferedAmount</code>属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">10000000</span>);</span><br><span class="line">socket.<span class="title function_">send</span>(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (socket.<span class="property">bufferedAmount</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 发送完毕</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 发送还没结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="webSocket-onerror"><a href="#webSocket-onerror" class="headerlink" title="webSocket.onerror"></a>webSocket.onerror</h4><p>实例对象的<code>onerror</code>属性，用于指定报错时的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socket.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// handle error event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.<span class="title function_">addEventListener</span>(<span class="string">&quot;error&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// handle error event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="WebSocket-服务器"><a href="#WebSocket-服务器" class="headerlink" title="WebSocket 服务器"></a>WebSocket 服务器</h3><p>WebSocket 协议需要服务器支持。各种服务器的实现，可以查看维基百科的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Comparison_of_WebSocket_implementations">列表</a>。</p>
<p>常用的 Node 实现有以下三种。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/uWebSockets/uWebSockets">µWebSockets</a></li>
<li><a target="_blank" rel="noopener" href="http://socket.io/">Socket.IO</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/theturtle32/WebSocket-Node">WebSocket-Node</a></li>
</ul>
<p>具体的用法请查看它们的文档，本教程不详细介绍了。</p>
<h3 id="参考链接-13"><a href="#参考链接-13" class="headerlink" title="参考链接"></a>参考链接</h3><ul>
<li>Ryan Stewart, <a target="_blank" rel="noopener" href="http://www.adobe.com/devnet/html5/articles/real-time-data-exchange-in-html5-with-websockets.html">Real-time data exchange in HTML5 with WebSockets</a></li>
<li>Malte Ubl &amp; Eiji Kitamura，<a target="_blank" rel="noopener" href="https://www.html5rocks.com/en/tutorials/websockets/basics/">Introducing WebSockets: Bringing Sockets to the Web</a></li>
<li>Jack Lawson, <a target="_blank" rel="noopener" href="http://buildnewgames.com/websockets/">WebSockets: A Guide</a></li>
<li>Michael W., <a target="_blank" rel="noopener" href="http://codular.com/node-web-sockets">Starting with Node and Web Sockets</a></li>
<li>Jesse Cravens, <a target="_blank" rel="noopener" href="http://tech.pro/tutorial/1167/introduction-to-websockets">Introduction to WebSockets</a></li>
<li>Matt West, <a target="_blank" rel="noopener" href="http://blog.teamtreehouse.com/an-introduction-to-websockets">An Introduction to WebSockets</a></li>
<li>Maciej Sopyło, <a target="_blank" rel="noopener" href="http://net.tutsplus.com/tutorials/javascript-ajax/node-js-better-performance-with-socket-io-and-dot/">Node.js: Better Performance With Socket.IO and doT</a></li>
<li>Jos Dirksen, <a target="_blank" rel="noopener" href="http://www.smartjava.org/content/capture-canvas-and-webgl-output-video-using-websockets">Capture Canvas and WebGL output as video using websockets</a></li>
<li>Fionn Kellehe, <a target="_blank" rel="noopener" href="https://nodesource.com/blog/understanding-socketio">Understanding Socket.IO</a></li>
<li><a target="_blank" rel="noopener" href="http://cjihrig.com/blog/how-to-use-websockets/">How to Use WebSockets</a></li>
<li><a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/websockets/websockets_send_receive_messages.htm">WebSockets - Send &amp; Receive Messages</a></li>
</ul>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">小u</div><div class="post-copyright__author_desc">热爱可抵岁月漫长</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2023/10/01/codenotes/front_end/WebApi/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2023/10/01/codenotes/front_end/WebApi/')">WebApi</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2023/10/01/codenotes/front_end/WebApi/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=WebApi&amp;url=http://example.com/2023/10/01/codenotes/front_end/WebApi/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E5%89%8D%E7%AB%AF/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>前端<span class="tagsPageCount">10</span></a><a class="post-meta__box__tags" href="/tags/WebApi/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>WebApi<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/01/codenotes/front_end/2023ts/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">都2023年了你还不学ts？</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/01/interview/day/8/1/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">8.7-Java 语言具有哪些特点</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/10/01/codenotes/book/front/" title="前端书籍推荐"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">前端书籍推荐</div></div></a></div><div><a href="/2023/10/01/codenotes/front_end/2023ts/" title="都2023年了你还不学ts？"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">都2023年了你还不学ts？</div></div></a></div><div><a href="/2023/10/01/codenotes/front_end/HTML/" title="HTML"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">HTML</div></div></a></div><div><a href="/2023/10/01/codenotes/front_end/ts/" title="一文搞懂TypeScript"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">一文搞懂TypeScript</div></div></a></div><div><a href="/2023/10/01/projects/zatan/8/3/" title="vertical-align什么时候用并且有效"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">vertical-align什么时候用并且有效</div></div></a></div><div><a href="/2023/10/01/projects/zatan/7/3/" title="css中margin和padding的区别"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">css中margin和padding的区别</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" ait="status"/></div></div><div class="author-info__description">Java,java,springboot,mysql,redis,教程,git,软件,编程,开发,互联网,Java 基础,Java 教程,Java程序员进阶之路,Java 入门,Vue,前端,算法</div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎来看我的博客 博客主地址：http://blog.xiaou61.top/  备用地址：https://newblog.guoyaxue.top/</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#WebApi"><span class="toc-number">1.</span> <span class="toc-text">WebApi</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Canvas-API"><span class="toc-number">2.</span> <span class="toc-text">Canvas API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Canvas-API%EF%BC%9A%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2"><span class="toc-number">2.2.</span> <span class="toc-text">Canvas API：绘制图形</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84"><span class="toc-number">2.2.1.</span> <span class="toc-text">路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E5%9E%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">线型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A9%E5%BD%A2"><span class="toc-number">2.2.3.</span> <span class="toc-text">矩形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%A7%E7%BA%BF"><span class="toc-number">2.2.4.</span> <span class="toc-text">弧线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC"><span class="toc-number">2.2.5.</span> <span class="toc-text">文本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%90%E5%8F%98%E8%89%B2%E5%92%8C%E5%9B%BE%E5%83%8F%E5%A1%AB%E5%85%85"><span class="toc-number">2.2.6.</span> <span class="toc-text">渐变色和图像填充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1"><span class="toc-number">2.2.7.</span> <span class="toc-text">阴影</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Canvas-API%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">Canvas API：图像处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CanvasRenderingContext2D-drawImage"><span class="toc-number">2.3.1.</span> <span class="toc-text">CanvasRenderingContext2D.drawImage()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%83%8F%E7%B4%A0%E8%AF%BB%E5%86%99"><span class="toc-number">2.3.2.</span> <span class="toc-text">像素读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CanvasRenderingContext2D-save-%EF%BC%8CCanvasRenderingContext2D-restore"><span class="toc-number">2.3.3.</span> <span class="toc-text">CanvasRenderingContext2D.save()，CanvasRenderingContext2D.restore()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CanvasRenderingContext2D-canvas"><span class="toc-number">2.3.4.</span> <span class="toc-text">CanvasRenderingContext2D.canvas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2"><span class="toc-number">2.3.5.</span> <span class="toc-text">图像变换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">&lt;canvas&gt; 元素的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTMLCanvasElement-toDataURL"><span class="toc-number">2.4.1.</span> <span class="toc-text">HTMLCanvasElement.toDataURL()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTMLCanvasElement-toBlob"><span class="toc-number">2.4.2.</span> <span class="toc-text">HTMLCanvasElement.toBlob()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Canvas-%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.5.</span> <span class="toc-text">Canvas 使用实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C"><span class="toc-number">2.5.1.</span> <span class="toc-text">动画效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%83%8F%E7%B4%A0%E5%A4%84%E7%90%86"><span class="toc-number">2.5.2.</span> <span class="toc-text">像素处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">2.6.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%AA%E8%B4%B4%E6%9D%BF%E6%93%8D%E4%BD%9C-Clipboard-API-%E6%95%99%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">剪贴板操作 Clipboard API 教程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Document-execCommand-%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">Document.execCommand() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-Clipboard-API"><span class="toc-number">3.3.</span> <span class="toc-text">异步 Clipboard API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Clipboard-%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.4.</span> <span class="toc-text">Clipboard 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Clipboard-readText"><span class="toc-number">3.4.1.</span> <span class="toc-text">Clipboard.readText()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Clipboard-read"><span class="toc-number">3.4.2.</span> <span class="toc-text">Clipboard.read()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Clipboard-writeText"><span class="toc-number">3.4.3.</span> <span class="toc-text">Clipboard.writeText()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Clipboard-write"><span class="toc-number">3.4.4.</span> <span class="toc-text">Clipboard.write()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copy-%E4%BA%8B%E4%BB%B6%EF%BC%8Ccut-%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.5.</span> <span class="toc-text">copy 事件，cut 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#paste-%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.6.</span> <span class="toc-text">paste 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-1"><span class="toc-number">3.7.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fetch-API-%E6%95%99%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">Fetch API 教程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Response-%E5%AF%B9%E8%B1%A1%EF%BC%9A%E5%A4%84%E7%90%86-HTTP-%E5%9B%9E%E5%BA%94"><span class="toc-number">4.2.</span> <span class="toc-text">Response 对象：处理 HTTP 回应</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Response-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E6%AD%A5%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.1.</span> <span class="toc-text">Response 对象的同步属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E8%AF%B7%E6%B1%82%E6%98%AF%E5%90%A6%E6%88%90%E5%8A%9F"><span class="toc-number">4.2.2.</span> <span class="toc-text">判断请求是否成功</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Response-headers-%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.3.</span> <span class="toc-text">Response.headers 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%86%85%E5%AE%B9%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.4.</span> <span class="toc-text">读取内容的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Response-clone"><span class="toc-number">4.2.5.</span> <span class="toc-text">Response.clone()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Response-body-%E5%B1%9E%E6%80%A7"><span class="toc-number">4.2.6.</span> <span class="toc-text">Response.body 属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fetch-%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9A%E5%AE%9A%E5%88%B6-HTTP-%E8%AF%B7%E6%B1%82"><span class="toc-number">4.3.</span> <span class="toc-text">fetch()的第二个参数：定制 HTTP 请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fetch-%E9%85%8D%E7%BD%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%8C%E6%95%B4-API"><span class="toc-number">4.4.</span> <span class="toc-text">fetch()配置对象的完整 API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%B6%88fetch-%E8%AF%B7%E6%B1%82"><span class="toc-number">4.5.</span> <span class="toc-text">取消fetch()请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-2"><span class="toc-number">4.6.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FontFace-API"><span class="toc-number">5.</span> <span class="toc-text">FontFace API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Geolocation-API"><span class="toc-number">6.</span> <span class="toc-text">Geolocation API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Geolocation-%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.1.</span> <span class="toc-text">Geolocation 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Geolocation-getCurrentPosition"><span class="toc-number">6.1.1.</span> <span class="toc-text">Geolocation.getCurrentPosition()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Geolocation-watchPosition"><span class="toc-number">6.1.2.</span> <span class="toc-text">Geolocation.watchPosition()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Geolocation-clearWatch"><span class="toc-number">6.1.3.</span> <span class="toc-text">Geolocation.clearWatch()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Coordinates-%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.2.</span> <span class="toc-text">Coordinates 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-3"><span class="toc-number">6.3.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IntersectionObserver"><span class="toc-number">7.</span> <span class="toc-text">IntersectionObserver</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">7.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IntersectionObserver-observe"><span class="toc-number">7.2.</span> <span class="toc-text">IntersectionObserver.observe()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#callback-%E5%8F%82%E6%95%B0"><span class="toc-number">7.2.1.</span> <span class="toc-text">callback 参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IntersectionObserverEntry-%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.2.2.</span> <span class="toc-text">IntersectionObserverEntry 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Option-%E5%AF%B9%E8%B1%A1"><span class="toc-number">7.2.3.</span> <span class="toc-text">Option 对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">7.3.</span> <span class="toc-text">实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%8A%A0%E8%BD%BD%EF%BC%88lazy-load%EF%BC%89"><span class="toc-number">7.3.1.</span> <span class="toc-text">惰性加载（lazy load）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E9%99%90%E6%BB%9A%E5%8A%A8"><span class="toc-number">7.3.2.</span> <span class="toc-text">无限滚动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E9%A2%91%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE"><span class="toc-number">7.3.3.</span> <span class="toc-text">视频自动播放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-4"><span class="toc-number">7.4.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Intl-RelativeTimeFormat"><span class="toc-number">8.</span> <span class="toc-text">Intl.RelativeTimeFormat</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-1"><span class="toc-number">8.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Intl-RelativeTimeFormat-prototype-format"><span class="toc-number">8.2.</span> <span class="toc-text">Intl.RelativeTimeFormat.prototype.format()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Intl-RelativeTimeFormat-prototype-formatToParts"><span class="toc-number">8.3.</span> <span class="toc-text">Intl.RelativeTimeFormat.prototype.formatToParts()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-5"><span class="toc-number">8.4.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Offline-%E5%BA%94%E7%94%A8"><span class="toc-number">9.</span> <span class="toc-text">Offline 应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Page-Lifecycle-API"><span class="toc-number">10.</span> <span class="toc-text">Page Lifecycle API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%98%B6%E6%AE%B5"><span class="toc-number">10.1.</span> <span class="toc-text">生命周期阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF"><span class="toc-number">10.2.</span> <span class="toc-text">常见场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.3.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#focus-%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.3.1.</span> <span class="toc-text">focus 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#blur-%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.3.2.</span> <span class="toc-text">blur 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#visibilitychange-%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.3.3.</span> <span class="toc-text">visibilitychange 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#freeze-%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.3.4.</span> <span class="toc-text">freeze 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#resume-%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.3.5.</span> <span class="toc-text">resume 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pageshow-%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.3.6.</span> <span class="toc-text">pageshow 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pagehide-%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.3.7.</span> <span class="toc-text">pagehide 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#beforeunload-%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.3.8.</span> <span class="toc-text">beforeunload 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unload-%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.3.9.</span> <span class="toc-text">unload 事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E9%98%B6%E6%AE%B5"><span class="toc-number">10.4.</span> <span class="toc-text">获取当前阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#document-wasDiscarded"><span class="toc-number">10.5.</span> <span class="toc-text">document.wasDiscarded</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-6"><span class="toc-number">10.6.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Page-Visibility-API"><span class="toc-number">11.</span> <span class="toc-text">Page Visibility API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">11.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#document-visibilityState"><span class="toc-number">11.2.</span> <span class="toc-text">document.visibilityState</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#document-hidden"><span class="toc-number">11.3.</span> <span class="toc-text">document.hidden</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#visibilitychange-%E4%BA%8B%E4%BB%B6-1"><span class="toc-number">11.4.</span> <span class="toc-text">visibilitychange 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%8D%B8%E8%BD%BD"><span class="toc-number">11.5.</span> <span class="toc-text">页面卸载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-7"><span class="toc-number">11.6.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Point-lock-API"><span class="toc-number">12.</span> <span class="toc-text">Point lock API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Server-Sent-Events"><span class="toc-number">13.</span> <span class="toc-text">Server-Sent Events</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="toc-number">13.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E-WebSocket-%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">13.2.</span> <span class="toc-text">与 WebSocket 的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-API"><span class="toc-number">13.3.</span> <span class="toc-text">客户端 API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EventSource-%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.3.1.</span> <span class="toc-text">EventSource 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readyState-%E5%B1%9E%E6%80%A7"><span class="toc-number">13.3.2.</span> <span class="toc-text">readyState 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#url-%E5%B1%9E%E6%80%A7"><span class="toc-number">13.3.3.</span> <span class="toc-text">url 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#withCredentials-%E5%B1%9E%E6%80%A7"><span class="toc-number">13.3.4.</span> <span class="toc-text">withCredentials 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#onopen-%E5%B1%9E%E6%80%A7"><span class="toc-number">13.3.5.</span> <span class="toc-text">onopen 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#onmessage-%E5%B1%9E%E6%80%A7"><span class="toc-number">13.3.6.</span> <span class="toc-text">onmessage 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#onerror-%E5%B1%9E%E6%80%A7"><span class="toc-number">13.3.7.</span> <span class="toc-text">onerror 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">13.3.8.</span> <span class="toc-text">自定义事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#close-%E6%96%B9%E6%B3%95"><span class="toc-number">13.3.9.</span> <span class="toc-text">close() 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.4.</span> <span class="toc-text">服务器实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">13.4.1.</span> <span class="toc-text">数据格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#data-%E5%AD%97%E6%AE%B5"><span class="toc-number">13.4.2.</span> <span class="toc-text">data 字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#id-%E5%AD%97%E6%AE%B5"><span class="toc-number">13.4.3.</span> <span class="toc-text">id 字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#event-%E5%AD%97%E6%AE%B5"><span class="toc-number">13.4.4.</span> <span class="toc-text">event 字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#retry-%E5%AD%97%E6%AE%B5"><span class="toc-number">13.4.5.</span> <span class="toc-text">retry 字段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Node-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">13.5.</span> <span class="toc-text">Node 服务器实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-8"><span class="toc-number">13.6.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service-Worker"><span class="toc-number">14.</span> <span class="toc-text">Service Worker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AB%E4%B9%89"><span class="toc-number">14.1.</span> <span class="toc-text">含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">14.2.</span> <span class="toc-text">使用步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BB%E8%AE%B0"><span class="toc-number">14.2.1.</span> <span class="toc-text">登记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">14.2.2.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB"><span class="toc-number">14.2.3.</span> <span class="toc-text">激活</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service-Worker-%E4%B8%8E%E7%BD%91%E9%A1%B5%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">14.3.</span> <span class="toc-text">Service Worker 与网页的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-9"><span class="toc-number">14.4.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SVG-%E5%9B%BE%E5%83%8F"><span class="toc-number">15.</span> <span class="toc-text">SVG 图像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">15.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">15.2.</span> <span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE"><span class="toc-number">15.2.1.</span> <span class="toc-text">&lt;svg&gt;标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-1"><span class="toc-number">15.2.2.</span> <span class="toc-text">&lt;circle&gt;标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-2"><span class="toc-number">15.2.3.</span> <span class="toc-text">&lt;line&gt;标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-3"><span class="toc-number">15.2.4.</span> <span class="toc-text">&lt;polyline&gt;标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-4"><span class="toc-number">15.2.5.</span> <span class="toc-text">&lt;rect&gt;标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-5"><span class="toc-number">15.2.6.</span> <span class="toc-text">&lt;ellipse&gt;标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-6"><span class="toc-number">15.2.7.</span> <span class="toc-text">&lt;polygon&gt;标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-7"><span class="toc-number">15.2.8.</span> <span class="toc-text">&lt;path&gt;标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-8"><span class="toc-number">15.2.9.</span> <span class="toc-text">&lt;text&gt;标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-9"><span class="toc-number">15.2.10.</span> <span class="toc-text">&lt;use&gt;标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-10"><span class="toc-number">15.2.11.</span> <span class="toc-text">&lt;g&gt;标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-11"><span class="toc-number">15.2.12.</span> <span class="toc-text">&lt;defs&gt;标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-12"><span class="toc-number">15.2.13.</span> <span class="toc-text">&lt;pattern&gt;标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-13"><span class="toc-number">15.2.14.</span> <span class="toc-text">&lt;image&gt;标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-14"><span class="toc-number">15.2.15.</span> <span class="toc-text">&lt;animate&gt;标签</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-15"><span class="toc-number">15.2.16.</span> <span class="toc-text">&lt;animateTransform&gt;标签</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-%E6%93%8D%E4%BD%9C"><span class="toc-number">15.3.</span> <span class="toc-text">JavaScript 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DOM-%E6%93%8D%E4%BD%9C"><span class="toc-number">15.3.1.</span> <span class="toc-text">DOM 操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-SVG-DOM"><span class="toc-number">15.3.2.</span> <span class="toc-text">获取 SVG DOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96-SVG-%E6%BA%90%E7%A0%81"><span class="toc-number">15.3.3.</span> <span class="toc-text">读取 SVG 源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SVG-%E5%9B%BE%E5%83%8F%E8%BD%AC%E4%B8%BA-Canvas-%E5%9B%BE%E5%83%8F"><span class="toc-number">15.3.4.</span> <span class="toc-text">SVG 图像转为 Canvas 图像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E6%8A%98%E7%BA%BF%E5%9B%BE"><span class="toc-number">15.4.</span> <span class="toc-text">实例：折线图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-10"><span class="toc-number">15.5.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-Share-API"><span class="toc-number">16.</span> <span class="toc-text">Web Share API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">16.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%86%E8%8A%82"><span class="toc-number">16.2.</span> <span class="toc-text">接口细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BA%AB%E6%96%87%E4%BB%B6"><span class="toc-number">16.3.</span> <span class="toc-text">分享文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-11"><span class="toc-number">16.4.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-Audio-API"><span class="toc-number">17.</span> <span class="toc-text">Web Audio API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-2"><span class="toc-number">17.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#context-createBuffer"><span class="toc-number">17.2.</span> <span class="toc-text">context.createBuffer()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">17.3.</span> <span class="toc-text">过滤器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-Components"><span class="toc-number">18.</span> <span class="toc-text">Web Components</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">18.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Custom-Element"><span class="toc-number">18.2.</span> <span class="toc-text">Custom Element</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="toc-number">18.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95"><span class="toc-number">18.2.2.</span> <span class="toc-text">生命周期方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">18.2.3.</span> <span class="toc-text">自定义属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-customElements-whenDefined"><span class="toc-number">18.2.4.</span> <span class="toc-text">window.customElements.whenDefined()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">18.2.5.</span> <span class="toc-text">回调函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Custom-Element-%E7%9A%84%E5%AD%90%E5%85%83%E7%B4%A0"><span class="toc-number">18.2.6.</span> <span class="toc-text">Custom Element 的子元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE-16"><span class="toc-number">18.3.</span> <span class="toc-text">&lt;template&gt;标签</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95-3"><span class="toc-number">18.3.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-importNode"><span class="toc-number">18.3.2.</span> <span class="toc-text">document.importNode()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shadow-DOM"><span class="toc-number">18.4.</span> <span class="toc-text">Shadow DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML-Import"><span class="toc-number">18.5.</span> <span class="toc-text">HTML Import</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">18.5.1.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">18.5.2.</span> <span class="toc-text">脚本的执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Web-Component%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-number">18.5.3.</span> <span class="toc-text">Web Component的封装</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Polymer-js"><span class="toc-number">18.6.</span> <span class="toc-text">Polymer.js</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">18.6.1.</span> <span class="toc-text">直接使用的组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-1"><span class="toc-number">18.6.2.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6"><span class="toc-number">18.6.3.</span> <span class="toc-text">自定义组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">18.6.4.</span> <span class="toc-text">组件的使用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-12"><span class="toc-number">18.7.</span> <span class="toc-text">参考链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WebSocket"><span class="toc-number">19.</span> <span class="toc-text">WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-5"><span class="toc-number">19.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket-%E6%8F%A1%E6%89%8B"><span class="toc-number">19.2.</span> <span class="toc-text">WebSocket 握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">19.3.</span> <span class="toc-text">客户端的简单示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-API-1"><span class="toc-number">19.4.</span> <span class="toc-text">客户端 API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-WebSocket"><span class="toc-number">19.4.1.</span> <span class="toc-text">构造函数 WebSocket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webSocket-readyState"><span class="toc-number">19.4.2.</span> <span class="toc-text">webSocket.readyState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webSocket-onopen"><span class="toc-number">19.4.3.</span> <span class="toc-text">webSocket.onopen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webSocket-onclose"><span class="toc-number">19.4.4.</span> <span class="toc-text">webSocket.onclose</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webSocket-onmessage"><span class="toc-number">19.4.5.</span> <span class="toc-text">webSocket.onmessage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webSocket-send"><span class="toc-number">19.4.6.</span> <span class="toc-text">webSocket.send()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webSocket-bufferedAmount"><span class="toc-number">19.4.7.</span> <span class="toc-text">webSocket.bufferedAmount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#webSocket-onerror"><span class="toc-number">19.4.8.</span> <span class="toc-text">webSocket.onerror</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebSocket-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">19.5.</span> <span class="toc-text">WebSocket 服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5-13"><span class="toc-number">19.6.</span> <span class="toc-text">参考链接</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/27/" title="再见 MyBatis-Plus ！">再见 MyBatis-Plus ！</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/26/" title="“人尽皆知”的单例模式">“人尽皆知”的单例模式</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/29/" title="阿里的同事，写的代码真 TMD 优雅！">阿里的同事，写的代码真 TMD 优雅！</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/28/" title="别再用 BeanUtils 了，这款 PO VO DTO 转换神器不香么？">别再用 BeanUtils 了，这款 PO VO DTO 转换神器不香么？</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/30/" title="MyBatis过时了吗？">MyBatis过时了吗？</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="小u" target="_blank">小u</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">238</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">39</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">50</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://mydocs.guoyaxue.top/" title="旧版博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="旧版博客"/><span class="back-menu-item-text">旧版博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://pan.xiaou61.top/#/" title="免费网盘"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="免费网盘"/><span class="back-menu-item-text">免费网盘</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://cloud.xiaou61.top/" title="云盘(自用)"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="云盘(自用)"/><span class="back-menu-item-text">云盘(自用)</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://wpzc.xiaou61.top/" title="云盘转存"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="云盘转存"/><span class="back-menu-item-text">云盘转存</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://love.xiaou61.top/#/" title="关于我们(My girlFriend)"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="关于我们(My girlFriend)"/><span class="back-menu-item-text">关于我们(My girlFriend)</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">娱乐项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://fxq.xiaou61.top/#/" title="飞行棋"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="飞行棋"/><span class="back-menu-item-text">飞行棋</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/game/sqnwmai803/" title="谁去拿外卖"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="谁去拿外卖"/><span class="back-menu-item-text">谁去拿外卖</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/desktop.html" title="win12网页版"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/icon/logo.svg" alt="win12网页版"/><span class="back-menu-item-text">win12网页版</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://game.xiaou61.top/" title="在线游戏"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="在线游戏"/><span class="back-menu-item-text">在线游戏</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 开往</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><span> 开往</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>3</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JVM/" style="font-size: 0.88rem;">JVM<sup>22</sup></a><a href="/tags/Nginx/" style="font-size: 0.88rem;">Nginx<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>1</sup></a><a href="/tags/Ts/" style="font-size: 0.88rem;">Ts<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size: 0.88rem;">TypeScript<sup>1</sup></a><a href="/tags/WebApi/" style="font-size: 0.88rem;">WebApi<sup>1</sup></a><a href="/tags/coder1v5/" style="font-size: 0.88rem;">coder1v5<sup>2</sup></a><a href="/tags/css/" style="font-size: 0.88rem;">css<sup>3</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>12</sup></a><a href="/tags/javaSE/" style="font-size: 0.88rem;">javaSE<sup>3</sup></a><a href="/tags/javaWeb/" style="font-size: 0.88rem;">javaWeb<sup>2</sup></a><a href="/tags/js%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">js逆向<sup>1</sup></a><a href="/tags/leetcode/" style="font-size: 0.88rem;">leetcode<sup>3</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>8</sup></a><a href="/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/" style="font-size: 0.88rem;">书籍推荐<sup>2</sup></a><a href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%90%AC%E8%BF%90/" style="font-size: 0.88rem;">公众号搬运<sup>35</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 0.88rem;">前端<sup>10</sup></a><a href="/tags/%E5%8A%9E%E5%85%AC/" style="font-size: 0.88rem;">办公<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 0.88rem;">后端<sup>8</sup></a><a href="/tags/%E5%A4%A9%E6%B6%AF%E8%AE%BA%E5%9D%9B/" style="font-size: 0.88rem;">天涯论坛<sup>1</sup></a><a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 0.88rem;">导航<sup>1</sup></a><a href="/tags/%E5%B0%B1%E4%B8%9A/" style="font-size: 0.88rem;">就业<sup>16</sup></a><a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 0.88rem;">微信<sup>1</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/" style="font-size: 0.88rem;">技术杂谈<sup>51</sup></a><a href="/tags/%E6%8E%98%E9%87%91/" style="font-size: 0.88rem;">掘金<sup>14</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 0.88rem;">杂项<sup>1</sup></a><a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 0.88rem;">测试<sup>1</sup></a><a href="/tags/%E6%B8%A1%E4%B8%80%E5%A4%A7%E5%B8%88%E8%AF%BE/" style="font-size: 0.88rem;">渡一大师课<sup>3</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 0.88rem;">爬虫<sup>1</sup></a><a href="/tags/%E7%9B%AE%E5%BD%95/" style="font-size: 0.88rem;">目录<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>4</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 0.88rem;">虚拟机<sup>12</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>6</sup></a><a href="/tags/%E8%B7%AF%E9%A3%9E%E5%AD%A6%E9%99%A2/" style="font-size: 0.88rem;">路飞学院<sup>3</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">面向对象<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>51</sup></a><a href="/tags/%E9%A3%9E%E8%A1%8C%E6%A3%8B/" style="font-size: 0.88rem;">飞行棋<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="7409599794" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>