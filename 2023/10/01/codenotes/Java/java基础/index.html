<!DOCTYPE html><html class="hide-aside" lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>java基础 | 小u的博客</title><meta name="keywords" content="java,javaSE"><meta name="author" content="小u"><meta name="copyright" content="小u"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="java基础"><meta name="application-name" content="java基础"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="java基础"><meta property="og:url" content="http://example.com/2023/10/01/codenotes/Java/java%E5%9F%BA%E7%A1%80/index.html"><meta property="og:site_name" content="小u的博客"><meta property="og:description" content="Java​    这个是书写的第一本小册，用来详细的去复习java的基础的内容，这里会记录一些我从其他书籍上看到的相关的介绍，简介等，以及自己对于这个的理解，以及一些详细的案例。综合考虑来制作这样的一本java基础书籍，会持续的去补充这里的东西。 java概述以及环境变量的配置为什么选择java很"><meta property="og:locale" content="en"><meta property="og:image" content="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png"><meta property="article:author" content="小u"><meta property="article:tag" content="Java,java,springboot,mysql,redis,教程,git,软件,编程,开发,互联网,Java 基础,Java 教程,Java程序员进阶之路,Java 入门,Vue,前端,算法"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png"><meta name="description" content="Java​    这个是书写的第一本小册，用来详细的去复习java的基础的内容，这里会记录一些我从其他书籍上看到的相关的介绍，简介等，以及自己对于这个的理解，以及一些详细的案例。综合考虑来制作这样的一本java基础书籍，会持续的去补充这里的东西。 java概述以及环境变量的配置为什么选择java很"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2023/10/01/codenotes/Java/java%E5%9F%BA%E7%A1%80/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//hm.baidu.com"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1433b93d16cca6b366bdf23126c0c200";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"tianli","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"784b999ee9b2f0689c5a","Referer":"https://mydocs-1305448902.cos-website.ap-nanjing.myqcloud.com/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: 小u","link":"Link: ","source":"Source: 小u的博客","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小u的博客',
  title: 'java基础',
  postAI: '',
  pageFillDescription: 'Java, java概述以及环境变量的配置, 为什么选择java, 为什么java最广泛, java简介, 关于java的常见误解, java语法基础, 第一个java程序, 基本语法, java标识符, java修饰符, java变量, java关键字, final, static, java注释, java数据类型, 01、比特和字节, 1）bit（比特）, 2）Byte（字节）, 02.基本数据类型, 整型, 浮点型, 布尔类型, 字符串型, 03、单精度和双精度, 04、引用数据类型, 05、栈和堆, 06、数据类型之间的转换, 01、自动类型转换, 02、强制类型转换, 07、缓存池, java运算符, 01、算术运算符, 02、关系运算符, 03、位运算符, 04、逻辑运算符, 05、赋值运算符, 06、三元运算符, 07、运算符优先级, java流程控制语句, 01、if-else 相关, 1）if 语句, 2）if-else 语句, 3）if-else-if 语句, 4）if 嵌套语句, 02、switch 语句, 03、for 循环, 1）普通 for 循环, 2）for-each, 3）无限 for 循环, 04、while 循环, 05、do-while 循环, 06、break, 07、continue, 08、switch case 语句, 案例, 1.*回文数：正序和倒序一样的整数, 2.给定两个整数被除数和除数将两个数相除要求不能使用除法。乘法和取余, 小结, 数组 amp 字符串, java数组, 一维数组, 二维数组, 打印java数组, stream 流打印 Java 数组, for 循环打印 Java 数组, Arrays 工具类打印 Java 数组, Arrays工具类打印二维数组, POJO 的打印规约, 字符串, Java String类, 创建字符串, 字符串长度, String 方法, 解读String源码, String 类的声明, String 类的底层实现, 类的 hashCode 方法, String 类的 substring 方法, String 类的 indexOf 方法, 类的其他方法, string字符串为什么不可变, String Pool, String StringBuffer and StringBuilder, new String(abc), Java 字符串优化：详解 String.intern() 方法, StringJoiner, 字符串相等判断：Java中的equals()与x3Dx3D的区别与用法, 案例, 总结 amp 后记这个是书写的第一本小册用来详细的去复习的基础的内容这里会记录一些我从其他书籍上看到的相关的介绍简介等以及自己对于这个的理解以及一些详细的案例综合考虑来制作这样的一本基础书籍会持续的去补充这里的东西概述以及环境变量的配置为什么选择很简单因为因为是全球排名第一的编程语言工程师也是市场需求最大的软件工程师选择就是选择了高薪虽然现在市场上有很多制造失业等的一些焦虑不过这种现象再各个行业都有所体现相对来说目前还是值得去入手的一门语言为什么最广泛从互联网到企业平台是应用最广泛的编程语言原因在于是基于虚拟机的跨平台语言一次编写到处运行程序易于编写而且有内置垃圾收集不必考虑内存管理虚拟机拥有工业级的稳定性和高度优化的性能且经过了长时期的考验拥有最广泛的开源社区支持各种高质量组件随时可用语言常年霸占着三大市场互联网和企业应用这是的长期优势和市场地位大数据平台主要有等他们都是或一种运行于的编程语言开发的移动平台这意味着拥有最广泛的就业市场同时是一门面向对象的编程语言这个在后续会说什么是面向对象的编程语言对于的可移植性也是非常可见的有一句口号一次编写到处运行这也是的魅力所在而实现这种特性的正是虚拟机已编译的程序可以在任何带有的平台上运行你可以在平台编写代码然后拿到上运行只要你在编写完代码后将代码编译成文件再把文件打成包这个包就可以在不同的平台上运行了是一个强类型语言它允许扩展编译时检查潜在类型不匹配问题的功能要求显式的方法声明它不支持风格的隐式声明这些严格的要求保证编译程序能捕捉调用错误这就导致更可靠的程序简介最早是由公司已被收购的詹姆斯高斯林高司令人称之父在上个世纪年代初开发的一种编程语言最初被命名为目标是针对小型家电设备的嵌入式应用结果市场没啥反响谁料到互联网的崛起让重新焕发了生机于是公司改造了在年以的名称正式发布原因是已经被人注册了因此注册了这个商标随着互联网的高速发展逐渐成为最重要的网络编程语言介于编译型语言和解释型语言之间编译型语言如代码是直接编译成机器码执行但是不同的平台等的指令集不同因此需要编译出每一种平台的对应机器码解释型语言如没有这个问题可以由解释器直接加载源码然后运行代价是运行效率太低而是将代码编译成一种字节码它类似于抽象的指令然后针对不同平台编写虚拟机不同平台的虚拟机负责加载字节码并执行这样就实现了一次编写到处运行的效果当然这是针对开发者而言对于虚拟机需要为每个平台分别开发为了保证不同平台不同公司开发的虚拟机都能正确执行字节码公司制定了一系列的虚拟机规范从实践的角度看的兼容性做得非常好低版本的字节码完全可以正常运行在高版本的上随着的发展给又分出了三个不同版本这三者之间有啥关系呢简单来说就是标准版包含标准的和标准库而是企业版它只是在的基础上加上了大量的和库以便方便开发应用数据库消息服务等的应用使用的虚拟机和完全相同就和不同它是一个针对嵌入式设备的瘦身版的标准库无法在上使用的虚拟机也是瘦身版毫无疑问是整个平台的核心而是进一步学习应用所必须的我们熟悉的等框架都是开源生态系统的一部分不幸的是从来没有真正流行起来反而是开发成为了移动平台的标准之一因此没有特殊需求不建议学习直到现在已经迎来了的版本对于的开发工具也是有很多的选择目前推荐用的就是这本书也都是在上来进行操作的关于的常见误解当然关于安装的这部分这个书就不做解释了也可能以后会做解释目前是不做解释了话不多说直接开始下面的学习语法基础第一个程序首先要知道是面向对象设计的所以首先要引入下面几个概念对象对象是类的一个实例有状态和行为例如一条狗是一个对象它的状态有颜色名字品种行为有摇尾巴叫吃等类类是一个模板它描述一类对象的行为和状态方法方法就是行为一个类可以有很多方法逻辑运算数据修改以及所有动作都是在方法中完成的实例变量每个对象都有独特的实例变量对象的状态由这些实例变量的值决定一般的每一个语言的开始都是从开始当然也不例外这就是的乍一看还是非常的麻烦的但是如果详细的说明其实也没那么麻烦了下面就对这一行代码进行一个简单的解析在一个程序中你总能找到一个类似的定义这个定义被称为类这里的类名是大小写敏感用来定义一个类表示这个类是公开的都是的关键字必须小写是类的名字按照习惯首字母要大写而花括号中间则是类的定义注意到类的定义中我们定义了一个名为的方法方法是可执行的代码块一个方法除了方法名还有用括起来的方法参数这里的方法有一个参数参数类型是参数名是用来修饰方法这里表示它是一个公开的静态方法是方法的返回类型而花括号中间的就是方法的代码方法的代码每一行用结束这里只有一行代码就是它用来打印一个字符串到屏幕上规定某个类定义的是程序的固定入口方法因此程序总是从方法开始执行注意到源码的缩进不是必须的但是用缩进后格式好看很容易看出代码块的开始和结束缩进一般是个空格或者一个最后当我们把代码保存为文件时文件名必须是而且文件名也要注意大小写因为要和我们定义的类名完全保持一致简单来说我们可以来看这个图之后我们在中点击运行就可以了这样我们就书写完我们的第一个程序了这里就不讲如何用命令在控制台上做输出了因为这本书主打的就是一个快速入门所以一些不重要或者是已经被淘汰的东西我这里就不做介绍了基本语法编写程序时应注意以下几点大小写敏感是大小写敏感的这就意味着标识符与是不同的类名对于所有的类来说类名的首字母应该大写如果类名由若干单词组成那么每个单词的首字母应该大写例如方法名所有的方法名都应该以小写字母开头如果方法名含有若干单词则后面的每个单词首字母大写源文件名源文件名必须和类名相同当保存文件的时候你应该使用类名作为文件名保存切记是大小写敏感的文件名的后缀为如果文件名和类名不相同则会导致编译错误主方法入口所有的程序由方法开始执行标识符所有的组成部分都需要名字类名变量名以及方法名都被称为标识符关于标识符有以下几点需要注意所有的标识符都应该以字母或者美元符或者下划线开始首字符之后可以是字母或者美元符下划线或数字的任何字符组合关键字不能用作标识符标识符是大小写敏感的合法标识符举例非法标识符举例修饰符像其他语言一样可以使用修饰符来修饰类中方法和属性主要有两类修饰符访问控制修饰符非访问控制修饰符变量什么是变量变量就是初中数学的代数的概念例如一个简单的方程都是变量在中变量分为两种基本类型的变量和引用类型的变量我们先讨论基本类型的变量在中变量必须先定义后使用在定义变量的时候可以给它一个初始值例如上述语句定义了一个整型类型的变量名称为初始值为不写初始值就相当于给它指定了默认值默认值总是来看一个完整的定义变量然后打印变量值的例子定义类型变量并赋予初始值打印该变量的值变量的一个重要特点是可以重新赋值例如对变量先赋值再赋值观察两次打印的结果定义类型变量并赋予初始值打印该变量的值观察是否为重新赋值为打印该变量的值观察是否为注意到第一次定义变量的时候需要指定变量类型因此使用语句而第二次重新赋值的时候变量已经存在了不能再重复定义因此不能指定变量类型必须使用语句变量不但可以重新赋值还可以赋值给其他变量让我们来看一个例子定义变量同时赋值为打印的值变量赋值为打印的值变量赋值为的值为因此赋值后的值也是打印的值变量赋值为的值为因此赋值后的值是打印的值再次打印的值应该是还是我们一行一行地分析代码执行流程执行该语句定义了变量同时赋值为因此在内存中为变量分配一个存储单元填入值执行时把写入变量的存储单元因此原有的值被覆盖现在的值为执行时定义了一个新的变量同时对赋值因此需要新分配一个存储单元给变量并写入和变量一样的值结果是变量的值也变为执行时首先计算等式右边的值结果为因为此刻的值为然后将结果写入的存储单元因此变量最终的值变为可见变量可以反复赋值注意等号是赋值语句不是数学意义上的相等否则无法解释中主要有如下几种类型的变量局部变量类变量静态变量成员变量非静态变量下面我们就来对一个变量的例题进行练习题目非常的简单就是一个关于公交车上下车的问题功能概述题目如下一开始公交车上没有乘客第一站上去一个乘客第二站上去俩位乘客下来一个乘客第三站上去俩位乘客下来一个乘客第四站下来一位乘客第五站上来一位乘客问题到了终点站车上一共几位乘客变量练习之计算公交车的人数关键字有一组关键字这些关键字是保留字不能用作变量方法类或任何其他标识符关键字就是系统指定的不需要我们去定义的一些东西他一共有下面这几种类别关键字说明访问控制私有的受保护的公共的默认类方法和变量修饰符声明抽象类扩充继承最终值不可改变的实现接口接口本地原生方法非实现创建静态严格浮点精准浮点线程同步短暂易失程序控制语句跳出循环定义一个值以供选择继续运行否则循环如果实例返回根据值选择执行循环错误处理断言表达式是否为真捕捉异常有没有异常都执行抛出一个异常对象声明一个异常可能被抛出捕获异常包相关引入包基本类型布尔型字节型字符型双精度浮点单精度浮点整型长整型短整型变量引用父类超类本类无返回值保留关键字是关键字但不能使用是关键字但不能使用注意的不是关键字类似于和它是一个字面常量不允许作为标识符使用这里将对关键字进行一个介绍这里没听懂也没关系只是方便后续去查看的用于声明抽象类以及抽象方法在这个示例中我们创建了一个名为的抽象类其中包含一个抽象方法和一个具体方法中的一种基本数据类型表示布尔值即真或假数据类型常用于判断条件循环控制和逻辑运算等场景在这个示例中我们定义了一个变量通过语句我们可以根据这些变量的值进行不同的操作用于跳出循环结构如和循环或语句当遇到语句时程序将立即跳出当前循环或语句继续执行紧跟在循环或语句后面的代码在这个示例中我们使用循环遍历到的整数当等于时我们使用语句跳出循环用于表示一个位字节有符号整数它的值范围是到由于类型占用的空间较小它通常用于处理大量的数据如文件读写网络传输等场景以节省内存空间在这个示例中我们声明了三个类型的变量并分别赋予了不同的值通常与语句一起使用语句允许根据某个变量的值来选择执行不同的代码块在语句中用于标识每个可能的值和对应的代码块例子我们直接放到中一起讲用于捕获语句中的异常在块中可能会抛出异常而在块中可以捕获这些异常并进行处理块可以有多个每个块可以捕获特定类型的异常在块中可以根据需要进行异常处理例如输出错误信息进行日志记录恢复程序状态等这个程序使用语句捕获异常在块中尝试将字符串转换为整数类型由于这个字符串不是有效的数字格式将会抛出异常在块中捕获到了这个异常并输出一条错误信息用于声明一个字符类型的变量类型的变量可以存储任意的字符可以使用单引号将字符括起来来表示这个程序创建了一个类型的变量并将其赋值为大写字母用于声明一个类用于继续下一个循环可以在指定条件下跳过其余代码用于指定语句中除去条件之外的默认代码块这个我们放到里一起演示通常和关键字配合使用后紧跟循环体循环与循环类似不同之处在于循环会先执行循环体中的代码然后再检查循环条件因此循环至少会执行一次循环体中的代码用于声明一个双精度浮点类型的变量用于指示语句中的备用分支及格了挂科了用于定义一组固定的常量枚举用于指示一个类是从另一个类或接口继承的动物正在吃东西狗在汪汪叫类中有一个方法输出字符串动物正在吃东西类继承自类并定义了一个方法输出字符串狗在汪汪叫用于表示某个变量方法或类是最终的不能被修改或继承变量表示一个常量一旦被赋值其值就不能再被修改这在声明不可变的值时非常有用方法表示一个不能被子类重写的方法这在设计类时确保某个方法的实现不会被子类修改时非常有用动物发出声音错误无法覆盖来自的方法狗吠叫类表示一个不能被继承的类这在设计类时确保其不会被其他类继承时非常有用类就是的动物发出声音错误类型无法继承类狗吠叫和配合使用表示无论是否处理异常总是执行块中的代码抛出异常发生了异常块被执行表示单精度浮点数注意要在数字后面加上表示这是一个类型科学计数法表示小数在中浮点数默认是类型如果要使用类型的数据需要在数字后面加上一个或者表示这是一个类型的字面量另外也可以使用科学计数法表示浮点数例如表示用于声明一个循环如果循环次数是固定的建议使用循环用于指定条件如果条件为真则执行对应代码是正数是负数是零用于实现接口下面是一个实现了接口的类的示例线程执行的代码用于导入对应的类或者接口例如如果要使用标准库中的类可以这样写用于判断对象是否属于某个类型例如假设有一个类和一个类类继承自类可以使用运算符来判断一个对象是否为类或其子类的实例用于表示整数值声明一个类型的变量将整数值赋给变量声明并初始化一个类型的变量赋值为整数值用于声明接口会定义一组方法的签名即方法名参数列表和返回值类型但没有方法体其他类可以实现接口并提供方法的具体实现用于表示长整数值声明一个类型的变量将长整数值赋给变量需要在数字后面加上或表示这是一个类型的值声明并初始化一个类型的变量赋值为长整数值用于声明一个本地方法本地方法是指在代码中声明但在本地代码通常是或代码中实现的方法它通常用于与操作系统或其他本地库进行交互用于创建一个新的对象以下是使用关键字创建对象实例的基本语法以下是使用关键字创建数组实例的基本语法如果一个变量是空的什么引用也没有指向就可以将它赋值为和空指针异常息息相关声明一个字符串引用初始化为声明一个类型的引用初始化为用于声明类所在的包一个访问权限修饰符表示方法或变量只对当前类可见私有属性只能在当前类的内部访问私有方法只能在当前类的内部调用在这个示例中类有一个私有属性和一个私有方法这些成员只能在类的内部访问和调用对其他类不可见一个访问权限修饰符表示方法或变量对同一包内的类和所有子类可见受保护的属性可以被子类和同一包中的其他类访问受保护的方法可以被子类和同一包中的其他类调用可以访问中的受保护属性可以调用中的受保护方法在这个示例中类有一个受保护的属性和一个受保护的方法这些成员可以被子类和同一包中的其他类访问和调用类继承自类并可以访问和修改中的受保护成员一个访问权限修饰符除了可以声明方法和变量所有类可见还可以声明类方法必须声明为公有属性可以被任何类访问公有方法可以被任何类调用在这个示例中类有一个公有属性和一个公有方法这些成员可以被任何类访问和调用无论这些类是否在同一个包中用于从方法中返回一个值或终止方法的执行语句可以将方法的计算结果返回给调用者或者在方法执行到某个特定条件时提前结束方法返回的值并结束方法的执行此外语句还可以用于提前结束方法的执行例如假设我们要编写一个方法用于判断一个整数是否为偶数在这个示例中我们定义了一个名为的方法该方法接收一个整数参数如果是偶数我们使用语句提前返回否则方法执行将继续最后返回用于表示短整数占用个字节位的内存空间声明一个类型的变量赋值为声明一个类型的变量赋值为表示该变量或方法是静态变量或静态方法静态变量属于类的成员静态方法属于类的成员在这个示例中类有一个静态变量和一个静态方法这些成员属于类的成员可以通过类名直接访问不需要创建对象并不常见通常用于修饰一个方法用于限制浮点数计算的精度和舍入行为当你在类接口或方法上使用时该范围内的所有浮点数计算将遵循标准的规定以确保跨平台的浮点数计算的一致性不同的硬件平台和实现可能对浮点数计算的精度和舍入行为有差异这可能导致在不同环境中运行相同的浮点数计算代码产生不同的结果使用关键字可以确保在所有平台上获得相同的浮点数计算结果避免计算结果的不一致问题但请注意使用可能会对性能产生影响因为可能需要更多的计算和转换来确保遵循标准因此在使用时需要权衡精度和一致性与性能之间的关系输出在这个示例中类被声明为因此类中的所有浮点数计算都将遵循标准在大多数现代操作系统上使用可能不会产生显著差异因为大家都遵循标准除非是一些较旧的硬件平台标准是一个定义浮点数表示和运算的国际标准由国际电气和电子工程师协会制定首次发布于年标准主要规定了以下几个方面浮点数表示标准定义了两种浮点数格式单精度位和双精度位这两种格式分别由符号位指数位和尾数位组成用于表示浮点数的大小和精度四舍五入和舍入模式标准定义了多种舍入模式例如向最接近的数舍入向零舍入向正无穷舍入和向负无穷舍入等这些模式指导了浮点数计算过程中如何处理精度损失和舍入误差特殊值标准定义了一些特殊的浮点数值如正无穷负无穷和非数值这些特殊值用于表示浮点数计算中可能出现的溢出下溢和未定义结果等情况浮点数运算标准规定了浮点数的基本运算加减乘除和比较运算等于不等于大于小于大于等于小于等于的行为和结果这些运算需要遵循标准中规定的表示舍入和特殊值处理规则来看示例输出结果我们可以看到标准中的浮点数表示和运算单精度浮点数的加法变量和分别存储了和它们的和等于由于浮点数表示的精度限制的实际值可能与理论值略有误差特殊值变量和分别存储了正无穷负无穷和非数值这些特殊值是由除法运算产生的当被除数为或结果无法表示时会返回相应的特殊值可用于调用父类的方法或者字段调用父类的构造方法调用父类的方法用于根据某个变量的值选择执行不同的代码块语句通常与和一起使用每个子句表示一个可能的值和对应的代码块而子句用于处理不在子句中的值在这个示例中我们定义了一个名为的整数变量并赋予了一个值然后我们使用语句根据的值来输出对应的星期几每个子句表示可能的值后面紧跟着要执行的代码使用语句跳出语句避免执行其他子句的代码如果的值不在子句中子句将被执行用于指定多线程代码中的同步方法变量或者代码块同步方法同步代码块执行一些需要同步的操作可用于在方法或构造方法中引用当前对象使用关键字引用当前对象的成员变量使用关键字引用当前对象的成员变量返回当前对象本身在这个示例中类有一个私有成员变量并定义了一个构造方法一个方法和一个返回当前对象的方法在构造方法中使用关键字引用当前对象的成员变量并将传入的参数赋值给该成员变量在方法中使用关键字引用当前对象的成员变量并输出该成员变量的值在方法中直接返回当前对象本身主动抛出异常手动抛出异常执行一些操作用于声明异常手动抛出异常执行一些操作修饰的字段不会被序列化省略和方法在这个示例中类实现了接口表示该类的对象可以被序列化该类有三个成员变量分别是和其中成员变量被标记为表示在序列化过程中忽略这个成员变量用于包裹要捕获异常的代码块可能抛出异常的代码异常处理代码用于指定方法没有返回值方法体保证不同线程对它修饰的变量进行操作时的可见性即一个线程修改了某个变量的值新值对其他线程来说是立即可见的线程执行的代码在这个示例中类继承了类重写了方法类有一个成员变量被标记为表示这个变量是共享的可能会被多个线程同时访问在方法中使用循环检查变量的值如果为就继续执行循环体中的代码在另一个方法中将变量的值设置为表示需要停止线程如果循环次数不固定建议使用循环除了这些关键字中还有两个非常特殊的保留字和它们不能在程序中使用在语言中叫做无限跳转语句在中不再使用语句因为无限跳转会破坏程序结构中确实可以使用标签与和语句结合来实现类似的跳转功能以下是一个简单的示例跳过中的当前迭代结束在这个示例中我们使用了两层嵌套循环外层循环有一个名为的标签当等于且等于时我们使用语句跳过外层循环中的当前迭代这与的行为类似来看输出结果跳过中的当前迭代结束尽管可以使用标签实现类似的跳转功能但这种用法在中仍然较少见因为过度使用可能导致代码难以理解和维护通常建议尽可能使用其他控制结构如和语句来组织代码以下是一个使用和语句替代标签跳转的示例在这个示例中我们使用了一个布尔变量来决定是否跳过外层循环的当前迭代跳过外层循环中的当前迭代在这个示例中当等于且等于时我们将设置为然后使用语句跳出内层循环在外层循环中我们检查变量的值如果为则跳过外层循环的当前迭代这个示例的输出结果与之前的示例相同跳过外层循环中的当前迭代在语言中是声明常量的关键字在中可以使用三个关键字的组合来达到常量的效果在这个示例中我们使用关键字组合定义了一个名为的常量因为它是的所以其他类可以访问这个常量因为它是的所以它与类关联而不是类的实例因为它是的所以它的值不能被更改之后我们详细介绍俩个常用的关键字数据声明数据为常量可以是编译时常量也可以是在运行时被初始化后不能被改变的常量对于基本类型使数值不变对于引用类型使引用不变也就不能引用其它对象但是被引用的对象本身是可以修改的方法声明方法不能被子类重写方法隐式地被指定为如果在子类中定义的方法和基类中的一个方法签名相同此时子类的方法不是重写基类方法而是在子类中定义了一个新的方法类声明类不允许被继承静态变量静态变量又称为类变量也就是说这个变量属于类的类所有的实例都共享静态变量可以直接通过类名来访问它静态变量在内存中只存在一份实例变量每创建一个实例就会产生一个实例变量它与该实例同生共死实例变量静态变量静态方法静态方法在类加载的时候就存在了它不依赖于任何实例所以静态方法必须有实现也就是说它不能是抽象方法只能访问所属类的静态字段和静态方法方法中不能有和关键字因为这两个关键字与具体对象关联静态语句块静态语句块在类初始化时运行一次静态内部类非静态内部类依赖于外部类的实例也就是说需要先创建外部类实例才能用这个实例去创建非静态内部类而静态内部类不需要静态内部类不能访问外部类的非静态的变量和方法静态导包在使用静态变量和方法时不用再指明从而简化代码但可读性大大降低初始化顺序静态变量和静态语句块优先于实例变量和普通语句块静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序静态变量静态语句块实例变量普通语句块最后才是构造函数的初始化构造函数存在继承的情况下初始化顺序为父类静态变量静态语句块子类静态变量静态语句块父类实例变量普通语句块父类构造函数子类实例变量普通语句块子类构造函数以上就是关键字的一些详细介绍了以后也会详细介绍这个的现在就不做介绍了注释类似于也支持单行以及多行注释注释中的字符将被编译器忽略这是第一个程序它将输出这是一个多行注释的示例这是单行注释的示例这个也是单行注释的示例下面我们来详细的说一下注释单行注释单行注释通常用于解释方法内某单行代码的作用用于表示年龄但如果写在行尾的话其实是不符合阿里巴巴的开发规约的正确的单行注释如上图中所说在被注释语句上方另起一行使用注释用于表示年龄多行注释多行注释使用的频率其实并不高通常用于解释一段代码的作用用于表示年纪用于表示姓名沉默王二以开始以结束但不如用多个来得痛快因为和不在一起敲起来麻烦用于表示年纪用于表示姓名沉默王二文档注释文档注释可用在三个地方类字段和方法用来解释它们是干嘛的微信搜索沉默王二回复姓名方法作为程序的入口参数在中按下后敲下回车键就可以自动添加文档注释的格式是自动补全的文档注释的注意事项命令只能为和修饰的字段方法和类生成文档和修饰的字段和方法的注释将会被忽略掉因为我们本来就不希望这些字段和方法暴露给调用者如果类不是的话会执行失败文档注释中可以嵌入一些标记比如说段落标记超链接标记等等但不要使用标题标记比如说因为会插入自己的标题容易发生冲突文档注释中可以插入一些注解比如说引用其他类版本号参数标识符作者标识符已废弃标识符等等注释规约类字段方法必须使用文档注释不能使用单行注释和多行注释因为注释文档在编辑窗口中可以悬浮提示提高编码效率比如说在使用类的时候鼠标悬停在上时可以得到以下提示所有的抽象方法包括接口中的方法必须要用注释除了返回值参数异常说明外还必须指出该方法做什么事情实现什么功能所有的类都必须添加创建者和创建日期中可以在中设置语法如下所示注释名字设置好后在新建一个类的时候就可以自动生成了注释所有的枚举类型字段必须要有注释说明每个数据项的用途代码修改的同时注释也要进行相应的修改记住一点注释是程序固有的一部分第一注释要能够准确反映设计思想和代码逻辑第二注释要能够描述业务含义使别的程序员能够迅速了解到代码背后的信息完全没有注释的大段代码对于阅读者形同天书注释是给自己看的即使隔很长时间也能清晰理解当时的思路注释也是给继任者看的使其能够快速接替自己的工作数据类型中的数据类型可分为种基本数据类型基本数据类型是语言操作数据的基础包括和共种引用数据类型除了基本数据类型以外的类型都是所谓的引用类型常见的有数组类和接口基本数据类型来个思维导图感受下基本数据类型是可以直接进行运算的类型定义了以下几种基本数据类型整数类型浮点数类型字符类型布尔类型定义的这些基本数据类型有什么区别呢要了解这些区别我们就必须简单了解一下计算机内存的基本结构计算机内存的最小存储单元是字节一个字节就是一个位二进制数即个它的二进制表示范围从换算成十进制是换算成十六进制是内存单元从开始编号称为内存地址每个内存单元可以看作一间房间内存地址就是门牌号一个字节是字节是是是是一个拥有内存的计算机的字节数量就是不同的数据类型占用的字节数不一样我们看一下基本数据类型占用的字节数恰好就是一个字节而和需要个字节我们用表格来直观的感受一下基本数据类型数据类型默认值大小比特字节字节字节字节字节字节字节比特和字节比特币听说过吧字节跳动听说过吧这些名字当然不是乱起的确实和比特字节有关系比特比特作为信息技术的最基本存储单位非常小但大名鼎鼎的比特币就是以此命名的它的简写为小写字母大家都知道计算机是以二进制存储数据的二进制的一位就是比特也就是说比特要么为要么为字节通常来说一个英文字符是一个字节一个中文字符是两个字节字节与比特的换算关系是字节比特在往上的单位就是并不是字节因为计算机只认识二进制因此是的次方也就是个字节基本数据类型整型对于整型类型只定义了带符号的整型因此最高位的表示符号位表示正数表示负数各种整型能表示的最大范围如下下面来看一个定义整型的加下划线更容易识别十六进制表示的二进制表示的型的结尾需要加特别注意同一个数的不同进制的表示是完全相同的例如浮点型浮点类型的数就是小数因为小数用科学计数法表示的时候小数点是可以浮动的如可以表示成也可以表示成所以称为浮点数下面是定义浮点数的例子科学计数法表示的科学计数法表示的对于类型需要加上后缀浮点数可表示的范围非常大类型可最大表示而类型可最大表示布尔类型布尔类型只有和两个值布尔类型总是关系运算的计算结果计算结果为计算结果为字符串型字符类型表示一个字符的类型除了可表示标准的外还可以表示一个字符中注意类型使用单引号且仅有一个字符要和双引号的字符串类型区分开单精度和双精度单精度和双精度是指两种不同精度的浮点数表示方法单精度是这样的格式位符号位指数位小数单精度浮点数通常占用位字节存储空间数值范围大约是到精度大约为到位有效数字双精度是这样的格式位符号位指数为小数双精度浮点数通常占用位字节存储空间数值范围大约是到精度大约为到位有效数字计算精度取决于小数位尾数小数位越多则能表示的数越大那么计算精度则越高一个数由若干位数字组成其中影响测量精度的数字称作有效数字也称有效数位有效数字指科学计算中用以表示一个浮点数精度的那些数字一般地指一个用小数形式表示的浮点数中从第一个非零的数字算起的所有数字如和的有效数字都有位以下是确定有效数字的一些基本规则非零数字总是有效的位于两个非零数字之间的零是有效的对于小数从左侧开始的第一个非零数字之前的零是无效的对于整数从右侧开始的第一个非零数字之后的零是无效的下面是一些示例说明如何确定有效数字个有效数字所有数字都是非零数字个有效数字零位于两个非零数字之间个有效数字从左侧开始的前两个零是无效的个有效数字从右侧开始的两个零是无效的基本数据类型在作为成员变量和静态变量的时候有默认值引用数据类型也有的学完数组字符串以及面向对象编程后会更加清楚这里先简单过一下引用数据类型是最典型的引用数据类型所以我们就拿类举例看下面这段代码输出结果如下所示在中是一个很神奇的存在在你以后的程序生涯中见它的次数不会少尤其是伴随着令人烦恼的空指针异常也就是所谓的也就是说引用数据类型的默认值为包括数组和接口那你是不是很好奇为什么数组和接口也是引用数据类型啊先来看数组是一个类型的数组对吧打印结果如下所示表示数组是类型的后面是十六进制的这样的打印结果太人性化了一般人表示看不懂为什么会这样显示呢查看一下类的方法就明白了数组虽然没有显式定义成一个类但它的确是一个对象继承了祖先类的所有方法那为什么数组不单独定义一个类来表示呢就像字符串类那样呢一个合理的解释是将其隐藏了假如真的存在一个我们也可以假想它真实的样子它必须要定义一个容器来存放数组的元素就像类那样数组内部定义数组没必要的再来看接口是一个非常典型的接口而是接口的一个实现对于接口类型的引用变量来说你没法直接一个只能一个实现它的类的对象那自然接口也是引用数据类型了来看一下基本数据类型和引用数据类型之间最大的差别基本数据类型变量名指向具体的数值基本数据类型存储在栈上引用数据类型变量名指向的是存储对象的内存地址在栈上内存地址指向的对象存储在堆上上面说了栈和队那么什么是栈和堆呢下面来进行一个讲解栈和堆堆是堆栈是栈如果看到堆栈的话请不要怀疑自己那是翻译的错堆栈也是栈反正我很不喜欢堆栈这种叫法容易让新人掉坑里堆是在程序运行时在内存中申请的空间可理解为动态的过程切记不是在编译时因此中的对象就放在这里这样做的好处就是当需要一个对象时只需要通过关键字写一行代码即可当执行这行代码时会自动在内存的堆区分配空间这样就很灵活栈能够和处理器也就是脑子直接关联因此访问速度更快既然访问速度快要好好利用啊就把对象的引用放在栈里为什么呢因为引用的使用频率高吗不是的因为在编译程序时必须明确的知道存储在栈里的东西的生命周期否则就没法释放旧的内存来开辟新的内存空间存放引用空间就那么大前浪要把后浪拍死在沙滩上啊这么说就理解了吧如果还不理解的话可以看一下这个视频讲的非常不错什么是堆什么是栈他们之间有什么区别和联系用图来表示一下左侧是栈右侧是堆这里再补充一些额外的知识点能看懂就继续吸收看不懂可以先去学下一节以后再来补没关系的学习就是这样可以跳过可以温故举个例子这段代码会先在堆里创建一个沉默王二的字符串对象然后再把对象的引用放到栈里面这里面还会涉及到字符串常量池后面会讲那么对于这样一段代码有基本数据类型的变量有引用类型的变量堆和栈都是如何存储他们的呢我来画个图表示下应该一目了然了吧如果还不理解以后我会再一些面试题中更新这些的具体讲解的数据类型之间的转换数据类型转换的目的是确保在表达式求值时不同类型的数据能够相互兼容自动类型转换自动类型转换自动类型提升是编译器在不需要显式转换的情况下将一种基本数据类型自动转换为另一种基本数据类型的过程这种转换通常发生在表达式求值期间当不同类型的数据需要相互兼容时自动类型转换遵循以下规则如果任何操作数是类型其他操作数将被转换为类型否则如果任何操作数是类型其他操作数将被转换为类型否则如果任何操作数是类型其他操作数将被转换为类型否则所有操作数将被转换为类型需要注意的是自动类型转换只发生在兼容类型之间例如从较小的数据类型如到较大的数据类型如或的转换是安全的因为较大的数据类型可以容纳较小数据类型的所有可能值下面是一个简单的示例演示了自动类型转换自动类型转换被转换为类型结果输出结果在这个示例中我们有一个类型的变量和一个类型的变量当我们将它们相乘时根据自动类型转换的规则将被转换为类型以便将两个类型的操作数相乘最终结果将是一个类型的值再来举个例子顾客到超市购物购买牙膏盒面巾纸盒其中牙膏的价格是元面巾纸的价格是元求商品总价格实现代码如下定义牙膏的价格单精度浮点型定义面巾纸的价格双精度浮点型定义牙膏的数量整型定义面巾纸的数量计算总价一共付给收银员元输出总价上述代码中首先定义了一个类型的变量存储牙膏的价格然后定义了一个类型的变量存储面巾纸的价格再定义两个类型的变量存储物品的数量最后进行了乘运算以及和运算之后将结果储存在一个类型的变量中进行输出一共付给收银员元从执行结果看出和三种数据类型参与运算最后输出的结果为类型的数据这种转换一般称为表达式中类型的自动提升自动类型提升有好处但它也会引起令人疑惑的编译错误例如下面看起来正确的程序却会引起问题如上所示第二行会报类型不匹配无法从转换为错误该程序试图将一个完全合法的型的值存储给一个型的变量但是当表达式求值的时候操作数被自动的提升为型计算结果也被提升为型这样表达式的结果现在是型不强制转换它就不能被赋为型所以应该使用一个显示的强制类型转换例如这样就能产生正确的值注意类型比较特殊自动转换成和但和不能自动转换为而且也不能自动转换为或强制类型转换强制类型转换是中将一种数据类型显式转换为另一种数据类型的过程与自动类型转换不同强制类型转换需要程序员显式地指定要执行的转换强制类型转换在以下情况中可能需要将较大的数据类型转换为较小的数据类型将浮点数转换为整数将字符类型转换为数值类型需要注意的是强制类型转换可能会导致数据丢失或精度降低因为目标类型可能无法容纳原始类型的所有可能值因此在进行强制类型转换时需要确保转换后的值仍然在目标类型的范围内以下是一个简单的示例演示了强制类型转换强制类型转换将类型转换为类型整数值输出整数值在这个示例中我们有一个类型的变量我们希望将其转换为类型的变量为此我们使用强制类型转换语法即在要转换的变量之前加上目标类型的括号如需要注意的是将转换为类型时小数部分将被截断因此输出结果将是在这种情况下精度丢失是可以接受的但在其他情况下我们可能需要更加小心地处理类型转换以避免数据丢失顾客到超市购物购买牙膏盒面巾纸盒其中牙膏的价格是元面巾纸的价格是元求商品总价格在计算总价时采用类型的数据进行存储实现代码如下一共付给收银员元在上述实例中有类型类型和类型的数据参与运算其运算结果默认为类型题目要求的结果为类型因为类型的取值范围要小于类型的取值范围所以需要进行强制类型转换一共付给收银员元这个在我们的实际开发中是非常常用的一个存在当然在中是可以实现快速的转换的这里就不做过多的介绍了缓存池这个能帮助你更好的理解数据类型属于是面试的范围了与的区别在于每次都会新建一个对象会使用缓存池中的对象多次调用会取得同一个对象的引用方法的实现比较简单就是先判断值是否在缓存池中如果在的话就直接返回缓存池的内容在中缓存池的大小默认为编译器会在自动装箱过程调用方法因此多个值相同且值在缓存池范围内的实例使用自动装箱来创建那么就会引用相同的对象基本类型对应的缓冲池如下在使用这些基本类型对应的包装类型时如果该数值范围在缓冲池范围内就可以直接使用缓冲池中的对象运算符计算机的最基本用途之一就是执行数学运算作为一门计算机语言也提供了一套丰富的运算符来操纵变量我们可以把运算符分成以下几组算术运算符关系运算符位运算符逻辑运算符赋值运算符其他运算符下面我们要学习的大概就是下图算术运算符算术运算符除了最常见的加减乘除还有一个取余的运算符用于得到除法运算后的余数来串代码感受下对于初学者来说加法减法乘法很好理解但除法和取余会有一点点疑惑在以往的认知里是除不尽的结果应该是而不应该是相应的余数也不应该是这是为什么呢因为数字在程序中可以分为两种一种是整型一种是浮点型整型和整型的运算结果就是整型不会出现浮点型否则就会出现浮点型需要注意的是当浮点数除以的时候结果为或者的中文意思是无穷大的中文意思是这不是一个数字当整数除以的时候会抛出异常所以整数在进行除法运算时需要先判断除数是否为以免程序抛出异常算术运算符中还有两种特殊的运算符自增运算符和自减运算符它们也叫做一元运算符只有一个操作数一元运算符可以放在数字的前面或者后面放在前面叫前自增前自减放在后面叫后自增后自减前自增和后自增是有区别的拿这个表达式来说它可以拆分为所以表达式的结果为拿这个表达式来说它可以拆分为所以表达式的结果为对于前自减和后自减来说你可以自己试一把关系运算符关系运算符用来比较两个操作数返回结果为或者来看示例位运算符在学习位运算符之前需要先学习一下二进制因为位运算符操作的不是整型数值本身而是整型数值对应的二进制从程序的输出结果可以看得出来的二进制是用补到位的二进制是现代的二进制记数系统由戈特弗里德威廉莱布尼茨于年设计莱布尼茨是德意志哲学家数学家历史上少见的通才来看示例的二进制的二进制二进制是二进制是二进制是二进制是二进制是二进制是二进制是对于初学者来说位运算符无法从直观上去计算出结果不像加减乘除那样因为我们日常接触的都是十进制位运算的时候需要先转成二进制然后再计算出结果鉴于此初学者在写代码的时候其实很少会用到位运算对于编程高手来说为了提高程序的性能会在一些地方使用位运算比如说在计算哈希值的时候如果对位运算一点都不懂的话遇到这样的源码就很吃力所以说虽然位运算用的少但还是要懂按位左移运算符等于乘以的次方等于乘以的次方按位右移运算符等于除以的次方等于除以的次方逻辑运算符逻辑与运算符多个条件中只要有一个为结果就为逻辑或运算符多个条件只要有一个为结果就为逻辑非运算符用来反转条件的结果如果条件为则逻辑非运算符将得到单逻辑与运算符很少用因为不管第一个条件为还是依然会检查第二个单逻辑或运算符也会检查第二个条件也就是说和性能不如和但用法一样赋值运算符赋值操作符恐怕是中使用最频繁的操作符了它就是把操作符右侧的值赋值给左侧的变量来看示例不过在进行数值的赋值时需要小点心比如说下面这种情况编译器之所以提示错误是因为右侧的算术表达式默认为类型左侧是类型的时候需要进行强转除此之外还会有边界问题比如说两个非常大的相乘结果可能就超出了的范围程序输出的结果为这个答案很明显不是我们想要的结果虽然可以通过右侧表达式强转的方法解决但尽量不要这样做结果非常大的时候尽量提前使用相应的类型进行赋值三元运算符三元运算符用于替代可以使用一行代码完成条件判断的要求来看示例如果前面的条件为则结果为前的值否则为后的值我们来看一个相关的案例一座寺庙住着三个和尚已知他们身高求这三个和尚的最高值三元运算符练习就是先和比之后较大的和比附上一个运算优先级基本记住优先于所有就可以了学了这么多的运算符下面来看运算符的一个优先级运算符优先级当多个运算符出现在一个表达式中谁先谁后呢这就涉及到运算符的优先级别的问题在一个多运算符的表达式中运算符优先级不同会导致最后得出的结果差别甚大例如这个表达式如果按加号最优先计算答案就是如果按照乘号最优先答案则是再如这里得到而不是因为乘法运算符比加法运算符有较高的优先级所以先计算得到然后再加下表中具有最高优先级的运算符在的表的最上面最低优先级的在表的底部类别操作符关联性后缀点操作符左到右一元从左到右一元从右到左乘性左到右加性左到右移位左到右关系左到右相等左到右按位与左到右按位异或左到右按位或左到右逻辑与左到右逻辑或左到右条件从右到左赋值从右到左逗号左到右流程控制语句流程控制语句是我们写代码中非常重要的知识我们的程序就是由这些结构而成的比如说等等接下来我们一个个来了解下相关语句语句的格式如下布尔表达式如果条件为则执行这块代码画个流程图表示一下来写个示例输出青春年华语句语句的格式如下布尔表达式条件为时执行的代码块条件为时执行的代码块画个流程图表示一下来写个示例青春年华而立之年输出而立之年除了这个例子之外还有一个判断闰年被整除但不能被整除或者被整除的例子闰年普通年份输出闰年如果执行语句比较简单的话可以使用三元运算符来代替语句如果条件为返回后面前面的值如果条件为返回后面的值偶数奇数输出奇数语句语句的格式如下条件条件为时执行的代码条件条件为时执行的代码条件条件为时执行的代码以上条件均为时执行的代码画个流程图表示一下来写个示例青春年华而立之年不惑之年知天命输出而立之年嵌套语句嵌套语句的格式如下外侧条件外侧条件为时执行的代码内侧条件内侧条件为时执行的代码画个流程图表示一下来写个示例女生法定结婚年龄输出女生法定结婚年龄语句语句用来判断变量与多个值之间的相等性变量的类型可以是或者或者对应的包装器类型以及字符串和枚举类型来看一下语句的格式变量可选值可选值匹配后执行的代码该关键字是可选项可选值可选值匹配后执行的代码该关键字是可选项该关键字是可选项所有可选值都不匹配后执行的代码变量可以有个或者个值值类型必须和变量类型是一致的并且值是确定的值必须是唯一的不能重复否则编译会出错关键字是可选的如果没有则执行下一个如果有则跳出语句关键字也是可选的画个流程图来个示例上学苏州工作洛阳工作未知可省略输出上学当两个值要执行的代码相同时可以把要执行的代码写在下一个语句中而上一个语句中什么也没有来看一下示例沉默王二詹姆斯篮球运动员穆里尼奥足球教练沉默王二沉默王三乒乓球爱好者名字没有匹配项输出乒乓球爱好者枚举作为语句的变量也很常见来看例子网球运动员费德勒足球运动员罗篮球运动员詹姆斯未知运动员类型输出篮球运动员詹姆斯循环普通循环普通的循环可以分为个部分初始变量循环开始执行时的初始条件条件循环每次执行时要判断的条件如果为就执行循环体如果为就跳出循环当然了条件是可选的如果没有条件则会一直循环循环体循环每次要执行的代码块直到条件变为自增自减初始变量变化的方式来看一下普通循环的格式初始变量条件自增自减循环体画个流程图来个示例输出之后再来看一个有趣的打印循环通常用于遍历数组和集合它的使用规则比普通的循环还要简单不需要初始变量不需要条件不需要下标来自增或者自减来看一下语法元素类型元素数组或集合要执行的代码来看一下示例一枚有趣的程序员输出一枚有趣的程序员无限循环停不下来输出停不下来停不下来停不下来停不下来一旦运行起来就停不下来了除非强制停止循环来看一下循环的格式条件循环体画个流程图来个示例接下来这个会是多少次呢其实很好猜到就是五次接下来看的无限死循环停不下来输出停不下来停不下来停不下来停不下来把的条件设置为并且循环体中没有关键字的话程序一旦运行起来就根本停不下来了除非强制停止循环来看一下循环的格式循环体提交画个流程图来个示例同时也是可以死循环的停不下来输出停不下来停不下来停不下来停不下来把的条件设置为并且循环体中没有关键字的话程序一旦运行起来就根本停不下来了除非强制停止关键字通常用于中断循环或语句它在指定条件下中断程序的当前流程如果是内部循环则仅中断内部循环可以将关键字用于所有类型循环语句中比如说循环循环以及循环来画个流程图感受一下用在循环中的示例用在嵌套循环中的示例用在循环中的示例用在循环中的示例用在语句中的示例上学苏州工作洛阳工作未知可省略当我们需要在循环或者循环中立即跳转到下一个循环时就可以使用关键字通常用于跳过指定条件下的循环体如果循环是嵌套的仅跳过当前循环来个示例使用关键字将会被跳过输出再来个循环嵌套的例子当时跳过打印出什么玩意呢没有输出被跳过了再来看一下循环时的使用示例输出注意如果把条件中的省略掉的话程序就会进入死循环一直在最后再来看一下循环时的使用示例输出注意同样的如果把条件中的省略掉的话程序就会进入死循环一直在语句语句判断一个变量与一系列值中某个值是否相等每个值称为一个分支语句可选语句可选你可以有任意数量的语句可选语句语句有如下规则语句中的变量类型可以是或者从开始支持字符串类型了同时标签必须为字符串常量或字面量语句可以拥有多个语句每个后面跟一个要比较的值和冒号语句中的值的数据类型必须与变量的数据类型相同而且只能是常量或者字面常量当变量的值与语句的值相等时那么语句之后的语句开始执行直到语句出现才会跳出语句当遇到语句时语句终止程序跳转到语句后面的语句执行语句不必须要包含语句如果没有语句出现程序会继续执行下一条语句直到出现语句语句可以包含一个分支该分支一般是语句的最后一个分支可以在任何位置但建议在最后一个在没有语句的值和变量值相等的时候执行分支不需要语句一个简单的案例优秀良好及格你需要再努力努力未知等级你的等级是案例在结束了上面的学习之后我们已经初步的掌握了一些写程序的能力下面的几个程序来帮助大家更好的理解回文数正序和倒序一样的整数例如力扣算法真题回文数定义临时的值利用循环从右往左获取每一次数字从右往左获得数字更新数据存储下面我们来解析一下这段程序首先定义一个类名为力扣算法真题回文数的公共类在方法中定义一个整型变量并且初始化为表示需要判断的整数定义一个临时变量并且将赋值给它用于后面判断回文数时的比较定义一个整型变量并且初始化为用于存储从右往左获取的每一位数字利用循环从右往左获取的每一位数字具体实现如下通过取模运算获取的个位数字将除以更新的值将乘以加上将获取的数字存储到中循环结束后中存储的就是从右往左的倒序数字最后通过方法输出的值然后通过判断是否等于来判断是否为回文数如果相等则输出否则输出总之这段代码的实现思路是将整数从右往左获取每一位数字然后将获取的数字存储到另一个变量中最后判断这两个变量是否相等从而判断整数是否为回文数给定两个整数被除数和除数将两个数相除要求不能使用除法乘法和取余最后要得到商和余数力扣算法真题求商和余数记录被除数定义定义除数余数为商为这一个就不做解析了小结至此我们的基础语法就已经学完了学习完这一个章节就算是对的一个基础入门了数组字符串数组一维数组我们在程序基础里介绍了数组这种数据类型有了数组我们还需要来操作它数组是一个对象它包含了一组固定数量的元素并且这些元素的类型是相同的数组会按照索引的方式将元素放在指定的位置上意味着我们可以通过索引来访问这些元素在中索引是从开始的我们可以将数组理解为一个个整齐排列的单元格每个单元格里面存放着一个元素数组元素的类型可以是基本数据类型比如说也可以是引用数据类型比如说包括自定义类型数组的声明方式分两种先来看第一种再来看第二种不同之处就在于中括号的位置是跟在类型关键字的后面还是跟在变量的名称的后面前一种的使用频率更高一些像的源码中就用了第一种方式同样的数组的初始化方式也有多种最常见的是上面这行代码中使用了关键字这就意味着数组的确是一个对象只有对象的创建才会用到关键字基本数据类型是不用的然后我们需要在方括号中指定数组的长度这时候数组中的每个元素都会被初始化为默认值类型的就为类型的就为不同数据类型的默认值不同另外还可以使用大括号的方式直接初始化数组中的元素这时候数组的元素分别是索引依次是长度是下面我们来说如何去访问数组前面提到过可以通过索引来访问数组的元素就像下面这样变量名加上中括号加上元素的索引就可以访问到数组通过操作符可以对元素进行赋值如果索引的值超出了数组的界限就会抛出既然数组的索引是从开始那就是到数组的结束不要使用超出这个范围内的索引访问数组就不会抛出数组越界的异常了当数组的元素非常多的时候逐个访问数组就太辛苦了所以需要通过遍历的方式通过循环就可以遍历数组因为数组的每个元素都可以通过索引来访问因此使用标准的循环可以完成一个数组的遍历为了实现循环遍历初始条件为因为索引总是从开始继续循环的条件为因为当时已经超出了索引范围索引范围是每次循环后第二种方式是使用循环直接迭代数组的每个元素注意在循环中变量直接拿到数组的元素而不是索引显然循环更加简洁但是循环无法拿到数组的索引因此到底用哪一种循环取决于我们的需要如果不需要关心索引的话意味着不需要修改数组的某个元素使用遍历更简洁一些当然也可以使用和循环在中可变参数用于将任意数量的参数传递给方法来看方法该方法可以接收任意数量的字符串参数可以是个或者个本质上可变参数就是通过数组实现的为了证明这一点我们可以看一下反编译一后的字节码所以我们其实可以直接将数组作为参数传递给该方法你好也可以直接传递多个字符串通过逗号隔开的方式你好在中数组与关系非常密切封装了很多常用的方法方便我们对集合进行一些操作而如果直接操作数组的话有很多不便因为数组本身没有提供这些封装好的操作所以有时候我们需要把数组转成最原始的方式就是通过遍历数组的方式一个个将数组添加到中更优雅的方式是通过类的方法不过需要注意的是的参数需要是数组而目前是类型我们需要换另外一种方式这又涉及到了流的知识后面会讲到还有一个需要注意的是方法返回的并不是它其实是类的一个内部类如果需要添加元素或者删除元素的话需要把它转成新增了流的概念这就意味着我们也可以将数组转成进行操作你好世界如果想对数组进行排序的话可以使用类提供的方法基本数据类型按照升序排列实现了接口的对象按照的排序来看第一个例子排序后的结果如下所示来看第二个例子只对位置上的元素进行反序所以结果如下所示有时候我们需要从数组中查找某个具体的元素最直接的方式就是通过遍历的方式找到了上例中从数组中查询元素找到后通过关键字退出循环如果数组提前进行了排序就可以使用二分查找法这样效率就会更高一些方法可供我们使用它需要传递一个数组和要查找的元素在了解了数组的一些规范之后下面来看几个例题比如一个简单的求和数组功能概述求出所有数据的和求所有数据的平均数统计有多少个数据比平均数小遍历数组求和数组中所有的和为数组中的平均数为一共有个数字比平均数小这里我们用到了随机数的生成也就是其中为数字的意思记录但不包含的值既生成范围内的值这个知识下面再来看一个经典的冒泡排序对数组进行排序是程序中非常基本的需求常用的排序算法有冒泡排序插入排序和快速排序等我们来看一下如何使用冒泡排序算法对一个整型数组从小到大进行排序排序前交换和排序后冒泡排序的特点是每一轮循环后最大的一个数被交换到末尾因此下一轮循环就可以刨除最后的数每一轮循环都比上一轮循环的结束位置靠前一位另外注意到交换两个变量的值必须借助一个临时变量像这么写是错误的现在是现在还是正确的写法是把的值保存在临时变量中现在是现在是现在是的值实际上的标准库已经内置了排序功能我们只需要调用提供的就可以排序必须注意对数组排序实际上修改了数组本身例如排序前的数组是在内存中这个整型数组表示如下当我们调用后这个整型数组在内存中变为即变量指向的数组内容已经被改变了如果对一个字符串数组进行排序例如排序前这个数组在内存中表示如下调用排序后这个数组在内存中表示如下原来的个字符串在内存中均没有任何变化但是数组的每个元素指向变化了之后再来看一个数组反转的例子更加巩固一下数组反转数组输入反转数组反转后数组是二维数组二维数组是一种数据类型可以存储多行和多列的数据它由一系列的行和列组成每个元素都可以通过一个行索引和列索引来访问例如一个行列的二维数组可以表示为以下形式在这个例子中第一行有个元素第二行有个元素第三行有个元素每个元素都有一个行索引和一个列索引例如元素是第行第列的元素它的值是使用二维数组可以有效地存储和处理表格数据如矩阵图像地图等等定义一个二维数组如下因为包含个数组因此为实际上在内存中的结构如下如果我们定义一个普通数组然后把赋值给它实际上就获取了数组的第个元素因为数组的每个元素也是一个数组因此指向的数组就是在内存中结构如下访问二维数组中的元素我们可以使用两个方括号来访问二维中的元素第一个表示我们要从中访问元素的数组而第二个表示我们要访问的元素索引让我们用一个例子来简化上面的解释在上面的示例中数组中有两个数组和第一个数组用表示第二个数组用表示第一个数组是第二个是第三个是依此类推因此要访问第一个数组中的项目我们将分配给第一个方括号由于我们试图访问数组中的第一项我们将使用它的索引即让我们进一步分解它这是访问元素的代码我在两个方括号中都加上了问号随着进展填写它们假设我们要访问第二个数组中的元素我们的代码将如下所示现在我们要在第二个数组中尝试访问其中一个元素就像一维数组一样每个元素都有一个从零开始的索引因此要访问第三个元素我们将其索引号传递给第二个方括号来看这样一个例子我们的目标是访问第三个数组中的访问方式仍然通过问号来表示我们首先给第一个问号一个指向要访问的特定数组的值数组数组数组我们要查找的数字在第三个数组中所以是第二个方括号的值将指向要访问的元素为此我们必须指定元素的索引以下是该数组中的索引索引索引索引索引的索引为因此我们可以将其添加到第二个方括号当你将其打印到控制台时将会打印出代码如下所示你可以使用嵌套循环遍历二维数组中的所有项目这是一个例子上面的代码将会打印出数组中的所有项目一个比较经典的用二维数组来实现的案例就是杨辉三角请输入要打印的行数每行的第一个和最后一个数字都是其他数字是上一行的两个数字之和打印杨辉三角这段代码使用了一个二维数组来存储杨辉三角中的数字首先程序要求用户输入要打印的行数然后调用方法来生成和打印杨辉三角在方法中程序使用了一个嵌套的循环来计算杨辉三角中的每个数字并将结果存储在二维数组中最后程序再次使用循环来遍历数组并打印出杨辉三角中的数字下面看他的打印结果请输入要打印的行数打印数组数组其实也是一个对象因为就是万物皆是对象但中并未明确的定义这样一个类因此数组也就没有机会覆盖方法如果尝试直接打印数组的话输出的结果并不是我们预期的结果为什么不能直接打印数组首先我们来看一下为什么不能直接打印数组直接打印的话会出现什么问题来看这样一个例子你好程序打印的结果是表示字符串数组的名后面的是十六进制的这样的打印结果太人性化了一般人表示看不懂为什么会这样显示呢查看一下类的方法就明白了再次证明数组虽然没有显式定义成一个类但它的确是一个对象继承了祖先类的所有方法那为什么数组不单独定义一个类来表示呢就像字符串类那样呢一个合理的说法是将其隐藏了假如真的存在这么一个类就叫吧我们假想一下它真实的样子必须得有一个容器来存放数组的每一个元素就像类那样类我们下面会做解释这里就不做解释了来简单的看一下类的源码下面我们来看几种打印数组的方式流打印数组我们来看第一种打印数组的方法使用时髦一点的流这个如果不会的可以跳过我们之后会做解释第一种形式第二种形式第三种形式没错这三种方式都可以轻松胜任本职工作并且显得有点高大上毕竟用到了以及表达式循环打印数组当然了也可以使用传统的方式循环甚至也行工具类打印数组我认为是打印数组的最佳方式没有之一可以将任意类型的数组转成字符串包括基本类型数组和引用类型数组该方法有多种重载形式使用方法来打印数组再优雅不过了程序打印结果哇打印格式不要太完美不多不少完全是我们预期的结果表明是一个数组点和空格用来分割元素工具类打印二维数组除了一维数组我们还可以用工具类来打印二维数组可以使用方法你好打印结果如下所示你好的打印规约阿里巴巴的开发手册上有这样一条规约什么是呢就是的缩写一般在应用程序中建立一个数据库的映射对象时我们称它为这类对象不继承或不实现任何其它框架的类或接口对于这样的类最好是重写一下它的方法方便查看这个对象到底包含了什么字段好排查问题如果不重写的话打印出来的对象就像直接打印数组的那样一串谁也看不懂的字符序列可以借助生成重写的方法特别方便字符串类字符串广泛应用在编程中在中字符串属于对象提供了类来创建和操作字符串被声明为因此它不可被继承等包装类也不能被继承在中内部使用数组存储数据在之后类的实现改用数组存储字符串同时使用来标识使用了哪种编码数组被声明为这意味着数组初始化之后就不能再引用其它数组并且内部没有改变数组的方法因此可以保证不可变创建字符串创建字符串最简单的方式如下在代码中遇到字符串常量时这里的值是编译器会使用该值创建一个对象和其它对象一样可以使用关键字和构造方法来创建对象用构造函数创建字符串创建的字符串存储在公共池中而创建的字符串对象在堆上直接创建直接创建相同引用对象创建对象创建类有种构造方法这些方法提供不同的参数来初始化字符串比如提供一个字符数组参数注意类是不可改变的所以你一旦创建了对象那它的值就无法改变了一会我们会介绍为什么的字符串不可变字符串长度用于获取有关对象的信息的方法称为访问器方法类的一个访问器方法是方法它返回字符串对象包含的字符数下面的代码执行后变量等于我的网址长度执行结果如下我的网址长度方法下面是类支持的方法更多详细参看文档序号方法描述返回指定索引处的值把这个字符串和另一个对象比较按字典顺序比较两个字符串按字典顺序比较两个字符串不考虑大小写将指定字符串连接到此字符串的结尾当且仅当字符串与指定的有相同顺序的字符时候返回真返回指定数组中表示该字符序列的返回指定数组中表示该字符序列的测试此字符串是否以指定的后缀结束将此字符串与指定的对象比较将此与另一个比较不考虑大小写使用平台的默认字符集将此编码为序列并将结果存储到一个新的数组中使用指定的字符集将此编码为序列并将结果存储到一个新的数组中将字符从此字符串复制到目标字符数组返回此字符串的哈希码返回指定字符在此字符串中第一次出现处的索引返回在此字符串中第一次出现指定字符处的索引从指定的索引开始搜索返回指定子字符串在此字符串中第一次出现处的索引返回指定子字符串在此字符串中第一次出现处的索引从指定的索引开始返回字符串对象的规范化表示形式返回指定字符在此字符串中最后一次出现处的索引返回指定字符在此字符串中最后一次出现处的索引从指定的索引处开始进行反向搜索返回指定子字符串在此字符串中最右边出现处的索引返回指定子字符串在此字符串中最后一次出现处的索引从指定的索引开始反向搜索返回此字符串的长度告知此字符串是否匹配给定的正则表达式测试两个字符串区域是否相等测试两个字符串区域是否相等返回一个新的字符串它是通过用替换此字符串中出现的所有得到的使用给定的替换此字符串所有匹配给定的正则表达式的子字符串使用给定的替换此字符串匹配给定的正则表达式的第一个子字符串根据给定正则表达式的匹配拆分此字符串根据匹配给定的正则表达式来拆分此字符串测试此字符串是否以指定的前缀开始测试此字符串从指定索引开始的子字符串是否以指定前缀开始返回一个新的字符序列它是此序列的一个子序列返回一个新的字符串它是此字符串的一个子字符串返回一个新字符串它是此字符串的一个子字符串将此字符串转换为一个新的字符数组使用默认语言环境的规则将此中的所有字符都转换为小写使用给定的规则将此中的所有字符都转换为小写返回此对象本身它已经是一个字符串使用默认语言环境的规则将此中的所有字符都转换为大写使用给定的规则将此中的所有字符都转换为大写返回字符串的副本忽略前导空白和尾部空白返回给定类型参数的字符串表示形式判断是否包含指定的字符系列判断字符串是否为空在有了这些方法的前提下就可以来进行一些案例的编写比如下面的案例字符串已知正确的用户名和密码请用程序进行模拟登录总共有三次机会登录之后会给出相应的提示用户登录定义变量请输入用户名请输入密码用户登录成功你的账户被锁定用户名或密码错误您还剩下次机会总体来说还是非常的简单的这里要注意的是字符串的比较不能直接用要使用方法来进行比较解读源码我们以的为例进行解读这里也是涉及到面试的东西可以当做一个了解类的声明第一类是的意味着它不能被子类继承第二类实现了接口意味着它可以序列化第三类实现了接口意味着最好不要用来比较两个字符串是否相等而应该用方法去比较因为是用来比较两个对象的地址这个在讲字符串比较的时候会详细讲如果只是说比较字符串内容的话可以使用类的方法第四和一样都实现了接口所以它们仨属于近亲由于是不可变的所以遇到字符串拼接的时候就可以考虑一下的另外两个好兄弟和它俩是可变的类的底层实现第五以前是用型数组实现的之后改成了型数组实现并增加了来表示编码这样做的好处是在字符为主的程序里可以把占用的内存减少一半当然天下没有免费的午餐这个改进在节省内存的同时引入了编码检测的开销是一种单字节字符集即每个字符只使用一个字节的编码方式也称为国际标准化组织它包含了西欧语言中使用的所有字符包括英语法语德语西班牙语葡萄牙语意大利语等等在编码中每个字符使用一个位即一个字节的编码可以表示种不同的字符其中包括字符集中的所有字符即到以及其他西欧语言中的特殊字符例如等等由于只使用一个字节表示一个字符因此在存储和传输文本时具有较小的存储空间和较快的速度接下来我们来详细地说一下从到最主要的目的是节省字符串占用的内存空间内存占用减少带来的另外一个好处就是次数也会减少我们使用命令就可以查看到堆内对象示例的统计信息查看的信息以及队列以我正在运行着的编程喵项目实例基于来说结果是这样的其中对象有个占用了个字节的内存排在第三位由于的内部实现仍然是所以我们可以看到内存占用排在第位的就是数组对象有个占用了个字节的内存排在第一位那也就是说优化节省内存空间是非常有必要的如果是去优化一个使用频率没有这么高的类就没什么必要对吧众所周知类型的数据在中是占用两个字节的并且使用的是编码其值范围在和包含之间也就是说使用来表示就会导致即使中的字符只用一个字节就能表示也得占用两个字节在计算机中单字节字符通常指的是一个字节位可以表示的字符而双字节字符则指需要两个字节位才能表示的字符单字节字符和双字节字符的定义是相对的不同的编码方式对应的单字节和双字节字符集也不同常见的单字节字符集有美国信息交换标准代码国际标准化组织标准编号汉字内码扩展规范中国国家标准现在已经被取代像拉丁字母数字标点符号控制字符都是单字节字符双字节字符集包括中国国家标准中文日文韩文拉丁文扩展字符属于双字节字符当然了仅仅将优化为是不够的还要配合的编码方式该编码方式是用单个字节来表示字符的这样就比编码节省了更多的空间换句话说对于这样的使用编码占用个字节就够了但对于小二这种木的办法只能使用来编码针对的源码里为了区别编码方式追加了一个字段来区分会根据字符串的内容自动设置为相应的编码要么要么也就是说从到中文是两个字节纯英文是一个字节在此之前呢中文是两个字节英文也是两个字节在中号的字符用个字节来表示使用和相同的编码只有号及以上的字符才用个个或者个字节来表示如果只有一个字节那么最高的比特位为如果有多个字节那么第一个字节从最高位开始连续有几个比特位的值为就使用几个字节编码剩下的字节均以开头具体的表现形式为一个字节两个字节编码形式开始两个三字节编码形式开始三个四字节编码形式开始四个也就是说是变长的那对于这种有随机访问方法的类来说就很不方便所谓的随机访问就是这种方法随便指定一个数字要能给出结果如果字符串中的每个字符占用的内存是不定长的那么进行随机访问的时候就需要从头开始数每个字符的长度才能找到你想要的字符那你可能会问也是变长的呢一个字符还可能占用个字节呢的确使用个或者个字节来存储字符对于编号范围在之间的字符使用两个字节存储对于编号范围在之间的字符使用四个字节存储具体来说就是将字符编号的所有比特位分成两部分较高的一些比特位用一个值介于之间的双字节存储较低的一些比特位剩下的比特位用一个值介于之间的双字节存储但是在中一个字符就是个字节占个字节的字符在里也是用两个来存储的而的各种操作都是以的字符为单位的是取得第几个取的也是第几个到第几个组成的子串甚至返回的都是的个数所以在的世界里就可以视为一个定长的编码参考链接类的方法第六每一个字符串都会有一个值这个哈希值在很大概率是不会重复的因此很适合来作为的键值来看类的方法方法首先检查是否已经计算过哈希码如果已经计算过则直接返回缓存的哈希码否则方法将使用一个循环遍历字符串的所有字符并使用一个乘法和加法的组合计算哈希码这种计算方法被称为倍哈希法计算完成后将得到的哈希值存储在成员变量中以便下次调用方法时直接返回该值而不需要重新计算这是一种缓存优化称为惰性计算倍哈希法是一种简单有效的字符串哈希算法常用于对字符串进行哈希处理该算法的基本思想是将字符串中的每个字符乘以一个固定的质数的幂次方并将它们相加得到哈希值具体地假设字符串为长度为则倍哈希值计算公式如下其中表示字符串中第个字符的码值表示幂运算倍哈希法的优点在于简单易实现计算速度快同时也比较均匀地分布在哈希表中方法我们会在另外一个章节里详细讲我们可以通过以下方法模拟的方法小博客字符串的哈希码是的看一下结果字符串博客的哈希码是的结果是一样的又学到了吧类的方法类中还有一个方法比较常用用来截取字符串的来看源码方法首先检查参数的有效性如果参数无效则抛出异常接下来方法根据参数计算子字符串的长度如果子字符串长度小于零抛出异常如果为且等于字符串的长度说明子串与原字符串相同因此直接返回原字符串否则使用数组原字符串的字符数组的一部分创建一个新的对象并返回下面是几个使用方法的示例提取字符串中的一段子串从第个字符包括提取到第个字符不包括输出提取字符串中的前缀或后缀提取前个字符即提取从第个字符开始的所有字符即处理字符串中的空格和分隔符去除字符串开头和结尾的空格将字符串按照空格分隔成单词数组提取第一个单词的首字母输出处理字符串中的数字和符号将字符串按照连字符分隔成四个部分提取最后一个部分的后三位数字输出总之方法可以根据需求灵活地提取字符串中的子串为字符串处理提供了便利类的方法方法用于查找一个子字符串在原字符串中第一次出现的位置并返回该位置的索引来看该方法的源码查找字符数组在字符数组中第一次出现的位置和参数指定数组中要搜索的范围和参数指定数组中要搜索的范围参数指定开始搜索的位置如果找到了数组则返回它在数组中的位置索引从开始否则返回如果开始搜索的位置已经超出数组的范围则直接返回如果数组为空则返回如果开始搜索的位置小于则从开始搜索如果数组为空则直接返回开始搜索的位置查找数组的第一个字符在数组中的位置循环查找数组在数组中的位置如果数组中当前位置的字符不是数组的第一个字符则在数组中继续查找数组的第一个字符如果在数组中找到了数组的第一个字符则继续查找数组的剩余部分是否匹配如果数组全部匹配则返回在数组中的位置索引没有找到数组则返回来看示例示例查找子字符串的位置查找子字符串在中第一次出现的位置输出示例查找字符串中某个字符的位置查找逗号在中第一次出现的位置输出示例查找子字符串的位置从指定位置开始查找从索引为的位置开始查找子字符串在中第一次出现的位置输出示例查找多个子字符串查找子字符串在中第一次出现的位置从索引为的位置开始查找子字符串在中第一次出现的位置输出输出类的其他方法比如说用于返回字符串长度比如说用于判断字符串是否为空比如说用于返回指定索引处的字符比如说用于返回字符串的字节数组可以指定编码方式比如说比如说用于去除字符串两侧的空白字符来看源码字符串为什么不可变可能是中使用频率最高的引用类型了因此类的设计者可以说是用心良苦比如说的不可变性类被关键字修饰所以它不会有子类这就意味着没有子类可以重写它的方法改变它的行为类的数据存储在数组中而这个数组也被关键字修饰了这就表示对象是没法被修改的只要初始化一次值就确定了那么这样写有什么好处呢第一可以保证对象的安全性避免被篡改毕竟像密码这种隐私信息一般就是用字符串存储的以下是一个简单的示例演示了字符串的不可变性如何有助于保证对象的安全性在本例中我们创建了一个简单的类该类使用类型的字段存储用户名和密码同时我们使用一个静态方法从外部获取用户凭据小获取用户凭据尝试修改从返回的用户名和密码字符串小李输出原始对象中的用户名和密码原始用户名原始密码在这个示例中尽管我们尝试修改返回的字符串数组即用户名和密码但原始对象中的用户名和密码保持不变这证明了字符串的不可变性有助于保护对象的安全性第二保证哈希值不会频繁变更毕竟要经常作为哈希表的键值经常变更的话哈希表的性能就会很差劲在类中哈希值是在第一次计算时缓存的后续对该哈希值的请求将直接使用缓存值这有助于提高哈希表等数据结构的性能以下是一个简单的示例演示了字符串的哈希值缓存机制计算字符串的哈希值此时会进行计算并缓存哈希值第一次计算的哈希值再次计算字符串的哈希值此时直接返回缓存的哈希值第二次计算计算字符串的哈希值由于字符串常量池的存在实际上和指向同一个字符串对象所以这里直接返回缓存的哈希值直接使用缓存在这个示例中我们创建了两个具有相同内容的字符串和首次计算的哈希值时会进行实际计算并缓存该值当我们再次计算的哈希值或计算具有相同内容的的哈希值时将直接返回缓存的哈希值而不进行重新计算由于对象是不可变的其哈希值在创建后不会发生变化这使得类可以缓存哈希值提高哈希表等数据结构的性能如果是可变的那么在每次修改时都需要重新计算哈希值这会降低性能第三可以实现字符串常量池会将相同内容的字符串存储在字符串常量池中这样具有相同内容的字符串变量可以指向同一个对象节省内存空间由于字符串的不可变性类的一些方法实现最终都返回了新的字符串对象就拿方法来说方法用于截取字符串最终返回的都是出来的新字符串对象还有方法方法用于拼接字符串不管编码是否一致最终也返回的是新的字符串对象替换方法其实也一样你可以自己一会看一下源码也是返回新的字符串对象这就意味着不管是截取拼接还是替换都不是在原有的字符串上进行的而是重新生成了新的字符串对象也就是说这些操作执行过后原来的字符串对象并没有发生改变线程安全不可变性天生具备线程安全可以在多个线程中安全地使用的需要如果一个对象已经被创建过了那么就会从中取得引用只有是不可变的才可能使用也叫做字符串常量值这个之后会介绍的字符串常量池保存着所有字符串字面量这些字面量在编译时期就确定不仅如此还可以使用的方法在运行过程将字符串添加到中当一个字符串调用方法时如果中已经存在一个字符串和该字符串值相等使用方法进行确定那么就会返回中字符串的引用否则就会在中添加一个新的字符串并返回这个新字符串的引用下面示例中和采用的方式新建了两个不同字符串而和是通过和方法取得同一个字符串引用首先把放到中然后返回这个字符串引用因此和引用的是同一个字符串如果是采用这种字面量的形式创建字符串会自动地将字符串放入中在之前被放在运行时常量池中它属于永久代而在被移到堆中这是因为永久代的空间有限在大量使用字符串的场景下会导致错误可变性不可变和可变线程安全不可变因此是线程安全的不是线程安全的是线程安全的内部使用进行同步下面来看他们的用法由于字符串是不可变的所以当遇到字符串拼接尤其是使用号操作符的时候就需要考量性能的问题你不能毫无顾虑地生产太多对象对珍贵的内存造成不必要的压力于是就设计了一个专门用来解决此问题的类其他方法不过由于操作字符串的方法加了关键字进行了同步主要是考虑到多线程环境下的安全问题所以执行效率会比较低于是就给生了个兄弟名叫说孩子你别管线程安全了你就在单线程环境下使用这样效率会高得多如果要在多线程环境下修改字符串你到时候可以使用来避免多线程冲突除了类名不同方法没有加基本上完全一样实际开发中的使用频率也是远高于甚至可以这么说完全取代了可以看做是一个容器创建之后里面的内容是可变的作用提高字符串的操作效率构造方法空参构造有参数常用方法添加反转返回长度可以把变成下面来看具体的几个案例字符串你是傻逼添加元素反转获取长度在底层对他做了一些特殊处理打印对象不是地址值而是属性值变回字符串最后总结一下一般会用到的场景就是字符串的拼接字符串的反转使用这种方式一共会创建两个字符串对象前提是中还没有字符串对象属于字符串字面量因此编译时期会在中创建一个字符串对象指向这个字符串字面量而使用的方式会在堆中创建一个字符串对象创建一个测试类其方法中使用这种方式来创建字符串对象使用进行反编译得到以下内容在中存储这字符串字面量是的字符串对象它指向这个字符串字面量在方法中行使用在堆中创建一个字符串对象并且使用将中的字符串对象作为构造函数的参数以下是构造函数的源码可以看到在将一个字符串对象作为另一个字符串对象的构造函数参数时并不会完全复制数组内容而是都会指向同一个数组字符串优化详解方法这个是美团技术团队深入的一个东西深入解析美团技术团队原网址在这里要理解美团技术团队的这篇文章你只需要记住这几点内容第一使用双引号声明的字符串对象会保存在字符串常量池中第二使用关键字创建的字符串对象会先从字符串常量池中找如果没找到就创建一个然后再在堆中创建字符串对象如果找到了就直接在堆中创建字符串对象第三针对没有使用双引号声明的字符串对象来说就像下面代码中的那样你好如果想把的内容也放入字符串常量池的话可以调用方法来完成不过需要注意的是的时候字符串常量池从永久代中移动到了堆中虽然此时永久代还没有完全被移除的时候永久代被彻底移除这个变化也直接影响了方法在执行时的策略之前执行方法的时候不管对象在堆中是否已经创建字符串常量池中仍然会创建一个内容完全相同的新对象之后呢由于字符串常量池放在了堆中执行方法的时候如果对象在堆中已经创建了字符串常量池中就不需要再创建新的对象了而是直接保存堆中对象的引用也就节省了一部分的内存空间例如下面的这个代码你好第一行代码字符串常量池中会先创建一个你好的对象然后堆中会再创建一个你好的对象引用的是堆中的对象第二行代码对执行方法该方法会从字符串常量池中查找你好这个字符串是否存在此时是存在的所以引用的是字符串常量池中的对象也就意味着和的引用地址是不同的一个来自堆一个来自字符串常量池所以输出的结果为再看下面这个代码你好这个输出结果就是了其实和一样也可以看成是一个容器作用提高字符串的操作效率代码编写特别简单但是目前市场上很少有人用因为这个是在之后才有的他的构造方法之后看他的成员方法看他一个简单的应用字符串这里就不做过多的介绍了字符串相等判断中的与的区别与用法这个问题看似简单却在上有超过万的访问量我说这个问题也可以引申为和操作符有什么区别操作符用于比较两个对象的地址是否相等方法用于比较两个对象的内容是否相等就好像我们普通人看见阿丽塔以为是洛丽塔看见洛丽塔以为是阿丽塔看起来一样就觉得她们是同一个人操作符就好像她们的妈妈要求更严格观察更细致一眼就能分辨出谁是姐姐谁是妹妹小萝莉小萝莉就上面这段代码来说输出的结果为而操作符输出的结果为前者要求内容相等就可以后者要求必须是同一个对象之前已经学过了的所有类都默认地继承这个超类该类有一个名为的方法一边说我一边打开了类的源码你看类的方法默认采用的是操作符进行比较假如子类没有重写该方法的话那么操作符和方法的功效就完全一样比较两个对象的内存地址是否相等但实际情况中有不少类重写了方法因为比较内存地址的要求比较严格不太符合现实中所有的场景需求拿类来说我们在比较字符串的时候的确只想判断它们俩的内容是相等的就可以了并不想比较它们俩是不是同一个对象况且字符串有字符串常量池的概念本身就推荐使用字符串这种形式来创建字符串对象而不是通过关键字的方式因为可以把字符串缓存在字符串常量池中方便下次使用不用遇到就在堆上开辟一块新的空间那就来看一下类的方法的源码吧首先如果两个字符串对象的可以那就直接返回了因为这种情况下字符串内容是必然相等的否则就按照字符编码进行比较分为和差别不是很大就拿的来说吧这个版本是也就是最新的长期支持版本该版本中类使用字节数组实现的所以比较两个字符串的内容是否相等时可以先比较字节数组的长度是否相等不相等就直接返回否则就遍历两个字符串的字节数组只有有一个字节不相等就返回这是中的方法源码判断是否为同一对象判断对象是否为类型判断字符串长度是否相等判断每个字符是否相等比更容易懂一些首先判断两个对象是否为同一个对象如果是则返回接着判断对象是否为类型如果不是则返回如果对象为类型则比较两个字符串的长度是否相等如果长度不相等则返回如果长度相等则逐个比较每个字符是否相等如果都相等则返回否则返回如果要进行两个字符串对象的内容比较除了方法还有其他两个可选的方案这个静态方法的优势在于不需要在调用之前判空如果直接使用则需要在调用之前对进行判空否则可能会抛出空指针用起来就完全没有这个担心小萝莉小萝莉小萝莉小萝莉类的的优势在于可以将字符串与任何的字符序列进行比较从源码上可以看得出如果是该方法还会进行同步非常的智能化如果是的话其实调用的还是方法当然了这也就意味着使用该方法进行比较的时候多出来了很多步骤性能上有些损失同样来看一下的源码同样更容易理解一些首先判断参数长度是否相等不相等则返回如果参数是的实例则取出其数组遍历比较两个数组的每个元素是否相等如果参数是的实例则直接调用方法比较两个字符串是否相等如果参数是其他实现了接口的对象则遍历比较两个对象的每个字符是否相等总体上感觉还是比较舒服下面来看几个例字这些也是一作为面试经常会考到的一些小题目小萝莉小萝莉小萝莉小萝莉小萝莉小萝莉小萝莉小萝莉小萝莉小萝莉第一行代码的结果为因为方法比较的是字符串的内容而两个字符串的内容都是相同的第二行代码的结果为因为使用关键字创建的字符串对象是在堆内存中创建的而使用双引号创建的字符串是在常量池中创建的两者在内存中的地址不同因此比较结果为第三行代码的结果为因为使用关键字创建的两个字符串对象在内存中的地址不同因此比较结果为第四行代码的结果为因为使用双引号创建的两个字符串都是在常量池中创建的并且内容相同因此比较结果为第五行代码的结果为因为使用双引号创建的字符串都是在常量池中创建的而小萝莉会在编译期间被优化为小萝莉因此比较结果为案例说了这么多我们来看几个实际的练习来进行巩固字符串罗马数字的俩种写法键盘录用请输入一个字符串字符串验证当前字符串不符合规则变换字符和数字的转换定义数组长度只能是数字下面我们来解析一下这个代码这段代码实现了将输入的阿拉伯数字字符串转换为对应的罗马数字字符串的功能具体实现过程如下首先通过类从控制台读入一个字符串然后调用方法验证输入的字符串是否符合规则如果不符合规则则重新输入直到输入符合规则为止接着使用类创建一个字符串缓冲区遍历输入的字符串中的每个字符将字符转换为对应的数字再调用方法将数字转换为对应的罗马数字字符串将转换后的字符串添加到字符串缓冲区中最后输出字符串缓冲区中的所有字符串即为对应的罗马数字字符串其中方法实现了将数字转换为对应的罗马数字字符串的功能使用了一个字符串数组来存储的罗马数字字符串根据输入的数字返回对应的罗马数字字符串方法用于验证输入的字符串是否符合规则规则为只能包含数字字符且长度不能超过个字符整个程序实现简单通过方法的封装和调用使得代码的可读性和可维护性都得到了提高字符串给定字符串把左侧字符移动到右侧去解决方法进行截取可以把字符串变成一个字符数组截取字符这段代码实现了判断两个字符串是否为旋转字符串的功能具体实现过程如下首先定义两个字符串和分别为原始字符串和待判断的字符串调用方法该方法使用循环将字符串向左旋转每次旋转后判断旋转后的字符串是否和相等如果相等则返回否则继续旋转方法用于将字符串向左旋转一位具体实现方式为将字符串的第一个字符移到字符串的末尾然后返回旋转后的字符串最后输出方法的返回值即为判断结果整个程序实现简单通过方法的封装和调用使得代码的可读性和可维护性都得到了提高总结后记全书写到这里也是字了首先说明这个里面很多都是借鉴了一些厉害的程序员的博客以及官方文档以及一些技术上的分析这里面说的很多都涉及到了底层源码之类的如果有错误的情况你可以联系我的邮箱来说明错误这个整体的写下来说实话我觉得适合一些有基础的人去看这些东西而不是基础的对于基础的如果你看完这个后非常的懵感觉什么也没有学到什么也没有记住你可以去看黑马的从入门到起飞那里面虽然知识不够深但也算是一个非常好理解的入门视频包括韩顺平的基础也是非常经典的一个视频有兴趣的都可以去查看最后我想说如果入门光了解这些东西是远远不够的需要去学习更多的知识同时我也追寻着其他人的脚步不断的去优化我的知识体系年月日这本书正式完结版本之后会更新面向对象当然这个就是之后的事情了可能一个月后可能更久因为最近在学一些算法当然之后我也会出算法之类的总结的就这样有缘再见',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-08 12:43:01',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://mydocs.guoyaxue.top/" title="旧版博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="旧版博客"/><span class="back-menu-item-text">旧版博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://pan.xiaou61.top/#/" title="免费网盘"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="免费网盘"/><span class="back-menu-item-text">免费网盘</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://cloud.xiaou61.top/" title="云盘(自用)"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="云盘(自用)"/><span class="back-menu-item-text">云盘(自用)</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://wpzc.xiaou61.top/" title="云盘转存"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="云盘转存"/><span class="back-menu-item-text">云盘转存</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://love.xiaou61.top/#/" title="关于我们(My girlFriend)"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="关于我们(My girlFriend)"/><span class="back-menu-item-text">关于我们(My girlFriend)</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">娱乐项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://fxq.xiaou61.top/#/" title="飞行棋"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="飞行棋"/><span class="back-menu-item-text">飞行棋</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/game/sqnwmai803/" title="谁去拿外卖"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="谁去拿外卖"/><span class="back-menu-item-text">谁去拿外卖</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/desktop.html" title="win12网页版"><img class="back-menu-item-icon" src="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/icon/logo.svg" alt="win12网页版"/><span class="back-menu-item-text">win12网页版</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://game.xiaou61.top/" title="在线游戏"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="在线游戏"/><span class="back-menu-item-text">在线游戏</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">小u的博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 开往</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><span> 开往</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>3</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JVM/" style="font-size: 1.05rem;">JVM<sup>22</sup></a><a href="/tags/Nginx/" style="font-size: 1.05rem;">Nginx<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>1</sup></a><a href="/tags/Ts/" style="font-size: 1.05rem;">Ts<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size: 1.05rem;">TypeScript<sup>1</sup></a><a href="/tags/WebApi/" style="font-size: 1.05rem;">WebApi<sup>1</sup></a><a href="/tags/coder1v5/" style="font-size: 1.05rem;">coder1v5<sup>2</sup></a><a href="/tags/css/" style="font-size: 1.05rem;">css<sup>3</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>12</sup></a><a href="/tags/javaSE/" style="font-size: 1.05rem;">javaSE<sup>3</sup></a><a href="/tags/javaWeb/" style="font-size: 1.05rem;">javaWeb<sup>2</sup></a><a href="/tags/js%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">js逆向<sup>1</sup></a><a href="/tags/leetcode/" style="font-size: 1.05rem;">leetcode<sup>3</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>8</sup></a><a href="/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/" style="font-size: 1.05rem;">书籍推荐<sup>2</sup></a><a href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%90%AC%E8%BF%90/" style="font-size: 1.05rem;">公众号搬运<sup>35</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 1.05rem;">前端<sup>10</sup></a><a href="/tags/%E5%8A%9E%E5%85%AC/" style="font-size: 1.05rem;">办公<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 1.05rem;">后端<sup>8</sup></a><a href="/tags/%E5%A4%A9%E6%B6%AF%E8%AE%BA%E5%9D%9B/" style="font-size: 1.05rem;">天涯论坛<sup>1</sup></a><a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 1.05rem;">导航<sup>1</sup></a><a href="/tags/%E5%B0%B1%E4%B8%9A/" style="font-size: 1.05rem;">就业<sup>16</sup></a><a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 1.05rem;">微信<sup>1</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/" style="font-size: 1.05rem;">技术杂谈<sup>51</sup></a><a href="/tags/%E6%8E%98%E9%87%91/" style="font-size: 1.05rem;">掘金<sup>14</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 1.05rem;">杂项<sup>1</sup></a><a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 1.05rem;">测试<sup>1</sup></a><a href="/tags/%E6%B8%A1%E4%B8%80%E5%A4%A7%E5%B8%88%E8%AF%BE/" style="font-size: 1.05rem;">渡一大师课<sup>3</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 1.05rem;">爬虫<sup>1</sup></a><a href="/tags/%E7%9B%AE%E5%BD%95/" style="font-size: 1.05rem;">目录<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>4</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 1.05rem;">虚拟机<sup>12</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>6</sup></a><a href="/tags/%E8%B7%AF%E9%A3%9E%E5%AD%A6%E9%99%A2/" style="font-size: 1.05rem;">路飞学院<sup>3</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">面向对象<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>51</sup></a><a href="/tags/%E9%A3%9E%E8%A1%8C%E6%A3%8B/" style="font-size: 1.05rem;">飞行棋<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">234</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">September 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">May 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/" itemprop="url">java</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/javaSE/" itemprop="url">javaSE</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/java/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>java</span></a><a class="article-meta__tags" href="/tags/javaSE/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>javaSE</span></a></span></div></div><h1 class="post-title" itemprop="name headline">java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-09-30T23:34:06.068Z" title="Created 2023-10-01 07:34:06">2023-10-01</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-08-08T04:43:01.394Z" title="Updated 2023-08-08 12:43:01">2023-08-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为邯郸"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>邯郸</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2023/10/01/codenotes/Java/java%E5%9F%BA%E7%A1%80/"><header><a class="post-meta-categories" href="/categories/java/" itemprop="url">java</a><a class="post-meta-categories" href="/categories/java/javaSE/" itemprop="url">javaSE</a><a href="/tags/java/" tabindex="-1" itemprop="url">java</a><a href="/tags/javaSE/" tabindex="-1" itemprop="url">javaSE</a><h1 id="CrawlerTitle" itemprop="name headline">java基础</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小u</span><time itemprop="dateCreated datePublished" datetime="2023-09-30T23:34:06.068Z" title="Created 2023-10-01 07:34:06">2023-10-01</time><time itemprop="dateCreated datePublished" datetime="2023-08-08T04:43:01.394Z" title="Updated 2023-08-08 12:43:01">2023-08-08</time></header><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400224.png" alt="黑白米白色文学作品中式文化宣传中文书籍封面 (images/Java/1.png)"></p>
<h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p>​    这个是书写的第一本小册，用来详细的去复习java的基础的内容，这里会记录一些我从其他书籍上看到的相关的介绍，简介等，以及自己对于这个的理解，以及一些详细的案例。综合考虑来制作这样的一本java基础书籍，会持续的去补充这里的东西。</p>
<h2 id="java概述以及环境变量的配置"><a href="#java概述以及环境变量的配置" class="headerlink" title="java概述以及环境变量的配置"></a>java概述以及环境变量的配置</h2><h3 id="为什么选择java"><a href="#为什么选择java" class="headerlink" title="为什么选择java"></a>为什么选择java</h3><p>很简单，因为因为Java是全球排名第一的编程语言，Java工程师也是市场需求最大的软件工程师，选择Java，就是选择了高薪。虽然现在市场上，有很多制造java失业等的一些焦虑，不过，这种现象再各个行业都有所体现，相对来说，java目前还是值得去入手的一门语言。</p>
<h3 id="为什么java最广泛"><a href="#为什么java最广泛" class="headerlink" title="为什么java最广泛"></a>为什么java最广泛</h3><p>从互联网到企业平台，Java是应用最广泛的编程语言，原因在于：</p>
<ul>
<li>Java是基于JVM虚拟机的跨平台语言，一次编写，到处运行；</li>
<li>Java程序易于编写，而且有内置垃圾收集，不必考虑内存管理；</li>
<li>Java虚拟机拥有工业级的稳定性和高度优化的性能，且经过了长时期的考验；</li>
<li>Java拥有最广泛的开源社区支持，各种高质量组件随时可用。</li>
</ul>
<p>Java语言常年霸占着三大市场：</p>
<ul>
<li>互联网和企业应用，这是Java EE的长期优势和市场地位；</li>
<li>大数据平台，主要有Hadoop、Spark、Flink等，他们都是Java或Scala（一种运行于JVM的编程语言）开发的；</li>
<li>Android移动平台。</li>
</ul>
<p>这意味着Java拥有最广泛的就业市场。</p>
<p>同时，<strong>Java是一门面向对象的编程语言</strong>。这个在后续会说什么是面向对象的编程语言。</p>
<p>对于java的可移植性，也是非常可见的，Java有一句口号：<code>Write once, run anywhere</code>，一次编写、到处运行。这也是Java的魅力所在。而实现这种特性的正是Java虚拟机JVM。已编译的Java程序可以在任何带有JVM的平台上运行。你可以在windows平台编写代码，然后拿到linux上运行。只要你在编写完代码后，将代码编译成.class文件，再把class文件打成Java包，这个jar包就可以在不同的平台上运行了。</p>
<p>Java是一个强类型语言，它允许扩展编译时检查潜在类型不匹配问题的功能。Java要求显式的方法声明，它不支持C风格的隐式声明。这些严格的要求保证编译程序能捕捉调用错误，这就导致更可靠的程序。</p>
<h3 id="java简介"><a href="#java简介" class="headerlink" title="java简介"></a>java简介</h3><p>ava最早是由SUN公司（已被Oracle收购）的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/James_Gosling">詹姆斯·高斯林</a>（高司令，人称Java之父）在上个世纪90年代初开发的一种编程语言，最初被命名为Oak，目标是针对小型家电设备的嵌入式应用，结果市场没啥反响。谁料到互联网的崛起，让Oak重新焕发了生机，于是SUN公司改造了Oak，在1995年以Java的名称正式发布，原因是Oak已经被人注册了，因此SUN注册了Java这个商标。随着互联网的高速发展，Java逐渐成为最重要的网络编程语言。</p>
<p>Java介于编译型语言和解释型语言之间。编译型语言如C、C++，代码是直接编译成机器码执行，但是不同的平台（x86、ARM等）CPU的指令集不同，因此，需要编译出每一种平台的对应机器码。解释型语言如Python、Ruby没有这个问题，可以由解释器直接加载源码然后运行，代价是运行效率太低。而Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。当然，这是针对Java开发者而言。对于虚拟机，需要为每个平台分别开发。为了保证不同平台、不同公司开发的虚拟机都能正确执行Java字节码，SUN公司制定了一系列的Java虚拟机规范。从实践的角度看，JVM的兼容性做得非常好，低版本的Java字节码完全可以正常运行在高版本的JVM上。</p>
<p>随着Java的发展，SUN给Java又分出了三个不同版本：</p>
<ul>
<li>Java SE：Standard Edition</li>
<li>Java EE：Enterprise Edition</li>
<li>Java ME：Micro Edition</li>
</ul>
<p>这三者之间有啥关系呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│Java EE                    │</span><br><span class="line">│    ┌────────────────────┐ │</span><br><span class="line">│    │Java SE             │ │</span><br><span class="line">│    │    ┌─────────────┐ │ │</span><br><span class="line">│    │    │   Java ME   │ │ │</span><br><span class="line">│    │    └─────────────┘ │ │</span><br><span class="line">│    └────────────────────┘ │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>简单来说，Java SE就是标准版，包含标准的JVM和标准库，而Java EE是企业版，它只是在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等，Java EE的应用使用的虚拟机和Java SE完全相同。</p>
<p>Java ME就和Java SE不同，它是一个针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”。</p>
<p>毫无疑问，Java SE是整个Java平台的核心，而Java EE是进一步学习Web应用所必须的。我们熟悉的Spring等框架都是Java EE开源生态系统的一部分。不幸的是，Java ME从来没有真正流行起来，反而是Android开发成为了移动平台的标准之一，因此，没有特殊需求，不建议学习Java ME。</p>
<p>直到现在，java已经迎来了20的版本。</p>
<p>对于java的开发工具，也是有很多的选择。目前推荐用的就是idea。这本书也都是在idea上来进行操作的。</p>
<h3 id="关于java的常见误解"><a href="#关于java的常见误解" class="headerlink" title="关于java的常见误解"></a>关于java的常见误解</h3><p>当然，关于安装的这部分，这个书就不做解释了，也可能以后会做解释，目前是不做解释了。话不多说，直接开始下面的学习。</p>
<h2 id="java语法基础"><a href="#java语法基础" class="headerlink" title="java语法基础"></a>java语法基础</h2><h3 id="第一个java程序"><a href="#第一个java程序" class="headerlink" title="第一个java程序"></a>第一个java程序</h3><p>首先要知道，java是面向对象设计的，所以，首先要引入下面几个概念：</p>
<ul>
<li><p><strong>对象</strong>：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</p>
</li>
<li><p><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</p>
</li>
<li><p><strong>方法</strong>：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</p>
</li>
<li><p><strong>实例变量</strong>：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</p>
<p>一般的，每一个语言的开始都是从Hello word开始，当然java也不例外。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是java的hello word 乍一看还是非常的麻烦的，但是如果详细的说明，其实也没那么麻烦了。下面就对这一行代码进行一个简单的解析。</p>
<p>在一个Java程序中，你总能找到一个类似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>的定义，这个定义被称为class（类），这里的类名是<code>Hello</code>，大小写敏感，<code>class</code>用来定义一个类，<code>public</code>表示这个类是公开的，<code>public</code>、<code>class</code>都是Java的关键字，必须小写，<code>Hello</code>是类的名字，按照习惯，首字母<code>H</code>要大写。而花括号<code>&#123;&#125;</code>中间则是类的定义。</p>
<p>注意到类的定义中，我们定义了一个名为<code>main</code>的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法是可执行的代码块，一个方法除了方法名<code>main</code>，还有用<code>()</code>括起来的方法参数，这里的<code>main</code>方法有一个参数，参数类型是<code>String[]</code>，参数名是<code>args</code>，<code>public</code>、<code>static</code>用来修饰方法，这里表示它是一个公开的静态方法，<code>void</code>是方法的返回类型，而花括号<code>&#123;&#125;</code>中间的就是方法的代码。</p>
<p>方法的代码每一行用<code>;</code>结束，这里只有一行代码，就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>它用来打印一个字符串到屏幕上。</p>
<p>Java规定，某个类定义的<code>public static void main(String[] args)</code>是Java程序的固定入口方法，因此，Java程序总是从<code>main</code>方法开始执行。</p>
<p>注意到Java源码的缩进不是必须的，但是用缩进后，格式好看，很容易看出代码块的开始和结束，缩进一般是4个空格或者一个tab。</p>
<p>最后，当我们把代码保存为文件时，文件名必须是<code>Hello.java</code>，而且文件名也要注意大小写，因为要和我们定义的类名<code>Hello</code>完全保持一致。</p>
<p>简单来说我们可以来看这个图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400654.jpeg" alt="img"></p>
<p>之后我们在idea中点击运行就可以了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400204.png" alt="image-20230614125030250"></p>
</li>
</ul>
<p>这样，我们就书写完我们的第一个程序了。</p>
<p>这里就不讲如何用命令在控制台上做输出了，因为这本书主打的就是一个快速入门，所以一些不重要，或者是已经被淘汰的东西，我这里就不做介绍了。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>编写 Java 程序时，应注意以下几点：</p>
<ul>
<li><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li>
<li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong> 。</li>
<li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li>
<li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</li>
<li><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</li>
</ul>
<h3 id="java标识符"><a href="#java标识符" class="headerlink" title="java标识符"></a>java标识符</h3><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p>
<p>关于 Java 标识符，有以下几点需要注意：</p>
<ul>
<li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li>
<li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li>
<li>关键字不能用作标识符</li>
<li>标识符是大小写敏感的</li>
<li>合法标识符举例：age、$salary、_value、__1_value</li>
<li>非法标识符举例：123abc、-salary</li>
</ul>
<h3 id="java修饰符"><a href="#java修饰符" class="headerlink" title="java修饰符"></a>java修饰符</h3><p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p>
<ul>
<li>访问控制修饰符 : default, public , protected, private</li>
<li>非访问控制修饰符 : final, abstract, static, synchronized</li>
</ul>
<h3 id="java变量"><a href="#java变量" class="headerlink" title="java变量"></a>java变量</h3><p>什么是变量？</p>
<p>变量就是初中数学的代数的概念，例如一个简单的方程，x，y都是变量。</p>
<p>在Java中，变量分为两种：基本类型的变量和引用类型的变量。</p>
<p>我们先讨论基本类型的变量。</p>
<p>在Java中，变量必须先定义后使用，在定义变量的时候，可以给它一个初始值。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int x = 1;</span><br></pre></td></tr></table></figure>

<p>上述语句定义了一个整型<code>int</code>类型的变量，名称为<code>x</code>，初始值为<code>1</code>。</p>
<p>不写初始值，就相当于给它指定了默认值。默认值总是<code>0</code>。</p>
<p>来看一个完整的定义变量，然后打印变量值的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 定义int类型变量x，并赋予初始值100</span></span><br><span class="line">        System.out.println(x); <span class="comment">// 打印该变量的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>变量的一个重要特点是可以重新赋值。例如，对变量<code>x</code>，先赋值<code>100</code>，再赋值<code>200</code>，观察两次打印的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 定义int类型变量x，并赋予初始值100</span></span><br><span class="line">        System.out.println(x); <span class="comment">// 打印该变量的值，观察是否为100</span></span><br><span class="line">        x = <span class="number">200</span>; <span class="comment">// 重新赋值为200</span></span><br><span class="line">        System.out.println(x); <span class="comment">// 打印该变量的值，观察是否为200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意到第一次定义变量<code>x</code>的时候，需要指定变量类型<code>int</code>，因此使用语句<code>int x = 100;</code>。而第二次重新赋值的时候，变量<code>x</code>已经存在了，不能再重复定义，因此不能指定变量类型<code>int</code>，必须使用语句<code>x = 200;</code>。</p>
<p>变量不但可以重新赋值，还可以赋值给其他变量。让我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 定义变量n，同时赋值为100</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n = &quot;</span> + n); <span class="comment">// 打印n的值</span></span><br><span class="line"></span><br><span class="line">        n = <span class="number">200</span>; <span class="comment">// 变量n赋值为200</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n = &quot;</span> + n); <span class="comment">// 打印n的值</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> n; <span class="comment">// 变量x赋值为n（n的值为200，因此赋值后x的值也是200）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x = &quot;</span> + x); <span class="comment">// 打印x的值</span></span><br><span class="line"></span><br><span class="line">        x = x + <span class="number">100</span>; <span class="comment">// 变量x赋值为x+100（x的值为200，因此赋值后x的值是200+100=300）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;x = &quot;</span> + x); <span class="comment">// 打印x的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;n = &quot;</span> + n); <span class="comment">// 再次打印n的值，n应该是200还是300？</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一行一行地分析代码执行流程：</p>
<p>执行<code>int n = 100;</code>，该语句定义了变量<code>n</code>，同时赋值为<code>100</code>，因此，JVM在内存中为变量<code>n</code>分配一个“存储单元”，填入值<code>100</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      n</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">│   │100│   │   │   │   │   │</span><br><span class="line">└───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>

<p>执行<code>n = 200;</code>时，JVM把<code>200</code>写入变量<code>n</code>的存储单元，因此，原有的值被覆盖，现在<code>n</code>的值为<code>200</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      n</span><br><span class="line">      │</span><br><span class="line">      ▼</span><br><span class="line">┌───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">│   │200│   │   │   │   │   │</span><br><span class="line">└───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>

<p>执行<code>int x = n;</code>时，定义了一个新的变量<code>x</code>，同时对<code>x</code>赋值，因此，JVM需要<em>新分配</em>一个存储单元给变量<code>x</code>，并写入和变量<code>n</code>一样的值，结果是变量<code>x</code>的值也变为<code>200</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      n           x</span><br><span class="line">      │           │</span><br><span class="line">      ▼           ▼</span><br><span class="line">┌───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">│   │200│   │   │200│   │   │</span><br><span class="line">└───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>

<p>执行<code>x = x + 100;</code>时，JVM首先计算等式右边的值<code>x + 100</code>，结果为<code>300</code>（因为此刻<code>x</code>的值为<code>200</code>），然后，将结果<code>300</code>写入<code>x</code>的存储单元，因此，变量<code>x</code>最终的值变为<code>300</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      n           x</span><br><span class="line">      │           │</span><br><span class="line">      ▼           ▼</span><br><span class="line">┌───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">│   │200│   │   │300│   │   │</span><br><span class="line">└───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>

<p>可见，变量可以反复赋值。注意，等号<code>=</code>是赋值语句，不是数学意义上的相等，否则无法解释<code>x = x + 100</code>。</p>
<p>Java 中主要有如下几种类型的变量</p>
<ul>
<li>局部变量</li>
<li>类变量（静态变量）</li>
<li>成员变量（非静态变量）</li>
</ul>
<p>下面我们就来对一个变量的例题进行练习。题目非常的简单，就是一个关于公交车上下车的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈功能概述〉&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *题目如下：一开始公交车上没有乘客。</span></span><br><span class="line"><span class="comment"> * 第一站：上去一个乘客</span></span><br><span class="line"><span class="comment"> * 第二站：上去俩位乘客，下来一个乘客。</span></span><br><span class="line"><span class="comment"> * 第三站：上去俩位乘客，下来一个乘客。</span></span><br><span class="line"><span class="comment"> * 第四站：下来一位乘客</span></span><br><span class="line"><span class="comment"> * 第五站：上来一位乘客</span></span><br><span class="line"><span class="comment"> * 问题：到了终点站，车上一共几位乘客</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:Lenovo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022/11/19 20:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> class 变量练习之计算公交车的人数 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        count=count+<span class="number">1</span>;</span><br><span class="line">        count=count+<span class="number">2</span>-<span class="number">1</span>;</span><br><span class="line">        count=count+<span class="number">2</span>-<span class="number">1</span>;</span><br><span class="line">        count=count-<span class="number">1</span>;</span><br><span class="line">        count=count+<span class="number">1</span>;</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="java关键字"><a href="#java关键字" class="headerlink" title="java关键字"></a>java关键字</h3><p>Java有一组关键字，这些关键字是保留字，不能用作变量、方法、类或任何其他标识符。关键字就是系统指定的，不需要我们去定义的一些东西。</p>
<p>他一共有下面这几种</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">关键字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">访问控制</td>
<td align="left">private</td>
<td align="left">私有的</td>
</tr>
<tr>
<td align="left">protected</td>
<td align="left">受保护的</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">public</td>
<td align="left">公共的</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">default</td>
<td align="left">默认</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">类、方法和变量修饰符</td>
<td align="left">abstract</td>
<td align="left">声明抽象</td>
</tr>
<tr>
<td align="left">class</td>
<td align="left">类</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">extends</td>
<td align="left">扩充、继承</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">final</td>
<td align="left">最终值、不可改变的</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">implements</td>
<td align="left">实现（接口）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">interface</td>
<td align="left">接口</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">native</td>
<td align="left">本地、原生方法（非 Java 实现）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">new</td>
<td align="left">创建</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">static</td>
<td align="left">静态</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">strictfp</td>
<td align="left">严格浮点、精准浮点</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">synchronized</td>
<td align="left">线程、同步</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">transient</td>
<td align="left">短暂</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">volatile</td>
<td align="left">易失</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">程序控制语句</td>
<td align="left">break</td>
<td align="left">跳出循环</td>
</tr>
<tr>
<td align="left">case</td>
<td align="left">定义一个值以供 switch 选择</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">continue</td>
<td align="left">继续</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">do</td>
<td align="left">运行</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">else</td>
<td align="left">否则</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">for</td>
<td align="left">循环</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">if</td>
<td align="left">如果</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">instanceof</td>
<td align="left">实例</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">return</td>
<td align="left">返回</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">switch</td>
<td align="left">根据值选择执行</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">while</td>
<td align="left">循环</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">错误处理</td>
<td align="left">assert</td>
<td align="left">断言表达式是否为真</td>
</tr>
<tr>
<td align="left">catch</td>
<td align="left">捕捉异常</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">finally</td>
<td align="left">有没有异常都执行</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">throw</td>
<td align="left">抛出一个异常对象</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">throws</td>
<td align="left">声明一个异常可能被抛出</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">try</td>
<td align="left">捕获异常</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">包相关</td>
<td align="left">import</td>
<td align="left">引入</td>
</tr>
<tr>
<td align="left">package</td>
<td align="left">包</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">基本类型</td>
<td align="left">boolean</td>
<td align="left">布尔型</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">字节型</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">字符型</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">双精度浮点</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">单精度浮点</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">整型</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">长整型</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">短整型</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">变量引用</td>
<td align="left">super</td>
<td align="left">父类、超类</td>
</tr>
<tr>
<td align="left">this</td>
<td align="left">本类</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">void</td>
<td align="left">无返回值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">保留关键字</td>
<td align="left">goto</td>
<td align="left">是关键字，但不能使用</td>
</tr>
<tr>
<td align="left">const</td>
<td align="left">是关键字，但不能使用</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>注意：</strong>Java 的 null 不是关键字，类似于 true 和 false，它是一个字面常量，不允许作为标识符使用。</p>
<p>这里将对关键字进行一个介绍，这里没听懂也没关系，只是方便后续去查看的。</p>
<p><strong>1、abstract：</strong> 用于声明抽象类，以及抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The animal is sleeping.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;The dog barks.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个名为 Animal 的抽象类，其中包含一个抽象方法 <code>makeSound()</code> 和一个具体方法 <code>sleep()</code>。</p>
<p><strong>2、boolean：</strong> Java 中的一种基本数据类型，表示布尔值，即真（true）或假（false）。boolean 数据类型常用于判断条件、循环控制和逻辑运算等场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isStudent</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isStudent) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;This person is a student.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;This person is not a student.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了一个 boolean 变量：isStudent。通过 if 语句，我们可以根据这些变量的值进行不同的操作。</p>
<p><strong>3、break：</strong> 用于跳出循环结构（如 for、while 和 do-while 循环）或 switch 语句。当遇到 break 语句时，程序将立即跳出当前循环或 switch 语句，继续执行紧跟在循环或 switch 语句后面的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;i: &quot;</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;Loop ended.&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用 for 循环遍历 0 到 9 的整数。当 i 等于 5 时，我们使用 break 语句跳出循环。</p>
<p><strong>4、byte：</strong> 用于表示一个 8 位（1 字节）有符号整数。它的值范围是 -128（-2^7）到 127（2^7 - 1）。</p>
<p>由于 byte 类型占用的空间较小，它通常用于处理大量的数据，如文件读写、网络传输等场景，以节省内存空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">minByte</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">maxByte</span> <span class="operator">=</span> <span class="number">127</span>;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们声明了三个 byte 类型的变量：minByte、maxByte，并分别赋予了不同的值。</p>
<p><strong>5、case：</strong> 通常与 switch 语句一起使用。switch 语句允许根据某个变量的值来选择执行不同的代码块。在 switch 语句中，case 用于标识每个可能的值和对应的代码块。</p>
<p>例子我们直接放到 switch 中一起讲。</p>
<p><strong>6、catch：</strong> 用于捕获 try 语句中的异常。在 try 块中可能会抛出异常，而在 catch 块中可以捕获这些异常并进行处理。catch 块可以有多个，每个 catch 块可以捕获特定类型的异常。在 catch 块中，可以根据需要进行异常处理，例如输出错误信息、进行日志记录、恢复程序状态等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Invalid number format&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序使用 try-catch 语句捕获 NumberFormatException 异常。在 try 块中，尝试将字符串 “abc” 转换为整数类型，由于这个字符串不是有效的数字格式，将会抛出 NumberFormatException 异常。在 catch 块中，捕获到了这个异常，并输出一条错误信息。</p>
<p><strong>7、char：</strong> 用于声明一个字符类型的变量。char 类型的变量可以存储任意的Unicode 字符，可以使用单引号将字符括起来来表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这个程序创建了一个 char 类型的变量 c，并将其赋值为大写字母 A。</p>
<p><strong>8、class：</strong> 用于声明一个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, my name is &quot;</span> + name + <span class="string">&quot; and I am &quot;</span> + age + <span class="string">&quot; years old.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>9、continue：</strong> 用于继续下一个循环，可以在指定条件下跳过其余代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>10、default：</strong> 用于指定 switch 语句中除去 case 条件之外的默认代码块。这个我们放到 switch 里一起演示。</p>
<p><strong>11、do：</strong> 通常和 while 关键字配合使用，do 后紧跟循环体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt;= <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>do-while 循环与 while 循环类似，不同之处在于 do-while 循环会先执行循环体中的代码，然后再检查循环条件。因此，do-while 循环至少会执行一次循环体中的代码。</p>
<p><strong>12、double：</strong> 用于声明一个双精度浮点类型的变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2.0</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br></pre></td></tr></table></figure>

<p><strong>13、else：</strong> 用于指示 if 语句中的备用分支。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">75</span>;</span><br><span class="line"><span class="keyword">if</span> (score &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;及格了&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;挂科了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>14、enum：</strong> 用于定义一组固定的常量枚举。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PlayerType</span> &#123;</span><br><span class="line">    TENNIS,</span><br><span class="line">    FOOTBALL,</span><br><span class="line">    BASKETBALL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>15、extends：</strong> 用于指示一个类是从另一个类或接口继承的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物正在吃东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗在汪汪叫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.eat();</span><br><span class="line">        dog.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Animal 类中有一个 <code>eat()</code> 方法，输出字符串 “动物正在吃东西”。Dog 类继承自 Animal 类，并定义了一个 <code>bark()</code> 方法，输出字符串 “狗在汪汪叫”。</p>
<p><strong>16、final：</strong> 用于表示某个变量、方法或类是最终的，不能被修改或继承。</p>
<p>①、final 变量：表示一个常量，一旦被赋值，其值就不能再被修改。这在声明不可变的值时非常有用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159265359</span>;</span><br></pre></td></tr></table></figure>

<p>②、final 方法表示一个不能被子类重写的方法。这在设计类时，确保某个方法的实现不会被子类修改时非常有用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物发出声音.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 错误: 无法覆盖来自 Animal 的 final 方法</span></span><br><span class="line">    <span class="comment">// void makeSound() &#123;</span></span><br><span class="line">    <span class="comment">//     System.out.println(&quot;狗吠叫.&quot;);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.makeSound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③、final 类表示一个不能被继承的类。这在设计类时，确保其不会被其他类继承时非常有用。String 类就是 final 的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">makeSound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物发出声音.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误: 类型 Dog 无法继承 final 类 Animal</span></span><br><span class="line"><span class="comment">// class Dog extends Animal &#123;</span></span><br><span class="line"><span class="comment">//     void makeSound() &#123;</span></span><br><span class="line"><span class="comment">//         System.out.println(&quot;狗吠叫.&quot;);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        animal.makeSound();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>17、finally：</strong> 和 <code>try-catch</code> 配合使用，表示无论是否处理异常，总是执行 finally 块中的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;  <span class="comment">// 抛出异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;发生了异常：&quot;</span> + e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;finally 块被执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>18、float：</strong> 表示单精度浮点数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">3.14f</span>;   <span class="comment">// 注意要在数字后面加上 f 表示这是一个 float 类型</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">1.23e-4f</span>;   <span class="comment">// 科学计数法表示小数</span></span><br></pre></td></tr></table></figure>

<p>在 Java 中，浮点数默认是 double 类型，如果要使用 float 类型的数据，需要在数字后面加上一个 f 或者 F，表示这是一个 float 类型的字面量。另外，也可以使用科学计数法表示浮点数，例如 1.23e-4 表示 0.000123。</p>
<p><strong>19、for：</strong> 用于声明一个 for 循环，如果循环次数是固定的，建议使用 for 循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;arr[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>20、if：</strong> 用于指定条件，如果条件为真，则执行对应代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(n + <span class="string">&quot; 是正数&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(n + <span class="string">&quot; 是负数&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(n + <span class="string">&quot; 是零&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>21、implements：</strong> 用于实现接口。</p>
<p>下面是一个实现了 Runnable 接口的类的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 线程执行的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>22、import：</strong> 用于导入对应的类或者接口。例如，如果要使用 Java 标准库中的 ArrayList 类，可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br></pre></td></tr></table></figure>

<p><strong>23、instanceof：</strong> 用于判断对象是否属于某个类型（class )。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如，假设有一个 Person 类和一个 Student 类，Student 类继承自 Person 类，可以使用 <span class="keyword">instanceof</span> 运算符来判断一个对象是否为 Person 类或其子类的实例：</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;p is an instance of Person&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;p is an instance of Student&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>24、int：</strong> 用于表示整数值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;           <span class="comment">// 声明一个 int 类型的变量 x</span></span><br><span class="line">x = <span class="number">10</span>;          <span class="comment">// 将整数值 10 赋给变量 x</span></span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">20</span>;     <span class="comment">// 声明并初始化一个 int 类型的变量 y，赋值为整数值 20</span></span><br></pre></td></tr></table></figure>

<p><strong>25、interface：</strong> 用于声明接口。会定义一组方法的签名（即方法名、参数列表和返回值类型），但没有方法体。其他类可以实现接口，并提供方法的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">method2</span><span class="params">(String param)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>26、long：</strong> 用于表示长整数值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> x;           <span class="comment">// 声明一个 long 类型的变量 x</span></span><br><span class="line">x = <span class="number">10000000000L</span>; <span class="comment">// 将长整数值 10000000000 赋给变量 x，需要在数字后面加上 L 或 l 表示这是一个 long 类型的值</span></span><br><span class="line"><span class="type">long</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">20000000000L</span>; <span class="comment">// 声明并初始化一个 long 类型的变量 y，赋值为长整数值 20000000000</span></span><br></pre></td></tr></table></figure>

<p><strong>27、native：</strong> 用于声明一个本地方法，本地方法是指在 Java 代码中声明但在本地代码（通常是 C 或 C++ 代码）中实现的方法，它通常用于与操作系统或其他本地库进行交互。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">nativeMethod</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p><strong>28、new：</strong> 用于创建一个新的对象。</p>
<p>以下是使用 new 关键字创建对象实例的基本语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassName</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassName</span>();</span><br></pre></td></tr></table></figure>

<p>以下是使用 new 关键字创建数组实例的基本语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p><strong>29、null：</strong> 如果一个变量是空的（什么引用也没有指向），就可以将它赋值为 null，和空指针异常息息相关。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 声明一个字符串引用，初始化为 null</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 声明一个 MyClass 类型的引用，初始化为 null</span></span><br></pre></td></tr></table></figure>

<p><strong>30、package：</strong> 用于声明类所在的包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mypackage;</span><br></pre></td></tr></table></figure>

<p><strong>31、private：</strong> 一个访问权限修饰符，表示方法或变量只对当前类可见。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x; <span class="comment">// 私有属性 x，只能在当前类的内部访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 私有方法 foo，只能在当前类的内部调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，MyClass 类有一个私有属性 x 和一个私有方法 <code>foo()</code>。这些成员只能在 MyClass 类的内部访问和调用，对其他类不可见。</p>
<p><strong>32、protected：</strong> 一个访问权限修饰符，表示方法或变量对同一包内的类和所有子类可见。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mypackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBaseClass</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> x; <span class="comment">// 受保护的属性 x，可以被子类和同一包中的其他类访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 受保护的方法 foo，可以被子类和同一包中的其他类调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example.mypackage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MySubClass</span> <span class="keyword">extends</span> <span class="title class_">MyBaseClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bar</span><span class="params">()</span> &#123;</span><br><span class="line">        x = <span class="number">10</span>; <span class="comment">// 可以访问 MyBaseClass 中的受保护属性 x</span></span><br><span class="line">        foo(); <span class="comment">// 可以调用 MyBaseClass 中的受保护方法 foo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，MyBaseClass 类有一个受保护的属性 x 和一个受保护的方法 <code>foo()</code>。这些成员可以被子类和同一包中的其他类访问和调用。MySubClass 类继承自 MyBaseClass 类，并可以访问和修改 MyBaseClass 中的受保护成员。</p>
<p><strong>33、public：</strong> 一个访问权限修饰符，除了可以声明方法和变量（所有类可见），还可以声明类。<code>main()</code> 方法必须声明为 public。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> x; <span class="comment">// 公有属性 x，可以被任何类访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 公有方法 foo，可以被任何类调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，MyClass 类有一个公有属性 x 和一个公有方法 <code>foo()</code>。这些成员可以被任何类访问和调用，无论这些类是否在同一个包中。</p>
<p><strong>35、return：</strong> 用于从方法中返回一个值或终止方法的执行。return 语句可以将方法的计算结果返回给调用者，或者在方法执行到某个特定条件时提前结束方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b;</span><br><span class="line">    <span class="keyword">return</span> sum; <span class="comment">// 返回 sum 的值，并结束方法的执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，return 语句还可以用于提前结束方法的执行。例如，假设我们要编写一个方法，用于判断一个整数是否为偶数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEven</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (number % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了一个名为 isEven 的方法，该方法接收一个整数参数 number。如果 number 是偶数，我们使用 return 语句提前返回 true。否则，方法执行将继续，最后返回 false。</p>
<p><strong>36、short：</strong> 用于表示短整数，占用 2 个字节（16 位）的内存空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 声明一个 short 类型的变量 x，赋值为 10</span></span><br><span class="line"><span class="type">short</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 声明一个 short 类型的变量 y，赋值为 20</span></span><br></pre></td></tr></table></figure>

<p><strong>37、static：</strong> 表示该变量或方法是静态变量或静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> x; <span class="comment">// 静态变量 x，属于类的成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法 foo，属于类的成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，MyClass 类有一个静态变量 x 和一个静态方法 <code>foo()</code>。这些成员属于类的成员，可以通过类名直接访问，不需要创建对象。</p>
<p><strong>38、strictfp（strict floating-point）：</strong> 并不常见，通常用于修饰一个方法，用于限制浮点数计算的精度和舍入行为。当你在类、接口或方法上使用 strictfp 时，该范围内的所有浮点数计算将遵循 IEEE 754 标准的规定，以确保跨平台的浮点数计算的一致性。</p>
<p>不同的硬件平台和 JVM 实现可能对浮点数计算的精度和舍入行为有差异，这可能导致在不同环境中运行相同的浮点数计算代码产生不同的结果。使用 strictfp 关键字可以确保在所有平台上获得相同的浮点数计算结果，避免计算结果的不一致问题。</p>
<p>但请注意，使用 strictfp 可能会对性能产生影响，因为可能需要更多的计算和转换来确保遵循 IEEE 754 标准。因此，在使用 strictfp 时，需要权衡精度和一致性与性能之间的关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">strictfp</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.2</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> a + b;</span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Result: 0.30000000000000004</span><br></pre></td></tr></table></figure>

<p>在这个示例中，MyClass 类被声明为 strictfp，因此类中的所有浮点数计算都将遵循 IEEE 754 标准。</p>
<p>在大多数现代操作系统上，使用 strictfp 可能不会产生显著差异，因为大家都遵循 IEEE 754 标准，除非是一些较旧的硬件平台。</p>
<p>IEEE 754 标准（IEEE Standard for Floating-Point Arithmetic）是一个定义浮点数表示和运算的国际标准。由国际电气和电子工程师协会（IEEE）制定，首次发布于1985年。</p>
<p>IEEE 754 标准主要规定了以下几个方面：</p>
<p>浮点数表示：标准定义了两种浮点数格式，单精度（32位）和双精度（64位）。这两种格式分别由符号位、指数位和尾数位组成，用于表示浮点数的大小和精度。</p>
<p>四舍五入和舍入模式：标准定义了多种舍入模式，例如向最接近的数舍入（Round to Nearest, Ties to Even）、向零舍入（Round toward Zero）、向正无穷舍入（Round toward +∞）和向负无穷舍入（Round toward -∞）等。这些模式指导了浮点数计算过程中如何处理精度损失和舍入误差。</p>
<p>特殊值：标准定义了一些特殊的浮点数值，如正无穷（+∞）、负无穷（-∞）和非数值（NaN）。这些特殊值用于表示浮点数计算中可能出现的溢出、下溢和未定义结果等情况。</p>
<p>浮点数运算：标准规定了浮点数的基本运算（加、减、乘、除）和比较运算（等于、不等于、大于、小于、大于等于、小于等于）的行为和结果。这些运算需要遵循标准中规定的表示、舍入和特殊值处理规则。</p>
<p>来看示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ieee754Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0.1f</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0.2f</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">        System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;c = a + b = &quot;</span> + c);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1.0</span> / <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> -<span class="number">1.0</span> / <span class="number">0.0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">0.0</span> / <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;x = 1.0 / 0.0 = &quot;</span> + x);</span><br><span class="line">        System.out.println(<span class="string">&quot;y = -1.0 / 0.0 = &quot;</span> + y);</span><br><span class="line">        System.out.println(<span class="string">&quot;z = 0.0 / 0.0 = &quot;</span> + z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400209.png" alt="img"></p>
<p>我们可以看到 IEEE 754 标准中的浮点数表示和运算：</p>
<ul>
<li>单精度浮点数的加法：变量 a 和 b 分别存储了 0.1 和 0.2，它们的和 c 等于 0.3。由于浮点数表示的精度限制，c 的实际值可能与理论值略有误差。</li>
<li>特殊值：变量 x、y 和 z 分别存储了正无穷（+∞）、负无穷（-∞）和非数值（NaN）。这些特殊值是由除法运算产生的，当被除数为 0 或结果无法表示时，会返回相应的特殊值。</li>
</ul>
<p><strong>39、super：</strong> 可用于调用父类的方法或者字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; is barking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.eat(); <span class="comment">// 调用父类的方法</span></span><br><span class="line">        System.out.println(name + <span class="string">&quot; is eating bones.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>40、switch：</strong> 用于根据某个变量的值选择执行不同的代码块。switch 语句通常与 case 和 default 一起使用。每个 case 子句表示一个可能的值和对应的代码块，而 default 子句用于处理不在 case 子句中的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dayOfWeek</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (dayOfWeek) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Monday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Tuesday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Wednesday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Thursday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Friday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Saturday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Sunday&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;Invalid day&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了一个名为 dayOfWeek 的整数变量，并赋予了一个值。然后，我们使用 switch 语句根据 dayOfWeek 的值来输出对应的星期几。每个 case 子句表示 dayOfWeek 可能的值，后面紧跟着要执行的代码。使用 break 语句跳出 switch 语句，避免执行其他 case 子句的代码。如果 dayOfWeek 的值不在 case 子句中，default 子句将被执行。</p>
<p><strong>41、synchronized：</strong> 用于指定多线程代码中的同步方法、变量或者代码块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 同步方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123; <span class="comment">// 同步代码块</span></span><br><span class="line">            <span class="comment">// 执行一些需要同步的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>42、this：</strong> 可用于在方法或构造方法中引用当前对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.num = num; <span class="comment">// 使用 this 关键字引用当前对象的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Doing something with &quot;</span> + <span class="built_in">this</span>.num); <span class="comment">// 使用 this 关键字引用当前对象的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MyClass <span class="title function_">getThis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>; <span class="comment">// 返回当前对象本身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，MyClass 类有一个私有成员变量 num，并定义了一个构造方法、一个方法和一个返回当前对象的方法。在构造方法中，使用 this 关键字引用当前对象的成员变量，并将传入的参数赋值给该成员变量。在方法 <code>doSomething()</code> 中，使用 this 关键字引用当前对象的成员变量，并输出该成员变量的值。在方法 <code>getThis()</code> 中，直接返回当前对象本身。</p>
<p><strong>43、throw：</strong> 主动抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;num must be greater than zero&quot;</span>); <span class="comment">// 手动抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行一些操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>44、throws：</strong> 用于声明异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;num must be greater than zero&quot;</span>); <span class="comment">// 手动抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行一些操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>45、transient：</strong> 修饰的字段不会被序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> id, String name, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略 getter 和 setter 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;MyClass&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, password=&#x27;&quot;</span> + password + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，MyClass 类实现了 Serializable 接口，表示该类的对象可以被序列化。该类有三个成员变量，分别是 id、name 和 password。其中，password 成员变量被标记为 transient，表示在序列化过程中忽略这个成员变量。</p>
<p><strong>45、try：</strong> 用于包裹要捕获异常的代码块。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 异常处理代码</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>46、void：</strong> 用于指定方法没有返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>47、volatile：</strong> 保证不同线程对它修饰的变量进行操作时的可见性，即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="comment">// 线程执行的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopThread</span><span class="params">()</span> &#123;</span><br><span class="line">        running = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，MyThread 类继承了 Thread 类，重写了 <code>run()</code> 方法。MyThread 类有一个成员变量 running，被标记为 volatile，表示这个变量是共享的，可能会被多个线程同时访问。在 <code>run()</code> 方法中，使用 while 循环检查 running 变量的值，如果 running 为 true，就继续执行循环体中的代码。在另一个方法 <code>stopThread()</code> 中，将 running 变量的值设置为 false，表示需要停止线程。</p>
<p><strong>48、while：</strong> 如果循环次数不固定，建议使用 while 循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“除了这些关键字，Java 中还有两个非常特殊的保留字（goto 和 const），它们不能在程序中使用。”</p>
<p>“goto 在 C语言中叫做‘无限跳转’语句，在 Java 中，不再使用 goto 语句，因为无限跳转会破坏程序结构。”</p>
<p>Java 中确实可以使用标签（label）与 break 和 continue 语句结合来实现类似 goto 的跳转功能。以下是一个简单的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LabelDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        outerLoop:</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;跳过 outerLoop 中的当前迭代&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span> outerLoop;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;i: &quot;</span> + i + <span class="string">&quot;, j: &quot;</span> + j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用了两层嵌套循环。外层循环有一个名为 outerLoop 的标签。当 i 等于 1 且 j 等于 1 时，我们使用 continue outerLoop 语句跳过外层循环中的当前迭代。这与 goto 的行为类似。</p>
<p>来看输出结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i: 0, j: 0</span><br><span class="line">i: 0, j: 1</span><br><span class="line">i: 0, j: 2</span><br><span class="line">i: 1, j: 0</span><br><span class="line">跳过 outerLoop 中的当前迭代</span><br><span class="line">i: 2, j: 0</span><br><span class="line">i: 2, j: 1</span><br><span class="line">i: 2, j: 2</span><br><span class="line">结束</span><br></pre></td></tr></table></figure>

<p>尽管可以使用标签实现类似 goto 的跳转功能，但这种用法在 Java 中仍然较少见，因为过度使用可能导致代码难以理解和维护。通常建议尽可能使用其他控制结构（如 if、for 和 while 语句）来组织代码。</p>
<p>以下是一个使用 if 和 for 语句替代标签跳转的示例。在这个示例中，我们使用了一个布尔变量 skipIteration 来决定是否跳过外层循环的当前迭代：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IfForDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">skipIteration</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;跳过外层循环中的当前迭代&quot;</span>);</span><br><span class="line">                    skipIteration = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;i: &quot;</span> + i + <span class="string">&quot;, j: &quot;</span> + j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (skipIteration) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，当 i 等于 1 且 j 等于 1 时，我们将 skipIteration 设置为 true，然后使用 break 语句跳出内层循环。在外层循环中，我们检查 skipIteration 变量的值，如果为 true，则跳过外层循环的当前迭代。</p>
<p>这个示例的输出结果与之前的示例相同：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i: 0, j: 0</span><br><span class="line">i: 0, j: 1</span><br><span class="line">i: 0, j: 2</span><br><span class="line">i: 1, j: 0</span><br><span class="line">跳过外层循环中的当前迭代</span><br><span class="line">i: 2, j: 0</span><br><span class="line">i: 2, j: 1</span><br><span class="line">i: 2, j: 2</span><br></pre></td></tr></table></figure>

<p>“const 在 C语言中是声明常量的关键字，在 Java 中可以使用 public static final 三个关键字的组合来达到常量的效果。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">calculateArea</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用 public static final 关键字组合定义了一个名为 PI 的常量。因为它是 public 的，所以其他类可以访问这个常量。因为它是 static 的，所以它与类关联，而不是类的实例。因为它是 final 的，所以它的值不能被更改。</p>
<p>之后我们详细介绍俩个常用的关键字</p>
<h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><p><strong>1. 数据</strong></p>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">// x = 2;  // cannot assign value to final variable &#x27;x&#x27;</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">A</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">y.a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2. 方法</strong></p>
<p>声明方法不能被子类重写。</p>
<p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p>
<p><strong>3. 类</strong></p>
<p>声明类不允许被继承。</p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p><strong>1. 静态变量</strong></p>
<ul>
<li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li>
<li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;         <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> y;  <span class="comment">// 静态变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// int x = A.x;  // Non-static field &#x27;x&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a.x;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> A.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 静态方法</strong></p>
<p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// public abstract static void func2();  // Illegal combination of modifiers: &#x27;abstract&#x27; and &#x27;static&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="comment">// int b = y;  // Non-static field &#x27;y&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="comment">// int b = this.y;     // &#x27;A.this&#x27; cannot be referenced from a static context</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 静态语句块</strong></p>
<p>静态语句块在类初始化时运行一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">A</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>4. 静态内部类</strong></p>
<p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">InnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// InnerClass innerClass = new InnerClass(); // &#x27;OuterClass.this&#x27; cannot be referenced from a static context</span></span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        <span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> outerClass.<span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">        <span class="type">StaticInnerClass</span> <span class="variable">staticInnerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticInnerClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<p><strong>5. 静态导包</strong></p>
<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.xxx.ClassName.*</span><br></pre></td></tr></table></figure>

<p><strong>6. 初始化顺序</strong></p>
<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="string">&quot;静态变量&quot;</span>;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态语句块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> <span class="string">&quot;实例变量&quot;</span>;</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;普通语句块&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后才是构造函数的初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InitialOrderTest</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;构造函数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
<p>以上就是关键字的一些详细介绍了，以后也会详细介绍这个的，现在就不做介绍了。</p>
<h3 id="java注释"><a href="#java注释" class="headerlink" title="java注释"></a>java注释</h3><p>类似于 C&#x2F;C++、Java 也支持单行以及多行注释。注释中的字符将被 Java 编译器忽略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">   <span class="comment">/* 这是第一个Java程序</span></span><br><span class="line"><span class="comment">    * 它将输出 Hello World</span></span><br><span class="line"><span class="comment">    * 这是一个多行注释的示例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">       <span class="comment">// 这是单行注释的示例</span></span><br><span class="line">       <span class="comment">/* 这个也是单行注释的示例 */</span></span><br><span class="line">       System.out.println(<span class="string">&quot;Hello World&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面我们来详细的说一下注释</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400211.png" alt="image-20230614133117174"></p>
<p>01、单行注释</p>
<p>单行注释通常用于解释方法内某单行代码的作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>; <span class="comment">// age 用于表示年龄</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但如果写在行尾的话，其实是不符合阿里巴巴的开发规约的</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400215.png" alt="img"></p>
<p>正确的单行注释如上图中所说，在被注释语句上方另起一行，使用 <code>//</code> 注释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// age 用于表示年龄</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>02、多行注释</p>
<p>多行注释使用的频率其实并不高，通常用于解释一段代码的作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">age 用于表示年纪</span></span><br><span class="line"><span class="comment">name 用于表示姓名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;沉默王二&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>以 <code>/*</code> 开始，以 <code>*/</code> 结束，但不如用多个 <code>//</code> 来得痛快，因为 <code>*</code> 和 <code>/</code> 不在一起，敲起来麻烦。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// age 用于表示年纪</span></span><br><span class="line"><span class="comment">// name 用于表示姓名</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;沉默王二&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>03、文档注释</p>
<p>文档注释可用在三个地方，类、字段和方法，用来解释它们是干嘛的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 微信搜索「沉默王二」，回复 Java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * main 方法作为程序的入口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PS：在 Intellij IDEA 中，按下 <code>/**</code> 后敲下回车键就可以自动添加文档注释的格式，<code>*/</code> 是自动补全的。</p>
<p>04、文档注释的注意事项</p>
<p>1）<code>javadoc</code> 命令只能为 public 和 protected 修饰的字段、方法和类生成文档。</p>
<p>default 和 private 修饰的字段和方法的注释将会被忽略掉。因为我们本来就不希望这些字段和方法暴露给调用者。</p>
<p>如果类不是 public 的话，javadoc 会执行失败。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400688.png" alt="img"></p>
<p>2）文档注释中可以嵌入一些 HTML 标记，比如说段落标记 <code>&lt;p&gt;</code>，超链接标记 <code>&lt;a&gt;&lt;/a&gt;</code> 等等，但不要使用标题标记，比如说 <code>&lt;h1&gt;</code>，因为 javadoc 会插入自己的标题，容易发生冲突。</p>
<p>3）文档注释中可以插入一些 <code>@</code> 注解，比如说 <code>@see</code> 引用其他类，<code>@version</code> 版本号，<code>@param</code> 参数标识符，<code>@author</code> 作者标识符，<code>@deprecated</code> 已废弃标识符，等等。</p>
<p>05、注释规约</p>
<p>1）类、字段、方法必须使用文档注释，不能使用单行注释和多行注释。因为注释文档在 IDE 编辑窗口中可以悬浮提示，提高编码效率。</p>
<p>比如说，在使用 String 类的时候，鼠标悬停在 String 上时可以得到以下提示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400720.png" alt="img"></p>
<p>2）所有的抽象方法包括接口中的方法)必须要用 Javadoc 注释、除了返回值、参数、 异常说明外，还必须指出该方法做什么事情，实现什么功能。</p>
<p>3）所有的类都必须添加创建者和创建日期。</p>
<p>Intellij IDEA 中可以在「File and Code Templates」中设置。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400757.png" alt="img"></p>
<p>语法如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* java注释</span><br><span class="line">* @author 名字</span><br><span class="line">* @date $&#123;DATE&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>设置好后，在新建一个类的时候就可以自动生成了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *java注释</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiaou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/6/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）所有的枚举类型字段必须要有注释，说明每个数据项的用途。</p>
<p>5）代码修改的同时，注释也要进行相应的修改。</p>
<p>“记住一点，注释是程序固有的一部分。”</p>
<ul>
<li>第一、注释要能够准确反映设计思想和代码逻辑;</li>
<li>第二、注释要能够描述业务含 义，使别的程序员能够迅速了解到代码背后的信息。</li>
</ul>
<p>完全没有注释的大段代码对于阅读者形同 天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路;注释也是给继任者看 的，使其能够快速接替自己的工作。</p>
<h3 id="java数据类型"><a href="#java数据类型" class="headerlink" title="java数据类型"></a>java数据类型</h3><p>Java 中的数据类型可分为 2 种：</p>
<p>1）<strong>基本数据类型</strong>。</p>
<p>基本数据类型是 Java 语言操作数据的基础，包括 boolean、char、byte、short、int、long、float 和 double，共 8 种。</p>
<p>2）<strong>引用数据类型</strong>。</p>
<p>除了基本数据类型以外的类型，都是所谓的引用类型。常见的有数组，类和接口。基本数据类型</p>
<p>来个思维导图，感受下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400799.png" alt="img"></p>
<p>基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型：</p>
<ul>
<li>整数类型：byte，short，int，long</li>
<li>浮点数类型：float，double</li>
<li>字符类型：char</li>
<li>布尔类型：boolean</li>
</ul>
<p>Java定义的这些基本数据类型有什么区别呢？要了解这些区别，我们就必须简单了解一下计算机内存的基本结构。</p>
<p>计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit。它的二进制表示范围从<code>00000000</code><del><code>11111111</code>，换算成十进制是0</del>255，换算成十六进制是<code>00</code>~&#96;ff&#96;。</p>
<p>内存单元从0开始编号，称为内存地址。每个内存单元可以看作一间房间，内存地址就是门牌号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0   1   2   3   4   5   6  ...</span><br><span class="line">┌───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">│   │   │   │   │   │   │   │...</span><br><span class="line">└───┴───┴───┴───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>

<p>一个字节是1byte，1024字节是1K，1024K是1M，1024M是1G，1024G是1T。一个拥有4T内存的计算机的字节数量就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4T = 4 x 1024G</span><br><span class="line">   = 4 x 1024 x 1024M</span><br><span class="line">   = 4 x 1024 x 1024 x 1024K</span><br><span class="line">   = 4 x 1024 x 1024 x 1024 x 1024</span><br><span class="line">   = 4398046511104</span><br></pre></td></tr></table></figure>

<p>不同的数据类型占用的字节数不一样。我们看一下Java基本数据类型占用的字节数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">       ┌───┐</span><br><span class="line">  byte │   │</span><br><span class="line">       └───┘</span><br><span class="line">       ┌───┬───┐</span><br><span class="line"> short │   │   │</span><br><span class="line">       └───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┐</span><br><span class="line">   int │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">  long │   │   │   │   │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┴───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┐</span><br><span class="line"> float │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┬───┬───┬───┬───┬───┬───┐</span><br><span class="line">double │   │   │   │   │   │   │   │   │</span><br><span class="line">       └───┴───┴───┴───┴───┴───┴───┴───┘</span><br><span class="line">       ┌───┬───┐</span><br><span class="line">  char │   │   │</span><br><span class="line">       └───┴───┘</span><br></pre></td></tr></table></figure>

<p><code>byte</code>恰好就是一个字节，而<code>long</code>和<code>double</code>需要8个字节。</p>
<p>我们用表格来直观的感受一下基本数据类型</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>默认值</th>
<th>大小</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>false</td>
<td>1 比特</td>
</tr>
<tr>
<td>char</td>
<td>‘\u0000’</td>
<td>2 字节</td>
</tr>
<tr>
<td>byte</td>
<td>0</td>
<td>1 字节</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
<td>2 字节</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
<td>4 字节</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
<td>8 字节</td>
</tr>
<tr>
<td>float</td>
<td>0.0f</td>
<td>4 字节</td>
</tr>
<tr>
<td>double</td>
<td>0.0</td>
<td>8 字节</td>
</tr>
</tbody></table>
<h4 id="01、比特和字节"><a href="#01、比特和字节" class="headerlink" title="01、比特和字节"></a>01、比特和字节</h4><p>比特币（Bitcoin）听说过吧？字节跳动（Byte Dance）听说过吧？这些名字当然不是乱起的，确实和比特、字节有关系。</p>
<h5 id="1）bit（比特）"><a href="#1）bit（比特）" class="headerlink" title="1）bit（比特）"></a>1）bit（比特）</h5><p>比特作为信息技术的最基本存储单位，非常小，但大名鼎鼎的比特币就是以此命名的，它的简写为小写字母“b”。</p>
<p>大家都知道，计算机是以二进制存储数据的，二进制的一位，就是 1 比特，也就是说，比特要么为 0 要么为 1。</p>
<h5 id="2）Byte（字节）"><a href="#2）Byte（字节）" class="headerlink" title="2）Byte（字节）"></a><strong>2）Byte（字节）</strong></h5><p>通常来说，一个英文字符是一个字节，一个中文字符是两个字节。字节与比特的换算关系是：1 字节 &#x3D; 8 比特。</p>
<p>在往上的单位就是 KB，并不是 1000 字节，因为计算机只认识二进制，因此是 2 的 10 次方，也就是 1024 个字节。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400153.png" alt="img"></p>
<h4 id="02-基本数据类型"><a href="#02-基本数据类型" class="headerlink" title="02.基本数据类型"></a>02.基本数据类型</h4><h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><p>对于整型类型，Java只定义了带符号的整型，因此，最高位的bit表示符号位（0表示正数，1表示负数）。各种整型能表示的最大范围如下：</p>
<ul>
<li>byte：-128 ~ 127</li>
<li>short: -32768 ~ 32767</li>
<li>int: -2147483648 ~ 2147483647</li>
<li>long: -9223372036854775808 ~ 9223372036854775807</li>
</ul>
<p>下面来看一个定义整型的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2147483647</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> -<span class="number">2147483648</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">2_000_000_000</span>; <span class="comment">// 加下划线更容易识别</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="number">0xff0000</span>; <span class="comment">// 十六进制表示的16711680</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="number">0b1000000000</span>; <span class="comment">// 二进制表示的512</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">9000000000000000000L</span>; <span class="comment">// long型的结尾需要加L</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>特别注意：同一个数的不同进制的表示是完全相同的，例如<code>15</code>&#x3D;<code>0xf</code>＝<code>0b1111</code>。</p>
<h5 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h5><p>浮点类型的数就是小数，因为小数用科学计数法表示的时候，小数点是可以“浮动”的，如1234.5可以表示成12.345x102，也可以表示成1.2345x103，所以称为浮点数。</p>
<p>下面是定义浮点数的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">3.14f</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="number">3.14e38f</span>; <span class="comment">// 科学计数法表示的3.14x10^38</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1.79e308</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d2</span> <span class="operator">=</span> -<span class="number">1.79e308</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d3</span> <span class="operator">=</span> <span class="number">4.9e-324</span>; <span class="comment">// 科学计数法表示的4.9x10^-324</span></span><br></pre></td></tr></table></figure>

<p>对于<code>float</code>类型，需要加上<code>f</code>后缀。</p>
<p>浮点数可表示的范围非常大，<code>float</code>类型可最大表示3.4x1038，而<code>double</code>类型可最大表示1.79x10308。</p>
<h5 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h5><p>布尔类型<code>boolean</code>只有<code>true</code>和<code>false</code>两个值，布尔类型总是关系运算的计算结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isGreater</span> <span class="operator">=</span> <span class="number">5</span> &gt; <span class="number">3</span>; <span class="comment">// 计算结果为true</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isAdult</span> <span class="operator">=</span> age &gt;= <span class="number">18</span>; <span class="comment">// 计算结果为false</span></span><br></pre></td></tr></table></figure>

<h5 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h5><p>字符类型<code>char</code>表示一个字符。Java的<code>char</code>类型除了可表示标准的ASCII外，还可以表示一个Unicode字符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">zh</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(zh);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意<code>char</code>类型使用单引号<code>&#39;</code>，且仅有一个字符，要和双引号<code>&quot;</code>的字符串类型区分开。</p>
<h4 id="03、单精度和双精度"><a href="#03、单精度和双精度" class="headerlink" title="03、单精度和双精度"></a>03、单精度和双精度</h4><p>单精度（single-precision）和双精度（double-precision）是指两种不同精度的浮点数表示方法。</p>
<p>单精度是这样的格式，1 位符号，8 位指数，23 位小数。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400212.png" alt="img"></p>
<p>单精度浮点数通常占用 32 位（4 字节）存储空间。数值范围大约是 ±1.4E-45 到 ±3.4028235E38，精度大约为 6 到 9 位有效数字。</p>
<p>双精度是这样的格式，1 位符号，11 位指数，52 为小数。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400275.png" alt="img"></p>
<p>双精度浮点数通常占用 64 位（8 字节）存储空间，数值范围大约是 ±4.9E-324 到 ±1.7976931348623157E308，精度大约为 15 到 17 位有效数字。</p>
<p>计算精度取决于小数位（尾数）。小数位越多，则能表示的数越大，那么计算精度则越高。</p>
<p>一个数由若干位数字组成，其中影响测量精度的数字称作有效数字，也称有效数位。有效数字指科学计算中用以表示一个浮点数精度的那些数字。一般地，指一个用小数形式表示的浮点数中，从第一个非零的数字算起的所有数字。如 1.24 和 0.00124 的有效数字都有 3 位。</p>
<p>以下是确定有效数字的一些基本规则：</p>
<ul>
<li>非零数字总是有效的。</li>
<li>位于两个非零数字之间的零是有效的。</li>
<li>对于小数，从左侧开始的第一个非零数字之前的零是无效的。</li>
<li>对于整数，从右侧开始的第一个非零数字之后的零是无效的。</li>
</ul>
<p>下面是一些示例，说明如何确定有效数字：</p>
<ul>
<li>1234：4 个有效数字（所有数字都是非零数字）</li>
<li>1002：4 个有效数字（零位于两个非零数字之间）</li>
<li>0.00234：3 个有效数字（从左侧开始的前两个零是无效的）</li>
<li>1200：2 个有效数字（从右侧开始的两个零是无效的）</li>
</ul>
<p>基本数据类型在作为成员变量和静态变量的时候有默认值，引用数据类型也有的（学完数组&amp;字符串，以及面向对象编程后会更加清楚，这里先简单过一下）。</p>
<h4 id="04、引用数据类型"><a href="#04、引用数据类型" class="headerlink" title="04、引用数据类型"></a>04、引用数据类型</h4><p>String是最典型的引用数据类型，所以我们就拿 String 类举例，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalRef</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String a;</span><br><span class="line">    <span class="keyword">static</span> String b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalRef</span> <span class="variable">lv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalRef</span>();</span><br><span class="line">        System.out.println(lv.a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<p>null 在 Java 中是一个很神奇的存在，在你以后的程序生涯中，见它的次数不会少，尤其是伴随着令人烦恼的“空指针异常”，也就是所谓的 <code>NullPointerException</code>。</p>
<p>也就是说，引用数据类型的默认值为 null，包括数组和接口。</p>
<p>那你是不是很好奇，为什么数组和接口也是引用数据类型啊？</p>
<p>先来看数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> [] arrays = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(arrays);</span><br></pre></td></tr></table></figure>

<p>arrays 是一个 int 类型的数组，对吧？打印结果如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[I@2d209079</span><br></pre></td></tr></table></figure>

<p><code>[I</code> 表示数组是 int 类型的，@ 后面是十六进制的 hashCode——这样的打印结果太“人性化”了，一般人表示看不懂！为什么会这样显示呢？查看一下 <code>java.lang.Object</code> 类的 <code>toString()</code> 方法就明白了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400371.png" alt="img"></p>
<p>数组虽然没有显式定义成一个类，但它的确是一个对象，继承了祖先类 Object 的所有方法。那为什么数组不单独定义一个类来表示呢？就像字符串 String 类那样呢？</p>
<p>一个合理的解释是 Java 将其隐藏了。假如真的存在一个 Array.java，我们也可以假想它真实的样子，它必须要定义一个容器来存放数组的元素，就像 String 类那样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组内部定义数组？没必要的！</p>
<p>再来看接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure>

<p>List 是一个非常典型的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>而 ArrayList 是 List 接口的一个实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>对于接口类型的引用变量来说，你没法直接 new 一个：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400428.png" alt="img"></p>
<p>只能 new 一个实现它的类的对象——那自然接口也是引用数据类型了。</p>
<p>来看一下基本数据类型和引用数据类型之间最大的差别。</p>
<p>基本数据类型：</p>
<ul>
<li>1、变量名指向具体的数值。</li>
<li>2、基本数据类型存储在栈上。</li>
</ul>
<p>引用数据类型：</p>
<ul>
<li>1、变量名指向的是存储对象的内存地址，在栈上。</li>
<li>2、内存地址指向的对象存储在堆上。</li>
</ul>
<p>上面说了栈和队，那么什么是栈和堆呢，下面来进行一个讲解。</p>
<h4 id="05、栈和堆"><a href="#05、栈和堆" class="headerlink" title="05、栈和堆"></a>05、栈和堆</h4><p>堆是堆（heap），栈是栈（stack），如果看到“堆栈”的话，请不要怀疑自己，那是翻译的错，堆栈也是栈，反正我很不喜欢“堆栈”这种叫法，容易让新人掉坑里。</p>
<p>堆是在程序运行时在内存中申请的空间（可理解为动态的过程）；切记，不是在编译时；因此，Java 中的对象就放在这里，这样做的好处就是：</p>
<blockquote>
<p>当需要一个对象时，只需要通过 new 关键字写一行代码即可，当执行这行代码时，会自动在内存的“堆”区分配空间——这样就很灵活。</p>
</blockquote>
<p>栈，能够和处理器（CPU，也就是脑子）直接关联，因此访问速度更快。既然访问速度快，要好好利用啊！Java 就把对象的引用放在栈里。为什么呢？因为引用的使用频率高吗？</p>
<p>不是的，因为 Java 在编译程序时，必须明确的知道存储在栈里的东西的生命周期，否则就没法释放旧的内存来开辟新的内存空间存放引用——空间就那么大，前浪要把后浪拍死在沙滩上啊。</p>
<p>这么说就理解了吧？</p>
<p>如果还不理解的话，可以看一下这个视频，讲的非常不错：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19729973/answer/2238950166">什么是堆？什么是栈？他们之间有什么区别和联系？open in new window</a></p>
<p>用图来表示一下，左侧是栈，右侧是堆。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400480.png" alt="img"></p>
<p>这里再补充一些额外的知识点，能看懂就继续吸收，看不懂可以先去学下一节，以后再来补，没关系的。学习就是这样，可以跳过，可以温故。</p>
<p>举个例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;xiaou&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这段代码会先在堆里创建一个 沉默王二的字符串对象，然后再把对象的引用 a 放到栈里面。这里面还会涉及到字符串常量池，后面会讲。</p>
<p>那么对于这样一段代码，有基本数据类型的变量，有引用类型的变量，堆和栈都是如何存储他们的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我来画个图表示下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400788.png" alt="img"></p>
<p>应该一目了然了吧？如果还不理解，以后我会再一些面试题中，更新这些的具体讲解的。</p>
<h4 id="06、数据类型之间的转换"><a href="#06、数据类型之间的转换" class="headerlink" title="06、数据类型之间的转换"></a>06、数据类型之间的转换</h4><p>数据类型转换的目的是确保在表达式求值时，不同类型的数据能够相互兼容。</p>
<h5 id="01、自动类型转换"><a href="#01、自动类型转换" class="headerlink" title="01、自动类型转换"></a>01、自动类型转换</h5><p>自动类型转换（自动类型提升）是 Java 编译器在不需要显式转换的情况下，将一种基本数据类型自动转换为另一种基本数据类型的过程。这种转换通常发生在表达式求值期间，当不同类型的数据需要相互兼容时。自动类型转换遵循以下规则：</p>
<ul>
<li>如果任何操作数是 double 类型，其他操作数将被转换为 double 类型。</li>
<li>否则，如果任何操作数是 float 类型，其他操作数将被转换为 float 类型。</li>
<li>否则，如果任何操作数是 long 类型，其他操作数将被转换为 long 类型。</li>
<li>否则，所有操作数将被转换为 int 类型。</li>
</ul>
<p>需要注意的是，自动类型转换只发生在兼容类型之间。例如，从较小的数据类型（如 int）到较大的数据类型（如 long 或 double）的转换是安全的，因为较大的数据类型可以容纳较小数据类型的所有可能值。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double</span><br><span class="line">char -&gt; int -&gt; long -&gt; float -&gt; double</span><br></pre></td></tr></table></figure>

<p>下面是一个简单的示例，演示了自动类型转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">doubleValue</span> <span class="operator">=</span> <span class="number">2.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动类型转换：intValue 被转换为 double 类型</span></span><br><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> intValue * doubleValue;</span><br><span class="line">System.out.println(<span class="string">&quot;结果: &quot;</span> + result); <span class="comment">// 输出：结果: 12.5</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们有一个 int 类型的变量 intValue 和一个 double 类型的变量 doubleValue。当我们将它们相乘时，根据自动类型转换的规则，intValue 将被转换为 double 类型，以便将两个 double 类型的操作数相乘。最终结果将是一个 double 类型的值：12.5。</p>
<p>再来举个例子，顾客到超市购物，购买牙膏 2 盒，面巾纸 4 盒。其中牙膏的价格是 10.9 元，面巾纸的价格是 5.8 元，求商品总价格。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">price1</span> <span class="operator">=</span> <span class="number">10.9f</span>; <span class="comment">// 定义牙膏的价格，单精度浮点型float</span></span><br><span class="line"><span class="type">double</span> <span class="variable">price2</span> <span class="operator">=</span> <span class="number">5.8</span>; <span class="comment">// 定义面巾纸的价格，双精度浮点型double</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// 定义牙膏的数量，整型 int</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">4</span>; <span class="comment">// 定义面巾纸的数量</span></span><br><span class="line"><span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> price1 * num1 + price2 * num2; <span class="comment">// 计算总价</span></span><br><span class="line">System.out.println(<span class="string">&quot;一共付给收银员&quot;</span> + res + <span class="string">&quot;元&quot;</span>); <span class="comment">// 输出总价</span></span><br></pre></td></tr></table></figure>

<p>上述代码中首先定义了一个 float 类型的变量存储牙膏的价格，然后定义了一个 double 类型的变量存储面巾纸的价格，再定义两个 int 类型的变量存储物品的数量，最后进行了乘运算以及和运算之后，将结果储存在一个 double 类型的变量中进行输出。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一共付给收银员44.99999923706055元</span><br></pre></td></tr></table></figure>

<p>从执行结果看出，float、int 和 double 三种数据类型参与运算，最后输出的结果为 double 类型的数据。这种转换一般称为“表达式中类型的自动提升”。</p>
<p>自动类型提升有好处，但它也会引起令人疑惑的编译错误。例如，下面看起来正确的程序却会引起问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">b = b * <span class="number">2</span>; <span class="comment">// Type mismatch: cannot convert from int to byte</span></span><br></pre></td></tr></table></figure>

<p>如上所示，第二行会报“类型不匹配：无法从int转换为byte”错误。</p>
<p>该程序试图将一个完全合法的 byte 型的值 50*2 存储给一个 byte 型的变量。但是当表达式求值的时候，操作数被自动的提升为 int 型，计算结果也被提升为 int 型。这样表达式的结果现在是 int 型，不强制转换它就不能被赋为 byte 型。</p>
<p>所以应该使用一个显示的强制类型转换，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">b = (<span class="type">byte</span>)(b*<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>这样就能产生正确的值 100。</p>
<p>注意：char 类型比较特殊，char 自动转换成 int、long、float 和 double，但 byte 和 short 不能自动转换为 char，而且 char 也不能自动转换为 byte 或 short。</p>
<h5 id="02、强制类型转换"><a href="#02、强制类型转换" class="headerlink" title="02、强制类型转换"></a>02、强制类型转换</h5><p>强制类型转换是 Java 中将一种数据类型显式转换为另一种数据类型的过程。与自动类型转换不同，强制类型转换需要程序员显式地指定要执行的转换。强制类型转换在以下情况中可能需要：</p>
<ul>
<li>将较大的数据类型转换为较小的数据类型。</li>
<li>将浮点数转换为整数。</li>
<li>将字符类型转换为数值类型。</li>
</ul>
<p>需要注意的是，强制类型转换可能会导致数据丢失或精度降低，因为目标类型可能无法容纳原始类型的所有可能值。因此，在进行强制类型转换时，需要确保转换后的值仍然在目标类型的范围内。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double -&gt; float -&gt; long -&gt; int -&gt; char -&gt; short -&gt; byte</span><br></pre></td></tr></table></figure>

<p>以下是一个简单的示例，演示了强制类型转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">doubleValue</span> <span class="operator">=</span> <span class="number">42.8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制类型转换：将 double 类型转换为 int 类型</span></span><br><span class="line"><span class="type">int</span> <span class="variable">intValue</span> <span class="operator">=</span> (<span class="type">int</span>) doubleValue;</span><br><span class="line">System.out.println(<span class="string">&quot;整数值: &quot;</span> + intValue); <span class="comment">// 输出：整数值: 42</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们有一个 double 类型的变量 doubleValue。我们希望将其转换为 int 类型的变量 intValue。为此，我们使用强制类型转换语法，即在要转换的变量之前加上目标类型的括号（如 (int)）。</p>
<p>需要注意的是，将 doubleValue 转换为 int 类型时，小数部分将被截断。因此，输出结果将是：Integer value: 42。在这种情况下，精度丢失是可以接受的，但在其他情况下，我们可能需要更加小心地处理类型转换以避免数据丢失。</p>
<p>顾客到超市购物，购买牙膏 2 盒，面巾纸 4 盒。其中牙膏的价格是 10.9 元，面巾纸的价格是 5.8 元，求商品总价格，在计算总价时采用 int 类型的数据进行存储。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">price1</span> <span class="operator">=</span> <span class="number">10.9f</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">price2</span> <span class="operator">=</span> <span class="number">5.8</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">res2</span> <span class="operator">=</span> (<span class="type">int</span>) (price1 * num1 + price2 * num2);</span><br><span class="line">System.out.println(<span class="string">&quot;一共付给收银员&quot;</span> + res2 + <span class="string">&quot;元&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在上述实例中，有 double 类型、float 类型和 int 类型的数据参与运算，其运算结果默认为 double 类型，题目要求的结果为 int 类型，因为 int 类型的取值范围要小于 double 类型的取值范围，所以需要进行强制类型转换。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一共付给收银员44元</span><br></pre></td></tr></table></figure>

<p>这个在我们的实际开发中是非常常用的一个存在。当然在idea中，是可以实现快速的转换的，这里就不做过多的介绍了。</p>
<h4 id="07、缓存池"><a href="#07、缓存池" class="headerlink" title="07、缓存池"></a>07、缓存池</h4><p>这个能帮助你更好的理解数据类型，属于是面试的范围了</p>
<p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">k</span> <span class="operator">=</span> Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">127</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">integerCacheHighPropValue</span> <span class="operator">=</span></span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line"></span><br><span class="line">    cache = <span class="keyword">new</span> <span class="title class_">Integer</span>[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> <span class="title class_">Integer</span>(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p>
<h3 id="java运算符"><a href="#java运算符" class="headerlink" title="java运算符"></a>java运算符</h3><p>计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组：</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>位运算符</li>
<li>逻辑运算符</li>
<li>赋值运算符</li>
<li>其他运算符</li>
</ul>
<p>下面我们要学习的，大概就是下图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400836.png" alt="img"></p>
<h4 id="01、算术运算符"><a href="#01、算术运算符" class="headerlink" title="01、算术运算符"></a>01、算术运算符</h4><p>算术运算符除了最常见的加减乘除，还有一个取余的运算符，用于得到除法运算后的余数，来串代码感受下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(a + b);<span class="comment">//15</span></span><br><span class="line">System.out.println(a - b);<span class="comment">//5</span></span><br><span class="line">System.out.println(a * b);<span class="comment">//50</span></span><br><span class="line">System.out.println(a / b);<span class="comment">//2</span></span><br><span class="line">System.out.println(a % b);<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">3</span>;</span><br><span class="line">System.out.println(a + b);<span class="comment">//13</span></span><br><span class="line">System.out.println(a - b);<span class="comment">//7</span></span><br><span class="line">System.out.println(a * b);<span class="comment">//30</span></span><br><span class="line">System.out.println(a / b);<span class="comment">//3</span></span><br><span class="line">System.out.println(a % b);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>对于初学者来说，加法（+）、减法（-）、乘法（*）很好理解，但除法（&#x2F;）和取余（%）会有一点点疑惑。在以往的认知里，10&#x2F;3 是除不尽的，结果应该是 3.333333…，而不应该是 3。相应的，余数也不应该是 1。这是为什么呢？</p>
<p>因为数字在程序中可以分为两种，一种是整型，一种是浮点型，整型和整型的运算结果就是整型，不会出现浮点型。否则，就会出现浮点型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3.0f</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">3.0</span>;</span><br><span class="line">System.out.println(a / c); <span class="comment">// 3.3333333</span></span><br><span class="line">System.out.println(a / d); <span class="comment">// 3.3333333333333335</span></span><br><span class="line">System.out.println(a % c); <span class="comment">// 1.0</span></span><br><span class="line">System.out.println(a % d); <span class="comment">// 1.0</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，当浮点数除以 0 的时候，结果为 Infinity 或者 NaN。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">10.0</span> / <span class="number">0.0</span>); <span class="comment">// Infinity</span></span><br><span class="line">System.out.println(<span class="number">0.0</span> / <span class="number">0.0</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>Infinity 的中文意思是无穷大，NaN 的中文意思是这不是一个数字（Not a Number）。</p>
<p>当整数除以 0 的时候（<code>10 / 0</code>），会抛出异常：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">	at com.itwanger.eleven.ArithmeticOperator.main(ArithmeticOperator.java:32)</span><br></pre></td></tr></table></figure>

<p>所以整数在进行除法运算时，需要先判断除数是否为 0，以免程序抛出异常。</p>
<p>算术运算符中还有两种特殊的运算符，自增运算符（++）和自减运算符（–），它们也叫做一元运算符，只有一个操作数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(x++);<span class="comment">//10 (11)  </span></span><br><span class="line">System.out.println(++x);<span class="comment">//12  </span></span><br><span class="line">System.out.println(x--);<span class="comment">//12 (11)  </span></span><br><span class="line">System.out.println(--x);<span class="comment">//10  </span></span><br></pre></td></tr></table></figure>

<p>一元运算符可以放在数字的前面或者后面，放在前面叫前自增（前自减），放在后面叫后自增（后自减）。</p>
<p>前自增和后自增是有区别的，拿 <code>int y = ++x</code> 这个表达式来说（x &#x3D; 10），它可以拆分为 <code>x = x+1 = 11; y = x = 11</code>，所以表达式的结果为 <code>x = 11, y = 11</code>。拿 <code>int y = x++</code> 这个表达式来说（x &#x3D; 10），它可以拆分为 <code>y = x = 10; x = x+1 = 11</code>，所以表达式的结果为 <code>x = 11, y = 10</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> ++x;</span><br><span class="line">System.out.println(y + <span class="string">&quot; &quot;</span> + x);<span class="comment">// 11 11</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">10</span>;</span><br><span class="line">y = x++;</span><br><span class="line">System.out.println(y + <span class="string">&quot; &quot;</span> + x);<span class="comment">// 10 11</span></span><br></pre></td></tr></table></figure>

<p>对于前自减和后自减来说，你可以自己试一把。</p>
<h4 id="02、关系运算符"><a href="#02、关系运算符" class="headerlink" title="02、关系运算符"></a>02、关系运算符</h4><p>关系运算符用来比较两个操作数，返回结果为 true 或者 false。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400885.png" alt="img"></p>
<p>来看示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line">System.out.println(a != b); <span class="comment">// true</span></span><br><span class="line">System.out.println(a &gt; b); <span class="comment">// false</span></span><br><span class="line">System.out.println(a &lt; b); <span class="comment">// true</span></span><br><span class="line">System.out.println(a &gt;= b); <span class="comment">// false</span></span><br><span class="line">System.out.println(a &lt;= b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="03、位运算符"><a href="#03、位运算符" class="headerlink" title="03、位运算符"></a>03、位运算符</h4><p>在学习位运算符之前，需要先学习一下二进制，因为位运算符操作的不是整型数值（int、long、short、char、byte）本身，而是整型数值对应的二进制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.toBinaryString(<span class="number">60</span>)); <span class="comment">// 111100</span></span><br><span class="line">System.out.println(Integer.toBinaryString(<span class="number">13</span>)); <span class="comment">// 1101</span></span><br></pre></td></tr></table></figure>

<p>从程序的输出结果可以看得出来，60 的二进制是 0011 1100（用 0 补到 8 位），13 的二进制是 0000 1101。</p>
<p>PS：现代的二进制记数系统由戈特弗里德·威廉·莱布尼茨于 1679 年设计。莱布尼茨是德意志哲学家、数学家，历史上少见的通才。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400962.png" alt="img"></p>
<p>来看示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">60</span>, b = <span class="number">13</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;a 的二进制：&quot;</span> + Integer.toBinaryString(a)); <span class="comment">// 111100</span></span><br><span class="line">System.out.println(<span class="string">&quot;b 的二进制：&quot;</span> + Integer.toBinaryString(b)); <span class="comment">// 1101</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a &amp; b;</span><br><span class="line">System.out.println(<span class="string">&quot;a &amp; b：&quot;</span> + c + <span class="string">&quot;，二进制是：&quot;</span> + Integer.toBinaryString(c));</span><br><span class="line"></span><br><span class="line">c = a | b;</span><br><span class="line">System.out.println(<span class="string">&quot;a | b：&quot;</span> + c + <span class="string">&quot;，二进制是：&quot;</span> + Integer.toBinaryString(c));</span><br><span class="line"></span><br><span class="line">c = a ^ b;</span><br><span class="line">System.out.println(<span class="string">&quot;a ^ b：&quot;</span> + c + <span class="string">&quot;，二进制是：&quot;</span> + Integer.toBinaryString(c));</span><br><span class="line"></span><br><span class="line">c = ~a;</span><br><span class="line">System.out.println(<span class="string">&quot;~a：&quot;</span> + c + <span class="string">&quot;，二进制是：&quot;</span> + Integer.toBinaryString(c));</span><br><span class="line"></span><br><span class="line">c = a &lt;&lt; <span class="number">2</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;a &lt;&lt; 2：&quot;</span> + c + <span class="string">&quot;，二进制是：&quot;</span> + Integer.toBinaryString(c));</span><br><span class="line"></span><br><span class="line">c = a &gt;&gt; <span class="number">2</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;a &gt;&gt; 2：&quot;</span> + c + <span class="string">&quot;，二进制是：&quot;</span> + Integer.toBinaryString(c));</span><br><span class="line"></span><br><span class="line">c = a &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;a &gt;&gt;&gt; 2：&quot;</span> + c + <span class="string">&quot;，二进制是：&quot;</span> + Integer.toBinaryString(c));</span><br></pre></td></tr></table></figure>

<p>对于初学者来说，位运算符无法从直观上去计算出结果，不像加减乘除那样。因为我们日常接触的都是十进制，位运算的时候需要先转成二进制，然后再计算出结果。</p>
<p>鉴于此，初学者在写代码的时候其实很少会用到位运算。对于编程高手来说，为了提高程序的性能，会在一些地方使用位运算。比如说，HashMap 在计算哈希值的时候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果对位运算一点都不懂的话，遇到这样的源码就很吃力。所以说，虽然位运算用的少，但还是要懂。</p>
<p>1）按位左移运算符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">10</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//10*2^2=10*4=40  </span></span><br><span class="line">System.out.println(<span class="number">10</span>&lt;&lt;<span class="number">3</span>);<span class="comment">//10*2^3=10*8=80  </span></span><br><span class="line">System.out.println(<span class="number">20</span>&lt;&lt;<span class="number">2</span>);<span class="comment">//20*2^2=20*4=80  </span></span><br><span class="line">System.out.println(<span class="number">15</span>&lt;&lt;<span class="number">4</span>);<span class="comment">//15*2^4=15*16=240 </span></span><br></pre></td></tr></table></figure>

<p><code>10&lt;&lt;2</code> 等于 10 乘以 2 的 2 次方；<code>10&lt;&lt;3</code> 等于 10 乘以 2 的 3 次方。</p>
<p>2）按位右移运算符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">10</span>&gt;&gt;<span class="number">2</span>);<span class="comment">//10/2^2=10/4=2</span></span><br><span class="line">System.out.println(<span class="number">20</span>&gt;&gt;<span class="number">2</span>);<span class="comment">//20/2^2=20/4=5</span></span><br><span class="line">System.out.println(<span class="number">20</span>&gt;&gt;<span class="number">3</span>);<span class="comment">//20/2^3=20/8=2</span></span><br></pre></td></tr></table></figure>

<p><code>10&gt;&gt;2</code> 等于 10 除以 2 的 2 次方；<code>20&gt;&gt;2</code> 等于 20 除以 2 的 2 次方。</p>
<h4 id="04、逻辑运算符"><a href="#04、逻辑运算符" class="headerlink" title="04、逻辑运算符"></a>04、逻辑运算符</h4><p>逻辑与运算符（&amp;&amp;）：多个条件中只要有一个为 false 结果就为 false。</p>
<p>逻辑或运算符（||）：多个条件只要有一个为 true 结果就为 true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> c=<span class="number">20</span>;</span><br><span class="line">System.out.println(a&lt;b&amp;&amp;a&lt;c);<span class="comment">//false &amp;&amp; true = false</span></span><br><span class="line"></span><br><span class="line">System.out.println(a&gt;b||a&lt;c);<span class="comment">//true || true = true</span></span><br></pre></td></tr></table></figure>

<p>逻辑非运算符（!）：用来反转条件的结果，如果条件为 true，则逻辑非运算符将得到 false。</p>
<p>单逻辑与运算符（&amp;）：很少用，因为不管第一个条件为 true 还是 false，依然会检查第二个。</p>
<p>单逻辑或运算符（|）：也会检查第二个条件。</p>
<p>也就是说，&amp; 和 | 性能不如 &amp;&amp; 和 ||，但用法一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> c=<span class="number">20</span>;</span><br><span class="line">System.out.println(a&lt;b&amp;a&lt;c);<span class="comment">//false &amp; true = false</span></span><br><span class="line"></span><br><span class="line">System.out.println(a&gt;b|a&lt;c);<span class="comment">//true | true = true  </span></span><br></pre></td></tr></table></figure>

<h4 id="05、赋值运算符"><a href="#05、赋值运算符" class="headerlink" title="05、赋值运算符"></a>05、赋值运算符</h4><p>赋值操作符恐怕是 Java 中使用最频繁的操作符了，它就是把操作符右侧的值赋值给左侧的变量。来看示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">20</span>;</span><br><span class="line">a+=<span class="number">4</span>;<span class="comment">//a=a+4 (a=10+4)  </span></span><br><span class="line">b-=<span class="number">4</span>;<span class="comment">//b=b-4 (b=20-4)  </span></span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>

<p>不过在进行数值的赋值时，需要小点心，比如说下面这种情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400234.png" alt="img"></p>
<p>编译器之所以提示错误，是因为 &#x3D; 右侧的算术表达式默认为 int 类型，左侧是 short 类型的时候需要进行强转。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//a+=b;//a=a+b internally so fine</span></span><br><span class="line">a = (<span class="type">short</span>)(a + b);</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>

<p>除此之外，还会有边界问题，比如说，两个非常大的 int 相乘，结果可能就超出了 int 的范围：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a * b;</span><br><span class="line">System.out.println(c); <span class="comment">// -10000</span></span><br></pre></td></tr></table></figure>

<p>程序输出的结果为 -10000，这个答案很明显不是我们想要的结果，虽然可以通过右侧表达式强转 long 的方法解决：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">long</span>)a * b;</span><br><span class="line">System.out.println(c); <span class="comment">// 21474836470000</span></span><br></pre></td></tr></table></figure>

<p>但尽量不要这样做，结果非常大的时候，尽量提前使用相应的类型进行赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> a * b;</span><br><span class="line">System.out.println(c); <span class="comment">// 21474836460000</span></span><br></pre></td></tr></table></figure>

<h4 id="06、三元运算符"><a href="#06、三元运算符" class="headerlink" title="06、三元运算符"></a>06、三元运算符</h4><p>三元运算符用于替代 if-else，可以使用一行代码完成条件判断的要求。来看示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> b=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> min=(a&lt;b)?a:b;</span><br><span class="line">System.out.println(min);</span><br></pre></td></tr></table></figure>

<p>如果 ? 前面的条件为 true，则结果为 : 前的值，否则为 : 后的值。</p>
<p>我们来看一个相关的案例</p>
<p><strong>一座寺庙住着三个和尚，已知他们身高，求这三个和尚的最高值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 三元运算符练习<span class="number">2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> height1=<span class="number">150</span>;</span><br><span class="line">        <span class="type">int</span> height2=<span class="number">210</span>;</span><br><span class="line">        <span class="type">int</span> height3=<span class="number">165</span>;</span><br><span class="line">        <span class="type">int</span> temp=height1&gt;height2?height1:height2;</span><br><span class="line">        <span class="type">int</span> max=temp&gt;height3?temp:height3;</span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就是先1和2比，之后较大的和3比。</p>
<p>附上一个运算优先级。基本记住()优先于所有就可以了。</p>
<p>学了这么多的运算符，下面来看运算符的一个优先级。</p>
<h4 id="07、运算符优先级"><a href="#07、运算符优先级" class="headerlink" title="07、运算符优先级"></a>07、运算符优先级</h4><p>当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果差别甚大。</p>
<p>例如，（1+3）＋（3+2）*2，这个表达式如果按加号最优先计算，答案就是 18，如果按照乘号最优先，答案则是 14。</p>
<p>再如，x &#x3D; 7 + 3 * 2;这里x得到13，而不是20，因为乘法运算符比加法运算符有较高的优先级，所以先计算3 * 2得到6，然后再加7。</p>
<p>下表中具有最高优先级的运算符在的表的最上面，最低优先级的在表的底部。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">操作符</th>
<th align="left">关联性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">后缀</td>
<td align="left">() [] . (点操作符)</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">一元</td>
<td align="left">expr++ expr–</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">一元</td>
<td align="left">++expr –expr + - ～ ！</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">乘性</td>
<td align="left">* &#x2F;％</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">加性</td>
<td align="left">+ -</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">移位</td>
<td align="left">&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">关系</td>
<td align="left">&gt; &gt;&#x3D; &lt; &lt;&#x3D;</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">相等</td>
<td align="left">&#x3D;&#x3D; !&#x3D;</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">按位与</td>
<td align="left">＆</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">按位异或</td>
<td align="left">^</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">按位或</td>
<td align="left">|</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">逻辑与</td>
<td align="left">&amp;&amp;</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">逻辑或</td>
<td align="left">| |</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">条件</td>
<td align="left">？：</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">赋值</td>
<td align="left">&#x3D; + &#x3D; - &#x3D; * &#x3D; &#x2F; &#x3D;％&#x3D; &gt;&gt; &#x3D; &lt;&lt; &#x3D;＆&#x3D; ^ &#x3D; | &#x3D;</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">逗号</td>
<td align="left">，</td>
<td align="left">左到右</td>
</tr>
</tbody></table>
<h3 id="java流程控制语句"><a href="#java流程控制语句" class="headerlink" title="java流程控制语句"></a>java流程控制语句</h3><p>流程控制语句是我们写代码中，非常重要的知识，我们的程序就是由这些结构而成的。</p>
<p>“比如说 if-else、switch、for、while、do-while、return、break、continue 等等，接下来，我们一个个来了解下。</p>
<h4 id="01、if-else-相关"><a href="#01、if-else-相关" class="headerlink" title="01、if-else 相关"></a>01、if-else 相关</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400466.png" alt="img"></p>
<h5 id="1）if-语句"><a href="#1）if-语句" class="headerlink" title="1）if 语句"></a><strong>1）if 语句</strong></h5><p>if 语句的格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;  </span><br><span class="line"><span class="comment">// 如果条件为 true，则执行这块代码</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>画个流程图表示一下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400520.png" alt="img"></p>
<p>来写个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">30</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">青春年华</span><br></pre></td></tr></table></figure>

<h5 id="2）if-else-语句"><a href="#2）if-else-语句" class="headerlink" title="2）if-else 语句"></a><strong>2）if-else 语句</strong></h5><p>if-else 语句的格式如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;  </span><br><span class="line"><span class="comment">// 条件为 true 时执行的代码块</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;  </span><br><span class="line"><span class="comment">// 条件为 false  时执行的代码块</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>画个流程图表示一下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400789.png" alt="img"></p>
<p>来写个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">30</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;青春年华&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;而立之年&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而立之年</span><br></pre></td></tr></table></figure>

<p>除了这个例子之外，还有一个判断闰年（被 4 整除但不能被 100 整除或者被 400 整除）的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> <span class="number">2020</span>;</span><br><span class="line"><span class="keyword">if</span> (((year % <span class="number">4</span> == <span class="number">0</span>) &amp;&amp; (year % <span class="number">100</span> != <span class="number">0</span>)) || (year % <span class="number">400</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;闰年&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;普通年份&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">闰年</span><br></pre></td></tr></table></figure>

<p>如果执行语句比较简单的话，可以使用三元运算符来代替 if-else 语句，如果条件为 true，返回 ? 后面 : 前面的值；如果条件为 false，返回 : 后面的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> (num % <span class="number">2</span> == <span class="number">0</span>) ? <span class="string">&quot;偶数&quot;</span> : <span class="string">&quot;奇数&quot;</span>;</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">奇数</span><br></pre></td></tr></table></figure>

<h5 id="3）if-else-if-语句"><a href="#3）if-else-if-语句" class="headerlink" title="3）if-else-if 语句"></a><strong>3）if-else-if 语句</strong></h5><p>if-else-if 语句的格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件<span class="number">1</span>)&#123;  </span><br><span class="line"><span class="comment">// 条件1 为 true 时执行的代码</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件<span class="number">2</span>)&#123;  </span><br><span class="line"><span class="comment">// 条件2 为 true 时执行的代码</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(条件<span class="number">3</span>)&#123;  </span><br><span class="line"><span class="comment">// 条件3 为 true 时执行的代码</span></span><br><span class="line">&#125;  </span><br><span class="line">...  </span><br><span class="line"><span class="keyword">else</span>&#123;  </span><br><span class="line"><span class="comment">// 以上条件均为 false 时执行的代码</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>画个流程图表示一下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400852.png" alt="img"></p>
<p>来写个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">30</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;青春年华&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">30</span> &amp;&amp; age &lt; <span class="number">40</span> ) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;而立之年&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">40</span> &amp;&amp; age &lt; <span class="number">50</span> ) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;不惑之年&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;知天命&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">而立之年</span><br></pre></td></tr></table></figure>

<h5 id="4）if-嵌套语句"><a href="#4）if-嵌套语句" class="headerlink" title="4）if 嵌套语句"></a><strong>4）if 嵌套语句</strong></h5><p>if 嵌套语句的格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(外侧条件)&#123;    </span><br><span class="line">     <span class="comment">// 外侧条件为 true 时执行的代码 </span></span><br><span class="line">    <span class="keyword">if</span>(内侧条件)&#123;  </span><br><span class="line">        <span class="comment">// 内侧条件为 true 时执行的代码</span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>画个流程图表示一下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400908.png" alt="img"></p>
<p>来写个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isGirl</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (age &gt;= <span class="number">20</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isGirl) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;女生法定结婚年龄&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">女生法定结婚年龄</span><br></pre></td></tr></table></figure>

<h4 id="02、switch-语句"><a href="#02、switch-语句" class="headerlink" title="02、switch 语句"></a>02、switch 语句</h4><p>switch 语句用来判断变量与多个值之间的相等性。变量的类型可以是 byte、short、int 或者 char，或者对应的包装器类型 Byte、Short、Integer、Character，以及字符串和枚举类型。</p>
<p>来看一下 switch 语句的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量) &#123;    </span><br><span class="line"><span class="keyword">case</span> 可选值<span class="number">1</span>:    </span><br><span class="line"> <span class="comment">// 可选值1匹配后执行的代码;    </span></span><br><span class="line"> <span class="keyword">break</span>;  <span class="comment">// 该关键字是可选项</span></span><br><span class="line"><span class="keyword">case</span> 可选值<span class="number">2</span>:    </span><br><span class="line"> <span class="comment">// 可选值2匹配后执行的代码;    </span></span><br><span class="line"> <span class="keyword">break</span>;  <span class="comment">// 该关键字是可选项</span></span><br><span class="line">......    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// 该关键字是可选项     </span></span><br><span class="line"> <span class="comment">// 所有可选值都不匹配后执行的代码 </span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<ul>
<li>变量可以有 1 个或者 N 个值。</li>
<li>值类型必须和变量类型是一致的，并且值是确定的。</li>
<li>值必须是唯一的，不能重复，否则编译会出错。</li>
<li>break 关键字是可选的，如果没有，则执行下一个 case，如果有，则跳出 switch 语句。</li>
<li>default 关键字也是可选的。</li>
</ul>
<p>画个流程图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400011.png" alt="img"></p>
<p>来个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">switch</span> (age) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">20</span> :</span><br><span class="line">        System.out.println(<span class="string">&quot;上学&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">24</span> :</span><br><span class="line">        System.out.println(<span class="string">&quot;苏州工作&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">30</span> :</span><br><span class="line">        System.out.println(<span class="string">&quot;洛阳工作&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;未知&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 可省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上学</span><br></pre></td></tr></table></figure>

<p>当两个值要执行的代码相同时，可以把要执行的代码写在下一个 case 语句中，而上一个 case 语句中什么也没有，来看一下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;沉默王二&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (name) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;詹姆斯&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;篮球运动员&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;穆里尼奥&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;足球教练&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;沉默王二&quot;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;沉默王三&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;乒乓球爱好者&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                <span class="string">&quot;名字没有匹配项&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">乒乓球爱好者</span><br></pre></td></tr></table></figure>

<p>枚举作为 switch 语句的变量也很常见，来看例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwitchEnumDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">PlayerTypes</span> &#123;</span><br><span class="line">        TENNIS,</span><br><span class="line">        FOOTBALL,</span><br><span class="line">        BASKETBALL,</span><br><span class="line">        UNKNOWN</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(createPlayer(PlayerTypes.BASKETBALL));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">createPlayer</span><span class="params">(PlayerTypes playerType)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (playerType) &#123;</span><br><span class="line">            <span class="keyword">case</span> TENNIS:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;网球运动员费德勒&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> FOOTBALL:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;足球运动员C罗&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> BASKETBALL:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;篮球运动员詹姆斯&quot;</span>;</span><br><span class="line">            <span class="keyword">case</span> UNKNOWN:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;未知&quot;</span>);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                        <span class="string">&quot;运动员类型: &quot;</span> + playerType);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">篮球运动员詹姆斯</span><br></pre></td></tr></table></figure>

<h4 id="03、for-循环"><a href="#03、for-循环" class="headerlink" title="03、for 循环"></a>03、for 循环</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400123.png" alt="img"></p>
<h5 id="1）普通-for-循环"><a href="#1）普通-for-循环" class="headerlink" title="1）普通 for 循环"></a><strong>1）普通 for 循环</strong></h5><p>普通的 for 循环可以分为 4 个部分：</p>
<p>1）初始变量：循环开始执行时的初始条件。</p>
<p>2）条件：循环每次执行时要判断的条件，如果为 true，就执行循环体；如果为 false，就跳出循环。当然了，条件是可选的，如果没有条件，则会一直循环。</p>
<p>3）循环体：循环每次要执行的代码块，直到条件变为 false。</p>
<p>4）自增&#x2F;自减：初始变量变化的方式。</p>
<p>来看一下普通 for 循环的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始变量;条件;自增/自减)&#123;  </span><br><span class="line"><span class="comment">// 循环体</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>画个流程图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400301.png" alt="img"></p>
<p>来个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;xiaou&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xiaou</span><br><span class="line">xiaou</span><br><span class="line">xiaou</span><br><span class="line">xiaou</span><br><span class="line">xiaou</span><br></pre></td></tr></table></figure>



<p>之后再来看一个有趣的打印</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;= i;j++) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;❤&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">❤</span><br><span class="line">❤❤</span><br><span class="line">❤❤❤</span><br><span class="line">❤❤❤❤</span><br><span class="line">❤❤❤❤❤</span><br></pre></td></tr></table></figure>

<h5 id="2）for-each"><a href="#2）for-each" class="headerlink" title="2）for-each"></a><strong>2）for-each</strong></h5><p>for-each 循环通常用于遍历数组和集合，它的使用规则比普通的 for 循环还要简单，不需要初始变量，不需要条件，不需要下标来自增或者自减。来看一下语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型 元素 : 数组或集合)&#123;  </span><br><span class="line"><span class="comment">// 要执行的代码</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>来看一下示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] strs = &#123;<span class="string">&quot;xiaou&quot;</span>, <span class="string">&quot;一枚有趣的程序员&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xiaou</span><br><span class="line">一枚有趣的程序员</span><br></pre></td></tr></table></figure>

<h5 id="3）无限-for-循环"><a href="#3）无限-for-循环" class="headerlink" title="3）无限 for 循环"></a><strong>3）无限 for 循环</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;停不下来。。。。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br></pre></td></tr></table></figure>

<p>一旦运行起来，就停不下来了，除非强制停止。</p>
<h4 id="04、while-循环"><a href="#04、while-循环" class="headerlink" title="04、while 循环"></a>04、while 循环</h4><p>来看一下 while 循环的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件)&#123;  </span><br><span class="line"><span class="comment">//循环体  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>画个流程图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400482.png" alt="img"></p>
<p>来个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;xiaou&quot;</span>);</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来这个会是多少次呢，其实很好猜到，就是五次</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xiaou</span><br><span class="line">xiaou</span><br><span class="line">xiaou</span><br><span class="line">xiaou</span><br><span class="line">xiaou</span><br></pre></td></tr></table></figure>

<p>接下来看while的无限死循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;停不下来。。。。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br></pre></td></tr></table></figure>

<p>把 while 的条件设置为 true，并且循环体中没有 break 关键字的话，程序一旦运行起来，就根本停不下来了，除非强制停止。</p>
<h4 id="05、do-while-循环"><a href="#05、do-while-循环" class="headerlink" title="05、do-while 循环"></a>05、do-while 循环</h4><p>来看一下 do-while 循环的格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;  </span><br><span class="line"><span class="comment">// 循环体</span></span><br><span class="line">&#125;<span class="keyword">while</span>(提交);  </span><br></pre></td></tr></table></figure>

<p>画个流程图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400547.png" alt="img"></p>
<p>来个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>



<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>同时，dowhile也是可以死循环的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;停不下来。。。。&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br><span class="line">停不下来。。。。</span><br></pre></td></tr></table></figure>

<p>把 do-while 的条件设置为 true，并且循环体中没有 break 关键字的话，程序一旦运行起来，就根本停不下来了，除非强制停止。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400635.png" alt="img"></p>
<h4 id="06、break"><a href="#06、break" class="headerlink" title="06、break"></a>06、break</h4><p>break 关键字通常用于中断循环或 switch 语句，它在指定条件下中断程序的当前流程。如果是内部循环，则仅中断内部循环。</p>
<p>可以将 break 关键字用于所有类型循环语句中，比如说 for 循环、while 循环，以及 do-while 循环。</p>
<p>来画个流程图感受一下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400683.png" alt="img"></p>
<p>用在 for 循环中的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用在嵌套 for 循环中的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span> &amp;&amp; j == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i + <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用在 while 循环中的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用在 do-while 循环中的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">5</span>) &#123; </span><br><span class="line">        j++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(j);</span><br><span class="line">    j++;</span><br><span class="line">&#125; <span class="keyword">while</span> (j &lt;= <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>用在 switch 语句中的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (age) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">20</span> :</span><br><span class="line">        System.out.println(<span class="string">&quot;上学&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">24</span> :</span><br><span class="line">        System.out.println(<span class="string">&quot;苏州工作&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">30</span> :</span><br><span class="line">        System.out.println(<span class="string">&quot;洛阳工作&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;未知&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 可省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="07、continue"><a href="#07、continue" class="headerlink" title="07、continue"></a>07、continue</h4><p>当我们需要在 for 循环或者 （do）while 循环中立即跳转到下一个循环时，就可以使用 continue 关键字，通常用于跳过指定条件下的循环体，如果循环是嵌套的，仅跳过当前循环。</p>
<p>来个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 continue 关键字</span></span><br><span class="line">        <span class="keyword">continue</span>;<span class="comment">// 5 将会被跳过</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>



<p>再来个循环嵌套的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">2</span> &amp;&amp; j == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//  当i=2，j=2时跳过</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(i + <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印出什么玩意呢？</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">3 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure>

<p>“2 2” 没有输出，被跳过了。</p>
<p>再来看一下 while 循环时 continue 的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>注意：如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。</p>
<p>最后，再来看一下 do-while 循环时 continue 的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;<span class="keyword">while</span>(i&lt;=<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>注意：同样的，如果把 if 条件中的“i++”省略掉的话，程序就会进入死循环，一直在 continue。</p>
<h4 id="08、switch-case-语句"><a href="#08、switch-case-语句" class="headerlink" title="08、switch case 语句"></a>08、switch case 语句</h4><p>switch case 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">case</span> value :</span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">//可选</span></span><br><span class="line">    <span class="comment">//你可以有任意数量的case语句</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">//可选</span></span><br><span class="line">       <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>switch case 语句有如下规则：</p>
<ul>
<li>switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。</li>
<li>switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。</li>
<li>case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。</li>
<li>当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。</li>
<li>当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。</li>
<li>switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。</li>
</ul>
<p>一个简单的案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="comment">//char grade = args[0].charAt(0);</span></span><br><span class="line">      <span class="type">char</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">switch</span>(grade)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;优秀&quot;</span>); </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span> :</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;F&#x27;</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;你需要再努力努力&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span> :</span><br><span class="line">            System.out.println(<span class="string">&quot;未知等级&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(<span class="string">&quot;你的等级是 &quot;</span> + grade);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>在结束了上面的学习之后，我们已经初步的掌握了一些写程序的能力，下面的几个程序，来帮助大家更好的理解。</p>
<h4 id="1-回文数：正序和倒序一样的整数"><a href="#1-回文数：正序和倒序一样的整数" class="headerlink" title="1.*回文数：正序和倒序一样的整数"></a>1.*回文数：正序和倒序一样的整数</h4><ul>
<li>例如121</li>
<li>12321</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 力扣算法真题回文数 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">121</span>;</span><br><span class="line">        <span class="type">int</span> temp=x;<span class="comment">//定义临时的值</span></span><br><span class="line">        <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//利用循环，从右往左获取每一次数字</span></span><br><span class="line">        <span class="keyword">while</span> (x!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//从右往左获得数字</span></span><br><span class="line">            <span class="type">int</span> ge=x%<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//更新数据</span></span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//num存储</span></span><br><span class="line">            num=num*<span class="number">10</span>+ge;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(num==temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们来解析一下这段程序。</p>
<ol>
<li>首先定义一个类名为“力扣算法真题回文数”的公共类。</li>
<li>在main()方法中，定义一个整型变量x并且初始化为121，表示需要判断的整数。</li>
<li>定义一个临时变量temp并且将x赋值给它，用于后面判断回文数时的比较。</li>
<li>定义一个整型变量num并且初始化为0，用于存储从右往左获取的每一位数字。</li>
<li>利用while循环从右往左获取x的每一位数字，具体实现如下：</li>
</ol>
<ul>
<li>通过取模运算获取x的个位数字ge。</li>
<li>将x除以10，更新x的值。</li>
<li>将num乘以10加上ge，将获取的数字存储到num中。</li>
</ul>
<ol>
<li>循环结束后，num中存储的就是x从右往左的倒序数字。</li>
<li>最后，通过System.out.println()方法输出num的值，然后通过判断num是否等于temp来判断x是否为回文数。如果相等，则输出true，否则输出false。</li>
</ol>
<p>总之，这段代码的实现思路是将整数从右往左获取每一位数字，然后将获取的数字存储到另一个变量中，最后判断这两个变量是否相等，从而判断整数是否为回文数。</p>
<h4 id="2-给定两个整数，被除数和除数，将两个数相除，要求不能使用除法。乘法和取余"><a href="#2-给定两个整数，被除数和除数，将两个数相除，要求不能使用除法。乘法和取余" class="headerlink" title="2.给定两个整数，被除数和除数，将两个数相除，要求不能使用除法。乘法和取余"></a>2.给定两个整数，被除数和除数，将两个数相除，要求不能使用除法。乘法和取余</h4><ul>
<li>最后要得到商和余数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 力扣算法真题求商和余数 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//记录被除数</span></span><br><span class="line">        <span class="type">int</span> dividend=<span class="number">100</span>;</span><br><span class="line">        <span class="comment">//定义count</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定义除数</span></span><br><span class="line">        <span class="type">int</span> divisor=<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (dividend&gt;=divisor)&#123;</span><br><span class="line">            dividend=dividend-divisor;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;余数为&quot;</span>+dividend);</span><br><span class="line">        System.out.println(<span class="string">&quot;商为&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这一个就不做解析了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>至此，我们的java基础语法就已经学完了，学习完这一个章节，就算是对java的一个基础入门了。</p>
<h2 id="数组-字符串"><a href="#数组-字符串" class="headerlink" title="数组 &amp; 字符串"></a>数组 &amp; 字符串</h2><h3 id="java数组"><a href="#java数组" class="headerlink" title="java数组"></a>java数组</h3><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><p>我们在Java程序基础里介绍了数组这种数据类型。有了数组，我们还需要来操作它。</p>
<p>数组是一个对象，它包含了一组固定数量的元素，并且这些元素的类型是相同的。数组会按照索引的方式将元素放在指定的位置上，意味着我们可以通过索引来访问这些元素。在 Java 中，索引是从 0 开始的。</p>
<p>我们可以将数组理解为一个个整齐排列的单元格，每个单元格里面存放着一个元素。</p>
<p>数组元素的类型可以是基本数据类型（比如说 int、double），也可以是引用数据类型（比如说 String），包括自定义类型。</p>
<p>数组的声明方式分两种。</p>
<p>先来看第一种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] anArray;</span><br></pre></td></tr></table></figure>

<p>再来看第二种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> anOtherArray[];</span><br></pre></td></tr></table></figure>

<p>不同之处就在于中括号的位置，是跟在类型关键字的后面，还是跟在变量的名称的后面。前一种的使用频率更高一些，像 ArrayList 的源码中就用了第一种方式。</p>
<p>同样的，数组的初始化方式也有多种，最常见的是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] anArray = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>上面这行代码中使用了 new 关键字，这就意味着数组的确是一个对象，只有对象的创建才会用到 new 关键字，基本数据类型是不用的。然后，我们需要在方括号中指定数组的长度。</p>
<p>这时候，数组中的每个元素都会被初始化为默认值，int 类型的就为 0，Object 类型的就为 null。 不同数据类型的默认值不同。</p>
<p>另外，还可以使用大括号的方式，直接初始化数组中的元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> anOtherArray[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>



<p>这时候，数组的元素分别是 1、2、3、4、5，索引依次是 0、1、2、3、4，长度是 5。</p>
<p>下面我们来说如何去访问数组</p>
<p>前面提到过，可以通过索引来访问数组的元素，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anArray[<span class="number">0</span>] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>变量名，加上中括号，加上元素的索引，就可以访问到数组，通过“&#x3D;”操作符可以对元素进行赋值。</p>
<p>如果索引的值超出了数组的界限，就会抛出 <code>ArrayIndexOutOfBoundException</code>。</p>
<p>既然数组的索引是从 0 开始，那就是到数组的 <code>length - 1</code> 结束，不要使用超出这个范围内的索引访问数组，就不会抛出数组越界的异常了。</p>
<p>当数组的元素非常多的时候，逐个访问数组就太辛苦了，所以需要通过遍历的方式。</p>
<p>通过<code>for</code>循环就可以遍历数组。因为数组的每个元素都可以通过索引来访问，因此，使用标准的<code>for</code>循环可以完成一个数组的遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ns.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ns[i];</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了实现<code>for</code>循环遍历，初始条件为<code>i=0</code>，因为索引总是从<code>0</code>开始，继续循环的条件为<code>i&lt;ns.length</code>，因为当<code>i=ns.length</code>时，<code>i</code>已经超出了索引范围（索引范围是<code>0</code> ~ <code>ns.length-1</code>），每次循环后，<code>i++</code>。</p>
<p>第二种方式是使用<code>for each</code>循环，直接迭代数组的每个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : ns) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在<code>for (int n : ns)</code>循环中，变量<code>n</code>直接拿到<code>ns</code>数组的元素，而不是索引。</p>
<p>显然<code>for each</code>循环更加简洁。但是，<code>for each</code>循环无法拿到数组的索引，因此，到底用哪一种<code>for</code>循环，取决于我们的需要。如果不需要关心索引的话（意味着不需要修改数组的某个元素），使用 for-each 遍历更简洁一些。当然，也可以使用 while 和 do-while 循环。</p>
<p>在 Java 中，可变参数用于将任意数量的参数传递给方法，来看 <code>varargsMethod()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">varargsMethod</span><span class="params">(String... varargs)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>该方法可以接收任意数量的字符串参数，可以是 0 个或者 N 个，本质上，可变参数就是通过数组实现的。为了证明这一点，我们可以看一下反编译一后的字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarargsDemo</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VarargsDemo</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">void</span> <span class="title function_">varargsMethod</span><span class="params">(String as[])</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，我们其实可以直接将数组作为参数传递给该方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">VarargsDemo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VarargsDemo</span>();</span><br><span class="line">String[] anArray = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;你好&quot;</span>, <span class="string">&quot;xiaou&quot;</span>&#125;;</span><br><span class="line">demo.varargsMethod(anArray);</span><br></pre></td></tr></table></figure>

<p>也可以直接传递多个字符串，通过逗号隔开的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">demo.varargsMethod(<span class="string">&quot;你好&quot;</span>, <span class="string">&quot;xiaou&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在 Java 中，数组与 List 关系非常密切。List 封装了很多常用的方法，方便我们对集合进行一些操作，而如果直接操作数组的话，有很多不便，因为数组本身没有提供这些封装好的操作，所以有时候我们需要把数组转成 List。</p>
<p>最原始的方式，就是通过遍历数组的方式，一个个将数组添加到 List 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] anArray = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; aList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> element : anArray) &#123;</span><br><span class="line">    aList.add(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更优雅的方式是通过 Arrays 类的 <code>asList()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; aList = Arrays.asList(anArray);</span><br></pre></td></tr></table></figure>

<p>不过需要注意的是，Arrays.asList 的参数需要是 Integer 数组，而 anArray 目前是 int 类型，我们需要换另外一种方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; aList = Arrays.stream(anArray).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>这又涉及到了 Java 流的知识，后面会讲到。</p>
<p>还有一个需要注意的是，Arrays.asList 方法返回的 ArrayList 并不是 <code>java.util.ArrayList</code>，它其实是 Arrays 类的一个内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">RandomAccess</span>, java.io.Serializable&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要添加元素或者删除元素的话，需要把它转成 <code>java.util.ArrayList</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(anArray));</span><br></pre></td></tr></table></figure>

<p>Java 8 新增了 Stream 流的概念，这就意味着我们也可以将数组转成 Stream 进行操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] anArray = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;xiaou&quot;</span>, <span class="string">&quot;你好&quot;</span>, <span class="string">&quot;世界&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; aStream = Arrays.stream(anArray);</span><br></pre></td></tr></table></figure>

<p>如果想对数组进行排序的话，可以使用 Arrays 类提供的 <code>sort()</code> 方法。</p>
<ul>
<li>基本数据类型按照升序排列</li>
<li>实现了 Comparable 接口的对象按照 <code>compareTo()</code> 的排序</li>
</ul>
<p>来看第一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] anArray = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>&#125;;</span><br><span class="line">Arrays.sort(anArray);</span><br></pre></td></tr></table></figure>

<p>排序后的结果如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>

<p>来看第二个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] yetAnotherArray = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;Z&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(yetAnotherArray, <span class="number">1</span>, <span class="number">3</span>,</span><br><span class="line">                Comparator.comparing(String::toString).reversed());</span><br></pre></td></tr></table></figure>

<p>只对 1-3 位置上的元素进行反序，所以结果如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A, Z, E, B, C]</span><br></pre></td></tr></table></figure>

<p>有时候，我们需要从数组中查找某个具体的元素，最直接的方式就是通过遍历的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] anArray = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; anArray.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (anArray[i] == <span class="number">4</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;找到了 &quot;</span> + i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中从数组中查询元素 4，找到后通过 break 关键字退出循环。</p>
<p>如果数组提前进行了排序，就可以使用二分查找法，这样效率就会更高一些。<code>Arrays.binarySearch()</code> 方法可供我们使用，它需要传递一个数组，和要查找的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] anArray = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(anArray, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>在了解了数组的一些规范之后，下面来看几个例题</p>
<p>比如一个简单的求和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 数组;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈功能概述〉&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *1.求出所有数据的和</span></span><br><span class="line"><span class="comment"> * 2.求所有数据的平均数</span></span><br><span class="line"><span class="comment"> * 3.统计有多少个数据比平均数小</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:xiaou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022/11/26 22:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a8</span>遍历数组求和 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">        Random r=<span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> number=r.nextInt(<span class="number">100</span>)+<span class="number">1</span>;</span><br><span class="line">            arr[i]=number;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            sum+=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组中所有的和为&quot;</span>+sum);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> avg=sum/arr.length;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组中的平均数为&quot;</span>+avg);</span><br><span class="line">        <span class="comment">//3</span></span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (arr[i]&lt;avg)&#123;</span><br><span class="line">               count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;一共有&quot;</span>+count+<span class="string">&quot;个数字，比平均数小&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们用到了随机数的生成，也就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> randomIndex= r.nextInt(num)</span><br><span class="line"><span class="comment">//其中num为数字的意思，记录0~num但不包含num的值既生成0~num-1范围内的值</span></span><br></pre></td></tr></table></figure>

<p>这个知识。</p>
<p>下面再来看一个经典的冒泡排序</p>
<p>对数组进行排序是程序中非常基本的需求。常用的排序算法有冒泡排序、插入排序和快速排序等。我们来看一下如何使用冒泡排序算法对一个整型数组从小到大进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">28</span>, <span class="number">12</span>, <span class="number">89</span>, <span class="number">73</span>, <span class="number">65</span>, <span class="number">18</span>, <span class="number">96</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">36</span> &#125;;</span><br><span class="line">        <span class="comment">// 排序前:</span></span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ns.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ns.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ns[j] &gt; ns[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 交换ns[j]和ns[j+1]:</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> ns[j];</span><br><span class="line">                    ns[j] = ns[j+<span class="number">1</span>];</span><br><span class="line">                    ns[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序后:</span></span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冒泡排序的特点是，每一轮循环后，最大的一个数被交换到末尾，因此，下一轮循环就可以“刨除”最后的数，每一轮循环都比上一轮循环的结束位置靠前一位。</p>
<p>另外，注意到交换两个变量的值必须借助一个临时变量。像这么写是错误的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int x = 1;</span><br><span class="line">int y = 2;</span><br><span class="line"></span><br><span class="line">x = y; // x现在是2</span><br><span class="line">y = x; // y现在还是2</span><br></pre></td></tr></table></figure>

<p>正确的写法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int x = 1;</span><br><span class="line">int y = 2;</span><br><span class="line"></span><br><span class="line">int t = x; // 把x的值保存在临时变量t中, t现在是1</span><br><span class="line">x = y; // x现在是2</span><br><span class="line">y = t; // y现在是t的值1</span><br></pre></td></tr></table></figure>

<p>实际上，Java的标准库已经内置了排序功能，我们只需要调用JDK提供的<code>Arrays.sort()</code>就可以排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] ns = &#123; <span class="number">28</span>, <span class="number">12</span>, <span class="number">89</span>, <span class="number">73</span>, <span class="number">65</span>, <span class="number">18</span>, <span class="number">96</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">36</span> &#125;;</span><br><span class="line">        Arrays.sort(ns);</span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>必须注意，对数组排序实际上修改了数组本身。例如，排序前的数组是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] ns = &#123; 9, 3, 6, 5 &#125;;</span><br></pre></td></tr></table></figure>

<p>在内存中，这个整型数组表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      ┌───┬───┬───┬───┐</span><br><span class="line">ns───▶│ 9 │ 3 │ 6 │ 5 │</span><br><span class="line">      └───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>

<p>当我们调用<code>Arrays.sort(ns);</code>后，这个整型数组在内存中变为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      ┌───┬───┬───┬───┐</span><br><span class="line">ns───▶│ 3 │ 5 │ 6 │ 9 │</span><br><span class="line">      └───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>

<p>即变量<code>ns</code>指向的数组内容已经被改变了。</p>
<p>如果对一个字符串数组进行排序，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] ns = &#123; &quot;banana&quot;, &quot;apple&quot;, &quot;pear&quot; &#125;;</span><br></pre></td></tr></table></figure>

<p>排序前，这个数组在内存中表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                   ┌──────────────────────────────────┐</span><br><span class="line">               ┌───┼──────────────────────┐           │</span><br><span class="line">               │   │                      ▼           ▼</span><br><span class="line">         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐</span><br><span class="line">ns ─────▶│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │</span><br><span class="line">         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘</span><br><span class="line">           │                 ▲</span><br><span class="line">           └─────────────────┘</span><br></pre></td></tr></table></figure>

<p>调用<code>Arrays.sort(ns);</code>排序后，这个数组在内存中表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                   ┌──────────────────────────────────┐</span><br><span class="line">               ┌───┼──────────┐                       │</span><br><span class="line">               │   │          ▼                       ▼</span><br><span class="line">         ┌───┬─┴─┬─┴─┬───┬────────┬───┬───────┬───┬──────┬───┐</span><br><span class="line">ns ─────▶│░░░│░░░│░░░│   │&quot;banana&quot;│   │&quot;apple&quot;│   │&quot;pear&quot;│   │</span><br><span class="line">         └─┬─┴───┴───┴───┴────────┴───┴───────┴───┴──────┴───┘</span><br><span class="line">           │                              ▲</span><br><span class="line">           └──────────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>原来的3个字符串在内存中均没有任何变化，但是<code>ns</code>数组的每个元素指向变化了。</p>
<p>之后再来看一个数组反转的例子，更加巩固一下数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 反转数组*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            b[j - <span class="number">1</span>] = a[i];</span><br><span class="line">            j = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*输入反转数组*/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;反转后数组是: \n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">            System.out.println(b[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> [] arr = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;;</span><br><span class="line">        reverse(arr, arr.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><p>二维数组是一种数据类型，可以存储多行和多列的数据。它由一系列的行和列组成，每个元素都可以通过一个行索引和列索引来访问。例如，一个3行4列的二维数组可以表示为以下形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array = [</span><br><span class="line">  [a, b, c, d],</span><br><span class="line">  [e, f, g, h],</span><br><span class="line">  [i, j, k, l]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在这个例子中，第一行有4个元素，第二行有4个元素，第三行有4个元素，每个元素都有一个行索引和一个列索引。例如，元素 array[1][2] 是第2行第3列的元素，它的值是 g。</p>
<p>使用二维数组可以有效地存储和处理表格数据，如矩阵、图像、地图等等。</p>
<p>定义一个二维数组如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] ns = &#123;</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">            &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(ns.length); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因为<code>ns</code>包含3个数组，因此，<code>ns.length</code>为<code>3</code>。实际上<code>ns</code>在内存中的结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                    ┌───┬───┬───┬───┐</span><br><span class="line">         ┌───┐  ┌──▶│ 1 │ 2 │ 3 │ 4 │</span><br><span class="line">ns ─────▶│░░░│──┘   └───┴───┴───┴───┘</span><br><span class="line">         ├───┤      ┌───┬───┬───┬───┐</span><br><span class="line">         │░░░│─────▶│ 5 │ 6 │ 7 │ 8 │</span><br><span class="line">         ├───┤      └───┴───┴───┴───┘</span><br><span class="line">         │░░░│──┐   ┌───┬───┬───┬───┐</span><br><span class="line">         └───┘  └──▶│ 9 │10 │11 │12 │</span><br><span class="line">                    └───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>

<p>如果我们定义一个普通数组<code>arr0</code>，然后把<code>ns[0]</code>赋值给它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] ns = &#123;</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">            &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span>[] arr0 = ns[<span class="number">0</span>];</span><br><span class="line">        System.out.println(arr0.length); <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上<code>arr0</code>就获取了<code>ns</code>数组的第0个元素。因为<code>ns</code>数组的每个元素也是一个数组，因此，<code>arr0</code>指向的数组就是<code>&#123; 1, 2, 3, 4 &#125;</code>。在内存中，结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            arr0 ─────┐</span><br><span class="line">                      ▼</span><br><span class="line">                    ┌───┬───┬───┬───┐</span><br><span class="line">         ┌───┐  ┌──▶│ 1 │ 2 │ 3 │ 4 │</span><br><span class="line">ns ─────▶│░░░│──┘   └───┴───┴───┴───┘</span><br><span class="line">         ├───┤      ┌───┬───┬───┬───┐</span><br><span class="line">         │░░░│─────▶│ 5 │ 6 │ 7 │ 8 │</span><br><span class="line">         ├───┤      └───┴───┴───┴───┘</span><br><span class="line">         │░░░│──┐   ┌───┬───┬───┬───┐</span><br><span class="line">         └───┘  └──▶│ 9 │10 │11 │12 │</span><br><span class="line">                    └───┴───┴───┴───┘</span><br></pre></td></tr></table></figure>

<p>访问二维数组中的元素</p>
<p>我们可以使用两个方括号来访问二维中的元素。</p>
<p>第一个表示我们要从中访问元素的数组，而第二个表示我们要访问的元素索引。</p>
<p>让我们用一个例子来简化上面的解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] oddNumbers = &#123; &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;, &#123;<span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(oddNumbers[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>oddNumbers</code> 数组中有两个数组——<code>&#123;1, 3, 5, 7&#125;</code> 和 <code>&#123;9, 11, 13, 15&#125;</code>。</p>
<p>第一个数组——<code>&#123;1, 3, 5, 7&#125;</code>——用 0 表示。</p>
<p>第二个数组——<code>&#123;9, 11, 13, 15&#125;</code>——用 1 表示。</p>
<p>第一个数组是 0，第二个是 1，第三个是 2，依此类推。</p>
<p>因此，要访问第一个数组中的项目，我们将 0 分配给第一个方括号。由于我们试图访问数组中的第一项，我们将使用它的索引，即 0：<code>oddNumbers[0][0]</code>。</p>
<p>让我们进一步分解它。</p>
<p>这是访问元素的代码：<code>oddNumbers[?][?]</code>。</p>
<p>我在两个方括号中都加上了问号——随着进展填写它们。</p>
<p>假设我们要访问第二个数组中的元素，我们的代码将如下所示：<code>oddNumbers[1][?]</code>。</p>
<p>现在我们要在第二个数组（<code>&#123;9, 11, 13, 15&#125;</code>）中尝试访问其中一个元素。就像一维数组一样，每个元素都有一个从零开始的索引。</p>
<p>因此，要访问第三个元素 <code>13</code>，我们将其索引号传递给第二个方括号：<code>oddNumbers[1][2]</code>。</p>
<p>来看这样一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] oddNumbers = &#123; &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;, &#123;<span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>&#125;, &#123;<span class="number">17</span>, <span class="number">19</span>, <span class="number">21</span>, <span class="number">23</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>我们的目标是访问第三个数组中的 21。访问方式仍然通过问号来表示：<code>oddNumbers[?][?]</code>。</p>
<p>我们首先给第一个问号一个指向要访问的特定数组的值。</p>
<p>数组 0 &#x3D;&gt; <code>&#123;1, 3, 5, 7&#125;</code></p>
<p>数组 1 &#x3D;&gt; <code>&#123;9, 11, 13, 15&#125;</code></p>
<p>数组 2 &#x3D;&gt; <code>&#123;17, 19, 21, 23&#125;</code></p>
<p>我们要查找的数字在第三个数组中，所以是：<code>oddNumbers[2][?]</code>。</p>
<p>第二个方括号的值将指向要访问的元素。为此，我们必须指定元素的索引。以下是该数组中的索引：</p>
<p>17 &#x3D;&gt; 索引 0</p>
<p>19 &#x3D;&gt; 索引 1</p>
<p>21 &#x3D;&gt; 索引 2</p>
<p>23 &#x3D;&gt; 索引 3</p>
<p>21 的索引为 2，因此我们可以将其添加到第二个方括号：<code>oddNumbers[2][2]</code>。当你将其打印到控制台时，将会打印出 21。</p>
<p>代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] oddNumbers = &#123; &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;, &#123;<span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>&#125;, &#123;<span class="number">17</span>, <span class="number">19</span>, <span class="number">21</span>, <span class="number">23</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(oddNumbers[<span class="number">2</span>][<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// 21</span></span><br></pre></td></tr></table></figure>

<p>你可以使用嵌套循环，遍历二维数组中的所有项目。这是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] oddNumbers = &#123; &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;, &#123;<span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>&#125;, &#123;<span class="number">17</span>, <span class="number">19</span>, <span class="number">21</span>, <span class="number">23</span>&#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; oddNumbers.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oddNumbers[i].length; j++)&#123;</span><br><span class="line">        System.out.println(oddNumbers[i][j]);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// 13</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 17</span></span><br><span class="line"><span class="comment">// 19</span></span><br><span class="line"><span class="comment">// 21</span></span><br><span class="line"><span class="comment">// 23</span></span><br></pre></td></tr></table></figure>

<p>上面的代码将会打印出 <code>oddNumbers</code> 数组中的所有项目。</p>
<p>一个比较经典的用二维数组来实现的案例就是杨辉三角</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YangHuiTriangle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;请输入要打印的行数：&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        printYangHuiTriangle(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printYangHuiTriangle</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] triangle = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 每行的第一个和最后一个数字都是1</span></span><br><span class="line">            triangle[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            triangle[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">// 其他数字是上一行的两个数字之和</span></span><br><span class="line">                triangle[i][j] = triangle[i - <span class="number">1</span>][j - <span class="number">1</span>] + triangle[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印杨辉三角</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.print(triangle[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“这段代码使用了一个二维数组来存储杨辉三角中的数字。首先，程序要求用户输入要打印的行数，然后调用 printYangHuiTriangle 方法来生成和打印杨辉三角。在 printYangHuiTriangle 方法中，程序使用了一个嵌套的 for 循环来计算杨辉三角中的每个数字，并将结果存储在二维数组 triangle 中。最后，程序再次使用循环来遍历数组并打印出杨辉三角中的数字。</p>
<p>下面看他的打印结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">请输入要打印的行数：<span class="number">6</span></span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">6</span> <span class="number">4</span> <span class="number">1</span> </span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">10</span> <span class="number">10</span> <span class="number">5</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure>

<h4 id="打印java数组"><a href="#打印java数组" class="headerlink" title="打印java数组"></a>打印java数组</h4><p>数组其实也是一个对象，因为java就是万物皆是对象，但 Java 中并未明确的定义这样一个类。</p>
<p>因此数组也就没有机会覆盖 <code>Object.toString()</code> 方法。如果尝试直接打印数组的话，输出的结果并不是我们预期的结果。为什么不能直接打印数组</p>
<p>“首先，我们来看一下，为什么不能直接打印数组，直接打印的话，会出现什么问题。”</p>
<p>来看这样一个例子。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String [] cmowers = &#123;&quot;你好&quot;&#125;;</span><br><span class="line">System.out.println(cmowers);</span><br></pre></td></tr></table></figure>

<p>程序打印的结果是：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Ljava.lang.String;@3d075dc0</span><br></pre></td></tr></table></figure>

<p><code>[Ljava.lang.String;</code> 表示字符串数组的 Class 名，@ 后面的是十六进制的 hashCode——这样的打印结果太“人性化”了，一般人表示看不懂！为什么会这样显示呢？查看一下 <code>java.lang.Object</code> 类的 <code>toString()</code> 方法就明白了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次证明，数组虽然没有显式定义成一个类，但它的确是一个对象，继承了祖先类 Object 的所有方法。</p>
<p>那为什么数组不单独定义一个类来表示呢？就像字符串 String 类那样呢？</p>
<p>一个合理的说法是 Java 将其隐藏了。假如真的存在这么一个类，就叫 Array.java 吧，我们假想一下它真实的样子，必须得有一个容器来存放数组的每一个元素，就像 String 类那样。String类我们下面会做解释，这里就不做解释了。</p>
<p>来简单的看一下string类的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>下面我们来看几种打印java数组的方式</p>
<h5 id="stream-流打印-Java-数组"><a href="#stream-流打印-Java-数组" class="headerlink" title="stream 流打印 Java 数组"></a>stream 流打印 Java 数组</h5><p>“我们来看第一种打印数组的方法，使用时髦一点的Stream 流 这个如果不会的可以跳过，我们之后会做解释</p>
<p>第一种形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(cmowers).stream().forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure>

<p>第二种形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(cmowers).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>第三种形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(cmowers).forEach(System.out::println);</span><br></pre></td></tr></table></figure>



<p>没错，这三种方式都可以轻松胜任本职工作，并且显得有点高大上，毕竟用到了 Stream，以及lambda 表达式</p>
<h5 id="for-循环打印-Java-数组"><a href="#for-循环打印-Java-数组" class="headerlink" title="for 循环打印 Java 数组"></a>for 循环打印 Java 数组</h5><p>“当然了，也可以使用传统的方式，for 循环。甚至 for-each 也行。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cmowers.length; i++)&#123;</span><br><span class="line">    System.out.println(cmowers[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String s : cmowers) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Arrays-工具类打印-Java-数组"><a href="#Arrays-工具类打印-Java-数组" class="headerlink" title="Arrays 工具类打印 Java 数组"></a>Arrays 工具类打印 Java 数组</h5><p>我认为 <code>Arrays.toString()</code> 是打印数组的最佳方式，没有之一。</p>
<p><code>Arrays.toString()</code> 可以将任意类型的数组转成字符串，包括基本类型数组和引用类型数组。该方法有多种重载形式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400785.png" alt="img"></p>
<p>使用 <code>Arrays.toString()</code> 方法来打印数组再优雅不过了，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String [] cmowers = &#123;<span class="string">&quot;java&quot;</span>,<span class="string">&quot;xiaou&quot;</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(cmowers));</span><br></pre></td></tr></table></figure>

<p>程序打印结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[java,xiaou]</span><br></pre></td></tr></table></figure>

<p>哇，打印格式不要太完美，不多不少！完全是我们预期的结果：<code>[]</code> 表明是一个数组，<code>,</code> 点和空格用来分割元素。</p>
<h5 id="Arrays工具类打印二维数组"><a href="#Arrays工具类打印二维数组" class="headerlink" title="Arrays工具类打印二维数组"></a>Arrays工具类打印二维数组</h5><p>除了一维数组，我们还可以用工具类来打印二维数组</p>
<p>“可以使用 <code>Arrays.deepToString()</code> 方法。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[][] deepArray = <span class="keyword">new</span> <span class="title class_">String</span>[][] &#123;&#123;<span class="string">&quot;nihao&quot;</span>, <span class="string">&quot;你好&quot;</span>&#125;, &#123;<span class="string">&quot;java&quot;</span>&#125;&#125;;</span><br><span class="line">System.out.println(Arrays.deepToString(deepArray));</span><br></pre></td></tr></table></figure>

<p>打印结果如下所示。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[nihao,你好], [java]]</span><br></pre></td></tr></table></figure>

<h5 id="POJO-的打印规约"><a href="#POJO-的打印规约" class="headerlink" title="POJO 的打印规约"></a>POJO 的打印规约</h5><p>阿里巴巴的 Java 开发手册上有这样一条规约：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400058.png" alt="img"></p>
<p>“什么是 POJO 呢，就是 Plain Ordinary Java Object 的缩写，一般在 Web 应用程序中建立一个数据库的映射对象时，我们称它为 POJO，这类对象不继承或不实现任何其它 Java 框架的类或接口。”</p>
<p>“对于这样的类，最好是重写一下它的 <code>toString()</code> 方法，方便查看这个对象到底包含了什么字段，好排查问题。”</p>
<p>“如果不重写的话，打印出来的 Java 对象就像直接打印数组的那样，一串谁也看不懂的字符序列。”</p>
<p>“可以借助 Intellij IDEA 生成重写的 <code>toString()</code> 方法，特别方便。”</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="Java-String类"><a href="#Java-String类" class="headerlink" title="Java String类"></a>Java String类</h3><p>字符串广泛应用 在 Java 编程中，在 Java 中字符串属于对象，Java 提供了 String 类来创建和操作字符串。</p>
<p>String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
<h4 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h4><p>创建字符串最简单的方式如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Runoob&quot;</span>;</span><br></pre></td></tr></table></figure>



<p>在代码中遇到字符串常量时，这里的值是 “<strong>Runoob</strong>“，编译器会使用该值创建一个 String 对象。</p>
<p>和其它对象一样，可以使用关键字和构造方法来创建 String 对象。</p>
<p>用构造函数创建字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Runoob&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>String 创建的字符串存储在公共池中，而 new 创建的字符串对象在堆上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Runoob&quot;</span>;              <span class="comment">// String 直接创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;Runoob&quot;</span>;              <span class="comment">// String 直接创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1;                    <span class="comment">// 相同引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Runoob&quot;</span>);   <span class="comment">// String 对象创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Runoob&quot;</span>);   <span class="comment">// String 对象创建</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400094.png" alt="img"></p>
<p>String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，比如提供一个字符数组参数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="type">char</span>[] helloArray = &#123; <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line">      <span class="type">String</span> <span class="variable">helloString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(helloArray);  </span><br><span class="line">      System.out.println( helloString );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**注意:**String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了,一会我们会介绍为什么java的字符串不可变</p>
<h4 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h4><p>用于获取有关对象的信息的方法称为访问器方法。</p>
<p>String 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。</p>
<p>下面的代码执行后，len 变量等于 17：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">site</span> <span class="operator">=</span> <span class="string">&quot;blog.guoyaxue.top&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> site.length();</span><br><span class="line">        System.out.println( <span class="string">&quot;我的网址长度 : &quot;</span> + len );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我的网址长度 : <span class="number">17</span></span><br></pre></td></tr></table></figure>

<h3 id="String-方法"><a href="#String-方法" class="headerlink" title="String 方法"></a>String 方法</h3><p>下面是 String 类支持的方法，更多详细，参看 <a target="_blank" rel="noopener" href="https://www.runoob.com/manual/jdk11api/java.base/java/lang/String.html">Java String API</a> 文档:</p>
<table>
<thead>
<tr>
<th align="left">SN(序号)</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-charat.html">char charAt(int index)</a> 返回指定索引处的 char 值。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-compareto.html">int compareTo(Object o)</a> 把这个字符串和另一个对象比较。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-compareto.html">int compareTo(String anotherString)</a> 按字典顺序比较两个字符串。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-comparetoignorecase.html">int compareToIgnoreCase(String str)</a> 按字典顺序比较两个字符串，不考虑大小写。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-concat.html">String concat(String str)</a> 将指定字符串连接到此字符串的结尾。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-contentequals.html">boolean contentEquals(StringBuffer sb)</a> 当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">[static String copyValueOf(char<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-copyvalueof.html">] data)</a> 返回指定数组中表示该字符序列的 String。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">[static String copyValueOf(char<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-copyvalueof.html">] data, int offset, int count)</a> 返回指定数组中表示该字符序列的 String。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-endswith.html">boolean endsWith(String suffix)</a> 测试此字符串是否以指定的后缀结束。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-equals.html">boolean equals(Object anObject)</a> 将此字符串与指定的对象比较。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-equalsignorecase.html">boolean equalsIgnoreCase(String anotherString)</a> 将此 String 与另一个 String 比较，不考虑大小写。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">[byte<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-getbytes.html">] getBytes()</a>  使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">[byte<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-getbytes.html">] getBytes(String charsetName)</a> 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">[void getChars(int srcBegin, int srcEnd, char<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-getchars.html">] dst, int dstBegin)</a> 将字符从此字符串复制到目标字符数组。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-hashcode.html">int hashCode()</a> 返回此字符串的哈希码。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(int ch)</a> 返回指定字符在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(int ch, int fromIndex)</a> 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(String str)</a>  返回指定子字符串在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-indexof.html">int indexOf(String str, int fromIndex)</a> 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-intern.html">String intern()</a>  返回字符串对象的规范化表示形式。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(int ch)</a>  返回指定字符在此字符串中最后一次出现处的索引。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(int ch, int fromIndex)</a> 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(String str)</a> 返回指定子字符串在此字符串中最右边出现处的索引。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-lastindexof.html">int lastIndexOf(String str, int fromIndex)</a>  返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-length.html">int length()</a> 返回此字符串的长度。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-matches.html">boolean matches(String regex)</a> 告知此字符串是否匹配给定的正则表达式。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-regionmatches.html">boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)</a> 测试两个字符串区域是否相等。</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-regionmatches.html">boolean regionMatches(int toffset, String other, int ooffset, int len)</a> 测试两个字符串区域是否相等。</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-replace.html">String replace(char oldChar, char newChar)</a> 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-replaceall.html">String replaceAll(String regex, String replacement)</a> 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-replacefirst.html">String replaceFirst(String regex, String replacement)</a>  使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</td>
</tr>
<tr>
<td align="left">32</td>
<td align="left">[String<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-split.html">] split(String regex)</a> 根据给定正则表达式的匹配拆分此字符串。</td>
</tr>
<tr>
<td align="left">33</td>
<td align="left">[String<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-split.html">] split(String regex, int limit)</a> 根据匹配给定的正则表达式来拆分此字符串。</td>
</tr>
<tr>
<td align="left">34</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-startswith.html">boolean startsWith(String prefix)</a> 测试此字符串是否以指定的前缀开始。</td>
</tr>
<tr>
<td align="left">35</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-startswith.html">boolean startsWith(String prefix, int toffset)</a> 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</td>
</tr>
<tr>
<td align="left">36</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-subsequence.html">CharSequence subSequence(int beginIndex, int endIndex)</a>  返回一个新的字符序列，它是此序列的一个子序列。</td>
</tr>
<tr>
<td align="left">37</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-substring.html">String substring(int beginIndex)</a> 返回一个新的字符串，它是此字符串的一个子字符串。</td>
</tr>
<tr>
<td align="left">38</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-substring.html">String substring(int beginIndex, int endIndex)</a> 返回一个新字符串，它是此字符串的一个子字符串。</td>
</tr>
<tr>
<td align="left">39</td>
<td align="left">[char<a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-tochararray.html">] toCharArray()</a> 将此字符串转换为一个新的字符数组。</td>
</tr>
<tr>
<td align="left">40</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-tolowercase.html">String toLowerCase()</a> 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td align="left">41</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-tolowercase.html">String toLowerCase(Locale locale)</a>  使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td align="left">42</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-tostring.html">String toString()</a>  返回此对象本身（它已经是一个字符串！）。</td>
</tr>
<tr>
<td align="left">43</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-touppercase.html">String toUpperCase()</a> 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td align="left">44</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-touppercase.html">String toUpperCase(Locale locale)</a> 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td align="left">45</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-trim.html">String trim()</a> 返回字符串的副本，忽略前导空白和尾部空白。</td>
</tr>
<tr>
<td align="left">46</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-valueof.html">static String valueOf(primitive data type x)</a> 返回给定data type类型x参数的字符串表示形式。</td>
</tr>
<tr>
<td align="left">47</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-contains.html">contains(CharSequence chars)</a> 判断是否包含指定的字符系列。</td>
</tr>
<tr>
<td align="left">48</td>
<td align="left"><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-string-isempty.html">isEmpty()</a> 判断字符串是否为空。</td>
</tr>
</tbody></table>
<p>在有了这些方法的前提下，就可以来进行一些案例的编写</p>
<p>比如下面的案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 字符串;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">已知正确的用户名和密码，请用程序进行模拟登录。</span></span><br><span class="line"><span class="comment">总共有三次机会。登录之后，会给出相应的提示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a3</span>用户登录 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.定义变量</span></span><br><span class="line">        String rightUsername=<span class="string">&quot;yuanfang&quot;</span>;</span><br><span class="line">        String rightPassword=<span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入用户名&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> sc.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入密码&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> sc.next();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (username.equals(rightUsername)&amp;&amp;password.equals(rightPassword))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;用户登录成功&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">2</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;你的账户&quot;</span>+username+<span class="string">&quot;被锁定&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;用户名或密码错误您还剩下&quot;</span>+(<span class="number">2</span>-i)+<span class="string">&quot;次机会&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总体来说还是非常的简单的，这里要注意的是。字符串的比较不能直接用&#x3D;&#x3D;。要使用equals方法来进行比较。</p>
<h3 id="解读String源码"><a href="#解读String源码" class="headerlink" title="解读String源码"></a>解读String源码</h3><p>我们以java8的为例进行解读，这里也是涉及到面试的东西，可以当做一个了解</p>
<h4 id="String-类的声明"><a href="#String-类的声明" class="headerlink" title="String 类的声明"></a>String 类的声明</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“第一，String 类是 final 的，意味着它不能被子类继承。”</p>
<p>“第二，String 类实现了 Serializable 接口，意味着它可以序列化。”</p>
<p>“第三，String 类实现了 Comparable 接口，意味着最好不要用‘&#x3D;&#x3D;’来比较两个字符串是否相等，而应该用 <code>compareTo()</code> 方法去比较。”</p>
<p>因为 &#x3D;&#x3D; 是用来比较两个对象的地址，这个在讲字符串比较的时候会详细讲。如果只是说比较字符串内容的话，可以使用 String 类的 equals 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String) anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“第四，StringBuffer、StringBuilder 和 String 一样，都实现了 CharSequence 接口，所以它们仨属于近亲。由于 String 是不可变的，所以遇到字符串拼接的时候就可以考虑一下 String 的另外两个好兄弟，StringBuffer 和 StringBuilder，它俩是可变的。”</p>
<h4 id="String-类的底层实现"><a href="#String-类的底层实现" class="headerlink" title="String 类的底层实现"></a>String 类的底层实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure>

<p>“第五，Java 9 以前，String 是用 char 型数组实现的，之后改成了 byte 型数组实现，并增加了 coder 来表示编码。这样做的好处是在 Latin1 字符为主的程序里，可以把 String 占用的内存减少一半。当然，天下没有免费的午餐，这个改进在节省内存的同时引入了编码检测的开销。”</p>
<blockquote>
<p>Latin1（Latin-1）是一种单字节字符集（即每个字符只使用一个字节的编码方式），也称为ISO-8859-1（国际标准化组织8859-1），它包含了西欧语言中使用的所有字符，包括英语、法语、德语、西班牙语、葡萄牙语、意大利语等等。在Latin1编码中，每个字符使用一个8位（即一个字节）的编码，可以表示256种不同的字符，其中包括ASCII字符集中的所有字符，即0x00到0x7F，以及其他西欧语言中的特殊字符，例如é、ü、ñ等等。由于Latin1只使用一个字节表示一个字符，因此在存储和传输文本时具有较小的存储空间和较快的速度</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们来详细地说一下。</p>
<p>从 <code>char[]</code> 到 <code>byte[]</code>，最主要的目的是<strong>节省字符串占用的内存空间</strong>。内存占用减少带来的另外一个好处，就是 GC 次数也会减少。</p>
<p>我们使用 <code>jmap -histo:live pid | head -n 10</code> 命令就可以查看到堆内对象示例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。</p>
<p>以我正在运行着的编程喵项目实例（基于 Java 8）来说，结果是这样的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400133.png" alt="img"></p>
<p>其中 String 对象有 17638 个，占用了 423312 个字节的内存，排在第三位。</p>
<p>由于 Java 8 的 String 内部实现仍然是 <code>char[]</code>，所以我们可以看到内存占用排在第 1 位的就是 char 数组。</p>
<p><code>char[]</code> 对象有 17673 个，占用了 1621352 个字节的内存，排在第一位。</p>
<p>那也就是说优化 String 节省内存空间是非常有必要的，如果是去优化一个使用频率没有 String 这么高的类，就没什么必要，对吧？</p>
<p>众所周知，char 类型的数据在 JVM 中是占用两个字节的，并且使用的是 UTF-8 编码，其值范围在 ‘\u0000’（0）和 ‘\uffff’（65,535）（包含）之间。</p>
<p>也就是说，使用 <code>char[]</code> 来表示 String 就会导致，即使 String 中的字符只用一个字节就能表示，也得占用两个字节。</p>
<blockquote>
<p>PS：在计算机中，单字节字符通常指的是一个字节（8位）可以表示的字符，而双字节字符则指需要两个字节（16位）才能表示的字符。单字节字符和双字节字符的定义是相对的，不同的编码方式对应的单字节和双字节字符集也不同。常见的单字节字符集有ASCII（美国信息交换标准代码）、ISO-8859（国际标准化组织标准编号8859）、GBK（汉字内码扩展规范）、GB2312（中国国家标准，现在已经被GBK取代），像拉丁字母、数字、标点符号、控制字符都是单字节字符。双字节字符集包括 Unicode、UTF-8、GB18030（中国国家标准），中文、日文、韩文、拉丁文扩展字符属于双字节字符。</p>
</blockquote>
<p>当然了，仅仅将 <code>char[]</code> 优化为 <code>byte[]</code> 是不够的，还要配合 Latin-1 的编码方式，该编码方式是用单个字节来表示字符的，这样就比 UTF-8 编码节省了更多的空间。</p>
<p>换句话说，对于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;jack&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这样的，使用 Latin-1 编码，占用 4 个字节就够了。</p>
<p>但对于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小二&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这种，木的办法，只能使用 UTF16 来编码。</p>
<p>针对 JDK 9 的 String 源码里，为了区别编码方式，追加了一个 coder 字段来区分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The identifier of the encoding used to encode the bytes in</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> value&#125;. The supported values in this implementation are</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LATIN1</span></span><br><span class="line"><span class="comment"> * UTF16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@implNote</span> This field is trusted by the VM, and is a subject to</span></span><br><span class="line"><span class="comment"> * constant folding if String instance is constant. Overwriting this</span></span><br><span class="line"><span class="comment"> * field after construction will cause problems.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span> coder;</span><br></pre></td></tr></table></figure>

<p>Java 会根据字符串的内容自动设置为相应的编码，要么 Latin-1 要么 UTF16。</p>
<p>也就是说，从 <code>char[]</code> 到 <code>byte[]</code>，<strong>中文是两个字节，纯英文是一个字节，在此之前呢，中文是两个字节，英文也是两个字节</strong>。</p>
<p>在 UTF-8 中，0-127 号的字符用 1 个字节来表示，使用和 ASCII 相同的编码。只有 128 号及以上的字符才用 2 个、3 个或者 4 个字节来表示。</p>
<ul>
<li>如果只有一个字节，那么最高的比特位为 0；</li>
<li>如果有多个字节，那么第一个字节从最高位开始，连续有几个比特位的值为 1，就使用几个字节编码，剩下的字节均以 10 开头。</li>
</ul>
<p>具体的表现形式为：</p>
<ul>
<li>0xxxxxxx：一个字节；</li>
<li>110xxxxx 10xxxxxx：两个字节编码形式（开始两个 1）；</li>
<li>1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式（开始三个 1）；</li>
<li>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式（开始四个 1）。</li>
</ul>
<p>也就是说，UTF-8 是变长的，那对于 String 这种有随机访问方法的类来说，就很不方便。所谓的随机访问，就是charAt、subString这种方法，随便指定一个数字，String要能给出结果。如果字符串中的每个字符占用的内存是不定长的，那么进行随机访问的时候，就需要从头开始数每个字符的长度，才能找到你想要的字符。</p>
<p>那你可能会问，UTF-16也是变长的呢？一个字符还可能占用 4 个字节呢？</p>
<p>的确，UTF-16 使用 2 个或者 4 个字节来存储字符。</p>
<ul>
<li>对于 Unicode 编号范围在 0 ~ FFFF 之间的字符，UTF-16 使用两个字节存储。</li>
<li>对于 Unicode 编号范围在 10000 ~ 10FFFF 之间的字符，UTF-16 使用四个字节存储，具体来说就是：将字符编号的所有比特位分成两部分，较高的一些比特位用一个值介于 D800<del>DBFF 之间的双字节存储，较低的一些比特位（剩下的比特位）用一个值介于 DC00</del>DFFF 之间的双字节存储。</li>
</ul>
<p>但是在 Java 中，一个字符（char）就是 2 个字节，占 4 个字节的字符，在 Java 里也是用两个 char 来存储的，而String的各种操作，都是以Java的字符（char）为单位的，charAt是取得第几个char，subString取的也是第几个到第几个char组成的子串，甚至length返回的都是char的个数。</p>
<p>所以UTF-16在Java的世界里，就可以视为一个定长的编码。</p>
<blockquote>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/447224628">https://www.zhihu.com/question/447224628open in new window</a></p>
</blockquote>
<h4 id="类的-hashCode-方法"><a href="#类的-hashCode-方法" class="headerlink" title="类的 hashCode 方法"></a>类的 hashCode 方法</h4><p>“第六，每一个字符串都会有一个 hash 值，这个哈希值在很大概率是不会重复的，因此 String 很适合来作为 HashMap的键值。”</p>
<p>来看 String 类的 hashCode 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Cache the hash code for the string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hashCode 方法首先检查是否已经计算过哈希码，如果已经计算过，则直接返回缓存的哈希码。否则，方法将使用一个循环遍历字符串的所有字符，并使用一个乘法和加法的组合计算哈希码。这种计算方法被称为“31 倍哈希法”。计算完成后，将得到的哈希值存储在 hash 成员变量中，以便下次调用 hashCode 方法时直接返回该值，而不需要重新计算。这是一种缓存优化，称为“惰性计算”。</p>
<p>31倍哈希法（31-Hash）是一种简单有效的字符串哈希算法，常用于对字符串进行哈希处理。该算法的基本思想是将字符串中的每个字符乘以一个固定的质数31的幂次方，并将它们相加得到哈希值。具体地，假设字符串为s，长度为n，则31倍哈希值计算公式如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">H(s) = (s[0] * 31^(n-1)) + (s[1] * 31^(n-2)) + ... + (s[n-1] * 31^0)</span><br></pre></td></tr></table></figure>

<p>其中，s[i]表示字符串s中第i个字符的ASCII码值，<code>^</code>表示幂运算。</p>
<p>31倍哈希法的优点在于简单易实现，计算速度快，同时也比较均匀地分布在哈希表中。</p>
<p>hashCode 方法，我们会在另外一个章节里详细讲。</p>
<p>我们可以通过以下方法模拟 String 的 hashCode 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashCodeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;小u博客&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> computeHashCode(text);</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串 \&quot;&quot;</span> + text + <span class="string">&quot;\&quot; 的哈希码是: &quot;</span> + hashCode);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;String 的 hashCode &quot;</span> + text.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">computeHashCode</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; text.length(); i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + text.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看一下结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字符串 &quot;xiaou博客&quot; 的哈希码是: -2068961410</span><br><span class="line">String 的 hashCode -2068961410</span><br></pre></td></tr></table></figure>

<p>结果是一样的，又学到了吧？</p>
<h4 id="String-类的-substring-方法"><a href="#String-类的-substring-方法" class="headerlink" title="String 类的 substring 方法"></a>String 类的 substring 方法</h4><p>String 类中还有一个方法比较常用 substring，用来截取字符串的，来看源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">subLen</span> <span class="operator">=</span> value.length - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="built_in">this</span> : <span class="keyword">new</span> <span class="title class_">String</span>(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>substring 方法首先检查参数的有效性，如果参数无效，则抛出 StringIndexOutOfBoundsException 异常。接下来，方法根据参数计算子字符串的长度。如果子字符串长度小于零，抛出StringIndexOutOfBoundsException异常。</p>
<p>如果 beginIndex 为 0，且 endIndex 等于字符串的长度，说明子串与原字符串相同，因此直接返回原字符串。否则，使用 value 数组（原字符串的字符数组）的一部分创建一个新的 String 对象并返回。</p>
<p>下面是几个使用 substring 方法的示例：</p>
<p>①、提取字符串中的一段子串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">subStr</span> <span class="operator">=</span> str.substring(<span class="number">7</span>, <span class="number">12</span>);  <span class="comment">// 从第7个字符（包括）提取到第12个字符（不包括）</span></span><br><span class="line">System.out.println(subStr);  <span class="comment">// 输出 &quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<p>②、提取字符串中的前缀或后缀：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> str.substring(<span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// 提取前5个字符，即 &quot;Hello,&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> str.substring(<span class="number">7</span>);     <span class="comment">// 提取从第7个字符开始的所有字符，即 &quot;world!&quot;</span></span><br></pre></td></tr></table></figure>

<p>③、处理字符串中的空格和分隔符：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;   Hello,   world!  &quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">trimmed</span> <span class="operator">=</span> str.trim();                  <span class="comment">// 去除字符串开头和结尾的空格</span></span><br><span class="line">String[] words = trimmed.split(<span class="string">&quot;\\s+&quot;</span>);       <span class="comment">// 将字符串按照空格分隔成单词数组</span></span><br><span class="line"><span class="type">String</span> <span class="variable">firstWord</span> <span class="operator">=</span> words[<span class="number">0</span>].substring(<span class="number">0</span>, <span class="number">1</span>);  <span class="comment">// 提取第一个单词的首字母</span></span><br><span class="line">System.out.println(firstWord);                <span class="comment">// 输出 &quot;H&quot;</span></span><br></pre></td></tr></table></figure>

<p>④、处理字符串中的数字和符号：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;1234-5678-9012-3456&quot;</span>;</span><br><span class="line">String[] parts = str.split(<span class="string">&quot;-&quot;</span>);             <span class="comment">// 将字符串按照连字符分隔成四个部分</span></span><br><span class="line"><span class="type">String</span> <span class="variable">last4Digits</span> <span class="operator">=</span> parts[<span class="number">3</span>].substring(<span class="number">1</span>);  <span class="comment">// 提取最后一个部分的后三位数字</span></span><br><span class="line">System.out.println(last4Digits);             <span class="comment">// 输出 &quot;456&quot;</span></span><br></pre></td></tr></table></figure>

<p>总之，substring 方法可以根据需求灵活地提取字符串中的子串，为字符串处理提供了便利。</p>
<h4 id="String-类的-indexOf-方法"><a href="#String-类的-indexOf-方法" class="headerlink" title="String 类的 indexOf 方法"></a>String 类的 indexOf 方法</h4><p>indexOf 方法用于查找一个子字符串在原字符串中第一次出现的位置，并返回该位置的索引。来看该方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找字符数组 target 在字符数组 source 中第一次出现的位置。</span></span><br><span class="line"><span class="comment"> * sourceOffset 和 sourceCount 参数指定 source 数组中要搜索的范围，</span></span><br><span class="line"><span class="comment"> * targetOffset 和 targetCount 参数指定 target 数组中要搜索的范围，</span></span><br><span class="line"><span class="comment"> * fromIndex 参数指定开始搜索的位置。</span></span><br><span class="line"><span class="comment"> * 如果找到了 target 数组，则返回它在 source 数组中的位置索引（从0开始），</span></span><br><span class="line"><span class="comment"> * 否则返回-1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(<span class="type">char</span>[] source, <span class="type">int</span> sourceOffset, <span class="type">int</span> sourceCount,</span></span><br><span class="line"><span class="params">        <span class="type">char</span>[] target, <span class="type">int</span> targetOffset, <span class="type">int</span> targetCount,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> fromIndex)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果开始搜索的位置已经超出 source 数组的范围，则直接返回-1（如果 target 数组为空，则返回 sourceCount）</span></span><br><span class="line">    <span class="keyword">if</span> (fromIndex &gt;= sourceCount) &#123;</span><br><span class="line">        <span class="keyword">return</span> (targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果开始搜索的位置小于0，则从0开始搜索</span></span><br><span class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        fromIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 target 数组为空，则直接返回开始搜索的位置</span></span><br><span class="line">    <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fromIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找 target 数组的第一个字符在 source 数组中的位置</span></span><br><span class="line">    <span class="type">char</span> <span class="variable">first</span> <span class="operator">=</span> target[targetOffset];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> sourceOffset + (sourceCount - targetCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环查找 target 数组在 source 数组中的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sourceOffset + fromIndex; i &lt;= max; i++) &#123;</span><br><span class="line">        <span class="comment">/* Look for first character. */</span></span><br><span class="line">        <span class="comment">// 如果 source 数组中当前位置的字符不是 target 数组的第一个字符，则在 source 数组中继续查找 target 数组的第一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (source[i] != first) &#123;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Found first character, now look at the rest of v2 */</span></span><br><span class="line">        <span class="comment">// 如果在 source 数组中找到了 target 数组的第一个字符，则继续查找 target 数组的剩余部分是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> j + targetCount - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> targetOffset + <span class="number">1</span>; j &lt; end &amp;&amp; source[j]</span><br><span class="line">                    == target[k]; j++, k++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 target 数组全部匹配，则返回在 source 数组中的位置索引</span></span><br><span class="line">            <span class="keyword">if</span> (j == end) &#123;</span><br><span class="line">                <span class="comment">/* Found whole string. */</span></span><br><span class="line">                <span class="keyword">return</span> i - sourceOffset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有找到 target 数组，则返回-1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看示例。</p>
<p>①、示例1：查找子字符串的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str.indexOf(<span class="string">&quot;world&quot;</span>);  <span class="comment">// 查找 &quot;world&quot; 子字符串在 str 中第一次出现的位置</span></span><br><span class="line">System.out.println(index);        <span class="comment">// 输出 7</span></span><br></pre></td></tr></table></figure>

<p>②、示例2：查找字符串中某个字符的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str.indexOf(<span class="string">&quot;,&quot;</span>);     <span class="comment">// 查找逗号在 str 中第一次出现的位置</span></span><br><span class="line">System.out.println(index);        <span class="comment">// 输出 5</span></span><br></pre></td></tr></table></figure>

<p>③、示例3：查找子字符串的位置（从指定位置开始查找）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> str.indexOf(<span class="string">&quot;l&quot;</span>, <span class="number">3</span>);  <span class="comment">// 从索引为3的位置开始查找 &quot;l&quot; 子字符串在 str 中第一次出现的位置</span></span><br><span class="line">System.out.println(index);        <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>

<p>④、示例4：查找多个子字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> str.indexOf(<span class="string">&quot;o&quot;</span>);    <span class="comment">// 查找 &quot;o&quot; 子字符串在 str 中第一次出现的位置</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index2</span> <span class="operator">=</span> str.indexOf(<span class="string">&quot;o&quot;</span>, <span class="number">5</span>); <span class="comment">// 从索引为5的位置开始查找 &quot;o&quot; 子字符串在 str 中第一次出现的位置</span></span><br><span class="line">System.out.println(index1);       <span class="comment">// 输出 4</span></span><br><span class="line">System.out.println(index2);       <span class="comment">// 输出 8</span></span><br></pre></td></tr></table></figure>

<h4 id="类的其他方法"><a href="#类的其他方法" class="headerlink" title="类的其他方法"></a>类的其他方法</h4><p>比如说 <code>length()</code> 用于返回字符串长度。</p>
<p>比如说 <code>isEmpty()</code> 用于判断字符串是否为空。</p>
<p>比如说 <code>charAt()</code> 用于返回指定索引处的字符。</p>
<p>比如说 <code>getBytes()</code> 用于返回字符串的字节数组，可以指定编码方式，比如说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>;</span><br><span class="line">System.out.println(Arrays.toString(text.getBytes(StandardCharsets.UTF_8)));</span><br></pre></td></tr></table></figure>

<p>比如说 <code>trim()</code> 用于去除字符串两侧的空白字符，来看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">trim</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> value.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">st</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>[] val = value;    <span class="comment">/* avoid getfield opcode */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[st] &lt;= <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">        st++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[len - <span class="number">1</span>] &lt;= <span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((st &gt; <span class="number">0</span>) || (len &lt; value.length)) ? substring(st, len) : <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="string字符串为什么不可变"><a href="#string字符串为什么不可变" class="headerlink" title="string字符串为什么不可变"></a>string字符串为什么不可变</h3><p>String 可能是 Java 中使用频率最高的引用类型了，因此 String 类的设计者可以说是用心良苦。</p>
<p>比如说 String 的不可变性。</p>
<ul>
<li>String 类被 final 关键字修饰，所以它不会有子类，这就意味着没有子类可以重写它的方法，改变它的行为。</li>
<li>String 类的数据存储在 <code>char[]</code> 数组中，而这个数组也被 final 关键字修饰了，这就表示 String 对象是没法被修改的，只要初始化一次，值就确定了。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么这样写，有什么好处呢。</p>
<p>第一，可以保证 String 对象的安全性，避免被篡改，毕竟像密码这种隐私信息一般就是用字符串存储的。</p>
<p>以下是一个简单的 Java 示例，演示了字符串的不可变性如何有助于保证 String 对象的安全性。在本例中，我们创建了一个简单的 User 类，该类使用 String 类型的字段存储用户名和密码。同时，我们使用一个静态方法 getUserCredentials 从外部获取用户凭据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">        <span class="built_in">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringSecurityExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;小u&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(username, password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取用户凭据</span></span><br><span class="line">        String[] credentials = getUserCredentials(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试修改从 getUserCredentials 返回的用户名和密码字符串</span></span><br><span class="line">        credentials[<span class="number">0</span>] = <span class="string">&quot;小李&quot;</span>;</span><br><span class="line">        credentials[<span class="number">1</span>] = <span class="string">&quot;612311&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出原始 User 对象中的用户名和密码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原始用户名: &quot;</span> + user.getUsername());</span><br><span class="line">        System.out.println(<span class="string">&quot;原始密码: &quot;</span> + user.getPassword());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] getUserCredentials(User user) &#123;</span><br><span class="line">        String[] credentials = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">2</span>];</span><br><span class="line">        credentials[<span class="number">0</span>] = user.getUsername();</span><br><span class="line">        credentials[<span class="number">1</span>] = user.getPassword();</span><br><span class="line">        <span class="keyword">return</span> credentials;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，尽管我们尝试修改 getUserCredentials 返回的字符串数组（即用户名和密码），但原始 User 对象中的用户名和密码保持不变。这证明了字符串的不可变性有助于保护 String 对象的安全性。</p>
<p>第二，保证哈希值不会频繁变更。毕竟要经常作为哈希表的键值，经常变更的话，哈希表的性能就会很差劲。</p>
<p>在 String 类中，哈希值是在第一次计算时缓存的，后续对该哈希值的请求将直接使用缓存值。这有助于提高哈希表等数据结构的性能。以下是一个简单的示例，演示了字符串的哈希值缓存机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">text1</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">text2</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算字符串 text1 的哈希值，此时会进行计算并缓存哈希值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">hashCode1</span> <span class="operator">=</span> text1.hashCode();</span><br><span class="line">System.out.println(<span class="string">&quot;第一次计算 text1 的哈希值: &quot;</span> + hashCode1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次计算字符串 text1 的哈希值，此时直接返回缓存的哈希值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">hashCode1Cached</span> <span class="operator">=</span> text1.hashCode();</span><br><span class="line">System.out.println(<span class="string">&quot;第二次计算: &quot;</span> + hashCode1Cached);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算字符串 text2 的哈希值，由于字符串常量池的存在，实际上 text1 和 text2 指向同一个字符串对象</span></span><br><span class="line"><span class="comment">// 所以这里直接返回缓存的哈希值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">hashCode2</span> <span class="operator">=</span> text2.hashCode();</span><br><span class="line">System.out.println(<span class="string">&quot;text2 直接使用缓存: &quot;</span> + hashCode2);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了两个具有相同内容的字符串 text1 和 text2。首次计算 text1 的哈希值时，会进行实际计算并缓存该值。当我们再次计算 text1 的哈希值或计算具有相同内容的 text2 的哈希值时，将直接返回缓存的哈希值，而不进行重新计算。</p>
<p>由于 String 对象是不可变的，其哈希值在创建后不会发生变化。这使得 String 类可以缓存哈希值，提高哈希表等数据结构的性能。如果 String 是可变的，那么在每次修改时都需要重新计算哈希值，这会降低性能。</p>
<p>第三，可以实现字符串常量池，Java 会将相同内容的字符串存储在字符串常量池中。这样，具有相同内容的字符串变量可以指向同一个 String 对象，节省内存空间。</p>
<p>“由于字符串的不可变性，String 类的一些方法实现最终都返回了新的字符串对象。”</p>
<p>“就拿 <code>substring()</code> 方法来说。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">subLen</span> <span class="operator">=</span> value.length - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="built_in">this</span> : <span class="keyword">new</span> <span class="title class_">String</span>(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>substring()</code> 方法用于截取字符串，最终返回的都是 new 出来的新字符串对象。</p>
<p>“还有 <code>concat()</code> 方法。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">concat</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">olen</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="keyword">if</span> (olen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (coder() == str.coder()) &#123;</span><br><span class="line">        <span class="type">byte</span>[] val = <span class="built_in">this</span>.value;</span><br><span class="line">        <span class="type">byte</span>[] oval = str.value;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> val.length + oval.length;</span><br><span class="line">        <span class="type">byte</span>[] buf = Arrays.copyOf(val, len);</span><br><span class="line">        System.arraycopy(oval, <span class="number">0</span>, buf, val.length, oval.length);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, coder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> length();</span><br><span class="line">    <span class="type">byte</span>[] buf = StringUTF16.newBytesFor(len + olen);</span><br><span class="line">    getBytes(buf, <span class="number">0</span>, UTF16);</span><br><span class="line">    str.getBytes(buf, len, UTF16);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, UTF16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>concat()</code> 方法用于拼接字符串，不管编码是否一致，最终也返回的是新的字符串对象。</p>
<p>“<code>replace()</code> 替换方法其实也一样，你可以自己一会看一下源码，也是返回新的字符串对象。”</p>
<p>“这就意味着，不管是截取、拼接，还是替换，都不是在原有的字符串上进行的，而是重新生成了新的字符串对象。也就是说，这些操作执行过后，<strong>原来的字符串对象并没有发生改变</strong>。”</p>
<p><strong>线程安全</strong></p>
<p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>
<p><strong>String Pool 的需要</strong></p>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400182.png" alt="img"></p>
<p>string pool也叫做字符串常量值，这个之后会介绍的。</p>
<h3 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h3><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 和 s2.intern() 方法取得同一个字符串引用。intern() 首先把 “aaa” 放到 String Pool 中，然后返回这个字符串引用，因此 s3 和 s4 引用的是同一个字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);           <span class="comment">// false</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s2.intern();</span><br><span class="line">System.out.println(s3 == s4);           <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">System.out.println(s5 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<h3 id="String-StringBuffer-and-StringBuilder"><a href="#String-StringBuffer-and-StringBuilder" class="headerlink" title="String, StringBuffer and StringBuilder"></a>String, StringBuffer and StringBuilder</h3><p><strong>1. 可变性</strong></p>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<p><strong>2. 线程安全</strong></p>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<p>下面来看他们的用法</p>
<p>由于字符串是不可变的，所以当遇到字符串拼接(尤其是使用<code>+</code>号操作符）的时候，就需要考量性能的问题，你不能毫无顾虑地生产太多 String 对象，对珍贵的内存造成不必要的压力。</p>
<p>于是 Java 就设计了一个专门用来解决此问题的 StringBuffer 类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuffer</span> <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, CharSequence &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，由于 StringBuffer 操作字符串的方法加了 <code>synchronized</code> 关键字进行了同步，主要是考虑到多线程环境下的安全问题，所以执行效率会比较低。</p>
<p>于是 Java 就给 StringBuffer “生了个兄弟”，名叫 StringBuilder，说，“孩子，你别管线程安全了，你就在单线程环境下使用，这样效率会高得多，如果要在多线程环境下修改字符串，你到时候可以使用 <code>ThreadLocal</code>来避免多线程冲突。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">StringBuilder</span> <span class="keyword">extends</span> <span class="title class_">AbstractStringBuilder</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, CharSequence</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Create a copy, don&#x27;t share the array</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了类名不同，方法没有加 synchronized，基本上完全一样。</p>
<p>实际开发中，StringBuilder 的使用频率也是远高于 StringBuffer，甚至可以这么说，StringBuilder 完全取代了 StringBuffer。</p>
<p>stringBuilder可以看做是一个容器。创建之后里面的内容是可变的。</p>
<ul>
<li>作用：提高字符串的操作效率</li>
</ul>
<p>构造方法</p>
<ul>
<li>空参构造</li>
<li>有参数</li>
</ul>
<p>常用方法</p>
<ul>
<li>append添加</li>
<li>reverse反转</li>
<li>length返回长度</li>
<li>toString可以把StringBulider变成String</li>
</ul>
<p>下面来看具体的几个案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 字符串;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a12StringBulider</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;你是傻逼&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素</span></span><br><span class="line">        sb.append(<span class="number">1</span>);</span><br><span class="line">        sb.append(<span class="number">2.3</span>);</span><br><span class="line">        sb.append(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="comment">//获取长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        System.out.println(length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//java在底层对他做了一些特殊处理。</span></span><br><span class="line">        <span class="comment">//打印对象不是地址值而是属性值</span></span><br><span class="line">        System.out.println(sb);</span><br><span class="line">        <span class="comment">//变回字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后总结一下，一般会用到StringBuilder的场景就是</p>
<ul>
<li>字符串的拼接</li>
<li>字符串的反转</li>
</ul>
<h3 id="new-String-“abc”"><a href="#new-String-“abc”" class="headerlink" title="new String(“abc”)"></a>new String(“abc”)</h3><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。</p>
<ul>
<li>“abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewStringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 javap -verbose 进行反编译，得到以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">Constant pool:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">   ##<span class="number">2</span> = Class              ##<span class="number">18</span>            <span class="comment">// java/lang/String</span></span><br><span class="line">   ##<span class="number">3</span> = String             ##<span class="number">19</span>            <span class="comment">// abc</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  ##<span class="number">18</span> = Utf8               java/lang/String</span><br><span class="line">  ##<span class="number">19</span> = Utf8               abc</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           ##<span class="number">2</span>                  <span class="comment">// class java/lang/String</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: ldc           ##<span class="number">3</span>                  <span class="comment">// String abc</span></span><br><span class="line">         <span class="number">6</span>: invokespecial ##<span class="number">4</span>                  <span class="comment">// Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">9</span>: astore_1</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>在 Constant Pool 中，##19 存储这字符串字面量 “abc”，##3 是 String Pool 的字符串对象，它指向 ##19 这个字符串字面量。在 main 方法中，0: 行使用 new ##2 在堆中创建一个字符串对象，并且使用 ldc ##3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(String original)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = original.value;</span><br><span class="line">    <span class="built_in">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Java-字符串优化：详解-String-intern-方法"><a href="#Java-字符串优化：详解-String-intern-方法" class="headerlink" title="Java 字符串优化：详解 String.intern() 方法"></a>Java 字符串优化：详解 String.intern() 方法</h3><p>这个是美团技术团队深入的一个东西</p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">深入解析String##intern - 美团技术团队 (meituan.com)</a></p>
<p>原网址在这里。</p>
<p>要理解美团技术团队的这篇文章，你只需要记住这几点内容：</p>
<p>第一，使用双引号声明的字符串对象会保存在字符串常量池中。</p>
<p>第二，使用 new 关键字创建的字符串对象会先从字符串常量池中找，如果没找到就创建一个，然后再在堆中创建字符串对象；如果找到了，就直接在堆中创建字符串对象。</p>
<p>第三，针对没有使用双引号声明的字符串对象来说，就像下面代码中的 s1 那样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;java&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;你好&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>如果想把 s1 的内容也放入字符串常量池的话，可以调用 <code>intern()</code> 方法来完成。</p>
<p>不过，需要注意的是，Java 7 的时候，字符串常量池从永久代中移动到了堆中，虽然此时永久代还没有完全被移除。Java 8 的时候，永久代被彻底移除。</p>
<p>这个变化也直接影响了 <code>String.intern()</code> 方法在执行时的策略，Java 7 之前，执行 <code>String.intern()</code> 方法的时候，不管对象在堆中是否已经创建，字符串常量池中仍然会创建一个内容完全相同的新对象； Java 7 之后呢，由于字符串常量池放在了堆中，执行 <code>String.intern()</code> 方法的时候，如果对象在堆中已经创建了，字符串常量池中就不需要再创建新的对象了，而是直接保存堆中对象的引用，也就节省了一部分的内存空间。</p>
<p>例如下面的这个代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;java你好&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">System.out.println(s1 == s2);</span><br></pre></td></tr></table></figure>

<p>第一行代码，字符串常量池中会先创建一个“java你好”的对象，然后堆中会再创建一个“java你好”的对象，s1 引用的是堆中的对象。</p>
<p>第二行代码，对 s1 执行 <code>intern()</code> 方法，该方法会从字符串常量池中查找“java你好”这个字符串是否存在，此时是存在的，所以 s2 引用的是字符串常量池中的对象。</p>
<p>也就意味着 s1 和 s2 的引用地址是不同的，一个来自堆，一个来自字符串常量池，所以输出的结果为 false。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>

<p>再看下面这个代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;java&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s1.intern();</span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个输出结果就是true了。</p>
<h3 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h3><p>StringJoiner其实和StringBuilder一样，也可以看成是一个容器。</p>
<p>作用：提高字符串的操作效率，代码编写特别简单。但是目前市场上很少有人用(因为这个是在jdk8之后才有的)</p>
<p>他的构造方法。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400249.png" alt="image-20230615151118413"></p>
<p>之后看他的成员方法</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400388.png" alt="image-20230615151125636"></p>
<p>看他一个简单的应用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 字符串;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a14StringJoiner</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        StringJoiner sj=<span class="keyword">new</span> <span class="title class_">StringJoiner</span>(<span class="string">&quot;---&quot;</span>);</span><br><span class="line">        sj.add(<span class="string">&quot;add&quot;</span>).add(<span class="string">&quot;bbb&quot;</span>).add(<span class="string">&quot;ccc&quot;</span>);</span><br><span class="line">        System.out.println(sj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里就不做过多的介绍了。</p>
<h3 id="字符串相等判断：Java中的equals-与-的区别与用法"><a href="#字符串相等判断：Java中的equals-与-的区别与用法" class="headerlink" title="字符串相等判断：Java中的equals()与&#x3D;&#x3D;的区别与用法"></a>字符串相等判断：Java中的equals()与&#x3D;&#x3D;的区别与用法</h3><p>“这个问题看似简单，却在 Stack Overflow 上有超过 370 万+的访问量。”我说，“这个问题也可以引申为 <code>.equals()</code> 和 ‘&#x3D;&#x3D;’ 操作符有什么区别。”</p>
<ul>
<li>“&#x3D;&#x3D;”操作符用于比较两个对象的地址是否相等。</li>
<li><code>.equals()</code> 方法用于比较两个对象的内容是否相等。</li>
</ul>
<p><code>.equals()</code> 就好像我们普通人，看见阿丽塔以为是洛丽塔，看见洛丽塔以为是阿丽塔，看起来一样就觉得她们是同一个人；“&#x3D;&#x3D;”操作符就好像她们的妈妈，要求更严格，观察更细致，一眼就能分辨出谁是姐姐谁是妹妹。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">alita</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;小萝莉&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">luolita</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;小萝莉&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(alita.equals(luolita)); <span class="comment">// true</span></span><br><span class="line">System.out.println(alita == luolita); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>就上面这段代码来说，<code>.equals()</code> 输出的结果为 true，而“&#x3D;&#x3D;”操作符输出的结果为 false——前者要求内容相等就可以，后者要求必须是同一个对象。</p>
<p>之前已经学过了，Java 的所有类都默认地继承 Object 这个超类，该类有一个名为 <code>.equals()</code> 的方法。一边说，我一边打开了 Object 类的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你看，Object 类的 <code>.equals()</code> 方法默认采用的是“&#x3D;&#x3D;”操作符进行比较。假如子类没有重写该方法的话，那么“&#x3D;&#x3D;”操作符和 <code>.equals()</code> 方法的功效就完全一样——比较两个对象的内存地址是否相等。</p>
<p>但实际情况中，有不少类重写了 <code>.equals()</code> 方法，因为比较内存地址的要求比较严格，不太符合现实中所有的场景需求。拿 String 类来说，我们在比较字符串的时候，的确只想判断它们俩的内容是相等的就可以了，并不想比较它们俩是不是同一个对象。</p>
<p>况且，字符串有字符串常量池的概念，本身就推荐使用 <code>String s = &quot;字符串&quot;</code> 这种形式来创建字符串对象，而不是通过 new 关键字的方式，因为可以把字符串缓存在字符串常量池中，方便下次使用，不用遇到 new 就在堆上开辟一块新的空间。</p>
<p>那就来看一下 String 类的 <code>.equals()</code> 方法的源码吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">aString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="keyword">if</span> (coder() == aString.coder()) &#123;</span><br><span class="line">            <span class="keyword">return</span> isLatin1() ? StringLatin1.equals(value, aString.value)</span><br><span class="line">                    : StringUTF16.equals(value, aString.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，如果两个字符串对象的可以“&#x3D;&#x3D;”，那就直接返回 true 了，因为这种情况下，字符串内容是必然相等的。否则就按照字符编码进行比较，分为 UTF16 和 Latin1，差别不是很大，就拿 Latin1 的来说吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(<span class="type">byte</span>[] value, <span class="type">byte</span>[] other)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value.length == other.length) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value[i] != other[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个 JDK 版本是 Java 17，也就是最新的 LTS（长期支持）版本。该版本中，String 类使用字节数组实现的，所以比较两个字符串的内容是否相等时，可以先比较字节数组的长度是否相等，不相等就直接返回 false；否则就遍历两个字符串的字节数组，只有有一个字节不相等，就返回 false。</p>
<p>这是 Java 8 中的 equals 方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否为同一对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断对象是否为 String 类型</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="comment">// 判断字符串长度是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 判断每个字符是否相等</span></span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK 8 比 JDK 17 更容易懂一些：首先判断两个对象是否为同一个对象，如果是，则返回 true。接着，判断对象是否为 String 类型，如果不是，则返回 false。如果对象为 String 类型，则比较两个字符串的长度是否相等，如果长度不相等，则返回 false。如果长度相等，则逐个比较每个字符是否相等，如果都相等，则返回 true，否则返回 false。</p>
<p>“如果要进行两个字符串对象的内容比较，除了 <code>.equals()</code> 方法，还有其他两个可选的方案。”</p>
<p>1）<code>Objects.equals()</code></p>
<p><code>Objects.equals()</code> 这个静态方法的优势在于不需要在调用之前判空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="literal">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果直接使用 <code>a.equals(b)</code>，则需要在调用之前对 a 进行判空，否则可能会抛出空指针 <code>java.lang.NullPointerException</code>。<code>Objects.equals()</code> 用起来就完全没有这个担心。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Objects.equals(<span class="string">&quot;小萝莉&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;小&quot;</span> + <span class="string">&quot;萝莉&quot;</span>)) <span class="comment">// --&gt; true</span></span><br><span class="line">Objects.equals(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;小&quot;</span> + <span class="string">&quot;萝莉&quot;</span>)); <span class="comment">// --&gt; false</span></span><br><span class="line">Objects.equals(<span class="literal">null</span>, <span class="literal">null</span>) <span class="comment">// --&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">a.equals(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;小&quot;</span> + <span class="string">&quot;萝莉&quot;</span>)); <span class="comment">// throw exception</span></span><br></pre></td></tr></table></figure>



<p>2）String 类的 <code>.contentEquals()</code></p>
<p><code>.contentEquals()</code> 的优势在于可以将字符串与任何的字符序列（StringBuffer、StringBuilder、String、CharSequence）进行比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contentEquals</span><span class="params">(CharSequence cs)</span> &#123;</span><br><span class="line">    <span class="comment">// Argument is a StringBuffer, StringBuilder</span></span><br><span class="line">    <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> AbstractStringBuilder) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> StringBuffer) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(cs) &#123;</span><br><span class="line">                <span class="keyword">return</span> nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nonSyncContentEquals((AbstractStringBuilder)cs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Argument is a String</span></span><br><span class="line">    <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="keyword">return</span> equals(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Argument is a generic CharSequence</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cs.length();</span><br><span class="line">    <span class="keyword">if</span> (n != length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">byte</span>[] val = <span class="built_in">this</span>.value;</span><br><span class="line">    <span class="keyword">if</span> (isLatin1()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((val[i] &amp; <span class="number">0xff</span>) != cs.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!StringUTF16.contentEquals(val, cs, n)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码上可以看得出，如果 cs 是 StringBuffer，该方法还会进行同步，非常的智能化；如果是 String 的话，其实调用的还是 <code>equals()</code> 方法。当然了，这也就意味着使用该方法进行比较的时候，多出来了很多步骤，性能上有些损失。</p>
<p>同样来看一下 JDK 8 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contentEquals</span><span class="params">(CharSequence cs)</span> &#123;</span><br><span class="line">    <span class="comment">// argument can be any CharSequence implementation</span></span><br><span class="line">    <span class="keyword">if</span> (cs.length() != value.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Argument is a StringBuffer, StringBuilder or String</span></span><br><span class="line">    <span class="keyword">if</span> (cs <span class="keyword">instanceof</span> AbstractStringBuilder) &#123;</span><br><span class="line">        <span class="type">char</span> v1[] = value;</span><br><span class="line">        <span class="type">char</span> v2[] = ((AbstractStringBuilder)cs).getValue();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Argument is a String</span></span><br><span class="line">    <span class="keyword">if</span> (cs.equals(<span class="built_in">this</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// Argument is a non-String, non-AbstractStringBuilder CharSequence</span></span><br><span class="line">    <span class="type">char</span> v1[] = value;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">    <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v1[i] != cs.charAt(i))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样更容易理解一些：首先判断参数长度是否相等，不相等则返回 false。如果参数是 AbstractStringBuilder 的实例，则取出其 char 数组，遍历比较两个 char 数组的每个元素是否相等。如果参数是 String 的实例，则直接调用 equals 方法比较两个字符串是否相等。如果参数是其他实现了 CharSequence 接口的对象，则遍历比较两个对象的每个字符是否相等。</p>
<p>总体上感觉还是 <code>Objects.equals()</code> 比较舒服</p>
<p>下面来看几个例字，这些也是一作为面试，经常会考到的一些小题目。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;小萝莉&quot;</span>).equals(<span class="string">&quot;小萝莉&quot;</span>)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;小萝莉&quot;</span>) == <span class="string">&quot;小萝莉&quot;</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;小萝莉&quot;</span>) == <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;小萝莉&quot;</span>)</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;小萝莉&quot;</span> == <span class="string">&quot;小萝莉&quot;</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;小萝莉&quot;</span> == <span class="string">&quot;小&quot;</span> + <span class="string">&quot;萝莉&quot;</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>第一行代码的结果为<code>true</code>，因为<code>equals()</code>方法比较的是字符串的内容，而两个字符串的内容都是相同的。</p>
<p>第二行代码的结果为<code>false</code>，因为使用<code>new</code>关键字创建的字符串对象是在堆内存中创建的，而使用双引号创建的字符串是在常量池中创建的，两者在内存中的地址不同，因此比较结果为<code>false</code>。</p>
<p>第三行代码的结果为<code>false</code>，因为使用<code>new</code>关键字创建的两个字符串对象在内存中的地址不同，因此比较结果为<code>false</code>。</p>
<p>第四行代码的结果为<code>true</code>，因为使用双引号创建的两个字符串都是在常量池中创建的，并且内容相同，因此比较结果为<code>true</code>。</p>
<p>第五行代码的结果为<code>true</code>，因为使用双引号创建的字符串都是在常量池中创建的，而<code>&quot;小&quot; + &quot;萝莉&quot;</code>会在编译期间被优化为<code>&quot;小萝莉&quot;</code>，因此比较结果为<code>true</code>。</p>
<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><p>说了这么多，我们来看几个实际的练习，来进行巩固</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400624.png" alt="image-20230615152328622"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 字符串;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.StringJoiner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a15</span>罗马数字的俩种写法 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.键盘录用</span></span><br><span class="line">        Scanner sc=<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        String str;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入一个字符串&quot;</span>);</span><br><span class="line">            str = sc.next();</span><br><span class="line">            <span class="comment">//字符串验证</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> checkStr(str);</span><br><span class="line">            <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;当前字符串不符合规则&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb=<span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">//变换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="type">int</span> number=c-<span class="number">48</span>;<span class="comment">//字符和数字的转换</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> changeLuoMa(number);</span><br><span class="line">            sb.append(s+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">changeLuoMa</span><span class="params">(<span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="comment">//定义数组</span></span><br><span class="line">        String arr[]=&#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;I&quot;</span>,<span class="string">&quot;II&quot;</span>,<span class="string">&quot;III&quot;</span>,<span class="string">&quot;IIII&quot;</span>,<span class="string">&quot;V&quot;</span>,<span class="string">&quot;VI&quot;</span>,<span class="string">&quot;VII&quot;</span>,<span class="string">&quot;VIII&quot;</span>,<span class="string">&quot;VIIII&quot;</span>,<span class="string">&quot;X&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> arr[number];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkStr</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="comment">//长度</span></span><br><span class="line">        <span class="keyword">if</span> (str.length()&gt;<span class="number">9</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只能是数字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c&lt;<span class="string">&#x27;0&#x27;</span>||c&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面我们来解析一下这个代码：</p>
<p>这段代码实现了将输入的阿拉伯数字字符串转换为对应的罗马数字字符串的功能。具体实现过程如下：</p>
<ol>
<li><p>首先通过<code>Scanner</code>类从控制台读入一个字符串，然后调用<code>checkStr()</code>方法验证输入的字符串是否符合规则，如果不符合规则则重新输入，直到输入符合规则为止。</p>
</li>
<li><p>接着使用<code>StringBuilder</code>类创建一个字符串缓冲区，遍历输入的字符串中的每个字符，将字符转换为对应的数字，再调用<code>changeLuoMa()</code>方法将数字转换为对应的罗马数字字符串，将转换后的字符串添加到字符串缓冲区中。</p>
</li>
<li><p>最后输出字符串缓冲区中的所有字符串，即为对应的罗马数字字符串。</p>
</li>
</ol>
<p>其中<code>changeLuoMa()</code>方法实现了将数字转换为对应的罗马数字字符串的功能，使用了一个字符串数组来存储1~10的罗马数字字符串，根据输入的数字返回对应的罗马数字字符串。</p>
<p><code>checkStr()</code>方法用于验证输入的字符串是否符合规则，规则为只能包含数字字符，且长度不能超过9个字符。</p>
<p>整个程序实现简单，通过方法的封装和调用，使得代码的可读性和可维护性都得到了提高。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071400667.png" alt="image-20230615152950182"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 字符串;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a16</span>给定字符串 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String strA=<span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">        String strB=<span class="string">&quot;bcdea&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> result=check(strA,strB);</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String strA,String strB)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strA.length(); i++) &#123;</span><br><span class="line">            strA=rotate(strA);</span><br><span class="line">            <span class="keyword">if</span> (strA.equals(strB))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把左侧字符移动到右侧去</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">rotate</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="comment">//解决方法：</span></span><br><span class="line">        <span class="comment">//1.substring进行截取。</span></span><br><span class="line">        <span class="comment">//2.可以把字符串变成一个字符数组</span></span><br><span class="line">            <span class="comment">//截取字符</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">first</span> <span class="operator">=</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">end</span> <span class="operator">=</span> str.substring(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>  end+first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>这段代码实现了判断两个字符串是否为旋转字符串的功能。具体实现过程如下：</p>
<ol>
<li><p>首先定义两个字符串<code>strA</code>和<code>strB</code>，分别为原始字符串和待判断的字符串。</p>
</li>
<li><p>调用<code>check()</code>方法，该方法使用循环将<code>strA</code>字符串向左旋转，每次旋转后判断旋转后的字符串是否和<code>strB</code>相等，如果相等则返回<code>true</code>，否则继续旋转。</p>
</li>
<li><p><code>rotate()</code>方法用于将字符串向左旋转一位，具体实现方式为将字符串的第一个字符移到字符串的末尾，然后返回旋转后的字符串。</p>
</li>
<li><p>最后输出<code>check()</code>方法的返回值，即为判断结果。</p>
</li>
</ol>
<p>整个程序实现简单，通过方法的封装和调用，使得代码的可读性和可维护性都得到了提高。</p>
<h2 id="总结-后记"><a href="#总结-后记" class="headerlink" title="总结 &amp; 后记"></a>总结 &amp; 后记</h2><p>全书写到这里，也是42000字了，首先说明，这个里面很多都是借鉴了一些厉害的程序员的博客，以及官方文档，以及一些技术上的分析。这里面说的，很多都涉及到了底层源码之类的，如果有错误的情况，你可以联系我的邮箱来说明错误,<a href="mailto:&#51;&#49;&#53;&#x33;&#x35;&#54;&#54;&#x39;&#x31;&#x33;&#64;&#113;&#113;&#46;&#x63;&#111;&#109;">&#51;&#49;&#53;&#x33;&#x35;&#54;&#54;&#x39;&#x31;&#x33;&#64;&#113;&#113;&#46;&#x63;&#111;&#109;</a>。这个整体的写下来，说实话我觉得，适合一些有java基础的人去看这些东西，而不是0基础的，对于0基础的，如果你看完这个后，非常的懵，感觉什么也没有学到，什么也没有记住，你可以去看黑马的java从入门到起飞，那里面虽然知识不够深，但也算是一个非常好理解的入门视频，包括韩顺平的基础，也是非常经典的一个视频。有兴趣的都可以去查看。最后我想说，如果入门java，光了解这些东西，是远远不够的，需要去学习更多的知识，同时，我也追寻着其他人的脚步，不断的去优化我的知识体系。</p>
<p>2023年6月15日，这本书正式完结，v1.0版本。之后会更新java面向对象，当然这个就是之后的事情了，可能一个月后，可能更久。因为最近在学一些算法。当然，之后我也会出算法之类的总结的。就这样，有缘再见。</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">小u</div><div class="post-copyright__author_desc">热爱可抵岁月漫长</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2023/10/01/codenotes/Java/java%E5%9F%BA%E7%A1%80/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2023/10/01/codenotes/Java/java%E5%9F%BA%E7%A1%80/')">java基础</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2023/10/01/codenotes/Java/java%E5%9F%BA%E7%A1%80/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=java基础&amp;url=http://example.com/2023/10/01/codenotes/Java/java%E5%9F%BA%E7%A1%80/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>java<span class="tagsPageCount">12</span></a><a class="post-meta__box__tags" href="/tags/javaSE/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>javaSE<span class="tagsPageCount">3</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/01/codenotes/Java/coder/1/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">如何打造高效的学习环境</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/01/codenotes/Java/spring6/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Spring6</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/10/01/codenotes/Java/qf/2/" title="重学java第一阶段(下)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">重学java第一阶段(下)</div></div></a></div><div><a href="/2023/10/01/codenotes/Java/qf/1/" title="重学java第一阶段(上)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">重学java第一阶段(上)</div></div></a></div><div><a href="/2023/10/01/codenotes/Java/JDK%E6%96%B0%E7%89%B9%E6%80%A7/" title="JDK9~JDK17新特性"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">JDK9~JDK17新特性</div></div></a></div><div><a href="/2023/10/01/codenotes/Java/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="java面向对象"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">java面向对象</div></div></a></div><div><a href="/2023/10/01/codenotes/Java/spring6/" title="Spring6"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">Spring6</div></div></a></div><div><a href="/2023/10/01/codenotes/other/clean-code/" title="《代码整洁之道》"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">《代码整洁之道》</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" ait="status"/></div></div><div class="author-info__description">Java,java,springboot,mysql,redis,教程,git,软件,编程,开发,互联网,Java 基础,Java 教程,Java程序员进阶之路,Java 入门,Vue,前端,算法</div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎来看我的博客 博客主地址：http://blog.xiaou61.top/  备用地址：https://newblog.guoyaxue.top/</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java"><span class="toc-number">1.</span> <span class="toc-text">Java</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E6%A6%82%E8%BF%B0%E4%BB%A5%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">2.</span> <span class="toc-text">java概述以及环境变量的配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9java"><span class="toc-number">2.1.</span> <span class="toc-text">为什么选择java</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88java%E6%9C%80%E5%B9%BF%E6%B3%9B"><span class="toc-number">2.2.</span> <span class="toc-text">为什么java最广泛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E7%AE%80%E4%BB%8B"><span class="toc-number">2.3.</span> <span class="toc-text">java简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Ejava%E7%9A%84%E5%B8%B8%E8%A7%81%E8%AF%AF%E8%A7%A3"><span class="toc-number">2.4.</span> <span class="toc-text">关于java的常见误解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">java语法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AAjava%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.1.</span> <span class="toc-text">第一个java程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">3.3.</span> <span class="toc-text">java标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.4.</span> <span class="toc-text">java修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%8F%98%E9%87%8F"><span class="toc-number">3.5.</span> <span class="toc-text">java变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">3.6.</span> <span class="toc-text">java关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#final"><span class="toc-number">3.6.1.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static"><span class="toc-number">3.6.2.</span> <span class="toc-text">static</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E6%B3%A8%E9%87%8A"><span class="toc-number">3.7.</span> <span class="toc-text">java注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.8.</span> <span class="toc-text">java数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#01%E3%80%81%E6%AF%94%E7%89%B9%E5%92%8C%E5%AD%97%E8%8A%82"><span class="toc-number">3.8.1.</span> <span class="toc-text">01、比特和字节</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89bit%EF%BC%88%E6%AF%94%E7%89%B9%EF%BC%89"><span class="toc-number">3.8.1.1.</span> <span class="toc-text">1）bit（比特）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89Byte%EF%BC%88%E5%AD%97%E8%8A%82%EF%BC%89"><span class="toc-number">3.8.1.2.</span> <span class="toc-text">2）Byte（字节）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#02-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.8.2.</span> <span class="toc-text">02.基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="toc-number">3.8.2.1.</span> <span class="toc-text">整型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-number">3.8.2.2.</span> <span class="toc-text">浮点型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.8.2.3.</span> <span class="toc-text">布尔类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9E%8B"><span class="toc-number">3.8.2.4.</span> <span class="toc-text">字符串型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#03%E3%80%81%E5%8D%95%E7%B2%BE%E5%BA%A6%E5%92%8C%E5%8F%8C%E7%B2%BE%E5%BA%A6"><span class="toc-number">3.8.3.</span> <span class="toc-text">03、单精度和双精度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#04%E3%80%81%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.8.4.</span> <span class="toc-text">04、引用数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#05%E3%80%81%E6%A0%88%E5%92%8C%E5%A0%86"><span class="toc-number">3.8.5.</span> <span class="toc-text">05、栈和堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#06%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.8.6.</span> <span class="toc-text">06、数据类型之间的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#01%E3%80%81%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.8.6.1.</span> <span class="toc-text">01、自动类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#02%E3%80%81%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.8.6.2.</span> <span class="toc-text">02、强制类型转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#07%E3%80%81%E7%BC%93%E5%AD%98%E6%B1%A0"><span class="toc-number">3.8.7.</span> <span class="toc-text">07、缓存池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.</span> <span class="toc-text">java运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#01%E3%80%81%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.1.</span> <span class="toc-text">01、算术运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#02%E3%80%81%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.2.</span> <span class="toc-text">02、关系运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#03%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.3.</span> <span class="toc-text">03、位运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#04%E3%80%81%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.4.</span> <span class="toc-text">04、逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#05%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.5.</span> <span class="toc-text">05、赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#06%E3%80%81%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.9.6.</span> <span class="toc-text">06、三元运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#07%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.9.7.</span> <span class="toc-text">07、运算符优先级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.10.</span> <span class="toc-text">java流程控制语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#01%E3%80%81if-else-%E7%9B%B8%E5%85%B3"><span class="toc-number">3.10.1.</span> <span class="toc-text">01、if-else 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89if-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.10.1.1.</span> <span class="toc-text">1）if 语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89if-else-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.10.1.2.</span> <span class="toc-text">2）if-else 语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89if-else-if-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.10.1.3.</span> <span class="toc-text">3）if-else-if 语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%89if-%E5%B5%8C%E5%A5%97%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.10.1.4.</span> <span class="toc-text">4）if 嵌套语句</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#02%E3%80%81switch-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.10.2.</span> <span class="toc-text">02、switch 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#03%E3%80%81for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.10.3.</span> <span class="toc-text">03、for 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E6%99%AE%E9%80%9A-for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.10.3.1.</span> <span class="toc-text">1）普通 for 循环</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89for-each"><span class="toc-number">3.10.3.2.</span> <span class="toc-text">2）for-each</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E6%97%A0%E9%99%90-for-%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.10.3.3.</span> <span class="toc-text">3）无限 for 循环</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#04%E3%80%81while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.10.4.</span> <span class="toc-text">04、while 循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#05%E3%80%81do-while-%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.10.5.</span> <span class="toc-text">05、do-while 循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#06%E3%80%81break"><span class="toc-number">3.10.6.</span> <span class="toc-text">06、break</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#07%E3%80%81continue"><span class="toc-number">3.10.7.</span> <span class="toc-text">07、continue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#08%E3%80%81switch-case-%E8%AF%AD%E5%8F%A5"><span class="toc-number">3.10.8.</span> <span class="toc-text">08、switch case 语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">3.11.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9B%9E%E6%96%87%E6%95%B0%EF%BC%9A%E6%AD%A3%E5%BA%8F%E5%92%8C%E5%80%92%E5%BA%8F%E4%B8%80%E6%A0%B7%E7%9A%84%E6%95%B4%E6%95%B0"><span class="toc-number">3.11.1.</span> <span class="toc-text">1.*回文数：正序和倒序一样的整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BB%99%E5%AE%9A%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%EF%BC%8C%E8%A2%AB%E9%99%A4%E6%95%B0%E5%92%8C%E9%99%A4%E6%95%B0%EF%BC%8C%E5%B0%86%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9B%B8%E9%99%A4%EF%BC%8C%E8%A6%81%E6%B1%82%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E9%99%A4%E6%B3%95%E3%80%82%E4%B9%98%E6%B3%95%E5%92%8C%E5%8F%96%E4%BD%99"><span class="toc-number">3.11.2.</span> <span class="toc-text">2.给定两个整数，被除数和除数，将两个数相除，要求不能使用除法。乘法和取余</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.12.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.</span> <span class="toc-text">数组 &amp; 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.</span> <span class="toc-text">java数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.1.</span> <span class="toc-text">一维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.2.</span> <span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0java%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.3.</span> <span class="toc-text">打印java数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#stream-%E6%B5%81%E6%89%93%E5%8D%B0-Java-%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">stream 流打印 Java 数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#for-%E5%BE%AA%E7%8E%AF%E6%89%93%E5%8D%B0-Java-%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">for 循环打印 Java 数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Arrays-%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%89%93%E5%8D%B0-Java-%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.3.3.</span> <span class="toc-text">Arrays 工具类打印 Java 数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB%E6%89%93%E5%8D%B0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.3.4.</span> <span class="toc-text">Arrays工具类打印二维数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#POJO-%E7%9A%84%E6%89%93%E5%8D%B0%E8%A7%84%E7%BA%A6"><span class="toc-number">4.1.3.5.</span> <span class="toc-text">POJO 的打印规约</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-String%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">Java String类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.1.1.</span> <span class="toc-text">创建字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="toc-number">5.1.2.</span> <span class="toc-text">字符串长度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">String 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E8%AF%BBString%E6%BA%90%E7%A0%81"><span class="toc-number">5.3.</span> <span class="toc-text">解读String源码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">5.3.1.</span> <span class="toc-text">String 类的声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E7%B1%BB%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.3.2.</span> <span class="toc-text">String 类的底层实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84-hashCode-%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.3.</span> <span class="toc-text">类的 hashCode 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E7%B1%BB%E7%9A%84-substring-%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.4.</span> <span class="toc-text">String 类的 substring 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String-%E7%B1%BB%E7%9A%84-indexOf-%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.5.</span> <span class="toc-text">String 类的 indexOf 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.6.</span> <span class="toc-text">类的其他方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">5.4.</span> <span class="toc-text">string字符串为什么不可变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-Pool"><span class="toc-number">5.5.</span> <span class="toc-text">String Pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-StringBuffer-and-StringBuilder"><span class="toc-number">5.6.</span> <span class="toc-text">String, StringBuffer and StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-String-%E2%80%9Cabc%E2%80%9D"><span class="toc-number">5.7.</span> <span class="toc-text">new String(“abc”)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BC%98%E5%8C%96%EF%BC%9A%E8%AF%A6%E8%A7%A3-String-intern-%E6%96%B9%E6%B3%95"><span class="toc-number">5.8.</span> <span class="toc-text">Java 字符串优化：详解 String.intern() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringJoiner"><span class="toc-number">5.9.</span> <span class="toc-text">StringJoiner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89%E5%88%A4%E6%96%AD%EF%BC%9AJava%E4%B8%AD%E7%9A%84equals-%E4%B8%8E-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%94%A8%E6%B3%95"><span class="toc-number">5.10.</span> <span class="toc-text">字符串相等判断：Java中的equals()与&#x3D;&#x3D;的区别与用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-number">5.11.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-%E5%90%8E%E8%AE%B0"><span class="toc-number">6.</span> <span class="toc-text">总结 &amp; 后记</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/27/" title="再见 MyBatis-Plus ！">再见 MyBatis-Plus ！</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/26/" title="“人尽皆知”的单例模式">“人尽皆知”的单例模式</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/29/" title="阿里的同事，写的代码真 TMD 优雅！">阿里的同事，写的代码真 TMD 优雅！</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/28/" title="别再用 BeanUtils 了，这款 PO VO DTO 转换神器不香么？">别再用 BeanUtils 了，这款 PO VO DTO 转换神器不香么？</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/30/" title="MyBatis过时了吗？">MyBatis过时了吗？</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="小u" target="_blank">小u</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">238</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">39</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">50</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://mydocs.guoyaxue.top/" title="旧版博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="旧版博客"/><span class="back-menu-item-text">旧版博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://pan.xiaou61.top/#/" title="免费网盘"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="免费网盘"/><span class="back-menu-item-text">免费网盘</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://cloud.xiaou61.top/" title="云盘(自用)"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="云盘(自用)"/><span class="back-menu-item-text">云盘(自用)</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://wpzc.xiaou61.top/" title="云盘转存"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="云盘转存"/><span class="back-menu-item-text">云盘转存</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://love.xiaou61.top/#/" title="关于我们(My girlFriend)"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="关于我们(My girlFriend)"/><span class="back-menu-item-text">关于我们(My girlFriend)</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">娱乐项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://fxq.xiaou61.top/#/" title="飞行棋"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="飞行棋"/><span class="back-menu-item-text">飞行棋</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/game/sqnwmai803/" title="谁去拿外卖"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="谁去拿外卖"/><span class="back-menu-item-text">谁去拿外卖</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/desktop.html" title="win12网页版"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/icon/logo.svg" alt="win12网页版"/><span class="back-menu-item-text">win12网页版</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://game.xiaou61.top/" title="在线游戏"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="在线游戏"/><span class="back-menu-item-text">在线游戏</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 开往</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><span> 开往</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>3</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JVM/" style="font-size: 0.88rem;">JVM<sup>22</sup></a><a href="/tags/Nginx/" style="font-size: 0.88rem;">Nginx<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>1</sup></a><a href="/tags/Ts/" style="font-size: 0.88rem;">Ts<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size: 0.88rem;">TypeScript<sup>1</sup></a><a href="/tags/WebApi/" style="font-size: 0.88rem;">WebApi<sup>1</sup></a><a href="/tags/coder1v5/" style="font-size: 0.88rem;">coder1v5<sup>2</sup></a><a href="/tags/css/" style="font-size: 0.88rem;">css<sup>3</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>12</sup></a><a href="/tags/javaSE/" style="font-size: 0.88rem;">javaSE<sup>3</sup></a><a href="/tags/javaWeb/" style="font-size: 0.88rem;">javaWeb<sup>2</sup></a><a href="/tags/js%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">js逆向<sup>1</sup></a><a href="/tags/leetcode/" style="font-size: 0.88rem;">leetcode<sup>3</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>8</sup></a><a href="/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/" style="font-size: 0.88rem;">书籍推荐<sup>2</sup></a><a href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%90%AC%E8%BF%90/" style="font-size: 0.88rem;">公众号搬运<sup>35</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 0.88rem;">前端<sup>10</sup></a><a href="/tags/%E5%8A%9E%E5%85%AC/" style="font-size: 0.88rem;">办公<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 0.88rem;">后端<sup>8</sup></a><a href="/tags/%E5%A4%A9%E6%B6%AF%E8%AE%BA%E5%9D%9B/" style="font-size: 0.88rem;">天涯论坛<sup>1</sup></a><a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 0.88rem;">导航<sup>1</sup></a><a href="/tags/%E5%B0%B1%E4%B8%9A/" style="font-size: 0.88rem;">就业<sup>16</sup></a><a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 0.88rem;">微信<sup>1</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/" style="font-size: 0.88rem;">技术杂谈<sup>51</sup></a><a href="/tags/%E6%8E%98%E9%87%91/" style="font-size: 0.88rem;">掘金<sup>14</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 0.88rem;">杂项<sup>1</sup></a><a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 0.88rem;">测试<sup>1</sup></a><a href="/tags/%E6%B8%A1%E4%B8%80%E5%A4%A7%E5%B8%88%E8%AF%BE/" style="font-size: 0.88rem;">渡一大师课<sup>3</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 0.88rem;">爬虫<sup>1</sup></a><a href="/tags/%E7%9B%AE%E5%BD%95/" style="font-size: 0.88rem;">目录<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>4</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 0.88rem;">虚拟机<sup>12</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>6</sup></a><a href="/tags/%E8%B7%AF%E9%A3%9E%E5%AD%A6%E9%99%A2/" style="font-size: 0.88rem;">路飞学院<sup>3</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">面向对象<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>51</sup></a><a href="/tags/%E9%A3%9E%E8%A1%8C%E6%A3%8B/" style="font-size: 0.88rem;">飞行棋<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="7409599794" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>