<!DOCTYPE html><html class="hide-aside" lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>java面向对象 | 小u的博客</title><meta name="keywords" content="java,面向对象"><meta name="author" content="小u"><meta name="copyright" content="小u"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="java面向对象"><meta name="application-name" content="java面向对象"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="java面向对象"><meta property="og:url" content="http://example.com/2023/10/01/codenotes/Java/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/index.html"><meta property="og:site_name" content="小u的博客"><meta property="og:description" content="前言这本书励志与用这一本书讲透java的面向对象，其实面向对象是一个非常常见的场景在java里面，所以这个是每一个学习java要实现掌握的，并且详细掌握的，为了以后我们去学习一些框架，打下基础。 什么是面向对象相信很多Java开发者，在最初接触Java的时候就听说过，Java是一种面向对象的开发语"><meta property="og:locale" content="en"><meta property="og:image" content="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png"><meta property="article:author" content="小u"><meta property="article:tag" content="Java,java,springboot,mysql,redis,教程,git,软件,编程,开发,互联网,Java 基础,Java 教程,Java程序员进阶之路,Java 入门,Vue,前端,算法"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png"><meta name="description" content="前言这本书励志与用这一本书讲透java的面向对象，其实面向对象是一个非常常见的场景在java里面，所以这个是每一个学习java要实现掌握的，并且详细掌握的，为了以后我们去学习一些框架，打下基础。 什么是面向对象相信很多Java开发者，在最初接触Java的时候就听说过，Java是一种面向对象的开发语"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2023/10/01/codenotes/Java/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//hm.baidu.com"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?1433b93d16cca6b366bdf23126c0c200";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"tianli","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"784b999ee9b2f0689c5a","Referer":"https://mydocs-1305448902.cos-website.ap-nanjing.myqcloud.com/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":null},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"Author: 小u","link":"Link: ","source":"Source: 小u的博客","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.","copySuccess":"Copy success, copy and reprint please mark the address of this article"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"Traditional Chinese Activated Manually","cht_to_chs":"Simplified Chinese Activated Manually","day_to_night":"Dark Mode Activated Manually","night_to_day":"Light Mode Activated Manually","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '小u的博客',
  title: 'java面向对象',
  postAI: '',
  pageFillDescription: '前言, 什么是面向对象, 什么是面向过程, 什么是面向对象, 类和对象, new一个对象, 初始化对象, 第一种：通过对象的引用变量。, 第二种：通过方法初始化。, 第三种：通过构造方法初始化。, 关于对象, 1）抽象的历程, 2）对象具有接口, 3）访问权限修饰符, 4）组合, 面向对象三大基本特征, 封装(Encapsulation), 继承(Inheritance)], 单继承, 多继承, 如何实现继承, extends 关键字, implements 关键字, 练习, 多态(Polymorphism), 01、多态与后期绑定, 02、多态与构造方法, 03、多态与向下转型, 面向对象的五大基本原则, 单一职责原（single-responsibility-principle）), 开放封闭原则（Open-Closed principle, 里氏替换原则（Liskov-Substitution Principle], 依赖倒置原则（Dependecy-Inversion Principle）, 接口隔离原则（Interface-Segregation Principle）, 案例, java中的包, 包的作用域, 导入包, 包的最佳实践, java中的变量, 01、局部变量, 02、成员变量, 03、静态变量, 04、常量, java中的方法, 01、Java中的方法是什么？, 02、如何声明方法？, 03、方法有哪几种？, 1）预先定义方法, 2）用户自定义方法, 04、什么是实例方法？, 05、什么是静态方法？, 06、什么是抽象方法？, 07、方法重写与重载, javq实现平台无关性, 什么是平台无关性, 平台无关性好处, 平台无关性的实现, 编译原理基础, 字节码, Java语言规范, 小结, 语言无关性, Java可变参数, java native方法, 1、JNI：Java Native Interface, 2、用 C 语言编写程序本地方法, 01）编写带有 native 方法的 Java 类 HelloJNI.java, 02）编译 HelloJNI.java, 03）使用 javah -jni HelloJNI 生成扩展名为 h 的头文件, 04）使用 C 语言实现本地方法, 05）编写编译脚本 , 06）执行编译脚本, 07）运行 HelloJNI, 3、JNI 调用 C 的流程图, 4、native 关键字, java的构造方法, 01、创建构造方法的规则, 02、默认构造方法, 3、有参构造方法, 04、重载构造方法, 05、构造方法和方法的区别, 06、复制对象, 1）通过构造方法, 2）通过对象的值, 3）通过 Object 类的 clone() 方法, Java访问权限修饰符, 1. 修饰类, 2. 修饰方法和变量, java初始代码块, java抽象类, 01、定义抽象类, 02、抽象类的特征, 03、抽象类的应用场景, 01）第一种场景, 02）第二种场景, 04、抽象类总结, java接口, 术语, 接口继承, 继承关系, 01、定义接口, 02、接口的作用, 03、接口的三种模式, 1）策略模式, 2）适配器模式, 3）工厂模式, 04、抽象类和接口的区别, 1）语法层面上, 2）设计层面上, 案例, default方法, java内部类, 1）成员内部类, 2）局部内部类, 3）匿名内部类, 4）静态内部类, java关键字this和super, this, 01、 指向当前对象, 02、调用当前类的方法, 03、调用当前类的构造方法, 04、作为参数在方法中传递, 05、作为参数在构造方法中传递, 06、作为方法的返回值, super, java Static关键字, 01、静态变量, 02、静态方法, 03、静态代码块, 04、静态内部类前言这本书励志与用这一本书讲透的面向对象其实面向对象是一个非常常见的场景在里面所以这个是每一个学习要实现掌握的并且详细掌握的为了以后我们去学习一些框架打下基础什么是面向对象相信很多开发者在最初接触的时候就听说过是一种面向对象的开发语言那么什么是面向对象呢首先所谓面向对象其实是指软件工程中的一类编程风格很多人称呼他们为开发范式编程泛型面向对象是众多开发范式中的一种除了面向对象以外还有面向过程指令式编程函数式编程等虽然这几年函数式编程越来越被人们所熟知但是在所有的开发范式中我们接触最多的主要还是面向过程和面向对象两种什么是面向过程面向过程是一种以过程为中心的编程思想是一种自顶而下的编程模式最典型的面向过程的编程语言就是语言简单来说面向过程的开发范式中程序员需要把问题分解成一个一个步骤每个步骤用函数实现依次调用即可就是说在进行面向过程编程的时候不需要考虑那么多上来先定义一个函数然后使用各种诸如等方式进行代码执行最典型的用法就是实现一个简单的算法比如实现冒泡排序面向过程进行的软件开发其代码都是流程化的很明确的可以看出第一步做什么第二步做什么这种方式的代码执行起来效率很高但是面向过程同时存在着代码重用性低扩展能力差后期维护难度比较大等问题什么是面向对象面向对象的雏形最早在出现在年的语言中当时的程序设计领域正面临着一种危机在软硬件环境逐渐复杂的情况下软件如何得到良好的维护面向对象程序设计在某种程度上通过强调可重复性解决了这一问题目前较为流行的面向对象语言主要有等简单来说面向对象的开发范式中程序员将问题分解成一个一个步骤对每个步骤进行相应的抽象形成对象通过不同对象之间的调用组合解决问题就是说在进行面向对象进行编程的时候要把属性行为等封装成对象然后基于这些对象及对象的能力进行业务逻辑的实现比如想要造一辆车上来要先把车的各种属性定义出来然后抽象成一个类面向对象的编程方法之所以更加受欢迎是因为他更加符合人类的思维方式这种方式编写出来的代码扩展性可维护性都很高与其实面向对象是一种开发范式倒不如说面向对象是一种对现实世界的理解和抽象的方法通过对现实世界的理解和抽象在运用封装继承多态等方法通过抽象出对象的方式进行软件开发举个简单点的例子来区分一下面向过程和面向对象有一天你想吃小碗汤了怎么办呢有两个选择自己买食材豆腐皮啊肉啊蒜苔啊等等自己动手做到饭店去只需要对老板喊一声来份小碗汤第一种就是面向过程第二种就是面向对象面向过程有什么劣势呢假如你买了小碗汤的食材临了又想吃宫保鸡丁了你是不是还得重新买食材面向对象有什么优势呢假如你不想吃小碗汤了你只需要对老板说我那个小碗汤如果没做的话换成宫保鸡丁吧面向过程是流程化的一步一步上一步做完了再做下一步面向对象是模块化的我做我的你做你的我需要你做的话我就告诉你一声我不需要知道你到底怎么做只看功劳不看苦劳不过如果追到底的话面向对象的底层其实还是面向过程只不过把面向过程进行了抽象化封装成了类方便我们的调用类和对象对象可以是现实中看得见的任何物体比如说一只特立独行的猪也可以是想象中的任何虚拟物体比如说能七十二变的孙悟空通过类来定义这些物体这些物体有什么状态通过字段来定义比如说比如说猪的颜色是纯色还是花色这些物体有什么行为通过方法来定义比如说猪会吃会睡觉来定义一个简单的类给你看看一个类可以包含字段方法构造方法在类中字段有个分别是和它们也称为成员变量在类内部但在方法外部方法内部的叫临时变量成员变量有时候也叫做实例变量在编译时不占用内存空间在运行时获取内存也就是说只有在对象实例化后字段才会获取到内存这也正是它被称作实例变量的原因方法有个分别是和表示这个对象可以做什么也就是吃饭睡觉打豆豆那么我们可能会疑惑为什么没有构造方法的确在类的源码文件中没看到但在反编译后的字节码文件中是可以看得到的就是默认的构造方法因为是空的构造方法方法体中没有内容所以可以缺省聪明就聪明在这有些很死板的代码不需要开发人员添加它会偷偷地做了但是在实际的开发中我们还是推荐加上的一个对象创建对象时需要用到关键字这行代码就通过类创建了一个对象所有对象在创建的时候都会在堆内存中分配空间创建对象的时候需要一个方法作为入口方法可以在当前类中也可以在另外一个类中第一种方法直接放在类中输出结果如下所示第二种方法不在类中而在另外一个类中实际开发中我们通常不在当前类中直接创建对象并使用它而是放在使用对象的类中比如说上图中的类可以把类和类放在两个文件中也可以放在一个文件命名为中就像下面这样初始化对象在之前的例子中程序输出结果为为什么会有这样的输出结果呢因为对象没有初始化因此输出了的默认值的默认值那怎么初始化对象对字段赋值呢第一种通过对象的引用变量被称为对象的引用变量见下图通过对象的引用变量可以直接对字段进行初始化所以以上代码输出结果如下所示第二种通过方法初始化在类中新增方法然后在新建对象后传参进行初始化第三种通过构造方法初始化这也是最标准的一种做法直接在的时候把参数传递过去补充一点知识匿名对象匿名对象意味着没有引用变量它只能在创建的时候被使用一次可以直接通过匿名对象调用方法我们来看下面的这个手机在打电话手机在玩游戏面向方法创建手机的对象小米苹果我们把我们新建的这个对象也叫做在类中是不写方法的在以前编写方法的类都叫做测试类我们可以在测试类中创建类的对象进行赋值调用关于对象抽象的历程所有编程语言都是一种抽象甚至可以说我们能够解决的问题的复杂程度取决于抽象的类型和质量是历史上第一门获得成功的面向对象语言也为提供了灵感它有个基本特征万物皆对象一段程序实际上就是多个对象通过发送消息的方式来告诉彼此该做什么通过组合的方式可以将多个对象封装成其他更为基础的对象对象是通过类实例化的同一类型的对象可以接收相同的消息总结一句话就是状态行为标识对象每个对象在内存中都会有一个唯一的地址对象具有接口所有的对象都可以被归为一类并且同一类对象拥有一些共同的行为和特征在中关键字用来定义一个类型创建抽象数据类型是面向对象编程的一个基本概念你可以创建某种类型的变量中称之为对象或者实例然后你就可以操作这些变量中称之为发送消息或者发送请求最后对象决定自己该怎么做类描述了一系列具有相同特征和行为的对象从宽泛的概念上来说类其实就是一种自定义的数据类型一旦创建了一个类就可以用它创建任意多个对象面向对象编程语言遇到的最大一个挑战就是如何把现实虚拟的元素抽象为中的对象对象能够接收什么样的请求是由它的接口定义的具体是怎么做到的就由它的实现方法来实现访问权限修饰符类的创建者有时候也被称为提供者对应的类的使用者就被称为调用者就给我们提供了的基础实现的作者也就是基础的提供者多线程部分的作者是被程序员敬佩的一个大佬我们这些语言的使用者说白了就是的调用者当然了假如我们也提供了新的类给其他调用者我们也就成为了新的创建者创建者在创建新的类的时候只暴露必要的接口而隐藏其他所有不必要的信息之所以要这么做是因为如果这些信息对调用者是不可见的那么创建者就可以随意修改隐藏的信息而不用担心对调用者的影响这里就必须要讲到的权限修饰符访问权限修饰符的第一个作用是防止类的调用者接触到他们不该接触的内部实现第二个作用是让类的创建者可以轻松修改内部机制而不用担心影响到调用者的使用还有一种默认的权限修饰符是缺省的它修饰的类可以访问同一个包下面的其他类组合我们可以把一个创建好的类作为另外一个类的成员变量来使用利用已有的类组成成一个新的类被称为复用组合代表的关系是的关系之后来看我们中面向对象的三大基本特征面向对象三大基本特征封装所谓封装也就是把客观事物封装成抽象的类并且类可以把自己的数据和方法只让可信的类或者对象操作对不可信的进行信息隐藏简单的说一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体在一个对象内部某些代码或某些数据可以是私有的不能被外界访问通过这种方式对象对内部数据提供了不同级别的保护以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分封装从字面上来理解就是包装的意思专业点就是信息隐藏是指利用抽象将数据和基于数据的操作封装在一起使其构成一个不可分割的独立实体使用封装有大好处良好的封装能够减少耦合类内部的结构可以自由修改可以对成员进行更精确的控制隐藏信息实现细节如我们想要定义一个矩形先定义一个类并其中通过封装的手段放入一些必备数据矩形设置矩形的长度和宽度长度宽度获得矩形面积复制我们通过封装的方式给矩形定义了长度和宽度这就完成了对现实世界中的矩形的抽象的第一步如果这个还没有那么的直观那我们来看下面的这两个类对属性的封装一个人的姓名性别年龄妻子都是这个人的私有属性是该对象对外开发的接口可以看得出类里面的属性是没有的同时类的属性也是没有方法的所以封装把一个对象的属性私有化同时提供一些可以被外界访问的属性的方法如果不想被外界方法我们大可不必提供方法给外界访问但是如果一个类没有提供给外界任何可以访问的方法那么这个类也没有什么意义了比如我们将一个房子看做是一个对象里面有漂亮的装饰如沙发电视剧空调茶桌等等都是该房子的私有属性但是如果我们没有那些墙遮挡是不是别人就会一览无余呢没有一点儿隐私因为存在那个遮挡的墙我们既能够有自己的隐私而且我们可以随意的更改里面的摆设而不会影响到外面的人但是如果没有门窗一个包裹的严严实实的黑盒子又有什么存在的意义呢所以通过门窗别人也能够看到里面的风景所以说门窗就是房子对象留给外界访问的接口通过这个我们还不能真正体会封装的好处现在我们从程序的角度来分析封装带来的好处如果我们不使用封装那么该对象就没有和那么类应该这样写我们应该这样来使用它张三男貌似有点儿多余但是哪天如果我们需要修改例如将修改为类型的呢你只有一处使用了这个类还好如果你有几十个甚至上百个这样地方你是不是要改到崩溃如果使用了封装我们完全可以不需要做任何修改只需要稍微改变下类的方法即可对属性的封装一个人的姓名性别年龄妻子都是这个人的私有属性改成类型的转换即可省略其他属性的其他的地方依然这样引用保持不变到了这里我们确实可以看出封装确实可以使我们更容易地修改类的内部实现而无需修改使用了该类的代码我们再看这个好处封装可以对成员变量进行更精确的控制还是那个一般来说我们在引用这个对象的时候是不容易出错的但是有时你迷糊了写成了这样也许你是因为粗心写成了这样你发现了还好如果没有发现那就麻烦大了谁见过岁的老妖怪啊但是使用封装我们就可以避免这个问题我们对的访问入口做一些控制如对属性的封装一个人的姓名性别年龄妻子都是这个人的私有属性改成类型的提示錯誤信息省略其他属性的上面都是对方法的控制其实通过封装我们也能够对对象的出口做出很好的控制例如性别在数据库中一般都是以的方式来存储的但是在前台我们又不能展示这里我们只需要在方法里面做一些转换即可女男在使用的时候我们只需要使用即可实现正确的性别显示同理也可以用于针对不同的状态做出不同的操作启用禁用说了这么多我们来看实现封装的基本思路修改属性的可见性来限制对属性的访问一般限制为例如这段代码中将和属性设置为私有的只能本类才能访问其他类都访问不了如此就对信息进行了隐藏对每个值属性提供对外的公共方法访问也就是创建一对赋取值方法用于对私有属性的访问例如采用关键字是为了解决实例变量和局部变量中的变量之间发生的同名的冲突之后我们来复习一个这个关键字他是一个权限修饰符可以修饰成员成员变量和成员方法被修饰的成员只能在本类中才能访问如果一个关键字被修饰后就只能通过和方法来获得和更改参数面向方法提供和方法作用给赋值需要有赋值对外提供数据非法参数在睡觉在吃饭例如这里的和方法以及主函数里的调用面向方法小诗诗傻逼看了这么多相信大家应该已经看明白什么是封装了下面就开始讲第二个基本特征继承继承是指这样一种能力它可以使用现有类的所有功能并在无需重新编写原来的类的情况下对这些功能进行扩展通过继承创建的新类称为子类或派生类被继承的类称为基类父类或超类继承的过程就是从一般到特的过程继承是面向对象编程技术的一块基石因为它允许创建分等级层次的类继承就是子类继承父类的特征和行为使得子类对象实例具有父类的实例域和方法或子类从父类继承方法使得子类具有父类相同的行为生活中的继承兔子和羊属于食草动物类狮子和豹属于食肉动物类食草动物和食肉动物又是属于动物类所以继承需要符合的关系是父类更通用子类更具体虽然食草动物和食肉动物都是属于动物但是两者的属性和行为上有差别所以子类会具有父类的一般特性也会具有自身的特性我们想要定义一个正方形因为已经有了矩形所以我们可以直接继承类因为正方形是长方形的一种特例正方形继承自矩形设置正方形边长复制现实世界中正方形是矩形的特例或者说正方形是通过矩形派生出来的这种派生关系在面向对象中可以用继承来表达如果仅仅只有两三个类每个类的属性和方法很有限的情况下确实没必要实现继承但事情并非如此事实上一个系统中往往有很多个类并且有着很多相似之处比如猫和狗同属动物或者学生和老师同属人各个类可能又有很多个相同的属性和方法这样的话如果每个类都重新写不仅代码显得很乱代码工作量也很大这时继承的优势就出来了可以直接使用父类的属性和方法自己也可以有自己新的属性和方法满足拓展父类的方法如果自己有需求更改也可以重写这样使用继承不仅大大的减少了代码量也使得代码结构更加清晰可见所以这样从代码的层面上来看我们设计这个完整的类是这样的这里省略方法而类可以这样设计继承调用父类构造方法调用父类构造方法调用父类构造方法鸡下蛋我是老母鸡下蛋啦咯哒咯咯哒咯各自的类继承后可以直接使用类的属性和方法而不需要重复编写各个类如果有自己的方法也可很容易地拓展继承的分类继承分为单继承和多继承语言只支持类的单继承但可以通过实现接口的方式达到多继承的目的单继承单继承一个子类只有一个父类如我们上面讲过的类和它的子类单继承在类层次结构上比较清晰但缺点是结构的丰富度有时不能满足使用需求多继承多继承一个子类有多个直接的父类这样做的好处是子类拥有所有父类的特征子类的丰富度很高但是缺点就是容易造成混乱下图为一个混乱的例子要注意的是是不支持多继承的至于为什么不支持多继承呢我们来看一下解释下面我们来看这个菱型继承假设我们有类和类它们都继承了相同的类另外我们还有类类通过多重继承机制继承了类和类这时候因为同时继承了和并且和又同时继承了那么中就会因为多重继承继承到两份来自中的属性和方法这时候在使用的时候如果想要调用一个定义在中的方法时就会出现歧义因为这样的继承关系的形状类似于菱形因此这个问题被形象地称为菱形继承问题而为了解决菱形继承问题又引入了虚继承因为支持多继承引入了菱形继承问题又因为要解决菱形继承问题引入了虚继承而经过分析人们发现我们其实真正想要使用多继承的情况并不多所以在中不允许实现多继承即一个类不允许继承多个父类但是允许声明多继承即一个类可以实现多个接口一个接口也可以继承多个父接口由于接口只允许有方法声明而不允许有方法实现以前这就避免了中多继承的歧义问题但是不支持多继承在中支持了默认函数之后就不那么绝对了虽然我们还是没办法使用同时继承多个类但是因为有了默认函数我们有可能通过从多个接口中继承到多个默认函数那么又如何解决这种情况带来的菱形继承问题呢这个问题留给大家去查询答案虽然不支持多继承但是有三种实现多继承效果的方式分别是内部类多层继承和实现接口内部类可以继承一个与外部类无关的类保证了内部类的独立性正是基于这一点可以达到多继承的效果多层继承子类继承父类父类如果还继承其他的类那么这就叫多层继承这样子类就会拥有所有被继承类的属性和方法实现接口无疑是满足多继承使用需求的最好方式一个类可以实现多个接口满足自己在丰富性和复杂环境的使用需求类和接口相比类就是一个实体有属性和方法而接口更倾向于一组方法举个例子就拿斗罗大陆的唐三来看他存在的继承关系可能是这样的下面来一个图让你快速区分这个继承的分类如何实现继承关键字在中类的继承是单一继承也就是说一个子类只能拥有一个父类所以只能继承一个类其使用语法为子类名父类名例如类继承类它是这样的定义类类继承类子类继承父类后就拥有父类的非私有的属性和方法如果不明白请看这个案例在下创建一个项目创建一个类做测试分别创建类和类作为父类写一个方法类继承类之后就可以调用方法具体代码为父类的方法继承点击运行的时候子类可以直接使用父类的方法关键字使用关键字可以变相使拥有多继承的特性使用范围为类实现接口的情况一个类可以实现多个接口接口与接口之间用逗号分开我们来看一个案例创建一个类做测试分别创建接口和接口接口声明方法接口声明方法创建类实现和接口并且在类中需要重写方法和方法具体代码为以下会报错接口中的方法不能具体定义只能声明必须重写接口内的方法类实现和接口的时候需要实现其声明的方法点击运行结果如下这就是一个类实现接口的简单案例说了这么多我们来看一个继承的练习练习首先我们先画一个图画出继承关系画图是从下往上画之后是写代码写代码的话就是从上往下写先是动物面向对象进阶这里用的是所以所有继承他的子类都可以用这个方法如果是就只有自己可以用可以相当于一个人的私房钱吃东西喝水之后是猫和狗面向对象进阶猫在抓老鼠面向对象进阶狗在看见最后开始详细书写面向对象进阶哈士奇在拆家面向对象进阶面向对象进阶面向对象进阶泰迪又在蹭我的腿了面向对象进阶注意事项子类只能访问父类中非私有的成员创建一个布偶猫的对象创建一个哈奇士对象最后的是我们的测试类就可以发现测试成功了这样就算是一个完整的继承了多态所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式多态机制使具有不同内部结构的对象可以共享相同的外部接口这意味着虽然针对不同对象的具体操作不同但通过一个公共的类它们那些操作可以通过相同的方式予以调用最常见的多态就是将子类传入父类参数中运行时调用父类方法时通过传入的子类决定具体的内部结构或行为在我刻板的印象里西游记里的那段孙悟空和二郎神的精彩对战就能很好的解释多态这个词一个孙悟空能七十二变一个二郎神也能七十二变他们都可以变成不同的形态但只需要悄悄地喊一声变的多态是什么呢其实就是一种能力同一个行为具有不同的表现形式换句话说就是执行一段代码在运行时能根据对象的不同产生不同的结果和孙悟空和二郎神都只需要喊一声变然后就变了并且每次变得还不一样一个道理多态的前提条件有三个子类继承父类子类覆盖父类的方法父类引用指向子类对象这个简单理解他的应用场景就是比如说有一个登录系统有三个不同身份的人都需要登录这个时候我们登录系统的这个形参就可以写他父类的了多态的一个简单应用来看程序清单子类继承父类子类覆盖父类方法记住仇恨表明我们要奋发图强的心智父类引用指向子类对象对象是王二的时候输出勿忘国耻对象是王小二的时候输出记住仇恨表明我们要奋发图强的心智勿忘国耻多态与后期绑定现在我们来思考一个问题程序清单在执行时由于编译器只有一个引用它怎么知道究竟该调用父类的方法还是子类的方法呢答案是在运行时根据对象的类型进行后期绑定编译器在编译阶段并不知道对象的类型但是的方法调用机制能找到正确的方法体然后执行出正确的结果多态机制提供的一个重要的好处程序具有良好的扩展性来看程序清单子类继承父类子类覆盖父类方法记住仇恨表明我们要奋发图强的心智我不喜欢读书我就喜欢吃父类引用指向子类对象对象是王二的时候输出勿忘国耻对象是王小二的时候输出记住仇恨表明我们要奋发图强的心智勿忘国耻每周读一本好书在程序清单中我们在类中增加了方法在类中增加了方法但这丝毫不会影响到方法的调用方法忽略了周围代码发生的变化依然正常运行这让我想起了金庸倚天屠龙记里九阳真经的口诀他强由他强清风拂山岗他横由他横明月照大江多态的这个优秀的特性让我们在修改代码的时候不必过于紧张因为多态是一项让程序员将改变的与未改变的分离开来的重要特性多态与构造方法在构造方法中调用多态方法会产生一个奇妙的结果我们来看程序清单王小三的年龄子类覆盖父类方法我小三上幼儿园的年龄是上幼儿园之前我小三上幼儿园的年龄是上幼儿园之后王小三的年龄上幼儿园之前上幼儿园之后老子上幼儿园的年龄是岁半从输出结果上看是不是有点诧异明明在创建对象的时候年龄传递的是但输出结果既不是老子上幼儿园的年龄是岁半也不是我小三上幼儿园的年龄是为什么因为在创建子类对象时会先去调用父类的构造方法而父类构造方法中又调用了被子类覆盖的多态方法由于父类并不清楚子类对象中的属性值是什么于是把类型的属性暂时初始化为然后再调用子类的构造方法子类构造方法知道王小二的年龄是多态与向下转型向下转型是指将父类引用强转为子类类型这是不安全的因为有的时候父类引用指向的是父类对象向下转型就会抛出表示类型转换失败但如果父类引用指向的是子类对象那么向下转型就是成功的来看程序清单记住仇恨表明我们要奋发图强的心智我不喜欢读书我就喜欢吃能够向下转型不能向下转型勿忘国耻每周读一本好书简单的来总结这个就是具体这个怎么理解呢可以这样理解就是如果子类和父类都有这个变量那么之后输出的是父类的变量运行也看左边也就是说实际获取的值也是左边的值之后看这个方法调用的解释这里编译看左边简单来说就是编译的时候要去判断父类中是否有这个方法如果没有的话也会报错的然后运行的时候运行的就是右边子类所提供的方法内容因此这也就产生的多态的一个弊端不能调用子类的特殊功能解决方案也很简单变回子类类型用括起来进行转换但是也不能随便的转换就比如还是上边的代码你把转换为就会报错为了尽量避免这种情况的发生我们可以用来进行判断类型这里就要用到一个参数这也就可以判断是否是类型的如果是返回如果不是就返回因此可以看这个类型转换的一个判断代码但是这也有点麻烦所以在之后提供了新特性有点类似中语法糖的效果在介绍了面向对象的封装继承多态的三个基本特征之后我们基本掌握了对现实世界抽象的基本方法封装是对类的封装封装是对类的属性和方法进行封装只对外暴露方法而不暴露具体使用细节所以我们一般设计类成员变量时候大多设为私有而通过一些方法去读写继承子类继承父类即子承父业子类拥有父类除私有的所有属性和方法自己还能在此基础上拓展自己新的属性和方法主要目的是复用代码多态多态是同一个行为具有多个不同表现形式或形态的能力即一个父类可能有若干子类各子类实现父类方法有多种多样调用父类方法时父类引用变量指向不同子类实例而执行不同方法这就是所谓父类方法是多态的下面我们来用一个图来看懂这三者的关系莎士比亚说一千个读者眼里有一千个哈姆雷特说到对现实世界的抽象虽然方法相同但是运用同样的方法最终得到的结果可能千差万别那么如何评价这个抽象的结果的好坏呢这就要提到面喜爱那个对象的五大基本原则了有了五大原则我们参考他们来评价一个抽象的好坏面向对象的五大基本原则面向对象开发范式的最大的好处就是易用易扩展易维护但是什么样的代码是易用易扩展易维护的呢如何衡量他们呢罗伯特马丁在世纪早期提出了原则这是五个原则的缩写的组合这五个原则沿用至今单一职责原其核心思想为一个类最好只做一件事只有一个引起它的变化单一职责原则可以看做是低耦合高内聚在面向对象原则上的引申将职责定义为引起变化的原因以提高内聚性来减少引起变化的原因职责过多可能引起它变化的原因就越多这将导致职责依赖相互之间就产生影响从而大大损伤其内聚性和耦合度通常意义下的单一职责就是指只有一种单一功能不要为类实现过多的功能点以保证实体只有一个引起它变化的原因专注是一个人优良的品质同样的单一也是一个类的优良设计交杂不清的职责将使得代码看起来特别别扭牵一发而动全身有失美感和必然导致丑陋的系统错误风险开放封闭原则其核心思想是软件实体应该是可扩展的而不可修改的也就是对扩展开放对修改封闭的开放封闭原则主要体现在两个方面对扩展开放意味着有新的需求或变化时可以对现有代码进行扩展以适应新的情况对修改封闭意味着类一旦设计完成就可以独立完成其工作而不要对其进行任何尝试的修改实现开放封闭原则的核心思想就是对抽象编程而不对具体编程因为抽象相对稳定让类依赖于固定的抽象所以修改就是封闭的而通过面向对象的继承和多态机制又可以实现对抽象类的继承通过覆写其方法来改变固有行为实现新的拓展方法所以就是开放的需求总是变化没有不变的软件所以就需要用封闭开放原则来封闭变化满足需求同时还能保持软件内部的封装体系稳定不被需求的变化影响里氏替换原则其核心思想是子类必须能够替换其基类这一思想体现为对继承机制的约束规范只有子类能够替换基类时才能保证系统在运行期内识别子类这是保证继承复用的基础在父类和子类的具体行为中必须严格把握继承层次中的关系和特征将基类替换为子类程序的行为不会发生任何变化同时这一约束反过来则是不成立的子类可以替换基类但是基类不一定能替换子类里氏替换原则主要着眼于对抽象和多态建立在继承的基础上因此只有遵循了替换原则才能保证继承复用是可靠地实现的方法是面向接口编程将公共部分抽象为基类接口或抽象类通过在子类中通过覆写父类的方法实现新的方式支持同样的职责里氏替换原则是关于继承机制的设计原则违反了替换原则就必然导致违反开放封闭原则里氏替换原则能够保证系统具有良好的拓展性同时实现基于多态的抽象机制能够减少代码冗余避免运行期的类型判别依赖倒置原则其核心思想是依赖于抽象具体而言就是高层模块不依赖于底层模块二者都同依赖于抽象抽象不依赖于具体具体依赖于抽象我们知道依赖一定会存在于类与类模块与模块之间当两个模块之间存在紧密的耦合关系时最好的方法就是分离接口和实现在依赖之间定义一个抽象的接口使得高层模块调用接口而底层模块实现接口的定义以此来有效控制耦合关系达到依赖于抽象的设计目标抽象的稳定性决定了系统的稳定性因为抽象是不变的依赖于抽象是面向对象设计的精髓也是依赖倒置原则的核心依赖于抽象是一个通用的原则而某些时候依赖于细节则是在所难免的必须权衡在抽象和具体之间的取舍方法不是一层不变的依赖于抽象就是对接口编程不要对实现编程接口隔离原则其核心思想是使用多个小的专门的接口而不要使用一个大的总接口具体而言接口隔离原则体现在接口应该是内聚的应该避免胖接口一个类对另外一个类的依赖应该建立在最小的接口上不要强迫依赖不用的方法这是一种接口污染接口有效地将细节和抽象隔离体现了对抽象编程的一切好处接口隔离强调接口的单一性而胖接口存在明显的弊端会导致实现的类型必须完全实现接口的所有方法属性等而某些时候实现类型并非需要所有的接口定义在设计上这是浪费而且在实施上这会带来潜在的问题对胖接口的修改将导致一连串的客户端程序需要修改有时候这是一种灾难在这种情况下将胖接口分解为多个特点的定制化方法使得客户端仅仅依赖于它们的实际调用的方法从而解除了客户端不会依赖于它们不用的方法分离的手段主要有以下两种委托分离通过增加一个新的类型来委托客户的请求隔离客户和接口的直接依赖但是会增加系统的开销多重继承分离通过接口多继承来实现客户的需求这种方式是较好的以上就是个基本的面向对象设计原则它们就像面向对象程序设计中的金科玉律遵守它们可以使我们的代码更加鲜活易于复用易于拓展灵活优雅不同的设计模式对应不同的需求而设计原则则代表永恒的灵魂需要在实践中时时刻刻地遵守就如在那边启示录中所说的你并不必严格遵守这些原则违背它们也不会被处以宗教刑罚但你应当把这些原则看做警铃若违背了其中的一条那么警铃就会响起很多人刚开始可能对这些原则无法深刻的理解但是没关系随着自己开发经验的增长就会慢慢的可以理解这些原则了在了解了这个之后我们来看一个比较大的案例案例根据需求完成代码定义狗类属性年龄颜色行为表示吃的东西看家方法无参数定义猫类属性年龄颜色行为方法表示吃的东西逮老鼠方法无参数定义类饲养员属性姓名年龄行为方法功能喂养宠物狗表示喂养的东西行为方法功能喂养宠物猫表示喂养的东西生成空参有参构造和方法定义测试类完成以下打印效果方法打印内容如下年龄为岁的老王养了一只黑颜色的岁的狗岁的黑颜色的狗两只前腿死死的抱住骨头猛吃方法打印内容如下年龄为岁的老李养了一只灰颜色的岁的猫岁的灰颜色的猫眯着眼睛侧着头吃鱼思考和都是的子类以上案例中针对不同的动物定义了不同的方法过于繁琐能否简化并体会简化后的好处和虽然都是的子类但是都有其特有方法能否想办法在中调用特有方法下面我们来看思维导图之后开始进行代码演示先写父类的面向对象进阶动物在吃获取设置获取设置之后是子类的面向对象进阶岁的颜色的猫咪眯着眼睛侧着头吃猫捉老鼠面向对象进阶行为的颜色的狗俩只前脚死死抱着猛吃狗在看见这里是的这里用到了多态面向对象进阶这里的不要去继承饲养猫和狗年龄为岁的养了一直颜色的岁的狗年龄为岁的养了一直颜色的岁的猫没有这种动物获取设置获取设置之后再看类面向对象进阶创建对象并且调用方法老王黑白骨头鱼中的包为了更好地组织类提供了包机制用于区别类名的命名空间在前面的代码中我们把类和接口命名为等简单的名字在团队开发中如果小明写了一个类小红也写了一个类现在小白既想用小明的也想用小红的怎么办如果小军写了一个类恰好也自带了一个类如何解决类名冲突在中我们使用来解决名字冲突定义了一种名字空间称之为包一个类总是属于某个包类名比如只是一个简写真正的完整类名是包名类名例如小明的类存放在包下面因此完整类名是小红的类存放在包下面因此完整类名是小军的类存放在包下面因此完整类名是的类存放在包下面因此完整类名是在定义的时候我们需要在第一行声明这个属于哪个包小明的文件申明包名小军的文件申明包名在虚拟机执行的时候只看完整类名因此只要包名不同类就不同包可以是多层结构用隔开例如要特别注意包没有父子关系和是不同的包两者没有任何继承关系没有定义包名的它使用的是默认包非常容易引起名字冲突因此不推荐不写包名的做法我们还需要按照包结构把上面的文件组织起来假设以作为根目录作为源码目录那么所有文件结构就是即所有文件对应的目录层次要和包的层次一致编译后的文件也需要按照包结构存放如果使用把编译后的文件放到目录下那么编译的文件结构就是编译的命令相对比较复杂我们需要在目录下执行命令在中会自动根据包结构编译所有源码所以不必担心使用命令行编译的复杂命令因此我们可以总结出来包的优点有下面的三个部分把功能相似或相关的类或接口组织在同一个包中方便类的查找和使用如同文件夹一样包也采用了树形目录的存储方式同一个包中的类名字是不同的不同的包中的类的名字是可以相同的当同时调用两个不同包中相同类名的类时应该加上包名加以区别因此包可以避免名字冲突包也限定了访问权限拥有包访问权限的类才能访问某个包中的类包的作用域位于同一个包的类可以访问包作用域的字段和方法不用修饰的字段和方法就是包作用域例如类定义在包下面包作用域类也定义在包下面就可以直接访问类可以调用因为和在同一个包导入包在一个中我们总会引用其他的例如小明的类如果要引用小军的类他有三种写法第一种直接写出完整类名例如很显然每次都要写完整的类名比较痛苦因此第二种写法是用语句导入小军的然后写简单类名导入完整类名在写的时候可以使用表示把这个包下面的所有都导入进来但不包括子包的导入包的所有我们一般不推荐这种写法因为在导入了多个包后很难看出类属于哪个包还有一种的语法它可以导入一个类的静态字段和静态方法导入类的所有静态字段和静态方法相当于调用很少使用编译器最终编译出的文件只使用完整类名因此在代码中当编译器遇到一个名称时如果是完整类名就直接根据完整类名查找这个如果是简单类名按下面的顺序依次查找查找当前是否存在这个查找的包是否包含这个查找包是否包含这个如果按照上面的规则还无法确定类名则编译报错我们来看一个例子使用完整类名使用的类使用包的使用包的编译错误无法找到因此编写的时候编译器会自动帮我们做两个动作默认自动当前的其他默认自动注意自动导入的是包但类似这些包仍需要手动导入如果有两个名称相同例如和那么只能其中一个另一个必须写完整类名关于这个导包的问题我们简单的进行一些了解就可以了因为我们再用编程的时候实际上她会自动的给我们进行导入包的最佳实践为了避免名字冲突我们需要确定唯一的包名推荐的做法是使用倒置的域名来确保唯一性例如子包就可以根据功能自行命名要注意不要和包的类重名即自己的类不要使用这些名字要注意也不要和常用类重名内建的机制是为了避免命名冲突的核心类使用包编译器会自动导入的其它常用类定义在包名推荐使用倒置的域名例如中共有三种变量分别是类变量也叫静态变量成员变量和局部变量他们分别存放在的方法区堆内存和栈内存中类变量成员变量局部变量下面我们来详细的去了解一下这些变量中的变量局部变量在方法体内声明的变量被称为局部变量该变量只能在该方法内使用类中的其他方法并不知道该变量来看下面这个示例其中就是局部变量它们只能在当前这个方法中使用声明局部变量时的注意事项局部变量声明在方法构造方法或者语句块中局部变量在方法构造方法或者语句块被执行的时候创建当它们执行完成后将会被销毁访问修饰符不能用于局部变量局部变量只在声明它的方法构造方法或者语句块中可见局部变量是在栈上分配的局部变量没有默认值所以局部变量被声明后必须经过初始化才可以使用成员变量在类内部但在方法体外声明的变量称为成员变量或者实例变量或者字段之所以称为实例变量是因为该变量只能通过类的实例对象来访问来看下面这个示例其中是一个变量它是一个引用类型的变量关键字可以创建一个类的实例也称为对象通过操作符赋值给这个变量就成了这个对象的引用通过就可以访问成员变量了声明成员变量时的注意事项成员变量声明在一个类中但在方法构造方法和语句块之外当一个对象被实例化之后每个成员变量的值就跟着确定成员变量在对象创建的时候创建在对象被销毁的时候销毁成员变量的值应该至少被一个方法构造方法或者语句块引用使得外部能够通过这些方式获取实例变量信息成员变量可以声明在使用前或者使用后访问修饰符可以修饰成员变量成员变量对于类中的方法构造方法或者语句块是可见的一般情况下应该把成员变量设为私有通过使用访问修饰符可以使成员变量对子类可见成员变量具有默认值数值型变量的默认值是布尔型变量的默认值是引用类型变量的默认值是变量的值可以在声明时指定也可以在构造方法中指定静态变量通过关键字声明的变量被称为静态变量类变量它可以直接被类访问来看下面这个示例其中就是静态变量通过类名静态变量就可以访问了不需要创建类的实例声明静态变量时的注意事项静态变量在类中以关键字声明但必须在方法构造方法和语句块之外无论一个类创建了多少个对象类只拥有静态变量的一份拷贝静态变量除了被声明为常量外很少使用静态变量储存在静态存储区静态变量在程序开始时创建在程序结束时销毁与成员变量具有相似的可见性但为了对类的使用者可见大多数静态变量声明为类型静态变量的默认值和实例变量相似静态变量还可以在静态语句块中初始化常量在中有些数据的值是不会发生改变的这些数据被叫做常量使用关键字修饰的成员变量常量的值一旦给定就无法改变常量在程序运行过程中主要有个作用代表常数便于修改例如圆周率的值增强程序的可读性例如常量用来代表上和下要求常量名必须大写来看下面这个示例沉默中的方法中的方法是什么方法用来实现代码的可重用性我们编写一次方法并多次使用它通过增加或者删除方法中的一部分代码就可以提高整体代码的可读性只有方法被调用时它才会执行中最有名的方法当属方法这是程序的入口如何声明方法方法的声明反映了方法的一些信息比如说可见性返回类型方法名和参数如下图所示访问权限它指定了方法的可见性提供了四种访问权限修饰符该方法可以被所有类访问该方法只能在定义它的类中访问该方法可以被同一个包中的类或者不同包中的子类访问如果一个方法没有使用任何访问权限修饰符那么它是的意味着该方法只能被同一个包中的类可见返回类型方法返回的数据类型可以是基本数据类型对象和集合如果不需要返回数据则使用关键字方法名方法名最好反应出方法的功能比如我们要创建一个将两个数字相减的方法那么方法名最好是方法名最好是一个动词并且以小写字母开头如果方法名包含两个以上单词那么第一个单词最好是动词然后是形容词或者名词并且要以驼峰式的命名方式命名比如一个单词的方法名多个单词的方法名一个方法可能与同一个类中的另外一个方法同名这被称为方法重载参数参数被放在一个圆括号内如果有多个参数可以使用逗号隔开参数包含两个部分参数类型和参数名如果方法没有参数圆括号是空的方法签名每一个方法都有一个签名包括方法名和参数方法体方法体放在一对花括号内把一些代码放在一起用来执行特定的任务方法有哪几种方法可以分为两种一种叫标准类库方法一种叫用户自定义方法预先定义方法提供了大量预先定义好的方法供我们调用也称为标准类库方法或者内置方法比如说类的方法以及我们在初学阶段最常用的方法用来在控制台打印信息在上面的代码中我们使用了两个预先定义的方法方法是程序运行的入口方法是类的一个方法这些方法已经提前定义好了所以我们可以直接使用它们我们可以通过集成开发工具查看预先定义方法的方法签名方法的访问权限修饰符是返回类型为方法名为参数为以及方法是干嘛的预先定义方法让编程变得简单了起来我们只需要在实现某些功能的时候直接调用这些方法即可不需要重新编写的一个非常大的优势就是的设计者开发者为我们提供了大量的标准类库方法这对于初学编程的新手来说极其友好不仅如此码云上也有大量可以直接拿到生产环境下使用的第三方类库比如说啊包啊一线大厂或者顶级开发大佬贡献的类库比如说等等这里是建议使用的如果有时间我会详细的讲解一下这个包的但如果你想从一个初级开发者俗称调包侠晋升为一名优秀的工程师那就需要深入研究这些源码并掌握最好是能自己写出来这些源码最起码能自定义一些源码以便为我们所用用户自定义方法当预先定义方法无法满足我们的要求时就需要自定义一些方法比如说我们来定义这样一个方法用来检查数字是偶数还是奇数是偶数是奇数方法名叫做访问权限修饰符是并且是静态的返回类型是参数有一个整型的方法体中有一个语句如果可以被整除那么就打印这个数字是偶数否则就打印这个数字是奇数方法被定义好后如何被调用呢是偶数是奇数方法是程序的入口并且是静态的那么就可以直接调用同样是静态方法的当一个方法被关键字修饰时它就是一个静态方法换句话说静态方法是属于类的不属于类实例的不需要通过关键字创建对象来调用直接通过类名就可以调用这个其实放到这里讲解也是有些不好的但是如果一开始就讲解一这些的话难免会有人不懂什么是实例方法没有使用关键字修饰但在类中声明的方法被称为实例方法在调用实例方法之前必须创建类的对象方法是一个实例方法需要创建对象来访问实例方法有两种特殊类型方法方法方法用来获取私有变量修饰的字段的值方法用来设置私有变量的值方法以开头方法以开头这个熟悉不熟悉这个就是我们之前讲解的构造方法什么是静态方法相应的有关键字修饰的方法就叫做静态方法类中和方法都是静态方法不同的是方法是程序的入口当我们调用静态方法的时候就不需要出来类的对象就可以直接调用静态方法了一些工具类的方法都是静态方法比如说工具类库里面有大量的静态方法可以直接调用的目标是使用一个工具方法代替一段复杂代码从而最大限度的避免复制粘贴代码的问题彻底改变我们写代码的方式以计算为例以前打开搜索引擎搜加密打开某篇博客复制粘贴改改好用现在引入的存在就是为了减少代码搜索成本避免网络上参差不齐的代码出现导致的什么是抽象方法没有方法体的方法被称为抽象方法它总是在抽象类中声明这意味着如果类有抽象方法的话这个类就必须是抽象的可以使用关键字创建抽象方法和抽象类当一个类继承了抽象类后就必须重写抽象方法重写了抽象方法输出结果如下所示重写了抽象方法这个看的有一点的难懂这个概念和多态的相似还是很多的面向对象进阶这就是一个抽象类注意事项抽象类不能创建对象抽象类不一定有抽象方法但有抽象方法的类一定是抽象类抽象类可以有构造方法抽象类的子类要么重写抽象类中的所有抽象方法要么子类本身也是一个抽象类我们这里讲到了重写那么什么是重写呢方法重写与重载重载和重写是中两个比较重要的概念但是对于新手来说也比较容易混淆本文就举两个实际的例子来说明下到底是什么是重写和重载首先我们分别来看一下重载和重写的定义重载指的是在同一个类中多个函数或者方法有同样的名称但是参数列表不相同的情形这样的同名不同参数的函数或者方法之间互相称之为重载函数或者方法重写指的是在的子类与父类中有两个名称参数列表都相同的方法的情况由于他们具有相同的方法签名所以子类中的新方法将覆盖父类中原有的方法下面的是重载复制上面的代码中定义了两个方法一个是没有参数的方法另外一个是包含一个类型参数的方法我们就可以说这两个方法是重载方法因为他们的方法名相同参数列表不同在编译期编译期可以根据方法签名方法名和参数情况情况确定具体哪个方法被调用方法重载的条件需要具备以下条件和要求被重载的方法必须改变参数列表被重载的方法可以改变返回类型被重载的方法可以改变访问修饰符被重载的方法可以声明新的或更广的检查异常方法能够在同一个类中或者在一个子类中被重载下面是一个重写的例子看完代码之后不妨猜测一下输出结果复制输出结果复制上面的例子中我们分别在父类子类中都定义了方法并且他们都是无参方法所以我们就说这种情况就是方法重写即子类重写了父类中的方法在测试的方法中对象被定义为类型在编译期编译器会检查类中是否有可访问的方法只要其中包含方法那么就可以编译通过在运行期对象被出来并赋值给变量这时是明确的知道变量指向的其实是对象的引用所以当调用方法的时候就会调用类中定义的方法这就是所谓的动态多态性方法重写的条件需要具备以下条件和要求参数列表必须完全与被重写方法的相同返回类型必须完全与被重写方法的返回类型相同访问级别的限制性一定不能比被重写方法的强访问级别的限制性可以比被重写方法的弱重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常重写的方法能够抛出更少或更有限的异常也就是说被重写的方法声明了异常但重写的方法可以什么也不声明不能重写被标示为的方法如果不能继承一个方法则不能重写这个方法简单概括可以是方法重载是指多个方法的方法名相同但各自的参数不同重载方法应该完成类似的功能参考的重载方法返回值类型应该相同实现平台无关性相信对于很多开发来说在刚刚接触语言的时候就听说过是一门跨平台的语言是平台无关性的这也是语言可以迅速崛起并风光无限的一个重要原因那么到底什么是平台无关性又是如何实现平台无关性的呢本文就来简单介绍一下什么是平台无关性平台无关性就是一种语言在计算机上的运行不受平台的约束一次编译到处执行也就是说用创建的可执行二进制程序能够不加改变的运行于多个平台平台无关性好处作为一门平台无关性语言无论是在自身发展还是对开发者的友好度上都是很突出的因为其平台无关性所以程序可以运行在各种各样的设备上尤其是一些嵌入式设备如打印机扫描仪传真机等随着时代的来临也会有更多的终端接入网络相信平台无关性的也能做出一些贡献对于开发者来说减少了开发和部署到多个平台的成本和时间真正的做到一次编译到处运行平台无关性的实现对于的平台无关性的支持就像对安全性和网络移动性的支持一样是分布在整个体系结构中的其中扮演者重要的角色的有语言规范文件虚拟机等编译原理基础讲到语言规范文件虚拟机就不得不提到底是是如何运行起来的我们知道在计算机世界中计算机只认识和所以真正被计算机执行的其实是由和组成的二进制文件但是我们日常开发使用的等都属于高级语言而非二进制语言所以想要让计算机认识我们写出来的代码那就需要把他翻译成由和组成的二进制文件这个过程就叫做编译负责这一过程的处理的工具叫做编译器在平台中想要把文件编译成二进制文件需要经过两步编译前端编译和后端编译前端编译主要指与源语言有关但与目标机无关的部分中我们所熟知的的编译就是前端编译除了这种以外我们使用的很多如等都内置了前端编译器主要功能就是把代码转换成代码这里提到的代码其实就是文件后端编译主要是将中间代码再翻译成机器语言中这一步骤就是虚拟机来执行的所以我们说的的平台无关性实现主要作用于以上阶段如下图所示我们从后往前介绍一下这三位主演虚拟机文件语言规范虚拟机所谓平台无关性就是说要能够做到可以在多个平台上都能无缝对接但是对于不同的平台硬件和操作系统肯定都是不一样的对于不同的硬件和操作系统最主要的区别就是指令不同比如同样执行操作系统对应的二进制指令可能是而操作系统对应的指令可能是那么想要做到跨平台最重要的就是可以根据对应的硬件和操作系统生成对应的二进制指令而这一工作主要由我们的虚拟机完成虽然语言是平台无关的但是却是平台有关的不同的操作系统上面要安装对应的上图是官网下载的指引不同的操作系统需要下载对应的虚拟机有了虚拟机想要执行操作操作系统上面的虚拟机就会把指令翻译成操作系统上面的虚拟机就会把指令翻译成图中的文件中内容为内容所以之所以可以做到跨平台是因为虚拟机充当了桥梁他扮演了运行时程序与其下的硬件和操作系统之间的缓冲角色字节码各种不同的平台的虚拟机都使用统一的程序存储格式字节码是构成平台无关性的另一个基石虚拟机只与由字节码组成的文件进行交互我们说语言可以这里的其实指的就是生成文件的过程因为文件可以在任何平台创建也可以被任何平台的虚拟机装载并执行所以才有了的平台无关性语言规范已经有了统一的文件以及可以在不同平台上将文件翻译成对应的二进制文件的虚拟机就可以彻底实现跨平台了吗其实并不是的语言在跨平台方面也是做了一些努力的这些努力被定义在语言规范中比如中基本数据类型的值域和行为都是由其自己定义的而中基本数据类型是由它的占位宽度决定的占位宽度则是由所在平台决定的所以在不同的平台中对于同一个程序的编译结果会出现不同的行为举一个简单的例子对于类型在中占个字节这是固定的但是在中却不是固定的了在位计算机上类型的长度可能为两字节在位计算机上可能为字节当位计算机流行起来后类型的长度可能会达到字节这里说的都是可能哦通过保证基本数据类型在所有平台的一致性语言为平台无关性提供强了有力的支持小结对于的平台无关性的支持是分布在整个体系结构中的其中扮演着重要角色的有语言规范文件虚拟机等语言规范通过规定语言中基本数据类型的取值范围和行为文件所有文件要编译成统一的文件虚拟机通过虚拟机将文件转成对应平台的二进制文件等的平台无关性是建立在虚拟机的平台有关性基础之上的是因为虚拟机屏蔽了底层操作系统和硬件的差异语言无关性其实的无关性不仅仅体现在平台无关性上面向外扩展一下还具有语言无关性前面我们提到过其实并不是和文件进行交互的而是和文件也就是说其实运行的时候并不依赖于语言时至今日商业机构和开源机构已经在语言之外发展出一大批可以在上运行的语言了如等之所以可以支持就是因为这些语言也可以被编译成字节码文件而虚拟机并不关心字节码是有哪种语言编译而来的可变参数可变参数是的时候引入的功能它允许方法使用任意多个类型相同的值作为参数就像下面这样小小小你小你好静态方法就使用了可变参数所以可以也可以甚至个个或者更多个字符串都可以作为参数传递给方法说到可变参数我想起来阿里巴巴开发手册上有这样一条规约意思就是尽量不要使用可变参数如果要用的话可变参数必须要在参数列表的最后一位既然坑位有限只能在最后那么可变参数就只能有一个悠着点悠着点如果可变参数不在最后一位就会提示对应的错误如下图所示可变参数看起来就像是个语法糖它背后究竟隐藏了什么呢让我们来一探究竟在追求真理这条路上我们要执着其实也很简单当使用可变参数的时候实际上是先创建了一个数组该数组的大小就是可变参数的个数然后将参数放入数组当中再将数组传递给被调用的方法这就是为什么可以使用数组作为参数来调用带有可变参数的方法的根本原因那如果方法的参数是一个数组然后像使用可变参数那样去调用方法的时候能行得通吗可变参数可变参数顾名思义当一个方法需要处理任意多个相同类型的对象时就可以定义可变参数中有一个很好的例子就是类的方法就像下面这样年纪是年纪是名字是小表示将整数格式化为进制整数表示输出字符串如果不使用可变参数那需要格式化的参数就必须使用号操作符拼接起来了麻烦也就惹上身了在实际的项目代码中的日志输出就经常要用到可变参数就没法使用可变参数日志中需要记录多个参数时就痛苦不堪了就像下面这样名字是名字是年纪是查看源码就可以发现方法使用了可变参数那在使用可变参数的时候有什么注意事项吗有的我们要避免重载带有可变参数的方法这样很容易让编译器陷入自我怀疑中这时候编译器完全不知道该调用哪个方法还是傻傻分不清假如真的需要重载带有可变参数的方法就必须在调用方法的时候给出明确的指示不要让编译器去猜上面这段代码是可以编译通过的因为编译器知道参数是类型还是类型只不过为了运行时不抛出两个方法的内部要做好判空操作方法这是的一个特殊的方法他是的本地方法什么意思呢我们来看一个例子在介绍之前我们先了解什么是一般情况下我们完全可以使用语言编写程序但某些情况下可能满足不了需求或者不能更好的满足需求比如标准的类库不支持我们已经用另一种语言比如说编写了一个类库如何用代码调用呢某些运行次数特别多的方法为了加快性能需要用更接近硬件的语言比如汇编编写上面这三种需求说到底就是如何用代码调用不同语言编写的代码那么应运而生了从开始标准就成为平台的一部分它允许代码和其他语言编写的代码进行交互一开始是为了本地已编译语言尤其是和而设计的但是它并不妨碍你使用其他语言只要调用约定受支持就可以了使用与本地已编译的代码交互通常会丧失平台可移植性但是有些情况下这样做是可以接受的甚至是必须的比如使用一些旧的库与硬件操作系统进行交互或者为了提高程序的性能标准至少保证本地代码能工作能在任何虚拟机实现下通过我们就可以通过程序代码调用到操作系统相关的技术实现的库函数从而与其他技术和系统交互同时其他技术和系统也可以通过提供的相应原生接口调用应用系统内部实现的功能的缺点程序不再跨平台要想跨平台必须在不同的系统环境下重新编译本地语言部分程序不再是绝对安全的本地代码的不当使用可能导致整个程序崩溃一个通用规则是你应该让本地方法集中在少数几个类当中这样就降低了和之间的耦合性目前来讲使用的缺点相对于优点还是可以接受的可能后面随着的技术发展我们不在需要但是目前还是一直提供了对标准的支持用语言编写程序本地方法官方文档如下步骤如下编写带有方法的类生成文件使用命令编译所编写的类生成文件使用类名生成扩展名为的头文件也即生成文件使用或者其他编程想语言实现本地方法创建文件的实现也就是创建文件实现文件中的方法将编写的文件生成动态连接库生成文件下面我们通过一个程序的调用来完成这几个步骤编写带有方法的类在目录下创建文件内容如下所示加载名为的动态链接库定义本地方法调用本地方法后面执行的命令都将在的目录下解释一下这段代码用声明的方法告知调用该方法在外部定义也就是我们会用语言去实现加载动态库参数是动态库的名字我们可以这样理解程序中的方法在程序中没有实现但是我们下面要调用这个方法怎么办呢我们就需要对这个方法进行初始化所以用了代码块进行初始化后面会讲到编译在命令行通过来编译源代码使用生成扩展名为的头文件以后被弃用取而代之的是使用选项来生成头文件例如执行完毕后会在所在目录下生成一个名为的头文件打开文件可以看到如下代码看不懂没关系无所谓直到它是自动生成的就好使用语言实现本地方法创建一个文件实现本地方法注意这里需要引入头文件并且实现的方法名称需要与在中声明的名称一致类的方法编写编译脚本编译文件把生成的文件拷贝到当前目录注意事项是的安装路径需要根据实际情况修改在上动态链接库的后缀是而不是上的这里的选项是为了告诉编译器头文件的位置是安装目录的路径执行编译脚本执行完毕后会在当前目录下生成一个名为的动态链接库运行执行命令运行如果一切正常就会在终端上输出调用的流程图关键字用来修饰方法用声明的方法表示该方法的实现在外部定义可以用任何语言去实现它比如说简单地讲一个就是一个调用非代码的接口语法修饰方法的位置必须在返回类型之前和其余的方法控制符前后关系不受限制不能用修饰也没有方法体也没有左右大括号返回值可以是任意类型的构造方法在之前我们一直提到过构造方法那么什么是构造方法呢这里来进行一个详细的介绍在中构造方法是一种特殊的方法当一个类被实例化的时候就会调用构造方法只有在构造方法被调用的时候对象才会被分配内存空间每次使用关键字创建对象的时候构造方法至少会被调用一次如果你在一个类中没有看见构造方法并不是因为构造方法不存在而是被缺省了编译器会给这个类提供一个默认的构造方法就是说有两种类型的构造方法无参构造方法和有参构造方法创建构造方法的规则构造方法必须符合以下规则构造方法的名字必须和类名一样构造方法没有返回类型包括构造方法不能是抽象的静态的最终的同步的简单解析一下最后一条规则由于构造方法不能被子类继承所以用和关键字修饰没有意义构造方法用于初始化一个对象所以用关键字修饰没有意义多个线程不会同时创建内存地址相同的同一个对象所以用关键字修饰没有必要构造方法的语法格式如下默认无参构造方法定义有参数列表的构造方法类主体值得注意的是如果用声明构造方法的话编译时不会报错但会把这个所谓的构造方法当成普通方法来处理看起来很符合构造方法的写法与类名相同但其实只是一个不符合规范的普通方法方法名的首字母使用了大写方法体为空它并不是默认的无参构造方法可以通过反编译后的字节码验证才是真正的无参构造方法不过可以使用访问权限修饰符来修饰构造方法访问权限修饰符决定了构造方法的创建方式默认构造方法如果一个构造方法中没有任何参数那么它就是一个默认构造方法也称为无参构造方法一辆自行车被创建在上面这个例子中我们为类中创建了一个无参的构造方法它在我们创建对象的时候被调用程序输出结果如下所示一辆自行车被创建通常情况下无参构造方法是可以缺省的我们开发者并不需要显式的声明无参构造方法把这项工作交给编译器就可以了默认构造方法的目的是什么它为什么是一个空的啊默认构造方法的目的主要是为对象的字段提供默认值看下面这个例子你就明白了姓名年龄输出结果如下所示姓名年龄在上面的例子中默认构造方法初始化了和的值是类型所以默认值为是类型所以默认值为如果没有默认构造方法的话这项工作就无法完成了有参构造方法有参数的构造方法被称为有参构造方法参数可以有一个或多个有参构造方法可以为不同的对象提供不同的值当然也可以提供相同的值姓名年龄在上面的例子中构造方法有两个参数和这样的话我们在创建对象的时候就可以直接为和赋值了重载构造方法在中构造方法和方法类似只不过没有返回类型它也可以像方法一样被重载构造方法的重载也很简单只需要提供不同的参数列表即可编译器会通过参数的数量来决定应该调用哪一个构造方法姓名年龄性别王二王三创建对象的时候如果传递的是三个参数那么就会调用这个构造方法如果传递的是两个参数那么就会调用这个构造方法构造方法和方法的区别构造方法和方法之间的区别还是蛮多的比如说下面这些复制对象复制一个对象可以通过下面三种方式完成通过构造方法通过对象的值通过类的方法通过构造方法姓名年龄王二在上面的例子中有一个参数为的构造方法可以把该参数的字段直接复制到新的对象中这样的话就可以在关键字创建新对象的时候把之前的对象传递过去通过对象的值姓名年龄王二这种方式比较粗暴直接拿的字段值复制给对象通过类的方法姓名年龄王二通过方法复制对象的时候必须先实现接口的方法然后再调用方法访问权限修饰符这个是我们掌握封装的核心知识考虑两个场景场景工程师编写了一个类但是工程师并不希望被其他类都访问到该如何处理呢场景工程师编写了一个类其中有两个方法工程师只想让对外可见也就是说如果别的工程师来调用只可以调用方法该怎么处理呢此时访问权限控制便可以起到作用了在中提供了四种访问权限控制默认访问权限包访问权限类只可以用默认访问权限和修饰比如说或者但变量和方法则都可以修饰修饰类默认访问权限包访问权限用来修饰类的话表示该类只对同一个包中的其他类可见用来修饰类的话表示该类对其他所有的类都可见例默认访问权限包访问权限从代码可以看出修饰类采用的是默认访问权限而由于类和类在同一个包中因此类对于类是可见的例子默认访问权限包访问权限此时类和类不在同一个包中会发生什么情况呢下面是类中的提示的错误提示类在类中不可见从这里就可以看出如果用默认访问权限去修饰一个类该类只对同一个包中的其他类可见对于不同包中的类是不可见的正如上图的快速修正提示所示将类的默认访问权限更改为的话类对于类便可见了修饰方法和变量默认访问权限包访问权限如果一个类的方法或变量被包访问权限修饰也就意味着只能在同一个包中的其他类中显示地调用该类的方法或者变量在不同包中的类中不能显式地调用该类的方法或变量如果一个类的方法或者变量被修饰那么这个类的方法或者变量只能在该类本身中被访问在类外以及其他类中都不能显式的进行访问如果一个类的方法或者变量被修饰对于同一个包的类这个类的方法或变量是可以被访问的对于不同包的类只有继承于该类的类才可以访问到该类的方法或者变量被修饰的方法或者变量在任何地方都是可见的例没有变化默认访问权限包访问权限默认访问权限包访问权限此时在类是可以显示调用方法和的但是如果类和类不在同一个包中与类处于不同包中默认访问权限包访问权限默认访问权限包访问权限此时在类中会提示错误由此可以看出如果用默认访问权限来修饰类的方法或者变量则只能在同一个包的其他类中进行访问例此时是可以在中显示调用方法和的如果类和类处于不同包中则会在中报错如果在中定一个类继承则可以在类中显示调用方法和补充一些关于包和类文件的知识中的包主要是为了防止类文件命名冲突以及方便进行代码组织和管理对于一个源代码文件如果存在类的话只能有一个类且此时源代码文件的名称必须和类的名称完全相同另外如果还存在其他类这些类在包外是不可见的如果源代码文件没有类则源代码文件的名称可以随意命名简单的来说就是初始代码块代码初始化块用于初始化一些成员变量可以直接通过操作符对成员变量进行初始化但通过代码初始化块可以做更多的事情比如说打印出成员变量初始化后的值我们来看下面的代码可以直接通过操作符对成员变量进行初始化那为什么还需要代码初始化块呢我们可以通过代码初始化块执行一个更复杂的操作比如为集合填充值来看下面这段代码如果只使用操作符的话是没办法完成集合初始化的对吧后面只能出集合却没办法填充值代码初始化就可以完成这项工作再看下面的例子构造方法代码初始化块我们可以发现输出的结果是代码初始化块构造方法从输出结果看上去仿佛代码初始化块执行得更早对象在初始化的时候会先调用构造方法这是毫无疑问的只不过构造方法在执行的时候会把代码初始化块放在构造方法中其他代码之前所以先看到了代码初始化块后看到了构造方法对于代码初始化来说它有三个规则类实例化的时候执行代码初始化块实际上代码初始化块是放在构造方法中执行的只不过比较靠前代码初始化块里的执行顺序是从前到后的这些规则不用死记硬背大致了解一下就行了我们继续来看下面这段代码父类构造方法子类构造方法代码初始化块下面来看输出结果父类构造方法代码初始化块子类构造方法在默认情况下子类的构造方法在执行的时候会主动去调用父类的构造方法也就是说其实是构造方法先执行的再执行的代码初始化块这个例子再次印证了之前的第二条规则代码初始化块是放在构造方法中执行的只不过比较靠前下面是一个示例代码演示实例初始化块和静态初始化块的用法静态变量实例变量静态初始化块执行静态初始化块实例初始化块执行实例初始化块构造方法执行构造方法执行方法的静态变量的实例变量的静态变量的实例变量在这个示例代码中有一个静态变量和一个实例变量以及一个静态初始化块和一个实例初始化块在静态初始化块中我们打印了一条消息并修改了静态变量的值在实例初始化块中我们也打印了一条消息并修改了实例变量的值来看一下执行结果执行静态初始化块执行方法执行实例初始化块执行构造方法执行实例初始化块执行构造方法的静态变量的实例变量的静态变量的实例变量从输出结果可以看出静态初始化块在类加载时执行只会执行一次并且优先于实例初始化块和构造方法的执行实例初始化块在每次创建对象时执行在构造方法之前执行抽象类定义抽象类定义抽象类的时候需要用到关键字放在关键字前就像下面这样关于抽象类的命名阿里的开发手册上有强调抽象类命名要使用或开头这条规约还是值得遵守的真正做到名如其意抽象类的特征抽象类是不能实例化的尝试通过关键字实例化的话编译器会报错提示类是抽象的不能实例化虽然抽象类不能实例化但可以有子类子类通过关键字来继承抽象类就像下面这样如果一个类定义了一个或多个抽象方法那么这个类必须是抽象类当我们尝试在一个普通类中定义抽象方法的时候编译器会有两处错误提示第一处在类级别上提示这个类必须通过关键字定义见下图第二处在尝试定义的方法上提示抽象方法所在的类不是抽象的见下图抽象类中既可以定义抽象方法也可以定义普通方法就像下面这样运动员也要休息而不是挑战极限抽象类派生的子类必须实现父类中定义的抽象方法比如说抽象类中定义了方法子类中就必须实现我是张伯伦篮球场上得过分如果没有实现的话编译器会提示子类必须实现抽象方法见下图抽象类的应用场景第一种场景当我们希望一些通用的功能被多个子类复用的时候就可以使用抽象类比如说抽象类中有一个普通的方法表明所有运动员都需要休息那么这个方法就可以被子类复用运动员也要休息而不是挑战极限子类继承了类也就拥有了方法的对象可以直接调用父类的方法子类继承了类也拥有了方法的对象也可以直接调用父类的方法这样是不是就实现了代码的复用呢第二种场景当我们需要在抽象类中定义好然后在子类中扩展实现的时候就可以使用抽象类比如说抽象类中定义了一个抽象方法表明所有运动员都可以从事某项运动但需要对应子类去扩展实现表明篮球运动员打篮球足球运动员踢足球继承了类扩展实现了自己的方法我是张伯伦我篮球场上得过分继承了类扩展实现了自己的方法我是罗我能接住任意高度的头球为了进一步展示抽象类的特性我们再来看一个具体的示例假设现在有一个文件里面的内容非常简单只有一个现在需要有一个读取器将内容从文件中读取出来最好能按照大写的方式或者小写的方式来读这时候最好定义一个抽象类抽象类定义了一个读取文件的基础框架其中是一个抽象方法具体实现需要由子类来完成定义一个的对象表示读取的文件路径构造方法传入读取的文件路径读取的文件路径读取文件的方法返回一个字符串列表字符串列表表示文件的内容如果文件读取出错抛出该异常使用类的方法读取文件的每一行对每一行应用方法将其转化为指定的格式将处理后的每一行收集到一个字符串列表中返回抽象方法子类需要实现该方法将文件中的每一行转化为指定的格式文件中的每一行转化后的字符串为文件路径使用修饰表明该成员变量可以在需要时被子类访问到方法用来读取文件方法体里面调用了抽象方法需要子类来扩展实现大小写的不同读取方式在我看来类设计的就非常合理并且易于扩展子类只需要专注于具体的大小写实现方式就可以了小写的方式大写的方式从文件里面一行一行读取内容的代码被子类复用了与此同时子类只需要专注于自己该做的工作以小写的方式读取文件内容以大写的方式读取文件内容来看一下测试类在项目的目录下建一个文本文件名字叫里面的内容就是文件的具体位置如下图所示我用的集成开发环境是在目录下的文件可以通过的方式获取到路径然后就可以取到文本内容了输出结果如下所示抽象类总结好了对于抽象类我们简单总结一下抽象类不能被实例化抽象类应该至少有一个抽象方法否则它没有任何意义抽象类中的抽象方法没有方法体抽象类的子类必须给出父类中的抽象方法的具体实现除非该子类也是抽象类接口在抽象类中抽象方法本质上是定义接口规范即规定高层类的接口从而保证所有子类都有相同的接口实现这样多态就能发挥出威力如果一个抽象类没有字段所有方法全部都是抽象方法就可以把该抽象类改写为接口在中使用可以声明一个接口所谓就是比抽象类还要抽象的纯抽象接口因为它连字段都不能有因为接口定义的所有方法默认都是的所以这两个修饰符不需要写出来写不写效果都一样当一个具体的去实现一个时需要使用关键字举个例子我们知道在中一个类只能继承自另一个类不能从多个类继承但是一个类可以实现多个例如实现了两个术语注意区分术语的接口特指的定义表示一个接口类型和一组方法签名而编程接口泛指接口规范如方法签名数据格式网络协议等抽象类和接口的对比如下继承只能一个可以多个字段可以定义实例字段不能定义实例字段抽象方法可以定义抽象方法可以定义抽象方法非抽象方法可以定义非抽象方法可以定义方法接口继承一个可以继承自另一个继承自使用它相当于扩展了接口的方法例如此时接口继承自接口因此接口现在实际上有个抽象方法签名其中一个来自继承的接口继承关系合理设计和的继承关系可以充分复用代码一般来说公共逻辑适合放在中具体逻辑放到各个子类而接口层次代表抽象程度可以参考的集合类定义的一组接口抽象类以及具体子类的继承关系在使用的时候实例化的对象永远只能是某个具体的子类但总是通过接口去引用它因为接口比抽象类更抽象用接口引用具体子类的实例向上转型为接口向上转型为接口说了这么多让我们来看看接口对我们的用途定义接口接口通过关键字来定义它可以包含一些常量和方法来看下面这个示例常量抽象方法静态方法默认方法电子来看一下这段代码反编译后的字节码发现没接口中定义的所有变量或者方法都会自动添加上关键字接下来我来一一解释下接口中的核心知识点接口中定义的变量会在编译的时候自动加上修饰符注意看一下反编译后的字节码也就是说上例中的变量其实就是一个常量官方文档上有这样的声明换句话说接口可以用来作为常量类使用还能省略掉看似不错的一种选择对吧不过这种选择并不可取因为接口的本意是对方法进行抽象而常量接口会对子类中的变量造成命名空间上的污染没有使用或者关键字修饰的方法是隐式抽象的在编译的时候会自动加上修饰符也就是说上例中的其实是一个抽象方法没有方法体这是定义接口的本意从开始接口中允许有静态方法比如说上例中的方法静态方法无法由实现了该接口的类的对象调用它只能通过接口名来调用比如说接口中定义静态方法的目的是为了提供一种简单的机制使我们不必创建对象就能调用方法从而提高接口的竞争力接口中允许定义方法也是从开始的比如说上例中的方法它始终由一个代码块组成为实现该接口而不覆盖该方法的类提供默认实现既然要提供默认实现就要有方法体换句话说默认方法后面不能直接使用号来结束编译器会报错为什么要在接口中定义默认方法呢允许在接口中定义默认方法的理由很充分因为一个接口可能有多个实现类这些类就必须实现接口中定义的抽象类否则编译器就会报错假如我们需要在所有的实现类中追加某个具体的方法在没有方法的帮助下我们就必须挨个对实现类进行修改由之前的例子我们就可以得出下面这些结论接口中允许定义变量接口中允许定义抽象方法接口中允许定义静态方法之后接口中允许定义默认方法之后除此之外我们还应该知道接口不允许直接实例化否则编译器会报错需要定义一个类去实现接口见下例然后再实例化接口可以是空的既可以不定义变量也可以不定义方法最典型的例子就是接口在包下接口用来为序列化的具体实现提供一个标记也就是说只要某个类实现了接口那么它就可以用来序列化了不要在定义接口的时候使用关键字否则会报编译错误因为接口就是为了让子类实现的而阻止了这种行为接口的抽象方法不能是或者否则编译器都会报错接口的变量是隐式常量所以其值无法改变接口的作用第一使某些实现类具有我们想要的功能比如说实现了接口的类具有拷贝的功能实现了或者的类具有比较功能和一样都属于标记型接口它们内部都是空的实现了接口的类可以使用方法否则会抛出运行后没有报错现在把去掉运行后抛出第二原则上只支持单一继承但通过接口可以实现多重继承的目的如果有两个类共同继承一个父类那么父类的方法就会被两个子类重写然后如果有一个新类同时继承了这两个子类那么在调用重写方法的时候编译器就不能识别要调用哪个类的方法了这也正是著名的菱形问题见下图简单解释下同时继承了和的对象在调用和中重写的方法时就不知道该调用的方法还是的方法接口没有这方面的困扰来定义两个接口接口会飞接口会跑然后让类同时实现这两个接口会飞的猪会跑的猪在某种形式上接口实现了多重继承的目的现实世界里猪的确只会跑但在雷军的眼里站在风口的猪就会飞这就需要赋予这只猪更多的能力通过抽象类是无法实现的只能通过接口第三实现多态什么是多态呢通俗的理解就是同一个事件发生在不同的对象上会产生不同的结果鼠标左键点击窗口上的号可以关闭窗口点击超链接却可以打开新的网页多态可以通过继承的关系实现也可以通过接口的形式实现接口表示一个形状类实现了接口并重写了方法圆类也实现了接口并重写了方法正方形然后来看测试类这就实现了多态变量的引用类型都是但执行方法的时候虚拟机知道该去调用的方法还是的方法说一下多态存在的个前提要有继承关系比如说和都实现了接口子类要重写父类的方法和都重写了方法父类引用指向子类对象和的类型都为但前者指向的是对象后者指向的是对象然后我们来看一下测试结果圆正方形也就意味着尽管在循环中的类型都为但在调用方法的时候它知道对象应该调用类的方法对象应该调用类的方法接口的三种模式在编程领域好的设计模式能够让我们的代码事半功倍在使用接口的时候经常会用到三种模式分别是策略模式适配器模式和工厂模式策略模式策略模式的思想是针对一组算法将每一种算法封装到具有共同接口的实现类中接口的设计者可以在不影响调用者的情况下对算法做出改变示例如下接口教练方法防守何塞穆里尼奥防守赢得冠军德普瓜迪奥拉进攻就是最好的防守参数为接口为同一个方法传递不同的对象方法可以接受不同风格的并根据所传递的参数对象的不同而产生不同的行为这被称为策略模式适配器模式适配器模式的思想是针对调用者的需求对原有的接口进行转接生活当中最常见的适配器就是英语中文高清多媒体接口线可以同时发送音频和视频信号适配器模式的示例如下抽象类实现接口并置空方法新类继承适配器防守赢得冠军接口中定义了两个方法和如果类直接实现该接口的话就需要对两个方法进行实现如果我们只需要对其中一个方法进行实现的话就可以使用一个抽象类作为中间件即适配器用这个抽象类实现接口并对抽象类中的方法置空方法体只有一对花括号这时候新类就可以绕过接口继承抽象类我们就可以只对需要的方法进行覆盖而不是接口中的所有方法简单的来看一个案例面向对象进阶比如有这样一个接口里面有非常多的接口之后写一个类实现这个接口的时候必须要重写其中的所有的方法非常的麻烦如果你只想用那就没有办法了吗实际上是有的我们用一个中间的类面向对象进阶让外界调用她所以把她设置成抽象的之后我们直接继承这个类需要重写哪一个方法就重写哪一个就可以了面向对象进阶需要什么方法重写就可以了工厂模式所谓的工厂模式理解起来也不难就是什么工厂生产什么比如说宝马工厂生产宝马奔驰工厂生产奔驰级学院毕业级教练级学院毕业级教练示例如下教练教练学院级教练我是级证书教练级教练学院级教练我是级证书教练级教练学院对于一支球队来说需要什么样的教练就去找什么样的学院学院会介绍球队对应水平的教练有两个接口一个是教练可以指挥球队另外一个是教练学院能教出一名优秀的教练然后类实现接口类实现接口类实现接口类实现接口当需要级教练时就去找级教练学院当需要级教练时就去找级教练学院依次类推我们还可以用类实现接口类实现接口从而不断地丰富教练的梯队抽象类和接口的区别简单总结一下抽象类和接口的区别在中通过关键字定义的类叫做抽象类是一门面向对象的语言因此所有的对象都是通过类来描述的但反过来并不是所有的类都是用来描述对象的抽象类就是其中的一种以下示例展示了一个简单的抽象类个人认为一名教练必须攻守兼备我们知道有抽象方法的类被称为抽象类也就意味着抽象类中还能有不是抽象方法的方法这样的类就不能算作纯粹的接口尽管它也可以提供接口的功能只能说抽象类是普通类与接口之间的一种中庸之道接口英文在中是一个抽象类型是抽象方法的集合接口通过关键字来定义接口与抽象类的不同之处在于抽象类可以有方法体的方法但接口没有以前接口中的成员变量隐式为但抽象类不是的一个类可以实现多个接口但只能继承一个抽象类以下示例展示了一个简单的接口隐式的隐式的接口是隐式抽象的所以声明时没有必要使用关键字接口的每个方法都是隐式抽象的所以同样不需要使用关键字接口中的方法都是隐式的语法层面上抽象类可以提供成员方法的实现细节而接口中只能存在方法抽象类中的成员变量可以是各种类型的而接口中的成员变量只能是类型的接口中不能含有静态代码块而抽象类可以有静态代码块一个类只能继承一个抽象类而一个类却可以实现多个接口设计层面上抽象类是对一种事物的抽象即对类抽象继承抽象类的子类和抽象类本身是一种的关系而接口是对行为的抽象抽象类是对整个类整体进行抽象包括属性行为但是接口却是对类局部行为进行抽象举个简单的例子飞机和鸟是不同类的事物但是它们都有一个共性就是都会飞那么在设计的时候可以将飞机设计为一个类将鸟设计为一个类但是不能将飞行这个特性也设计为类因此它只是一个行为特性并不是对一类事物的抽象描述此时可以将飞行设计为一个接口包含方法然后和分别根据自己的需要实现这个接口然后至于有不同种类的飞机比如战斗机民用飞机等直接继承即可对于鸟也是类似的不同种类的鸟直接继承类即可从这里可以看出继承是一个是不是的关系而接口实现则是有没有的关系如果一个类继承了某个抽象类则子类必定是抽象类的种类而接口实现则是有没有具备不具备的关系比如鸟是否能飞或者是否具备飞行这个特点能飞行则可以实现这个接口不能飞行就不实现这个接口接口是对类的某种行为的一种抽象接口和类之间并没有很强的关联关系举个例子来说所有的类都可以实现接口从而具有序列化的功能但不能说所有的类和之间是的关系抽象类作为很多子类的父类它是一种模板式设计而接口是一种行为规范它是一种辐射式设计什么是模板式设计最简单例子大家都用过里面的模板如果用模板设计了和和公共的部分就是模板了如果它们的公共部分需要改动则只需要改动模板就可以了不需要重新对和进行改动而辐射式设计比如某个电梯都装了某种报警器一旦要更新报警器就必须全部更新也就是说对于抽象类如果需要添加新的方法可以直接在抽象类中添加具体的实现子类可以不进行变更而对于接口则不行如果接口进行了变更则所有实现这个接口的类都必须进行相应的改动简单的来说接口就是一个规范也是在以后多人协作创作项目的时候所使用的这个和抽象非常的类似那他们之间有什么区别的呢简单的来说接口是多继承的而抽象是单继承的所以接口就是一种规则下面我们来写一个案例来巩固这个操作案例首先我们话一个图帮助我们来理解之后开始我们的代码实现吧先看父类面向对象进阶因为创建人对象是没有意义的所以就把她写成一个抽象的获取设置获取设置之后再看接口面向对象进阶功能概述之后再看子类先是俩个定义了抽象的子类面向对象进阶面向对象进阶之后是她们的子类面向对象进阶篮球教练在教如何打篮球面向对象进阶篮球运动员在学习如何打篮球面向对象进阶乒乓球教练在教如何打乒乓球乒乓球教练学习说英语面向对象进阶乒乓球运动员在说英语乒乓球运动员在学习如何打乒乓球最后是我们的类面向对象进阶你好方法在接口中可以定义方法例如把接口的方法改为方法实现类可以不必覆写方法方法的目的是当我们需要给接口新增一个方法时会涉及到修改全部子类如果新增的是方法那么子类就不必全部修改只需要在需要覆写的地方去覆写新增方法方法和抽象类的普通方法是有所不同的因为没有字段方法无法访问字段而抽象类的普通方法可以访问实例字段内部类一般来说内部类分为成员内部类局部内部类匿名内部类和静态内部类成员内部类成员内部类是最常见的内部类看下面的代码看起来内部类就好像的一个成员成员内部类可以无限制访问外部类的所有成员属性小内部类可以随心所欲地访问外部类的成员但外部类想要访问内部类的成员就不那么容易了必须先创建一个成员内部类的对象再通过这个对象来访问小这也就意味着如果想要在静态方法中访问成员内部类的时候就必须先得创建一个外部类的对象因为内部类是依附于外部类的小这种创建内部类的方式在实际开发中并不常用因为内部类和外部类紧紧地绑定在一起使用起来非常不便局部内部类局部内部类是定义在一个方法或者一个作用域里面的类所以局部内部类的生命周期仅限于作用域内局部内部类就好像一个局部变量一样它是不能被权限修饰符修饰的比如说和等匿名内部类匿名内部类是我们平常用得最多的尤其是启动多线程的时候会经常用到并且也会帮我们自动生成匿名内部类就好像一个方法的参数一样用完就没了以至于我们都不需要为它专门写一个构造方法它的名字也是由系统自动命名的仔细观察编译后的字节码文件也可以发现匿名内部类连名字都不配拥有哈哈直接借用的外部类然后就搞定了匿名内部类是唯一一种没有构造方法的类就上面的写法来说匿名内部类也不允许我们为其编写构造方法因为它就像是直接通过关键字创建出来的一个对象匿名内部类的作用主要是用来继承其他类或者实现接口并不需要增加额外的方法方便对继承的方法进行实现或者重写静态内部类静态内部类和成员内部类类似只是多了一个关键字由于关键字的存在静态内部类是不允许访问外部类中非的变量和方法的这一点也非常好理解你一个静态的内部类访问我非静态的成员变量干嘛在中有这样一句话使用内部类最吸引人的原因是每个内部类都能独立地继承一个接口的实现所以无论外围类是否已经继承了某个接口的实现对于内部类都没有影响在我们程序设计中有时候会存在一些使用接口很难解决的问题这个时候我们可以利用内部类提供的可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题可以这样说接口只是解决了部分问题而内部类使得多重继承的解决方案变得更加完整使用内部类还能够为我们带来如下特性内部类可以使用多个实例每个实例都有自己的状态信息并且与其他外围对象的信息相互独立在单个外部类中可以让多个内部类以不同的方式实现同一个接口或者继承同一个类创建内部类对象的时刻并不依赖于外部类对象的创建内部类并没有令人迷惑的关系他就是一个独立的实体内部类提供了更好的封装除了该外围类其他类都不能访问关键字和关键字有很多种用法其中最常用的一个是它可以作为引用变量指向当前对象除此之外关键字还可以完成以下工作调用当前类的方法可以调用当前类的构造方法可以作为参数在方法中传递可以作为参数在构造方法中传递可以作为方法的返回值返回当前类的对象指向当前对象在上面的例子中构造方法的参数名和实例变量名相同由于没有使用关键字所以无法为实例变量赋值下面来看输出的结果从结果中可以看得出来尽管创建对象的时候传递了参数但实例变量并没有赋值这是因为如果构造方法中没有使用关键字的话和指向的并不是实例变量而是参数本身所以当我们在构造函数中加上就可以了这次实例变量有值了在构造方法中指向的就是实例变量而不再是参数本身了我慢吞吞地说着当然了如果参数名和实例变量名不同的话就不必使用关键字但我建议使用关键字这样的代码更有意义调用当前类的方法我们来看这个代码可以发现并没有这个关键字但是在我们的反编译字节码文件中出现了我们可以在一个类中使用关键字来调用另外一个方法如果没有使用的话编译器会自动帮我们加上在源代码中在调用的时候并没有使用关键字但通过反编译后的字节码可以看得到调用当前类的构造方法再来看下面这段代码在有参构造方法中使用了来调用无参构造方法可用于调用当前类的构造方法构造方法可以重用了来看一下输出结果同样的也可以在无参构造方法中使用并传递参数来调用有参构造方法下面再来看一个输出结果不过需要注意的是必须放在构造方法的第一行否则就报错了作为参数在方法中传递看上面的这个代码关键字可以作为参数在方法中传递此时它指向的是当前类的对象再看一下输出结果调用了并传递了参数中打印了当前对象的字符串方法中打印了对象的字符串从输出结果中可以看得出来两者是同一个对象作为参数在构造方法中传递继续来看代码在构造方法中我们使用关键字作为参数传递给了对象它其实指向的就是这个对象关键字也可以作为参数在构造方法中传递它指向的是当前类的对象当我们需要在多个类中使用一个对象的时候这非常有用来看一下输出结果作为方法的返回值方法返回了关键字指向的就是这个对象所以可以紧接着调用方法达到了链式调用的目的这也是关键字非常经典的一种用法来看一下输出结果关键字的用法主要有三种指向父类对象调用父类的方法可以调用父类的构造方法其实和有些相似只不过用意不大相同每当创建一个子类对象的时候也会隐式的创建父类对象由关键字引用如果父类和子类拥有同样名称的字段关键字可以用来访问父类的同名字段例如如下的代码白色黑色父类中有一个名为的字段子类中也有一个名为的字段子类的方法中通过关键字可以访问父类的来看一下输出结果黑色白色当子类和父类的方法名相同时可以使用关键字来调用父类的方法换句话说关键字可以用于方法重写时访问到父类的方法吃吃汪汪汪父类和子类中都有一个名为的方法通过可以访问到父类的方法再看这个代码动物来了狗狗来了子类的构造方法中第一行代码为它就是用来调用父类的构造方法的来看一下输出结果动物来了狗狗来了当然了在默认情况下是可以省略的编译器会主动去调用父类的构造方法也就是说子类即使不使用主动调用父类的构造方法父类的构造方法仍然会先执行动物来了狗狗来了输出结果和之前一样动物来了狗狗来了也可以用来调用父类的有参构造方法这样可以提高代码的可重用性类继承了类也就继承了和字段当在中新增了字段后构造方法中就可以使用来调用父类的有参构造方法来看一下输出结果关键字是中比较难以理解的一个关键字也是各大公司的面试官最喜欢问到的一个知识点之一既然是面试重点那可得好好学习下关键字的作用可以用一句话来描述方便在没有创建对象的情况下进行调用包括变量和方法也就是说只要类被加载了就可以通过类名进行访问静态变量如果在声明变量的时候使用了关键字那么这个变量就被称为静态变量静态变量只在类加载的时候获取一次内存空间这使得静态变量很节省内存空间郑州大学假设郑州大学录取了一万名新生那么在创建一万个对象的时候所有的字段和都会获取到一块内存学生的姓名和年纪不尽相同但都属于郑州大学如果每创建一个对象这个字段都要占用一块内存的话就很浪费对吧因此最好将这个字段设置为这样就只会占用一块内存而不是一万块郑州大学其中我们定义的别的变量都在堆内存但是只有定义的是再我们的你静态区域里我们创建一个成员变量并且在构造函数中让它自增因为成员变量会在创建对象的时候获取内存因此每一个对象都会有一个的副本的值并不会随着对象的增多而递增我们来看他的结果每创建一个对象的值就从自增到来看一下输出结果简单解释一下哈由于静态变量只会获取一次内存空间所以任何对象对它的修改都会得到保留所以每创建一个对象的值就会加所以最终的结果是另外需要注意的是由于静态变量属于一个类所以不要通过对象引用来访问而应该直接通过类名来访问否则编译器会发出警告静态方法静态方法有以下这些特征静态方法属于这个类而不是这个类的对象调用静态方法的时候不需要创建这个类的对象静态方法可以访问静态变量来继续上代码郑州大学河南大学方法就是一个静态方法所以它可以直接访问静态变量把它的值更改为河南大学并且可以通过类名直接调用方法就像这样来看一下程序的输出结果吧河南大学河南大学需要注意的是静态方法不能访问非静态变量和调用非静态方法我稍微改动一下代码编译器就会报错先是在静态方法中访问非静态变量编译器不允许然后在静态方法中访问非静态方法编译器同样不允许为什么方法是静态的如果方法不是静态的就意味着虚拟机在执行的时候需要先创建一个对象才能调用方法而方法作为程序的入口创建一个额外的对象显得非常多余类的几乎所有方法都是静态的可以直接通过类名来调用不需要创建类的对象静态代码块就像下面这串代码静态代码块方法静态代码块通常用来初始化一些静态变量它会优先于方法执行来看一下程序的输出结果吧静态代码块方法静态代码块没有在命令行中执行的时候会抛出的错误静态内部类常见的内部类有四种成员内部类局部内部类匿名内部类和静态内部类限于篇幅原因前三种不在我们本次的讨论范围之内以后有机会再细说第一次加载类时并不会初始化只有第一次调用方法时虚拟机才开始加载并初始化这样不仅能确保线程安全也能保证类的唯一性不过创建单例更优雅的一种方式是使用枚举以后再讲给你听需要注意的是第一静态内部类不能访问外部类的所有成员变量第二静态内部类可以访问外部类的所有静态变量包括私有静态变量第三外部类不能声明为',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-04 09:39:35',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://mydocs.guoyaxue.top/" title="旧版博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="旧版博客"/><span class="back-menu-item-text">旧版博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://pan.xiaou61.top/#/" title="免费网盘"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="免费网盘"/><span class="back-menu-item-text">免费网盘</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://cloud.xiaou61.top/" title="云盘(自用)"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="云盘(自用)"/><span class="back-menu-item-text">云盘(自用)</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://wpzc.xiaou61.top/" title="云盘转存"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="云盘转存"/><span class="back-menu-item-text">云盘转存</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://love.xiaou61.top/#/" title="关于我们(My girlFriend)"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="关于我们(My girlFriend)"/><span class="back-menu-item-text">关于我们(My girlFriend)</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">娱乐项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://fxq.xiaou61.top/#/" title="飞行棋"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="飞行棋"/><span class="back-menu-item-text">飞行棋</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/game/sqnwmai803/" title="谁去拿外卖"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="谁去拿外卖"/><span class="back-menu-item-text">谁去拿外卖</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/desktop.html" title="win12网页版"><img class="back-menu-item-icon" src="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/icon/logo.svg" alt="win12网页版"/><span class="back-menu-item-text">win12网页版</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://game.xiaou61.top/" title="在线游戏"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="在线游戏"/><span class="back-menu-item-text">在线游戏</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">小u的博客</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 开往</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><span> 开往</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> Newest Comments</span></div><div class="aside-list"><span>loading...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>3</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>1</sup></a><a href="/tags/JVM/" style="font-size: 1.05rem;">JVM<sup>22</sup></a><a href="/tags/Nginx/" style="font-size: 1.05rem;">Nginx<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 1.05rem;">Spring<sup>1</sup></a><a href="/tags/Ts/" style="font-size: 1.05rem;">Ts<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size: 1.05rem;">TypeScript<sup>1</sup></a><a href="/tags/WebApi/" style="font-size: 1.05rem;">WebApi<sup>1</sup></a><a href="/tags/coder1v5/" style="font-size: 1.05rem;">coder1v5<sup>2</sup></a><a href="/tags/css/" style="font-size: 1.05rem;">css<sup>3</sup></a><a href="/tags/java/" style="font-size: 1.05rem;">java<sup>12</sup></a><a href="/tags/javaSE/" style="font-size: 1.05rem;">javaSE<sup>3</sup></a><a href="/tags/javaWeb/" style="font-size: 1.05rem;">javaWeb<sup>2</sup></a><a href="/tags/js%E9%80%86%E5%90%91/" style="font-size: 1.05rem;">js逆向<sup>1</sup></a><a href="/tags/leetcode/" style="font-size: 1.05rem;">leetcode<sup>3</sup></a><a href="/tags/python/" style="font-size: 1.05rem;">python<sup>8</sup></a><a href="/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/" style="font-size: 1.05rem;">书籍推荐<sup>2</sup></a><a href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%90%AC%E8%BF%90/" style="font-size: 1.05rem;">公众号搬运<sup>35</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 1.05rem;">前端<sup>10</sup></a><a href="/tags/%E5%8A%9E%E5%85%AC/" style="font-size: 1.05rem;">办公<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 1.05rem;">后端<sup>8</sup></a><a href="/tags/%E5%A4%A9%E6%B6%AF%E8%AE%BA%E5%9D%9B/" style="font-size: 1.05rem;">天涯论坛<sup>1</sup></a><a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 1.05rem;">导航<sup>1</sup></a><a href="/tags/%E5%B0%B1%E4%B8%9A/" style="font-size: 1.05rem;">就业<sup>16</sup></a><a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 1.05rem;">微信<sup>1</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/" style="font-size: 1.05rem;">技术杂谈<sup>51</sup></a><a href="/tags/%E6%8E%98%E9%87%91/" style="font-size: 1.05rem;">掘金<sup>14</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 1.05rem;">杂项<sup>1</sup></a><a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 1.05rem;">测试<sup>1</sup></a><a href="/tags/%E6%B8%A1%E4%B8%80%E5%A4%A7%E5%B8%88%E8%AF%BE/" style="font-size: 1.05rem;">渡一大师课<sup>3</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 1.05rem;">爬虫<sup>1</sup></a><a href="/tags/%E7%9B%AE%E5%BD%95/" style="font-size: 1.05rem;">目录<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>4</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 1.05rem;">虚拟机<sup>12</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.05rem;">设计模式<sup>6</sup></a><a href="/tags/%E8%B7%AF%E9%A3%9E%E5%AD%A6%E9%99%A2/" style="font-size: 1.05rem;">路飞学院<sup>3</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 1.05rem;">面向对象<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>51</sup></a><a href="/tags/%E9%A3%9E%E8%A1%8C%E6%A3%8B/" style="font-size: 1.05rem;">飞行棋<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>Archives</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">October 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">234</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">September 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">May 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/" itemprop="url">java</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url">面向对象</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/java/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>java</span></a><a class="article-meta__tags" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>面向对象</span></a></span></div></div><h1 class="post-title" itemprop="name headline">java面向对象</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-09-30T23:34:06.070Z" title="Created 2023-10-01 07:34:06">2023-10-01</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-09-04T01:39:35.871Z" title="Updated 2023-09-04 09:39:35">2023-09-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为邯郸"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>邯郸</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2023/10/01/codenotes/Java/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><header><a class="post-meta-categories" href="/categories/java/" itemprop="url">java</a><a class="post-meta-categories" href="/categories/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" itemprop="url">面向对象</a><a href="/tags/java/" tabindex="-1" itemprop="url">java</a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" tabindex="-1" itemprop="url">面向对象</a><h1 id="CrawlerTitle" itemprop="name headline">java面向对象</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">小u</span><time itemprop="dateCreated datePublished" datetime="2023-09-30T23:34:06.070Z" title="Created 2023-10-01 07:34:06">2023-10-01</time><time itemprop="dateCreated datePublished" datetime="2023-09-04T01:39:35.871Z" title="Updated 2023-09-04 09:39:35">2023-09-04</time></header><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406250.png"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这本书励志与用这一本书讲透java的面向对象，其实面向对象是一个非常常见的场景在java里面，所以这个是每一个学习java要实现掌握的，并且详细掌握的，为了以后我们去学习一些框架，打下基础。</p>
<h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><p>相信很多Java开发者，在最初接触Java的时候就听说过，Java是一种面向对象的开发语言，那么什么是面向对象呢？</p>
<p>首先，所谓面向对象，其实是指软件工程中的一类编程风格，很多人称呼他们为开发范式、编程泛型（Programming Paradigm）。面向对象是众多开发范式中的一种。除了面向对象以外，还有面向过程、指令式编程、函数式编程等。</p>
<p>虽然这几年函数式编程越来越被人们所熟知，但是，在所有的开发范式中，我们接触最多的主要还是面向过程和面向对象两种。</p>
<h4 id="什么是面向过程"><a href="#什么是面向过程" class="headerlink" title="什么是面向过程"></a>什么是面向过程</h4><p>面向过程(Procedure Oriented)是一种以过程为中心的编程思想，是一种自顶而下的编程模式。最典型的面向过程的编程语言就是C语言。</p>
<p>简单来说，面向过程的开发范式中，程序员需要把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。</p>
<p>就是说，在进行面向过程编程的时候，不需要考虑那么多，上来先定义一个函数，然后使用各种诸如if-else、for-each等方式进行代码执行。最典型的用法就是实现一个简单的算法，比如实现冒泡排序。</p>
<p>面向过程进行的软件开发，其代码都是流程化的，很明确的可以看出第一步做什么、第二步做什么。这种方式的代码执行起来效率很高。</p>
<p>但是，面向过程同时存在着代码重用性低，扩展能力差，后期维护难度比较大等问题。</p>
<h4 id="什么是面向对象-1"><a href="#什么是面向对象-1" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h4><p>面向对象（Object Oriented）的雏形，最早在出现在1960年的Simula语言中，当时的程序设计领域正面临着一种危机：在软硬件环境逐渐复杂的情况下，软件如何得到良好的维护？</p>
<p>面向对象程序设计在某种程度上通过强调可重复性解决了这一问题。目前较为流行的面向对象语言主要有Java、C##、C++、Python、Ruby、PHP等。</p>
<p>简单来说，面向对象的开发范式中，程序员将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。</p>
<p>就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。比如:想要造一辆车，上来要先把车的各种属性定义出来，然后抽象成一个Car类。</p>
<p>面向对象的编程方法之所以更加受欢迎，是因为他更加符合人类的思维方式。这种方式编写出来的代码扩展性、可维护性都很高。</p>
<p>与其实面向对象是一种开发范式，倒不如说面向对象是一种对现实世界的理解和抽象的方法。通过对现实世界的理解和抽象，在运用封装、继承、多态等方法，通过抽象出对象的方式进行软件开发。</p>
<p>举个简单点的例子来区分一下面向过程和面向对象。</p>
<p>有一天，你想吃小碗汤了，怎么办呢？有两个选择：</p>
<p>1）自己买食材，豆腐皮啊、肉啊、蒜苔啊等等，自己动手做。</p>
<p>2）到饭店去，只需要对老板喊一声，“来份小碗汤。”</p>
<p>第一种就是面向过程，第二种就是面向对象。</p>
<p>面向过程有什么劣势呢？假如你买了小碗汤的食材，临了又想吃宫保鸡丁了，你是不是还得重新买食材？</p>
<p>面向对象有什么优势呢？假如你不想吃小碗汤了，你只需要对老板说，“我那个小碗汤如果没做的话，换成宫保鸡丁吧！”</p>
<p>面向过程是流程化的，一步一步，上一步做完了，再做下一步。</p>
<p>面向对象是模块化的，我做我的，你做你的，我需要你做的话，我就告诉你一声。我不需要知道你到底怎么做，只看功劳不看苦劳。</p>
<p>不过，如果追到底的话，面向对象的底层其实还是面向过程，只不过把面向过程进行了抽象化，封装成了类，方便我们的调用。</p>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>对象可以是现实中看得见的任何物体，比如说，一只特立独行的猪；也可以是想象中的任何虚拟物体，比如说能七十二变的孙悟空。</p>
<p>Java 通过类（class）来定义这些物体，这些物体有什么状态，通过字段来定义，比如说比如说猪的颜色是纯色还是花色；这些物体有什么行为，通过方法来定义，比如说猪会吃，会睡觉。</p>
<p>来，定义一个简单的类给你看看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dadoudou</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个类可以包含：</p>
<ul>
<li>字段（Filed）</li>
<li>方法（Method）</li>
<li>构造方法（Constructor）</li>
</ul>
<p>在 Person 类中，字段有 3 个，分别是 name、age 和 sex，它们也称为成员变量——在类内部但在方法外部，方法内部的叫临时变量。</p>
<p>成员变量有时候也叫做实例变量，在编译时不占用内存空间，在运行时获取内存，也就是说，只有在对象实例化（<code>new Person()</code>）后，字段才会获取到内存，这也正是它被称作“实例”变量的原因。</p>
<p>方法有 3 个，分别是 <code>eat()</code>、<code>sleep()</code> 和 <code>dadoudou()</code>，表示 Person 这个对象可以做什么，也就是吃饭睡觉打豆豆。</p>
<p>那么我们可能会疑惑，为什么没有构造方法。</p>
<p>的确在 Person 类的源码文件（.java）中没看到，但在反编译后的字节码文件（.class）中是可以看得到的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.itwanger.twentythree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dadoudou</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>public Person()&#123;&#125;</code> 就是默认的构造方法，因为是空的构造方法（方法体中没有内容），所以可以缺省。Java 聪明就聪明在这，有些很死板的代码不需要开发人员添加，它会偷偷地做了。但是在实际的开发中，我们还是推荐加上的。</p>
<h3 id="new一个对象"><a href="#new一个对象" class="headerlink" title="new一个对象"></a>new一个对象</h3><p>创建 Java 对象时，需要用到 <code>new</code> 关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>这行代码就通过 Person 类创建了一个 Person 对象。所有<strong>对象</strong>在创建的时候都会在<strong>堆内存中分配空间</strong>。</p>
<p>创建对象的时候，需要一个 <code>main()</code> 方法作为入口， <code>main()</code> 方法可以在当前类中，也可以在另外一个类中。</p>
<p>第一种：<code>main()</code> 方法直接放在 Person 类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dadoudou</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">        System.out.println(person.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>第二种：<code>main()</code> 方法不在 Person 类中，而在另外一个类中。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405369.png" alt="img"></p>
<p>实际开发中，我们通常不在当前类中直接创建对象并使用它，而是放在使用对象的类中，比如说上图中的 PersonTest 类。</p>
<p>可以把 PersonTest 类和 Person 类放在两个文件中，也可以放在一个文件（命名为 PersonTest.java）中，就像下面这样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PersonTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dadoudou</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="初始化对象"><a href="#初始化对象" class="headerlink" title="初始化对象"></a>初始化对象</h3><p>在之前的例子中，程序输出结果为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">null</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>为什么会有这样的输出结果呢？因为 Person 对象没有初始化，因此输出了 String 的默认值 null，int 的默认值 0。</p>
<p>那怎么初始化 Person 对象（对字段赋值）呢？</p>
<h5 id="第一种：通过对象的引用变量。"><a href="#第一种：通过对象的引用变量。" class="headerlink" title="第一种：通过对象的引用变量。"></a>第一种：通过对象的引用变量。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.name = <span class="string">&quot;xiaou&quot;</span>;</span><br><span class="line">        person.age = <span class="number">18</span>;</span><br><span class="line">        person.sex = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">        System.out.println(person.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>person 被称为对象 Person 的引用变量，见下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405376.png" alt="img"></p>
<p>通过对象的引用变量，可以直接对字段进行初始化（<code>person.name = &quot;xiaou&quot;</code>），所以以上代码输出结果如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xiaou</span><br><span class="line">18</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h5 id="第二种：通过方法初始化。"><a href="#第二种：通过方法初始化。" class="headerlink" title="第二种：通过方法初始化。"></a>第二种：通过方法初始化。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(String n, <span class="type">int</span> a, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">        sex = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.initialize(<span class="string">&quot;xiaou&quot;</span>,<span class="number">18</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">        System.out.println(person.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Person 类中新增方法 <code>initialize()</code>，然后在新建对象后传参进行初始化（<code>person.initialize(&quot;xiaou&quot;, 18, 1)</code>）。</p>
<h5 id="第三种：通过构造方法初始化。"><a href="#第三种：通过构造方法初始化。" class="headerlink" title="第三种：通过构造方法初始化。"></a>第三种：通过构造方法初始化。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xiaou&quot;</span>, <span class="number">18</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person.name);</span><br><span class="line">        System.out.println(person.age);</span><br><span class="line">        System.out.println(person.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也是最标准的一种做法，直接在 new 的时候把参数传递过去。</p>
<p>补充一点知识，匿名对象。匿名对象意味着没有引用变量，它只能在创建的时候被使用一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure>

<p>可以直接通过匿名对象调用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>().initialize(<span class="string">&quot;xiaou&quot;</span>, <span class="number">18</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>我们来看下面的这个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a1phone</span> &#123;</span><br><span class="line">    String brand;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机在打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playGame</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机在玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向方法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a1phonetest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建手机的对象</span></span><br><span class="line">        a1phone p=<span class="keyword">new</span> <span class="title class_">a1phone</span>();</span><br><span class="line">        p.brand=<span class="string">&quot;小米&quot;</span>;</span><br><span class="line">        p.price=<span class="number">1999.98</span>;</span><br><span class="line">        System.out.println(p.brand);</span><br><span class="line">        System.out.println(p.price);</span><br><span class="line">        p.call();</span><br><span class="line">        p.playGame();</span><br><span class="line">        a1phone p2=<span class="keyword">new</span> <span class="title class_">a1phone</span>();</span><br><span class="line">        p2.brand=<span class="string">&quot;苹果&quot;</span>;</span><br><span class="line">        p2.price=<span class="number">9999.99</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把我们新建的这个对象，也叫做javabean。</p>
<p>在javabean类中，是不写main方法的。</p>
<p>在以前，编写main方法的类，都叫做，测试类。</p>
<p>我们可以在测试类中创建javabean类的对象进行赋值调用</p>
<h3 id="关于对象"><a href="#关于对象" class="headerlink" title="关于对象"></a>关于对象</h3><h5 id="1）抽象的历程"><a href="#1）抽象的历程" class="headerlink" title="1）抽象的历程"></a><strong>1）抽象的历程</strong></h5><p>所有编程语言都是一种抽象，甚至可以说，我们能够解决的问题的复杂程度取决于抽象的类型和质量。</p>
<p>Smalltalk 是历史上第一门获得成功的面向对象语言，也为 Java 提供了灵感。它有 5 个基本特征：</p>
<ul>
<li>万物皆对象。</li>
<li>一段程序实际上就是多个对象通过发送消息的方式来告诉彼此该做什么。</li>
<li>通过组合的方式，可以将多个对象封装成其他更为基础的对象。</li>
<li>对象是通过类实例化的。</li>
<li>同一类型的对象可以接收相同的消息。</li>
</ul>
<p>总结一句话就是：</p>
<blockquote>
<p>状态+行为+标识&#x3D;对象，每个对象在内存中都会有一个唯一的地址。</p>
</blockquote>
<h5 id="2）对象具有接口"><a href="#2）对象具有接口" class="headerlink" title="2）对象具有接口"></a><strong>2）对象具有接口</strong></h5><p>所有的对象，都可以被归为一类，并且同一类对象拥有一些共同的行为和特征。在 Java 中，class 关键字用来定义一个类型。</p>
<p>创建抽象数据类型是面向对象编程的一个基本概念。你可以创建某种类型的变量，Java 中称之为对象或者实例，然后你就可以操作这些变量，Java 中称之为发送消息或者发送请求，最后对象决定自己该怎么做。</p>
<p>类描述了一系列具有相同特征和行为的对象，从宽泛的概念上来说，类其实就是一种自定义的数据类型。</p>
<p>一旦创建了一个类，就可以用它创建任意多个对象。面向对象编程语言遇到的最大一个挑战就是，如何把现实&#x2F;虚拟的元素抽象为 Java 中的对象。</p>
<p>对象能够接收什么样的请求是由它的接口定义的。具体是怎么做到的，就由它的实现方法来实现。</p>
<h5 id="3）访问权限修饰符"><a href="#3）访问权限修饰符" class="headerlink" title="3）访问权限修饰符"></a><strong>3）访问权限修饰符</strong></h5><p>类的创建者有时候也被称为 API 提供者，对应的，类的使用者就被称为 API 调用者。</p>
<p>JDK 就给我们提供了 Java 的基础实现，JDK 的作者也就是基础 API 的提供者（Java 多线程部分的作者 Doug Lea 是被 Java 程序员敬佩的一个大佬），我们这些 Java 语言的使用者，说白了就是 JDK 的调用者。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405378.png" alt="img"></p>
<p>当然了，假如我们也提供了新的类给其他调用者，我们也就成为了新的创建者。</p>
<p>API 创建者在创建新的类的时候，只暴露必要的接口，而隐藏其他所有不必要的信息，之所以要这么做，是因为如果这些信息对调用者是不可见的，那么创建者就可以随意修改隐藏的信息，而不用担心对调用者的影响。</p>
<p>这里就必须要讲到 java 的权限修饰符</p>
<p>访问权限修饰符的第一个作用是，防止类的调用者接触到他们不该接触的内部实现；第二个作用是，让类的创建者可以轻松修改内部机制而不用担心影响到调用者的使用。</p>
<ul>
<li>public</li>
<li>private</li>
<li>protected</li>
</ul>
<p>还有一种“默认”的权限修饰符，是缺省的，它修饰的类可以访问同一个包下面的其他类。</p>
<h5 id="4）组合"><a href="#4）组合" class="headerlink" title="4）组合"></a><strong>4）组合</strong></h5><p>我们可以把一个创建好的类作为另外一个类的成员变量来使用，利用已有的类组成成一个新的类，被称为“复用”，组合代表的关系是 has-a 的关系。</p>
<p>之后来看我们java中，面向对象的三大基本特征：</p>
<h2 id="面向对象三大基本特征"><a href="#面向对象三大基本特征" class="headerlink" title="面向对象三大基本特征"></a>面向对象三大基本特征</h2><h3 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装(Encapsulation)"></a>封装(Encapsulation)</h3><p>所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p>
<p>简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p>
<p>封装从字面上来理解就是包装的意思，专业点就是信息隐藏，<strong>是指利用抽象将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体</strong>。</p>
<p>使用封装有 4 大好处：</p>
<ul>
<li>1、良好的封装能够减少耦合。</li>
<li>2、类内部的结构可以自由修改。</li>
<li>3、可以对成员进行更精确的控制。</li>
<li>4、隐藏信息，实现细节。</li>
</ul>
<p>如我们想要定义一个矩形，先定义一个Rectangle类，并其中通过封装的手段放入一些必备数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 矩形</span><br><span class="line">*/</span><br><span class="line">class Rectangle &#123;</span><br><span class="line"></span><br><span class="line">     /**</span><br><span class="line">      * 设置矩形的长度和宽度</span><br><span class="line">      */</span><br><span class="line">     public Rectangle(int length, int width) &#123;</span><br><span class="line">         this.length = length;</span><br><span class="line">         this.width = width;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     /**</span><br><span class="line">      * 长度</span><br><span class="line">      */</span><br><span class="line">     private int length;</span><br><span class="line">    </span><br><span class="line">     /**</span><br><span class="line">      * 宽度</span><br><span class="line">      */</span><br><span class="line">     private int width;</span><br><span class="line">    </span><br><span class="line">     /**</span><br><span class="line">      * 获得矩形面积</span><br><span class="line">      *</span><br><span class="line">      * @return</span><br><span class="line">      */</span><br><span class="line">     public int area() &#123;</span><br><span class="line">         return this.length * this.width;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;复制ErrorOK!</span><br></pre></td></tr></table></figure>

<p>我们通过封装的方式，给”矩形”定义了”长度”和”宽度”，这就完成了对现实世界中的”矩形”的抽象的第一步。</p>
<p>如果这个还没有那么的直观，那我们来看下面的这两个类</p>
<p>Husband.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husband</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 对属性的封装</span></span><br><span class="line"><span class="comment">     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> String sex ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">private</span> Wife wife;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * setter()、getter()是该对象对外开发的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWife</span><span class="params">(Wife wife)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.wife = wife;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Wife.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wife</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> Husband husband;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHusband</span><span class="params">(Husband husband)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.husband = husband;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Husband <span class="title function_">getHusband</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> husband;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看得出， Husband 类里面的 wife 属性是没有 <code>getter()</code>的，同时 Wife 类的 age 属性也是没有 <code>getter()</code>方法的。</p>
<p>所以封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果不想被外界方法，我们大可不必提供方法给外界访问。</p>
<p>但是如果一个类没有提供给外界任何可以访问的方法，那么这个类也没有什么意义了。</p>
<p>比如我们将一个房子看做是一个对象，里面有漂亮的装饰，如沙发、电视剧、空调、茶桌等等都是该房子的私有属性，但是如果我们没有那些墙遮挡，是不是别人就会一览无余呢？没有一点儿隐私！</p>
<p>因为存在那个遮挡的墙，我们既能够有自己的隐私而且我们可以随意的更改里面的摆设而不会影响到外面的人。</p>
<p>但是如果没有门窗，一个包裹的严严实实的黑盒子，又有什么存在的意义呢？所以通过门窗别人也能够看到里面的风景。所以说门窗就是房子对象留给外界访问的接口。</p>
<p>通过这个我们还不能真正体会封装的好处。现在我们从程序的角度来分析封装带来的好处。如果我们不使用封装，那么该对象就没有 <code>setter()</code>和 <code>getter()</code>，那么 Husband 类应该这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husband</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name ;</span><br><span class="line">    <span class="keyword">public</span> String sex ;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age ;</span><br><span class="line">    <span class="keyword">public</span> Wife wife;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们应该这样来使用它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Husband</span> <span class="variable">husband</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Husband</span>();</span><br><span class="line">husband.age = <span class="number">30</span>;</span><br><span class="line">husband.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">husband.sex = <span class="string">&quot;男&quot;</span>;    <span class="comment">//貌似有点儿多余</span></span><br></pre></td></tr></table></figure>

<p>但是哪天如果我们需要修改 Husband，例如将 age 修改为 String 类型的呢？你只有一处使用了这个类还好，如果你有几十个甚至上百个这样地方，你是不是要改到崩溃。如果使用了封装，我们完全可以不需要做任何修改，只需要稍微改变下 Husband 类的 <code>setAge()</code>方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husband</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 对属性的封装</span></span><br><span class="line"><span class="comment">     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> String sex ;</span><br><span class="line">    <span class="keyword">private</span> String age ;    <span class="comment">/* 改成 String类型的*/</span></span><br><span class="line">    <span class="keyword">private</span> Wife wife;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">//转换即可</span></span><br><span class="line">        <span class="built_in">this</span>.age = String.valueOf(age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 省略其他属性的setter、getter **/</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的地方依然这样引用( <code>husband.setAge(22)</code> )保持不变。</p>
<p>到了这里我们确实可以看出，<strong>封装确实可以使我们更容易地修改类的内部实现，而无需修改使用了该类的代码</strong>。</p>
<p>我们再看这个好处：<strong>封装可以对成员变量进行更精确的控制</strong>。</p>
<p>还是那个 Husband，一般来说我们在引用这个对象的时候是不容易出错的，但是有时你迷糊了，写成了这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Husband</span> <span class="variable">husband</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Husband</span>();</span><br><span class="line">husband.age = <span class="number">300</span>;</span><br></pre></td></tr></table></figure>

<p>也许你是因为粗心写成了这样，你发现了还好，如果没有发现那就麻烦大了，谁见过 300 岁的老妖怪啊！</p>
<p>但是使用封装我们就可以避免这个问题，我们对 age 的访问入口做一些控制(setter)如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husband</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 对属性的封装</span></span><br><span class="line"><span class="comment">     * 一个人的姓名、性别、年龄、妻子都是这个人的私有属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> String sex ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age ;    <span class="comment">/* 改成 String类型的*/</span></span><br><span class="line">    <span class="keyword">private</span> Wife wife;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(age &gt; <span class="number">120</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;ERROR：error age input....&quot;</span>);    <span class="comment">//提示錯誤信息</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 省略其他属性的setter、getter **/</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面都是对 setter 方法的控制，其实通过封装我们也能够对对象的出口做出很好的控制。例如性别在数据库中一般都是以 1、0 的方式来存储的，但是在前台我们又不能展示 1、0，这里我们只需要在 <code>getter()</code>方法里面做一些转换即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getSexName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;0&quot;</span>.equals(sex))&#123;</span><br><span class="line">        sexName = <span class="string">&quot;女&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(sex))&#123;</span><br><span class="line">        sexName = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sexName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用的时候我们只需要使用 sexName 即可实现正确的性别显示。同理也可以用于针对不同的状态做出不同的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getCzHTML</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;1&quot;</span>.equals(zt))&#123;</span><br><span class="line">        czHTML = <span class="string">&quot;&lt;a href=&#x27;javascript:void(0)&#x27; onclick=&#x27;qy(&quot;</span>+id+<span class="string">&quot;)&#x27;&gt;启用&lt;/a&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        czHTML = <span class="string">&quot;&lt;a href=&#x27;javascript:void(0)&#x27; onclick=&#x27;jy(&quot;</span>+id+<span class="string">&quot;)&#x27;&gt;禁用&lt;/a&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> czHTML;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说了这么多，我们来看java实现封装的基本思路</p>
<ol>
<li>修改属性的可见性来限制对属性的访问（一般限制为private），例如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中，将 <strong>name</strong> 和 <strong>age</strong> 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</p>
<ol start="2">
<li>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用 <strong>this</strong> 关键字是为了解决实例变量（private String name）和局部变量（setName(String name)中的name变量）之间发生的同名的冲突。</p>
<p>之后我们来复习一个这个private关键字，他是一个权限修饰符。可以修饰成员(成员变量和成员方法)被private修饰的成员，只能在 本类中才能访问如果一个关键字被private修饰后，就只能通过set和get方法来获得和更改参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向方法;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供get和set方法</span></span><br><span class="line">    <span class="comment">//作用：给name赋值需要有赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String n)</span>&#123;</span><br><span class="line">        name=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对外提供数据</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a&gt;=<span class="number">18</span>&amp;&amp;a&lt;=<span class="number">50</span>)&#123;</span><br><span class="line">            age=a;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;非法参数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(String g)</span>&#123;</span><br><span class="line">        gender=g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGender</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在睡觉&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例如这里的get和set方法。</p>
<p>以及main主函数里的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向方法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">a3test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        a3 gf1=<span class="keyword">new</span> <span class="title class_">a3</span>();</span><br><span class="line">        gf1.setName(<span class="string">&quot;小诗诗&quot;</span>);</span><br><span class="line">        gf1.setAge(<span class="number">18</span>);</span><br><span class="line">        gf1.setGender(<span class="string">&quot;傻逼&quot;</span>);</span><br><span class="line">        System.out.println(gf1.getAge());</span><br><span class="line">        System.out.println(gf1.getName());</span><br><span class="line">        System.out.println(gf1.getGender());</span><br><span class="line">        gf1.eat();</span><br><span class="line">        gf1.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看了这么多，相信大家应该已经看明白什么是封装了。</p>
<p>下面就开始讲第二个基本特征</p>
<h3 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承(Inheritance)]"></a>继承(Inheritance)]</h3><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p>
<p>通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特的过程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405383.png" alt="image-20230615212720005"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405405.png" alt="image-20230615212731031"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405968.png" alt="image-20230615212738450"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405074.png" alt="image-20230615212754509"></p>
<p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p>
<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<p>生活中的继承：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405178.jpg" alt="img"></p>
<p>兔子和羊属于食草动物类，狮子和豹属于食肉动物类。</p>
<p>食草动物和食肉动物又是属于动物类。</p>
<p>所以继承需要符合的关系是：is-a，父类更通用，子类更具体。</p>
<p>虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以子类会具有父类的一般特性也会具有自身的特性。</p>
<p>我们想要定义一个正方形，因为已经有了矩形，所以我们可以直接继承Rectangle类，因为正方形是长方形的一种特例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 正方形，继承自矩形</span><br><span class="line"> */</span><br><span class="line">class Square extends Rectangle &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 设置正方形边长</span><br><span class="line">     *</span><br><span class="line">     * @param length</span><br><span class="line">     */</span><br><span class="line">    public Square(int length) &#123;</span><br><span class="line">        super(length, length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制ErrorOK!</span><br></pre></td></tr></table></figure>

<p>现实世界中，”正方形”是”矩形”的特例，或者说正方形是通过矩形派生出来的，这种派生关系，在面向对象中可以用继承来表达。</p>
<p>如果仅仅只有两三个类，每个类的属性和方法很有限的情况下确实没必要实现继承，但事情并非如此，事实上一个系统中往往有很多个类并且有着很多相似之处，比如猫和狗同属动物，或者学生和老师同属人。各个类可能又有很多个相同的属性和方法，这样的话如果每个类都重新写不仅代码显得很乱，代码工作量也很大。</p>
<p>这时继承的优势就出来了：可以直接使用父类的属性和方法，自己也可以有自己新的属性和方法满足拓展，父类的方法如果自己有需求更改也可以重写。这样<strong>使用继承不仅大大的减少了代码量，也使得代码结构更加清晰可见</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405237.png" alt="img"></p>
<p>所以这样从代码的层面上来看我们设计这个完整的 Animal 类是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> age, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里省略get set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sing&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 Dog，Cat，Chicken 类可以这样设计：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span><span class="comment">//继承animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> age, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(id, name, age, weight);<span class="comment">//调用父类构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> age, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(id, name, age, weight);<span class="comment">//调用父类构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Chicken</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chicken</span><span class="params">(<span class="type">int</span> id, String name, <span class="type">int</span> age, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(id, name, age, weight);<span class="comment">//调用父类构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//鸡下蛋</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">layEggs</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是老母鸡下蛋啦，咯哒咯！咯哒咯！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>各自的类继承 Animal 后可以直接使用 Animal 类的属性和方法而不需要重复编写，各个类如果有自己的方法也可很容易地拓展</p>
<p>继承的分类</p>
<p>继承分为单继承和多继承，Java 语言只支持类的单继承，但可以通过实现接口的方式达到多继承的目的。****</p>
<h4 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a><strong>单继承</strong></h4><p>单继承，一个子类只有一个父类，如我们上面讲过的 Animal 类和它的子类。<strong>单继承在类层次结构上比较清晰，但缺点是结构的丰富度有时不能满足使用需求</strong>。</p>
<h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a><strong>多继承</strong></h4><p>多继承，一个子类有多个直接的父类。这样做的好处是子类拥有所有父类的特征，<strong>子类的丰富度很高，但是缺点就是容易造成混乱</strong>。下图为一个混乱的例子。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405326.png" alt="img"></p>
<p>要注意的是，java是不支持多继承的，至于为什么不支持多继承呢，我们来看一下解释。</p>
<p>下面我们来看这个菱型继承</p>
<p>假设我们有类B和类C，它们都继承了相同的类A。另外我们还有类D，类D通过多重继承机制继承了类B和类C。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405633.jpg" alt="img">￼</p>
<p>这时候，因为D同时继承了B和C，并且B和C又同时继承了A，那么，D中就会因为多重继承，继承到两份来自A中的属性和方法。</p>
<p>这时候，在使用D的时候，如果想要调用一个定义在A中的方法时，就会出现歧义。</p>
<p>因为这样的继承关系的形状类似于菱形，因此这个问题被形象地称为菱形继承问题。</p>
<p>而C++为了解决菱形继承问题，又引入了<strong>虚继承</strong>。</p>
<p>因为支持多继承，引入了菱形继承问题，又因为要解决菱形继承问题，引入了虚继承。而经过分析，人们发现我们其实真正想要使用多继承的情况并不多。</p>
<p>所以，在 Java 中，不允许“实现多继承”，即一个类不允许继承多个父类。但是 Java 允许“声明多继承”，即一个类可以实现多个接口，一个接口也可以继承多个父接口。由于接口只允许有方法声明而不允许有方法实现（Java 8以前），这就避免了 C++ 中多继承的歧义问题。</p>
<p>但是，Java不支持多继承，在Java 8中支持了默认函数（default method ）之后就不那么绝对了。</p>
<p>虽然我们还是没办法使用extends同时继承多个类，但是因为有了默认函数，我们有可能通过implements从多个接口中继承到多个默认函数，那么，又如何解决这种情况带来的菱形继承问题呢？这个问题留给大家去查询答案。</p>
<p>Java 虽然不支持多继承，但是 Java 有三种实现多继承效果的方式，<strong>分别是</strong>内部类、多层继承和实现接口。</p>
<p>内部类可以继承一个与外部类无关的类，保证了内部类的独立性，正是基于这一点，可以达到多继承的效果。</p>
<p>**多层继承：**子类继承父类，父类如果还继承其他的类，那么这就叫**多层继承**。这样子类就会拥有所有被继承类的属性和方法。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405137.png" alt="img"></p>
<p>实现接口无疑是满足多继承使用需求的最好方式，一个类可以实现多个接口满足自己在丰富性和复杂环境的使用需求。</p>
<p>类和接口相比，<strong>类就是一个实体，有属性和方法，而接口更倾向于一组方法</strong>。举个例子，就拿斗罗大陆的唐三来看，他存在的继承关系可能是这样的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405239.png" alt="img"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405339.png" alt="image-20230615213114814"></p>
<p>下面来一个图，让你快速区分这个继承的分类</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405398.png" alt="img"></p>
<h4 id="如何实现继承"><a href="#如何实现继承" class="headerlink" title="如何实现继承"></a>如何实现继承</h4><h5 id="extends-关键字"><a href="#extends-关键字" class="headerlink" title="extends 关键字"></a><strong>extends 关键字</strong></h5><p>在 Java 中，类的继承是单一继承，也就是说一个子类只能拥有一个父类，所以<strong>extends</strong>只能继承一个类。其使用语法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class 子类名 extends 父类名&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>例如 Dog 类继承 Animal 类，它是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;&#125; <span class="comment">//定义Animal类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;&#125; <span class="comment">//Dog类继承Animal类</span></span><br></pre></td></tr></table></figure>

<p>子类继承父类后，就拥有父类的非私有的<strong>属性和方法</strong>。如果不明白，请看这个案例，在 IDEA 下创建一个项目，创建一个 test 类做测试，分别创建 Animal 类和 Dog 类，Animal 作为父类写一个 sayHello()方法，Dog 类继承 Animal 类之后就可以调用 sayHello()方法。具体代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">sayHello</span><span class="params">()</span><span class="comment">//父类的方法</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello,everybody&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span><span class="comment">//继承animal</span></span><br><span class="line">&#123; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       Dog dog=<span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">       dog.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击运行的时候 Dog 子类可以直接使用 Animal 父类的方法。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405539.png" alt="img"></p>
<h5 id="implements-关键字"><a href="#implements-关键字" class="headerlink" title="implements 关键字"></a><strong>implements 关键字</strong></h5><p>使用 implements 关键字可以变相使 Java 拥有多继承的特性，使用范围为类实现接口的情况，一个类可以实现多个接口(接口与接口之间用逗号分开)。</p>
<p>我们来看一个案例，创建一个 test2 类做测试，分别创建 doA 接口和 doB 接口，doA 接口声明 sayHello()方法，doB 接口声明 eat()方法，创建 Cat2 类实现 doA 和 doB 接口，并且在类中需要重写 sayHello()方法和 eat()方法。具体代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">doA</span>&#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">doB</span>&#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//以下会报错 接口中的方法不能具体定义只能声明</span></span><br><span class="line">    <span class="comment">//public void eat()&#123;System.out.println(&quot;eating&quot;);&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat2</span> <span class="keyword">implements</span>  <span class="title class_">doA</span>,doB&#123;</span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//必须重写接口内的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I&#x27;m eating&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Cat2 cat=<span class="keyword">new</span> <span class="title class_">Cat2</span>();</span><br><span class="line">        cat.sayHello();</span><br><span class="line">        cat.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cat 类实现 doA 和 doB 接口的时候，需要实现其声明的方法，点击运行结果如下，这就是一个类实现接口的简单案例：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405819.png" alt="img"></p>
<p>说了这么多我们来看一个继承的练习</p>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405901.png" alt="image-20230615213708484"></p>
<p>首先我们先画一个图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405176.png" alt="image-20230615213722540"></p>
<p>画出继承关系。画图是从下往上画。</p>
<p>之后是写代码。写代码的话，就是从上往下写。</p>
<p>先是动物</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">//这里用的是public。所以所有继承他的子类都可以用这个方法。</span></span><br><span class="line">    <span class="comment">//如果是private，就只有自己可以用</span></span><br><span class="line">    <span class="comment">//可以相当于一个人的私房钱</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drink</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喝水&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后是猫和狗</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cathMouse</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫在抓老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lookHome</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗在看见&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后开始详细书写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Husky</span> <span class="keyword">extends</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breakHome</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;哈士奇在拆家&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiHua</span> <span class="keyword">extends</span> <span class="title class_">Cat</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ragdoll</span> <span class="keyword">extends</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teddy</span> <span class="keyword">extends</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">touch</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;泰迪又在蹭我的腿了~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a4;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意事项，子类只能访问父类中非私有的成员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个布偶猫的对象</span></span><br><span class="line">        Ragdoll rd=<span class="keyword">new</span> <span class="title class_">Ragdoll</span>();</span><br><span class="line">        rd.eat();</span><br><span class="line">        rd.drink();</span><br><span class="line">        rd.cathMouse();</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//创建一个哈奇士对象</span></span><br><span class="line">        Husky h=<span class="keyword">new</span> <span class="title class_">Husky</span>();</span><br><span class="line">        h.eat();</span><br><span class="line">        h.breakHome();</span><br><span class="line">        h.drink();</span><br><span class="line">        h.lookHome();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后的是我们的测试类。就可以发现测试成功了。</p>
<p>这样就算是一个完整的继承了。</p>
<h3 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态(Polymorphism)"></a>多态(Polymorphism)</h3><p>所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。</p>
<p>这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p>
<p>最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。</p>
<p>在我刻板的印象里，西游记里的那段孙悟空和二郎神的精彩对战就能很好的解释“多态”这个词：一个孙悟空，能七十二变；一个二郎神，也能七十二变；他们都可以变成不同的形态，但只需要悄悄地喊一声“变”。</p>
<p>Java的多态是什么呢？其实就是一种能力——同一个行为具有不同的表现形式；换句话说就是，执行一段代码，Java 在运行时能根据对象的不同产生不同的结果。和孙悟空和二郎神都只需要喊一声“变”，然后就变了，并且每次变得还不一样；一个道理。</p>
<p>多态的前提条件有三个：</p>
<ul>
<li>子类继承父类</li>
<li>子类覆盖父类的方法</li>
<li>父类引用指向子类对象</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405247.png" alt="image-20230615214105578"></p>
<p>这个简单理解他的应用场景。就是</p>
<p>比如说有一个登录系统。</p>
<p>有三个不同身份的人都需要登录</p>
<p>这个时候。我们登录系统的这个形参。就可以写他父类的person了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405315.png" alt="image-20230615214129380"></p>
<p>多态的一个简单应用，来看程序清单1-1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类继承父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wangxiaoer</span> <span class="keyword">extends</span> <span class="title class_">Wanger</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123; <span class="comment">// 子类覆盖父类方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;记住仇恨，表明我们要奋发图强的心智&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line">        Wanger[] wangers = &#123; <span class="keyword">new</span> <span class="title class_">Wanger</span>(), <span class="keyword">new</span> <span class="title class_">Wangxiaoer</span>() &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Wanger wanger : wangers) &#123;</span><br><span class="line">            <span class="comment">// 对象是王二的时候输出：勿忘国耻</span></span><br><span class="line">            <span class="comment">// 对象是王小二的时候输出：记住仇恨，表明我们要奋发图强的心智</span></span><br><span class="line">            wanger.write();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wanger</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;勿忘国耻&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="01、多态与后期绑定"><a href="#01、多态与后期绑定" class="headerlink" title="01、多态与后期绑定"></a>01、多态与后期绑定</h5><p>现在，我们来思考一个问题：程序清单1-1在执行 <code>wanger.write()</code> 时，由于编译器只有一个 Wanger 引用，它怎么知道究竟该调用父类 Wanger 的 <code>write()</code> 方法，还是子类 Wangxiaoer 的 <code>write()</code> 方法呢？</p>
<p>答案是在运行时根据对象的类型进行后期绑定，编译器在编译阶段并不知道对象的类型，但是Java的方法调用机制能找到正确的方法体，然后执行出正确的结果。</p>
<p>多态机制提供的一个重要的好处程序具有良好的扩展性。来看程序清单2-1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类继承父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wangxiaoer</span> <span class="keyword">extends</span> <span class="title class_">Wanger</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123; <span class="comment">// 子类覆盖父类方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;记住仇恨，表明我们要奋发图强的心智&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我不喜欢读书，我就喜欢吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line">        Wanger[] wangers = &#123; <span class="keyword">new</span> <span class="title class_">Wanger</span>(), <span class="keyword">new</span> <span class="title class_">Wangxiaoer</span>() &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Wanger wanger : wangers) &#123;</span><br><span class="line">            <span class="comment">// 对象是王二的时候输出：勿忘国耻</span></span><br><span class="line">            <span class="comment">// 对象是王小二的时候输出：记住仇恨，表明我们要奋发图强的心智</span></span><br><span class="line">            wanger.write();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wanger</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;勿忘国耻&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;每周读一本好书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序清单 2-1 中，我们在 Wanger 类中增加了 read() 方法，在 Wangxiaoer 类中增加了eat()方法，但这丝毫不会影响到 write() 方法的调用。write() 方法忽略了周围代码发生的变化，依然正常运行。这让我想起了金庸《倚天屠龙记》里九阳真经的口诀：“他强由他强，清风拂山岗；他横由他横，明月照大江。”</p>
<p>多态的这个优秀的特性，让我们在修改代码的时候不必过于紧张，因为多态是一项让程序员“将改变的与未改变的分离开来”的重要特性。</p>
<h5 id="02、多态与构造方法"><a href="#02、多态与构造方法" class="headerlink" title="02、多态与构造方法"></a>02、多态与构造方法</h5><p>在构造方法中调用多态方法，会产生一个奇妙的结果，我们来看程序清单3-1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wangxiaosan</span> <span class="keyword">extends</span> <span class="title class_">Wangsan</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Wangxiaosan</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        System.out.println(<span class="string">&quot;王小三的年龄：&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123; <span class="comment">// 子类覆盖父类方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我小三上幼儿园的年龄是：&quot;</span> + <span class="built_in">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Wangxiaosan</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//      上幼儿园之前</span></span><br><span class="line"><span class="comment">//      我小三上幼儿园的年龄是：0</span></span><br><span class="line"><span class="comment">//      上幼儿园之后</span></span><br><span class="line"><span class="comment">//      王小三的年龄：4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wangsan</span> &#123;</span><br><span class="line">    Wangsan () &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;上幼儿园之前&quot;</span>);</span><br><span class="line">        write();</span><br><span class="line">        System.out.println(<span class="string">&quot;上幼儿园之后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老子上幼儿园的年龄是3岁半&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从输出结果上看，是不是有点诧异？明明在创建 Wangxiaosan 对象的时候，年龄传递的是 4，但输出结果既不是“老子上幼儿园的年龄是 3 岁半”，也不是“我小三上幼儿园的年龄是：4”。</p>
<p>为什么？</p>
<p>因为在创建子类对象时，会先去调用父类的构造方法，而父类构造方法中又调用了被子类覆盖的多态方法，由于父类并不清楚子类对象中的属性值是什么，于是把int类型的属性暂时初始化为 0，然后再调用子类的构造方法（子类构造方法知道王小二的年龄是 4）。</p>
<h5 id="03、多态与向下转型"><a href="#03、多态与向下转型" class="headerlink" title="03、多态与向下转型"></a>03、多态与向下转型</h5><p>向下转型是指将父类引用强转为子类类型；这是不安全的，因为有的时候，父类引用指向的是父类对象，向下转型就会抛出 ClassCastException，表示类型转换失败；但如果父类引用指向的是子类对象，那么向下转型就是成功的。</p>
<p>来看程序清单4-1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wangxiaosi</span> <span class="keyword">extends</span> <span class="title class_">Wangsi</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;记住仇恨，表明我们要奋发图强的心智&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我不喜欢读书，我就喜欢吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Wangsi[] wangsis = &#123; <span class="keyword">new</span> <span class="title class_">Wangsi</span>(), <span class="keyword">new</span> <span class="title class_">Wangxiaosi</span>() &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wangsis[1]能够向下转型</span></span><br><span class="line">        ((Wangxiaosi) wangsis[<span class="number">1</span>]).write();</span><br><span class="line">        <span class="comment">// wangsis[0]不能向下转型</span></span><br><span class="line">        ((Wangxiaosi)wangsis[<span class="number">0</span>]).write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Wangsi</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;勿忘国耻&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;每周读一本好书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>简单的来总结这个就是</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405473.png" alt="image-20230615214704491"></p>
<p>具体这个怎么理解呢。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405645.png" alt="image-20230615214725375"></p>
<p>可以这样理解。就是如果子类和父类都有这个变量。那么sout之后。输出的是父类的变量。</p>
<p>运行也看左边。也就是说实际获取的值也是左边的值。</p>
<p>之后看这个方法调用的解释</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405016.png" alt="image-20230615214738386"></p>
<p>这里编译看左边。简单来说。就是编译的时候要去判断父类中是否有这个方法。如果没有的话。也会报错的。然后运行的时候。运行的就是右边子类所提供的方法内容。</p>
<p>因此。这也就产生的多态的一个弊端。不能调用子类的特殊功能。解决方案也很简单：变回子类类型。用()括起来进行转换。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405079.png" alt="image-20230615214802731"></p>
<p>但是也不能随便的转换，</p>
<p>就比如还是上边的代码。</p>
<p>你把a转换为cat。</p>
<p>就会报错。为了尽量避免这种情况的发生。</p>
<p>我们可以用if来进行判断类型。</p>
<p>这里就要用到一个instanceof参数<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405156.png" alt="image-20230615214820668"></p>
<p>这也就可以判断a是否是dog类型的。如果是返回true。</p>
<p>如果不是就返回false</p>
<p>因此可以看这个类型转换的一个判断代码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405506.png" alt="image-20230615214833736"></p>
<p>但是这也有点麻烦。</p>
<p>所以java在jdk14之后提供了新特性。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405590.png" alt="image-20230615214844376"></p>
<p>有点类似python中语法糖的效果。</p>
<p>在介绍了面向对象的封装、继承、多态的三个基本特征之后，我们基本掌握了对现实世界抽象的基本方法。</p>
<p>封装：是对类的封装，封装是对类的属性和方法进行封装，只对外暴露方法而不暴露具体使用细节，所以我们一般设计类成员变量时候大多设为私有而通过一些 get、set 方法去读写。</p>
<p>继承：子类继承父类，即“子承父业”，子类拥有父类除私有的所有属性和方法，自己还能在此基础上拓展自己新的属性和方法。主要目的是<strong>复用代码</strong>。</p>
<p><strong>多态</strong>：多态是同一个行为具有多个不同表现形式或形态的能力。即一个父类可能有若干子类，各子类实现父类方法有多种多样，调用父类方法时，父类引用变量指向不同子类实例而执行不同方法，这就是所谓父类方法是多态的。</p>
<p>下面我们来用一个图来看懂这三者的关系</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405687.png" alt="img"></p>
<p>莎士比亚说：”一千个读者眼里有一千个哈姆雷特”，说到对现实世界的抽象，虽然方法相同，但是运用同样的方法，最终得到的结果可能千差万别，那么如何评价这个抽象的结果的好坏呢？</p>
<p>这就要提到面喜爱那个对象的五大基本原则了，有了五大原则，我们参考他们来评价一个抽象的好坏。</p>
<h2 id="面向对象的五大基本原则"><a href="#面向对象的五大基本原则" class="headerlink" title="面向对象的五大基本原则"></a>面向对象的五大基本原则</h2><p>面向对象开发范式的最大的好处就是易用、易扩展、易维护，但是，什么样的代码是易用、易扩展、易维护的呢？如何衡量他们呢？</p>
<p>罗伯特·C·马丁在21世纪早期提出了SOLID原则，这是五个原则的缩写的组合，这五个原则沿用至今。</p>
<h4 id="单一职责原（single-responsibility-principle）"><a href="#单一职责原（single-responsibility-principle）" class="headerlink" title="单一职责原（single-responsibility-principle）)"></a>单一职责原（single-responsibility-principle）)</h4><p>其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。</p>
<p>单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。 专注，是一个人优良的品质；同样的，单一也是一个类的优良设计。交杂不清的职责将使得代码看起来特别别扭牵一发而动全身，有失美感和必然导致丑陋的系统错误风险。</p>
<h4 id="开放封闭原则（Open-Closed-principle"><a href="#开放封闭原则（Open-Closed-principle" class="headerlink" title="开放封闭原则（Open-Closed principle"></a>开放封闭原则（Open-Closed principle</h4><p>其核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。</p>
<p>开放封闭原则主要体现在两个方面：</p>
<p>1、对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</p>
<p>2、对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。</p>
<p>实现开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。 “需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。</p>
<h4 id="里氏替换原则（Liskov-Substitution-Principle"><a href="#里氏替换原则（Liskov-Substitution-Principle" class="headerlink" title="里氏替换原则（Liskov-Substitution Principle]"></a>里氏替换原则（Liskov-Substitution Principle]</h4><p>其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。</p>
<p>在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。 里氏替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了Liskov替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。</p>
<p>里氏替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。</p>
<p>里氏替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。</p>
<h4 id="依赖倒置原则（Dependecy-Inversion-Principle）"><a href="#依赖倒置原则（Dependecy-Inversion-Principle）" class="headerlink" title="依赖倒置原则（Dependecy-Inversion Principle）"></a>依赖倒置原则（Dependecy-Inversion Principle）</h4><p>其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。</p>
<p>我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。</p>
<p>依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。</p>
<h4 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface-Segregation Principle）"></a>接口隔离原则（Interface-Segregation Principle）</h4><p>其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。</p>
<p>具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。</p>
<p>接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。 分离的手段主要有以下两种：</p>
<p>1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。</p>
<p>2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。</p>
<p>以上就是5个基本的面向对象设计原则，它们就像面向对象程序设计中的金科玉律，遵守它们可以使我们的代码更加鲜活，易于复用，易于拓展，灵活优雅。</p>
<p>不同的设计模式对应不同的需求，而设计原则则代表永恒的灵魂，需要在实践中时时刻刻地遵守。就如ARTHUR J.RIEL在那边《OOD启示录》中所说的：“你并不必严格遵守这些原则，违背它们也不会被处以宗教刑罚。但你应当把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。”</p>
<p>很多人刚开始可能对这些原则无法深刻的理解，但是没关系，随着自己开发经验的增长，就会慢慢的可以理解这些原则了。</p>
<p>在了解了这个之后，我们来看一个比较大的案例</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">根据需求完成代码:</span><br><span class="line">    <span class="number">1.</span>定义狗类</span><br><span class="line">        属性：</span><br><span class="line">            年龄，颜色</span><br><span class="line">        行为:</span><br><span class="line">            eat(String something)(something表示吃的东西)</span><br><span class="line">            看家lookHome方法(无参数)</span><br><span class="line"></span><br><span class="line">    <span class="number">2.</span>定义猫类</span><br><span class="line">        属性：</span><br><span class="line">            年龄，颜色</span><br><span class="line">        行为:</span><br><span class="line">            eat(String something)方法(something表示吃的东西)</span><br><span class="line">            逮老鼠catchMouse方法(无参数)</span><br><span class="line"></span><br><span class="line">    <span class="number">3.</span>定义Person类<span class="comment">//饲养员</span></span><br><span class="line">        属性：</span><br><span class="line">            姓名，年龄</span><br><span class="line">        行为：</span><br><span class="line">            keepPet(Dog dog,String something)方法</span><br><span class="line">                功能：喂养宠物狗，something表示喂养的东西</span><br><span class="line">        行为：</span><br><span class="line">            keepPet(Cat cat,String something)方法</span><br><span class="line">                功能：喂养宠物猫，something表示喂养的东西</span><br><span class="line">        生成空参有参构造，set和get方法  </span><br><span class="line">    <span class="number">4.</span>定义测试类(完成以下打印效果):</span><br><span class="line">        keepPet(Dog dog,String somethind)方法打印内容如下：</span><br><span class="line">            年龄为<span class="number">30</span>岁的老王养了一只黑颜色的<span class="number">2</span>岁的狗</span><br><span class="line">            <span class="number">2</span>岁的黑颜色的狗两只前腿死死的抱住骨头猛吃</span><br><span class="line">        keepPet(Cat cat,String somethind)方法打印内容如下：</span><br><span class="line">            年龄为<span class="number">25</span>岁的老李养了一只灰颜色的<span class="number">3</span>岁的猫</span><br><span class="line">            <span class="number">3</span>岁的灰颜色的猫眯着眼睛侧着头吃鱼</span><br><span class="line">    <span class="number">5.</span>思考：       </span><br><span class="line">        <span class="number">1.</span>Dog和Cat都是Animal的子类，以上案例中针对不同的动物，定义了不同的keepPet方法，过于繁琐，能否简化，并体会简化后的好处？</span><br><span class="line">        <span class="number">2.</span>Dog和Cat虽然都是Animal的子类，但是都有其特有方法，能否想办法在keepPet中调用特有方法？</span><br></pre></td></tr></table></figure>

<p>下面我们来看思维导图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405764.png" alt="image-20230615215501906"></p>
<p>之后开始进行代码演示：</p>
<p>先写父类的animal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String something)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物在吃&quot;</span>+something);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(<span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> color</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Animal&#123;age = &quot;</span> + age + <span class="string">&quot;, color = &quot;</span> + color + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后是子类的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(<span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(age, color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String something)</span> &#123;</span><br><span class="line">        System.out.println(getAge()+<span class="string">&quot;岁的&quot;</span>+getColor()+<span class="string">&quot;颜色的猫咪眯着眼睛&quot;</span> +</span><br><span class="line">                <span class="string">&quot;侧着头吃&quot;</span>+something);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">catchMouse</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫捉老鼠&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(<span class="type">int</span> age, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(age, color);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//行为</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String something)</span> &#123;</span><br><span class="line">        System.out.println(getAge()+<span class="string">&quot;的&quot;</span>+getColor()+<span class="string">&quot;颜色的狗，俩只前脚&quot;</span> +</span><br><span class="line">                <span class="string">&quot;死死抱着&quot;</span>+something+<span class="string">&quot;猛吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lookHome</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗在看见&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里是person的。person这里用到了多态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sound.midi.Soundbank;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的person不要去继承animal</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//饲养猫和狗</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">KeepPet</span><span class="params">(Animal a,String something)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">            Dog d=(Dog) a;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄为&quot;</span>+age+<span class="string">&quot;岁的&quot;</span>+name+<span class="string">&quot;养了一直&quot;</span>+a.getColor()</span><br><span class="line">                    +<span class="string">&quot;颜色的&quot;</span>+a.getAge()+<span class="string">&quot;岁的狗&quot;</span>);</span><br><span class="line">            d.eat(something);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">            Cat c=(Cat) a;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄为&quot;</span>+age+<span class="string">&quot;岁的&quot;</span>+name+<span class="string">&quot;养了一直&quot;</span>+a.getColor()</span><br><span class="line">                    +<span class="string">&quot;颜色的&quot;</span>+a.getAge()+<span class="string">&quot;岁的猫&quot;</span>);</span><br><span class="line">            c.eat(something);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有这种动物&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;name = &quot;</span> + name + <span class="string">&quot;, age = &quot;</span> + age + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后再看test类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建对象并且调用方法。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Person p1=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;老王&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        Dog d=<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="number">2</span>,<span class="string">&quot;黑&quot;</span>);</span><br><span class="line">        Cat c=<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="number">1</span>,<span class="string">&quot;白&quot;</span>);</span><br><span class="line">        p1.KeepPet(d,<span class="string">&quot;骨头&quot;</span>);</span><br><span class="line">        p1.KeepPet(c,<span class="string">&quot;鱼&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="java中的包"><a href="#java中的包" class="headerlink" title="java中的包"></a>java中的包</h2><p>为了更好地组织类，Java 提供了包机制，用于区别类名的命名空间。</p>
<p>在前面的代码中，我们把类和接口命名为<code>Person</code>、<code>Student</code>、<code>Hello</code>等简单的名字。</p>
<p>在团队开发中，如果小明写了一个<code>Person</code>类，小红也写了一个<code>Person</code>类，现在，小白既想用小明的<code>Person</code>，也想用小红的<code>Person</code>，怎么办？</p>
<p>如果小军写了一个<code>Arrays</code>类，恰好 JDK 也自带了一个<code>Arrays</code>类，如何解决类名冲突？</p>
<p>在 Java 中，我们使用<code>package</code>来解决名字冲突。</p>
<p>Java 定义了一种名字空间，称之为包：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，真正的完整类名是<code>包名.类名</code>。</p>
<p>例如：</p>
<p>小明的<code>Person</code>类存放在包<code>ming</code>下面，因此，完整类名是<code>ming.Person</code>；</p>
<p>小红的<code>Person</code>类存放在包<code>hong</code>下面，因此，完整类名是<code>hong.Person</code>；</p>
<p>小军的<code>Arrays</code>类存放在包<code>mr.jun</code>下面，因此，完整类名是<code>mr.jun.Arrays</code>；</p>
<p>JDK 的<code>Arrays</code>类存放在包<code>java.util</code>下面，因此，完整类名是<code>java.util.Arrays</code>。</p>
<p>在定义<code>class</code>的时候，我们需要在第一行声明这个<code>class</code>属于哪个包。</p>
<p>小明的<code>Person.java</code>文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ming; <span class="comment">// 申明包名ming</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小军的<code>Arrays.java</code>文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mr.jun; <span class="comment">// 申明包名mr.jun</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arrays</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Java 虚拟机执行的时候，JVM 只看完整类名，因此，只要包名不同，类就不同。</p>
<p>包可以是多层结构，用<code>.</code>隔开。例如：<code>java.util</code>。</p>
<blockquote>
<p>要特别注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</p>
</blockquote>
<p>没有定义包名的<code>class</code>，它使用的是默认包，非常容易引起名字冲突，因此，不推荐不写包名的做法。</p>
<p>我们还需要按照包结构把上面的 Java 文件组织起来。假设以<code>package_sample</code>作为根目录，<code>src</code>作为源码目录，那么所有文件结构就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ src</span><br><span class="line">    ├─ hong</span><br><span class="line">    │  └─ Person.java</span><br><span class="line">    │  ming</span><br><span class="line">    │  └─ Person.java</span><br><span class="line">    └─ mr</span><br><span class="line">       └─ jun</span><br><span class="line">          └─ Arrays.java</span><br></pre></td></tr></table></figure>

<p>即所有 Java 文件对应的目录层次要和包的层次一致。</p>
<p>编译后的<code>.class</code>文件也需要按照包结构存放。如果使用 IDE，把编译后的<code>.class</code>文件放到<code>bin</code>目录下，那么，编译的文件结构就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ bin</span><br><span class="line">   ├─ hong</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   │  ming</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   └─ mr</span><br><span class="line">      └─ jun</span><br><span class="line">         └─ Arrays.class</span><br></pre></td></tr></table></figure>

<p>编译的命令相对比较复杂，我们需要在<code>src</code>目录下执行<code>javac</code>命令：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d ../bin ming/Person.java hong/Person.java mr/jun/Arrays.java</span><br></pre></td></tr></table></figure>

<p>在 IDE 中，会自动根据包结构编译所有 Java 源码，所以不必担心使用命令行编译的复杂命令</p>
<p>因此，我们可以总结出来包的优点有下面的三个部分</p>
<ul>
<li>1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</li>
<li>2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li>
<li>3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li>
</ul>
<h4 id="包的作用域"><a href="#包的作用域" class="headerlink" title="包的作用域"></a>包的作用域</h4><p>位于同一个包的类，可以访问包作用域的字段和方法。</p>
<p>不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。例如，<code>Person</code>类定义在<code>hello</code>包下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">// 包作用域:</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Main</code>类也定义在<code>hello</code>包下面，就可以直接访问 Person 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p.hello(); <span class="comment">// 可以调用，因为Main和Person在同一个包</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h4><p>在一个<code>class</code>中，我们总会引用其他的<code>class</code>。例如，小明的<code>ming.Person</code>类，如果要引用小军的<code>mr.jun.Arrays</code>类，他有三种写法：</p>
<p>第一种，直接写出完整类名，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        mr.jun.<span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">mr</span>.jun.Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，每次都要写完整的类名比较痛苦。</p>
<p>因此，第二种写法是用<code>import</code>语句，导入小军的<code>Arrays</code>，然后写简单类名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入完整类名:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有<code>class</code>都导入进来（但不包括子包的<code>class</code>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入mr.jun包的所有class:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Arrays</span> <span class="variable">arrays</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Arrays</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一般不推荐这种写法，因为在导入了多个包后，很难看出<code>Arrays</code>类属于哪个包。</p>
<p>还有一种<code>import static</code>的语法，它可以导入一个类的静态字段和静态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入System类的所有静态字段和静态方法:</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 相当于调用System.out.println(…)</span></span><br><span class="line">        out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>import static</code>很少使用。</p>
<p>Java 编译器最终编译出的<code>.class</code>文件只使用 <em>完整类名</em>，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</p>
<ul>
<li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li>
<li>如果是简单类名，按下面的顺序依次查找：<ul>
<li>查找当前<code>package</code>是否存在这个<code>class</code>；</li>
<li>查找<code>import</code>的包是否包含这个<code>class</code>；</li>
<li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li>
</ul>
</li>
</ul>
<p>如果按照上面的规则还无法确定类名，则编译报错。</p>
<p>我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.Format;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        java.util.List list; <span class="comment">// ok，使用完整类名 -&gt; java.util.List</span></span><br><span class="line">        <span class="type">Format</span> <span class="variable">format</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// ok，使用import的类 -&gt; java.text.Format</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hi&quot;</span>; <span class="comment">// ok，使用java.lang包的String -&gt; java.lang.String</span></span><br><span class="line">        System.out.println(s); <span class="comment">// ok，使用java.lang包的System -&gt; java.lang.System</span></span><br><span class="line">        <span class="type">MessageFormat</span> <span class="variable">mf</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 编译错误：无法找到MessageFormat: MessageFormat cannot be resolved to a type</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，编写 class 的时候，编译器会自动帮我们做两个 import 动作：</p>
<ul>
<li>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>；</li>
<li>默认自动<code>import java.lang.*</code>。</li>
</ul>
<blockquote>
<p>注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。</p>
</blockquote>
<p>如果有两个<code>class</code>名称相同，例如，<code>mr.jun.Arrays</code>和<code>java.util.Arrays</code>，那么只能<code>import</code>其中一个，另一个必须写完整类名。</p>
<p>关于这个导包的问题，我们简单的进行一些了解就可以了，因为我们再用idea编程的时候，实际上她会自动的给我们进行导入</p>
<h4 id="包的最佳实践"><a href="#包的最佳实践" class="headerlink" title="包的最佳实践"></a>包的最佳实践</h4><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p>
<ul>
<li>org.apache</li>
<li>org.apache.commons.log</li>
<li>com.tobebetterjavaer.sample</li>
</ul>
<p>子包就可以根据功能自行命名。</p>
<p>要注意不要和<code>java.lang</code>包的类重名，即自己的类不要使用这些名字：</p>
<ul>
<li>String</li>
<li>System</li>
<li>Runtime</li>
<li>…</li>
</ul>
<p>要注意也不要和 JDK 常用类重名：</p>
<ul>
<li>java.util.List</li>
<li>java.text.Format</li>
<li>java.math.BigInteger</li>
<li>…</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405060.png" alt="image-20230615220313407"></p>
<p>Java 内建的<code>package</code>机制是为了避免<code>class</code>命名冲突；</p>
<p>JDK 的核心类使用<code>java.lang</code>包，编译器会自动导入；</p>
<p>JDK 的其它常用类定义在<code>java.util.*</code>，<code>java.math.*</code>，<code>java.text.*</code>，……；</p>
<p>包名推荐使用倒置的域名，例如<code>org.apache</code>。</p>
<p>Java中共有三种变量，分别是类变量(也叫静态变量)、成员变量和局部变量。他们分别存放在JVM的方法区、堆内存和栈内存中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Hollis</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Variables</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成员变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="type">int</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们来详细的去了解一下这些变量</p>
<h2 id="java中的变量"><a href="#java中的变量" class="headerlink" title="java中的变量"></a>java中的变量</h2><h4 id="01、局部变量"><a href="#01、局部变量" class="headerlink" title="01、局部变量"></a>01、局部变量</h4><p>在方法体内声明的变量被称为局部变量，该变量只能在该方法内使用，类中的其他方法并不知道该变量。来看下面这个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalVariable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 a、b、c 就是局部变量，它们只能在当前这个 main 方法中使用。</p>
<p>声明局部变量时的注意事项：</p>
<ul>
<li>局部变量声明在方法、构造方法或者语句块中。</li>
<li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，将会被销毁。</li>
<li>访问修饰符不能用于局部变量。</li>
<li>局部变量只在声明它的方法、构造方法或者语句块中可见。</li>
<li>局部变量是在栈上分配的。</li>
<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li>
</ul>
<h4 id="02、成员变量"><a href="#02、成员变量" class="headerlink" title="02、成员变量"></a>02、成员变量</h4><p>在类内部但在方法体外声明的变量称为成员变量，或者实例变量，或者字段。之所以称为实例变量，是因为该变量只能通过类的实例（对象）来访问。来看下面这个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceVariable</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">88</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InstanceVariable</span> <span class="variable">iv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstanceVariable</span>();</span><br><span class="line">        System.out.println(iv.data); <span class="comment">// 88</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 iv 是一个变量，它是一个引用类型的变量。<code>new</code> 关键字可以创建一个类的实例（也称为对象），通过“&#x3D;”操作符赋值给 iv 这个变量，iv 就成了这个对象的引用，通过 <code>iv.data</code> 就可以访问成员变量了。</p>
<p>声明成员变量时的注意事项：</p>
<ul>
<li>成员变量声明在一个类中，但在方法、构造方法和语句块之外。</li>
<li>当一个对象被实例化之后，每个成员变量的值就跟着确定。</li>
<li>成员变量在对象创建的时候创建，在对象被销毁的时候销毁。</li>
<li>成员变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息。</li>
<li>成员变量可以声明在使用前或者使用后。</li>
<li>访问修饰符可以修饰成员变量。</li>
<li>成员变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把成员变量设为私有。通过使用访问修饰符可以使成员变量对子类可见；成员变量具有默认值。数值型变量的默认值是 0，布尔型变量的默认值是 false，引用类型变量的默认值是 null。变量的值可以在声明时指定，也可以在构造方法中指定。</li>
</ul>
<h4 id="03、静态变量"><a href="#03、静态变量" class="headerlink" title="03、静态变量"></a>03、静态变量</h4><p>通过 static 关键字声明的变量被称为静态变量（类变量），它可以直接被类访问，来看下面这个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticVariable</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(StaticVariable.data); <span class="comment">// 99</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 data 就是静态变量，通过<code>类名.静态变量</code>就可以访问了，不需要创建类的实例。</p>
<p>声明静态变量时的注意事项：</p>
<ul>
<li>静态变量在类中以 static 关键字声明，但必须在方法构造方法和语句块之外。</li>
<li>无论一个类创建了多少个对象，类只拥有静态变量的一份拷贝。</li>
<li>静态变量除了被声明为常量外很少使用。</li>
<li>静态变量储存在静态存储区。</li>
<li>静态变量在程序开始时创建，在程序结束时销毁。</li>
<li>与成员变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</li>
<li>静态变量的默认值和实例变量相似。</li>
<li>静态变量还可以在静态语句块中初始化。</li>
</ul>
<h4 id="04、常量"><a href="#04、常量" class="headerlink" title="04、常量"></a>04、常量</h4><p>在 Java 中，有些数据的值是不会发生改变的，这些数据被叫做常量——使用 final 关键字修饰的成员变量。常量的值一旦给定就无法改变！</p>
<p>常量在程序运行过程中主要有 2 个作用：</p>
<ul>
<li>代表常数，便于修改（例如：圆周率的值，<code>final double PI = 3.14</code>）</li>
<li>增强程序的可读性（例如：常量 UP、DOWN 用来代表上和下，<code>final int UP = 0</code>）</li>
</ul>
<p>Java 要求常量名必须大写。来看下面这个示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FinalVariable</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CHEN</span> <span class="operator">=</span> <span class="string">&quot;沉&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MO</span> <span class="operator">=</span> <span class="string">&quot;默&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">FinalVariable</span> <span class="variable">fv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FinalVariable</span>();</span><br><span class="line">        System.out.println(fv.CHEN);</span><br><span class="line">        System.out.println(MO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="java中的方法"><a href="#java中的方法" class="headerlink" title="java中的方法"></a>java中的方法</h2><h4 id="01、Java中的方法是什么？"><a href="#01、Java中的方法是什么？" class="headerlink" title="01、Java中的方法是什么？"></a>01、Java中的方法是什么？</h4><p>方法用来实现代码的可重用性，我们编写一次方法，并多次使用它。通过增加或者删除方法中的一部分代码，就可以提高整体代码的可读性。</p>
<p>只有方法被调用时，它才会执行。Java 中最有名的方法当属 <code>main()</code> 方法，这是程序的入口。</p>
<h4 id="02、如何声明方法？"><a href="#02、如何声明方法？" class="headerlink" title="02、如何声明方法？"></a>02、如何声明方法？</h4><p>方法的声明反映了方法的一些信息，比如说可见性、返回类型、方法名和参数。如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405133.png" alt="img"></p>
<p><strong>访问权限</strong>：它指定了方法的可见性。Java 提供了四种访问权限修饰符o：</p>
<ul>
<li>public：该方法可以被所有类访问。</li>
<li>private：该方法只能在定义它的类中访问。</li>
<li>protected：该方法可以被同一个包中的类，或者不同包中的子类访问。</li>
<li>default：如果一个方法没有使用任何访问权限修饰符，那么它是 package-private 的，意味着该方法只能被同一个包中的类可见。</li>
</ul>
<p><strong>返回类型</strong>：方法返回的数据类型，可以是基本数据类型、对象和集合，如果不需要返回数据，则使用 void 关键字。</p>
<p><strong>方法名</strong>：方法名最好反应出方法的功能，比如，我们要创建一个将两个数字相减的方法，那么方法名最好是 subtract。</p>
<p>方法名最好是一个动词，并且以小写字母开头。如果方法名包含两个以上单词，那么第一个单词最好是动词，然后是形容词或者名词，并且要以驼峰式的命名方式命名。比如：</p>
<ul>
<li>一个单词的方法名：<code>sum()</code></li>
<li>多个单词的方法名：<code>stringComparision()</code></li>
</ul>
<p>一个方法可能与同一个类中的另外一个方法同名，这被称为方法重载。</p>
<p><strong>参数</strong>：参数被放在一个圆括号内，如果有多个参数，可以使用逗号隔开。参数包含两个部分，参数类型和参数名。如果方法没有参数，圆括号是空的。</p>
<p><strong>方法签名</strong>：每一个方法都有一个签名，包括方法名和参数。</p>
<p><strong>方法体</strong>：方法体放在一对花括号内，把一些代码放在一起，用来执行特定的任务。</p>
<h4 id="03、方法有哪几种？"><a href="#03、方法有哪几种？" class="headerlink" title="03、方法有哪几种？"></a>03、方法有哪几种？</h4><p>方法可以分为两种，一种叫标准类库方法，一种叫用户自定义方法。</p>
<h5 id="1）预先定义方法"><a href="#1）预先定义方法" class="headerlink" title="1）预先定义方法"></a><strong>1）预先定义方法</strong></h5><p>Java 提供了大量预先定义好的方法供我们调用，也称为标准类库方法，或者内置方法。比如说 String 类的 <code>length()</code>、<code>equals()</code>、<code>compare()</code> 方法，以及我们在初学 Java 阶段最常用的 <code>println()</code> 方法，用来在控制台打印信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredefinedMethodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Java&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们使用了两个预先定义的方法，<code>main()</code> 方法是程序运行的入口，<code>println()</code> 方法是 <code>PrintStream</code> 类的一个方法。这些方法已经提前定义好了，所以我们可以直接使用它们。</p>
<p>我们可以通过集成开发工具查看预先定义方法的方法签名。</p>
<p><code>println()</code> 方法的访问权限修饰符是 public，返回类型为 void，方法名为 println，参数为 <code>String x</code>，以及 Javadoc（方法是干嘛的）。</p>
<p>预先定义方法让编程变得简单了起来，我们只需要在实现某些功能的时候直接调用这些方法即可，不需要重新编写。</p>
<p>Java 的一个非常大的优势，就是，JDK 的设计者（开发者）为我们提供了大量的标准类库方法，这对于初学编程的新手来说极其友好；不仅如此，GitHub&#x2F;码云上也有大量可以直接拿到生产环境下使用的第三方类库，比如说 hutool 啊、Apache 包啊、一线大厂或者顶级开发大佬贡献的类库，比如说 Druid、Gson 等等。这里是建议使用hutool的，如果有时间我会详细的讲解一下这个包的。</p>
<p>但如果你想从一个初级开发者（俗称调包侠）晋升为一名优秀的 Java 工程师，那就需要深入研究这些源码，并掌握，最好是能自己写出来这些源码，最起码能自定义一些源码，以便为我们所用。</p>
<h5 id="2）用户自定义方法"><a href="#2）用户自定义方法" class="headerlink" title="2）用户自定义方法"></a><strong>2）用户自定义方法</strong></h5><p>当预先定义方法无法满足我们的要求时，就需要自定义一些方法，比如说，我们来定义这样一个方法，用来检查数字是偶数还是奇数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findEvenOdd</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(num + <span class="string">&quot; 是偶数&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(num + <span class="string">&quot; 是奇数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法名叫做 <code>findEvenOdd</code>，访问权限修饰符是 public，并且是静态的（static），返回类型是 void，参数有一个整型（int）的 num。方法体中有一个 if else 语句，如果 num 可以被 2 整除，那么就打印这个数字是偶数，否则就打印这个数字是奇数。</p>
<p>方法被定义好后，如何被调用呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvenOddDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        findEvenOdd(<span class="number">10</span>);</span><br><span class="line">        findEvenOdd(<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findEvenOdd</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(num + <span class="string">&quot; 是偶数&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(num + <span class="string">&quot; 是奇数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main()</code> 方法是程序的入口，并且是静态的，那么就可以直接调用同样是静态方法的 <code>findEvenOdd()</code>。</p>
<p>当一个方法被 static 关键字修饰时，它就是一个静态方法。换句话说，静态方法是属于类的，不属于类实例的（不需要通过 new 关键字创建对象来调用，直接通过类名就可以调用）。</p>
<p>这个其实放到这里讲解，也是有些不好的，但是如果一开始就讲解一这些的话，难免会有人不懂。</p>
<h4 id="04、什么是实例方法？"><a href="#04、什么是实例方法？" class="headerlink" title="04、什么是实例方法？"></a>04、什么是实例方法？</h4><p>没有使用 static 关键字修饰，但在类中声明的方法被称为实例方法，在调用实例方法之前，必须创建类的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceMethodExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InstanceMethodExample</span> <span class="variable">instanceMethodExample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InstanceMethodExample</span>();</span><br><span class="line">        System.out.println(instanceMethodExample.add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>add()</code> 方法是一个实例方法，需要创建 InstanceMethodExample 对象来访问。</p>
<p>实例方法有两种特殊类型：</p>
<ul>
<li>getter 方法</li>
<li>setter 方法</li>
</ul>
<p>getter 方法用来获取私有变量（private 修饰的字段）的值，setter 方法用来设置私有变量的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(<span class="type">int</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getter 方法以 get 开头，setter 方法以 set 开头。这个熟悉不熟悉，这个就是我们之前讲解的构造方法。</p>
<h4 id="05、什么是静态方法？"><a href="#05、什么是静态方法？" class="headerlink" title="05、什么是静态方法？"></a>05、什么是静态方法？</h4><p>相应的，有 static 关键字修饰的方法就叫做静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticMethodExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(add(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StaticMethodExample 类中，mian 和 add 方法都是静态方法，不同的是，main 方法是程序的入口。当我们调用静态方法的时候，就不需要 new 出来类的对象，就可以直接调用静态方法了，一些工具类的方法都是静态方法，比如说 hutool 工具类库，里面有大量的静态方法可以直接调用。</p>
<blockquote>
<p>Hutool 的目标是使用一个工具方法代替一段复杂代码，从而最大限度的避免“复制粘贴”代码的问题，彻底改变我们写代码的方式。</p>
</blockquote>
<p>以计算 MD5 为例：</p>
<ul>
<li>👴【以前】打开搜索引擎 -&gt; 搜“Java MD5 加密” -&gt; 打开某篇博客-&gt; 复制粘贴 -&gt; 改改好用</li>
<li>👦【现在】引入 Hutool -&gt; SecureUtil.md5()</li>
</ul>
<p>Hutool 的存在就是为了减少代码搜索成本，避免网络上参差不齐的代码出现导致的 bug。</p>
<h4 id="06、什么是抽象方法？"><a href="#06、什么是抽象方法？" class="headerlink" title="06、什么是抽象方法？"></a>06、什么是抽象方法？</h4><p>没有方法体的方法被称为抽象方法，它总是在抽象类中声明。这意味着如果类有抽象方法的话，这个类就必须是抽象的。可以使用 atstract 关键字创建抽象方法和抽象类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractDemo</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个类继承了抽象类后，就必须重写抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAbstractDemo</span> <span class="keyword">extends</span> <span class="title class_">AbstractDemo</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写了抽象方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyAbstractDemo</span> <span class="variable">myAbstractDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyAbstractDemo</span>();</span><br><span class="line">        myAbstractDemo.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重写了抽象方法</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405310.png" alt="image-20230616155035788"></p>
<p>这个看的有一点的难懂。</p>
<p>这个概念和多态的相似还是很多的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405541.png" alt="image-20230616155044664"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a10;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这就是一个抽象类。</p>
<p>注意事项：</p>
<p>1.抽象类不能创建对象</p>
<p>2.抽象类不一定有抽象方法，但有抽象方法的类一定是抽象类。</p>
<p>3.抽象类可以有构造方法。</p>
<p>4.抽象类的子类：</p>
<p>要么重写抽象类中的所有抽象方法</p>
<p>要么子类本身也是一个抽象类</p>
<p>我们这里讲到了重写，那么，什么是重写呢</p>
<h4 id="07、方法重写与重载"><a href="#07、方法重写与重载" class="headerlink" title="07、方法重写与重载"></a>07、方法重写与重载</h4><p>重载（Overloading）和重写（Overriding）是Java中两个比较重要的概念。但是对于新手来说也比较容易混淆，本文就举两个实际的例子，来说明下到底是什么是重写和重载。</p>
<p>首先我们分别来看一下重载和重写的定义：</p>
<p>重载：指的是在同一个类中，多个函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p>
<p>重写：指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。</p>
<p>下面的是重载</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Dog&#123;</span><br><span class="line">    public void bark()&#123;</span><br><span class="line">        System.out.println(&quot;woof &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //overloading method</span><br><span class="line">    public void bark(int num)&#123;</span><br><span class="line">        for(int i=0; i&lt;num; i++)</span><br><span class="line">            System.out.println(&quot;woof &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制ErrorOK!</span><br></pre></td></tr></table></figure>

<p>上面的代码中，定义了两个bark方法，一个是没有参数的bark方法，另外一个是包含一个int类型参数的bark方法。我们就可以说这两个方法是重载方法，因为他们的方法名相同，参数列表不同。</p>
<p>在编译期，编译期可以根据方法签名（方法名和参数情况）情况确定具体哪个bark方法被调用。</p>
<p>方法重载的条件需要具备以下条件和要求：</p>
<p>1、被重载的方法必须改变参数列表； 2、被重载的方法可以改变返回类型； 3、被重载的方法可以改变访问修饰符； 4、被重载的方法可以声明新的或更广的检查异常； 5、方法能够在同一个类中或者在一个子类中被重载。</p>
<p>下面是一个重写的例子，看完代码之后不妨猜测一下输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Dog&#123;</span><br><span class="line">    public void bark()&#123;</span><br><span class="line">        System.out.println(&quot;woof &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Hound extends Dog&#123;</span><br><span class="line">    public void sniff()&#123;</span><br><span class="line">        System.out.println(&quot;sniff &quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void bark()&#123;</span><br><span class="line">        System.out.println(&quot;bowl&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OverridingTest&#123;</span><br><span class="line">    public static void main(String [] args)&#123;</span><br><span class="line">        Dog dog = new Hound();</span><br><span class="line">        dog.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;复制ErrorOK!</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bowl复制ErrorOK!</span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们分别在父类、子类中都定义了bark方法，并且他们都是无参方法，所以我们就说这种情况就是方法重写。即子类Hound重写了父类Gog中的bark方法。</p>
<p>在测试的main方法中，<code>dog</code>对象被定义为<code>Dog</code>类型。</p>
<p>在编译期，编译器会检查Dog类中是否有可访问的<code>bark()</code>方法，只要其中包含<code>bark（）</code>方法，那么就可以编译通过。</p>
<p>在运行期，<code>Hound</code>对象被<code>new</code>出来，并赋值给<code>dog</code>变量，这时，JVM是明确的知道<code>dog</code>变量指向的其实是<code>Hound</code>对象的引用。所以，当<code>dog</code>调用<code>bark()</code>方法的时候，就会调用<code>Hound</code>类中定义的<code>bark（）</code>方法。这就是所谓的动态多态性。</p>
<p>方法重写的条件需要具备以下条件和要求：</p>
<p>1、参数列表必须完全与被重写方法的相同； 2、返回类型必须完全与被重写方法的返回类型相同； 3、访问级别的限制性一定不能比被重写方法的强； 4、访问级别的限制性可以比被重写方法的弱； 5、重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常 6、重写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明） 7、不能重写被标示为final的方法； 8、如果不能继承一个方法，则不能重写这个方法。</p>
<p>简单概括可以是</p>
<p>方法重载是指多个方法的方法名相同，但各自的参数不同；</p>
<p>重载方法应该完成类似的功能，参考<code>String</code>的<code>indexOf()</code>；</p>
<p>重载方法返回值类型应该相同。</p>
<h2 id="javq实现平台无关性"><a href="#javq实现平台无关性" class="headerlink" title="javq实现平台无关性"></a>javq实现平台无关性</h2><p>相信对于很多Java开发来说，在刚刚接触Java语言的时候，就听说过Java是一门跨平台的语言，Java是平台无关性的，这也是Java语言可以迅速崛起并风光无限的一个重要原因。那么，到底什么是平台无关性？Java又是如何实现平台无关性的呢？本文就来简单介绍一下。</p>
<h4 id="什么是平台无关性"><a href="#什么是平台无关性" class="headerlink" title="什么是平台无关性"></a>什么是平台无关性</h4><p>平台无关性就是一种语言在计算机上的运行不受平台的约束，一次编译，到处执行（Write Once ,Run Anywhere）。</p>
<p>也就是说，用Java创建的可执行二进制程序，能够不加改变的运行于多个平台。</p>
<h5 id="平台无关性好处"><a href="#平台无关性好处" class="headerlink" title="平台无关性好处"></a>平台无关性好处</h5><p>作为一门平台无关性语言，无论是在自身发展，还是对开发者的友好度上都是很突出的。</p>
<p>因为其平台无关性，所以Java程序可以运行在各种各样的设备上，尤其是一些嵌入式设备，如打印机、扫描仪、传真机等。随着5G时代的来临，也会有更多的终端接入网络，相信平台无关性的Java也能做出一些贡献。</p>
<p>对于Java开发者来说，Java减少了开发和部署到多个平台的成本和时间。真正的做到一次编译，到处运行。</p>
<h4 id="平台无关性的实现"><a href="#平台无关性的实现" class="headerlink" title="平台无关性的实现"></a>平台无关性的实现</h4><p>对于Java的平台无关性的支持，就像对安全性和网络移动性的支持一样，是分布在整个Java体系结构中的。其中扮演者重要的角色的有Java语言规范、Class文件、Java虚拟机（JVM）等。</p>
<h5 id="编译原理基础"><a href="#编译原理基础" class="headerlink" title="编译原理基础"></a>编译原理基础</h5><p>讲到Java语言规范、Class文件、Java虚拟机就不得不提Java到底是是如何运行起来的。</p>
<p>我们知道在计算机世界中，计算机只认识0和1，所以，真正被计算机执行的其实是由0和1组成的二进制文件。</p>
<p>但是，我们日常开发使用的C、C++、Java、Python等都属于高级语言，而非二进制语言。所以，想要让计算机认识我们写出来的Java代码，那就需要把他”翻译”成由0和1组成的二进制文件。这个过程就叫做编译。负责这一过程的处理的工具叫做编译器。</p>
<p>在Java平台中，想要把Java文件，编译成二进制文件，需要经过两步编译，前端编译和后端编译：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405606.jpg" alt="img"></p>
<p>前端编译主要指与源语言有关但与目标机无关的部分。Java中，我们所熟知的<code>javac</code>的编译就是前端编译。除了这种以外，我们使用的很多IDE，如eclipse，idea等，都内置了前端编译器。主要功能就是把<code>.java</code>代码转换成<code>.class</code>代码。</p>
<p>这里提到的<code>.class</code>代码，其实就是Class文件。</p>
<p>后端编译主要是将中间代码再翻译成机器语言。Java中，这一步骤就是Java虚拟机来执行的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405687.jpg" alt="img"></p>
<p>所以，我们说的，Java的平台无关性实现主要作用于以上阶段。如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405764.jpg" alt="img"></p>
<p>我们从后往前介绍一下这三位主演：Java虚拟机、Class文件、Java语言规范</p>
<p><strong>Java虚拟机</strong></p>
<p>所谓平台无关性，就是说要能够做到可以在多个平台上都能无缝对接。但是，对于不同的平台，硬件和操作系统肯定都是不一样的。</p>
<p>对于不同的硬件和操作系统，最主要的区别就是指令不同。比如同样执行a+b，A操作系统对应的二进制指令可能是10001000，而B操作系统对应的指令可能是11101110。那么，想要做到跨平台，最重要的就是可以根据对应的硬件和操作系统生成对应的二进制指令。</p>
<p>而这一工作，主要由我们的Java虚拟机完成。虽然Java语言是平台无关的，但是JVM却是平台有关的，不同的操作系统上面要安装对应的JVM。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405257.jpg" alt="img"></p>
<p>上图是Oracle官网下载JDK的指引，不同的操作系统需要下载对应的Java虚拟机。</p>
<p>有了Java虚拟机，想要执行a+b操作，A操作系统上面的虚拟机就会把指令翻译成10001000，B操作系统上面的虚拟机就会把指令翻译成11101110。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405350.jpg" alt="img"> ps：图中的Class文件中内容为mock内容</p>
<p>所以，Java之所以可以做到跨平台，是因为Java虚拟机充当了桥梁。他扮演了运行时Java程序与其下的硬件和操作系统之间的缓冲角色。</p>
<h5 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h5><p>各种不同的平台的虚拟机都使用统一的程序存储格式——字节码（ByteCode）是构成平台无关性的另一个基石。Java虚拟机只与由字节码组成的Class文件进行交互。</p>
<p>我们说Java语言可以Write Once ,Run Anywhere。这里的Write其实指的就是生成Class文件的过程。</p>
<p>因为Java Class文件可以在任何平台创建，也可以被任何平台的Java虚拟机装载并执行，所以才有了Java的平台无关性。</p>
<h5 id="Java语言规范"><a href="#Java语言规范" class="headerlink" title="Java语言规范"></a>Java语言规范</h5><p>已经有了统一的Class文件，以及可以在不同平台上将Class文件翻译成对应的二进制文件的Java虚拟机，Java就可以彻底实现跨平台了吗？</p>
<p>其实并不是的，Java语言在跨平台方面也是做了一些努力的，这些努力被定义在Java语言规范中。</p>
<p>比如，Java中基本数据类型的值域和行为都是由其自己定义的。而C&#x2F;C++中，基本数据类型是由它的占位宽度决定的，占位宽度则是由所在平台决定的。所以，在不同的平台中，对于同一个C++程序的编译结果会出现不同的行为。</p>
<p>举一个简单的例子，对于int类型，在Java中，int占4个字节，这是固定的。</p>
<p>但是在C++中却不是固定的了。在16位计算机上，int类型的长度可能为两字节；在32位计算机上，可能为4字节；当64位计算机流行起来后，int类型的长度可能会达到8字节。（这里说的都是可能哦！）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405424.jpg" alt="img"></p>
<p>通过保证基本数据类型在所有平台的一致性，Java语言为平台无关性提供强了有力的支持。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>对于Java的平台无关性的支持是分布在整个Java体系结构中的。其中扮演着重要角色的有Java语言规范、Class文件、Java虚拟机等。</p>
<ul>
<li>Java语言规范<ul>
<li>通过规定Java语言中基本数据类型的取值范围和行为</li>
</ul>
</li>
<li>Class文件<ul>
<li>所有Java文件要编译成统一的Class文件</li>
</ul>
</li>
<li>Java虚拟机<ul>
<li>通过Java虚拟机将Class文件转成对应平台的二进制文件等</li>
</ul>
</li>
</ul>
<p>Java的平台无关性是建立在Java虚拟机的平台有关性基础之上的，是因为Java虚拟机屏蔽了底层操作系统和硬件的差异。</p>
<h4 id="语言无关性"><a href="#语言无关性" class="headerlink" title="语言无关性"></a>语言无关性</h4><p>其实，Java的无关性不仅仅体现在平台无关性上面，向外扩展一下，Java还具有语言无关性。</p>
<p>前面我们提到过。JVM其实并不是和Java文件进行交互的，而是和Class文件，也就是说，其实JVM运行的时候，并不依赖于Java语言。</p>
<p>时至今日，商业机构和开源机构已经在Java语言之外发展出一大批可以在JVM上运行的语言了，如Groovy、Scala、Python等。之所以可以支持，就是因为这些语言也可以被编译成字节码（Class文件）。而虚拟机并不关心字节码是有哪种语言编译而来的。</p>
<h2 id="Java可变参数"><a href="#Java可变参数" class="headerlink" title="Java可变参数"></a>Java可变参数</h2><p>可变参数是 Java 1.5 的时候引入的功能，它允许方法使用任意多个、类型相同（<code>is-a</code>）的值作为参数。就像下面这样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    print(<span class="string">&quot;小&quot;</span>);</span><br><span class="line">    print(<span class="string">&quot;小&quot;</span>, <span class="string">&quot;u&quot;</span>);</span><br><span class="line">    print(<span class="string">&quot;小&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;你&quot;</span>);</span><br><span class="line">    print(<span class="string">&quot;小&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;你&quot;</span>, <span class="string">&quot;好&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String... strs)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (String s : strs)</span><br><span class="line">        System.out.print(s);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态方法 <code>print()</code> 就使用了可变参数，所以 <code>print(&quot;xiao&quot;)</code> 可以，<code>print(&quot;xiao&quot;, &quot;u&quot;)</code> 也可以，甚至 3 个、 4 个或者更多个字符串都可以作为参数传递给 <code>print()</code> 方法。</p>
<p>说到可变参数，我想起来阿里巴巴开发手册上有这样一条规约。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405491.png" alt="img"></p>
<p>意思就是尽量不要使用可变参数，如果要用的话，可变参数必须要在参数列表的最后一位。既然坑位有限，只能在最后，那么可变参数就只能有一个（悠着点，悠着点）。如果可变参数不在最后一位，IDE 就会提示对应的错误，如下图所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405628.png" alt="img"></p>
<p>可变参数看起来就像是个语法糖，它背后究竟隐藏了什么呢？让我们来一探究竟，在追求真理这条路上我们要执着。</p>
<p>其实也很简单。<strong>当使用可变参数的时候，实际上是先创建了一个数组，该数组的大小就是可变参数的个数，然后将参数放入数组当中，再将数组传递给被调用的方法</strong>。</p>
<p>这就是为什么可以使用数组作为参数来调用带有可变参数的方法的根本原因。</p>
<p>那如果方法的参数是一个数组，然后像使用可变参数那样去调用方法的时候，能行得通吗？</p>
<p>可变参数，可变参数，顾名思义，当一个方法需要处理任意多个相同类型的对象时，就可以定义可变参数。Java 中有一个很好的例子，就是 String 类的 <code>format()</code> 方法，就像下面这样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.format(<span class="string">&quot;年纪是: %d&quot;</span>, <span class="number">18</span>));</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;年纪是: %d 名字是: %s&quot;</span>, <span class="number">18</span>, <span class="string">&quot;小u&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><code>%d</code> 表示将整数格式化为 10 进制整数，<code>%s</code> 表示输出字符串。</p>
<p>如果不使用可变参数，那需要格式化的参数就必须使用“+”号操作符拼接起来了。麻烦也就惹上身了。</p>
<p>在实际的项目代码中，slf4j的日志输出就经常要用到可变参数（log4j就没法使用可变参数，日志中需要记录多个参数时就痛苦不堪了）。就像下面这样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line">logger.debug(<span class="string">&quot;名字是&#123;&#125;&quot;</span>, mem.getName());</span><br><span class="line">logger.debug(<span class="string">&quot;名字是&#123;&#125;，年纪是&#123;&#125;&quot;</span>, mem.getName(), mem.getAge());</span><br></pre></td></tr></table></figure>

<p>查看源码就可以发现，<code>debug()</code> 方法使用了可变参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String format, Object... arguments)</span>;</span><br></pre></td></tr></table></figure>

<p>“那在使用可变参数的时候有什么注意事项吗？”</p>
<p>有的。我们要避免重载带有可变参数的方法——这样很容易让编译器陷入自我怀疑中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    print(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String... strs)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (String a : strs)</span><br><span class="line">        System.out.print(a);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Integer... ints)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Integer i : ints)</span><br><span class="line">        System.out.print(i);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候，编译器完全不知道该调用哪个 <code>print()</code> 方法，<code>print(String... strs)</code> 还是 <code>print(Integer... ints)</code>，傻傻分不清。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405025.png" alt="img"></p>
<p>假如真的需要重载带有可变参数的方法，就必须在调用方法的时候给出明确的指示，不要让编译器去猜。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String [] strs = <span class="literal">null</span>;</span><br><span class="line">    print(strs);</span><br><span class="line"></span><br><span class="line">    Integer [] ints = <span class="literal">null</span>;</span><br><span class="line">    print(ints);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String... strs)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(Integer... ints)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码是可以编译通过的。因为编译器知道参数是 String 类型还是 Integer 类型，只不过为了运行时不抛出 <code>NullPointerException</code>，两个 <code>print()</code> 方法的内部要做好判空操作。</p>
<h2 id="java-native方法"><a href="#java-native方法" class="headerlink" title="java native方法"></a>java native方法</h2><p>这是java的一个特殊的方法。他是java的本地方法。什么意思呢，我们来看一个例子。</p>
<h4 id="1、JNI：Java-Native-Interface"><a href="#1、JNI：Java-Native-Interface" class="headerlink" title="1、JNI：Java Native Interface"></a><strong>1、JNI：Java Native Interface</strong></h4><p>在介绍 native 之前，我们先了解什么是 JNI。</p>
<p>一般情况下，我们完全可以使用 Java 语言编写程序，但某些情况下，Java 可能满足不了需求，或者不能更好的满足需求，比如：</p>
<ul>
<li>①、标准的 Java 类库不支持。</li>
<li>②、我们已经用另一种语言，比如说 C&#x2F;C++ 编写了一个类库，如何用 Java 代码调用呢？</li>
<li>③、某些运行次数特别多的方法，为了加快性能，需要用更接近硬件的语言（比如汇编）编写。</li>
</ul>
<p>上面这三种需求，说到底就是如何用 Java 代码调用不同语言编写的代码。那么 JNI 应运而生了。</p>
<p>从 Java 1.1 开始，Java Native Interface (JNI)标准就成为 Java 平台的一部分，它允许 Java 代码和其他语言编写的代码进行交互。</p>
<p>JNI 一开始是为了本地已编译语言，尤其是 C 和 C++而设计的，但是它并不妨碍你使用其他语言，只要调用约定受支持就可以了。使用 Java 与本地已编译的代码交互，通常会丧失平台可移植性，但是，有些情况下这样做是可以接受的，甚至是必须的，比如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。JNI 标准至少保证本地代码能工作能在任何 Java 虚拟机实现下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405116.png" alt="img"></p>
<p>通过 JNI，我们就可以通过 Java 程序（代码）调用到操作系统相关的技术实现的库函数，从而与其他技术和系统交互；同时其他技术和系统也可以通过 JNI 提供的相应原生接口调用 Java 应用系统内部实现的功能。</p>
<p>JNI 的缺点：</p>
<ul>
<li>①、程序不再跨平台。要想跨平台，必须在不同的系统环境下重新编译本地语言部分。</li>
<li>②、程序不再是绝对安全的，本地代码的不当使用可能导致整个程序崩溃。一个通用规则是，你应该让本地方法集中在少数几个类当中。这样就降低了 Java 和 C&#x2F;C++ 之间的耦合性。</li>
</ul>
<p>目前来讲使用 JNI 的缺点相对于优点还是可以接受的，可能后面随着 Java 的技术发展，我们不在需要 JNI，但是目前 JDK 还是一直提供了对 JNI 标准的支持。</p>
<h4 id="2、用-C-语言编写程序本地方法"><a href="#2、用-C-语言编写程序本地方法" class="headerlink" title="2、用 C 语言编写程序本地方法"></a><strong>2、用 C 语言编写程序本地方法</strong></h4><blockquote>
<p>官方文档如下：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html">https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.htmlopen in new window</a></p>
</blockquote>
<p>步骤如下：</p>
<p>①、编写带有 native 方法的 Java 类，生成.java 文件；</p>
<p>②、使用 javac 命令编译所编写的 Java 类，生成.class 文件；</p>
<p>③、使用 javah -jni java 类名 生成扩展名为 h 的头文件，也即生成 .h 文件；</p>
<p>④、使用 C&#x2F;C++（或者其他编程想语言）实现本地方法，创建 .h 文件的实现，也就是创建 .cpp 文件实现.h 文件中的方法；</p>
<p>⑤、将 C&#x2F;C++ 编写的文件生成动态连接库，生成 dll 文件；</p>
<p>下面我们通过一个 HelloWorld 程序的调用来完成这几个步骤。</p>
<h5 id="01）编写带有-native-方法的-Java-类-HelloJNI-java"><a href="#01）编写带有-native-方法的-Java-类-HelloJNI-java" class="headerlink" title="01）编写带有 native 方法的 Java 类 HelloJNI.java"></a>01）编写带有 native 方法的 Java 类 HelloJNI.java</h5><p>在 <code>/Users/itwanger/Documents/Github/javabetter/testjni</code> 目录下创建 HelloJNI.java 文件，内容如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJNI</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 加载名为 libhello.dylib 的动态链接库</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义本地方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">helloJNI</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HelloJNI</span>().helloJNI(); <span class="comment">// 调用本地方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PS：后面执行的命令都将在 testjni 的目录下</strong>。</p>
<p>解释一下这段代码：</p>
<p><code>private native void helloJNI()</code>：用 native 声明的方法告知 JVM 调用该方法在外部定义，也就是我们会用 C 语言去实现。</p>
<p><code>System.loadLibrary(&quot;hello&quot;)</code>：加载动态库，参数 hello 是动态库的名字。我们可以这样理解：程序中的方法 helloJNI() 在程序中没有实现，但是我们下面要调用这个方法，怎么办呢？</p>
<p>我们就需要对这个方法进行初始化，所以用了 static 代码块进行初始化，后面会讲到。</p>
<h5 id="02）编译-HelloJNI-java"><a href="#02）编译-HelloJNI-java" class="headerlink" title="02）编译 HelloJNI.java"></a>02）编译 HelloJNI.java</h5><p>在命令行通过 <code>javac HelloJNI.java</code> 来编译源代码。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405174.png" alt="img"></p>
<h5 id="03）使用-javah-jni-HelloJNI-生成扩展名为-h-的头文件"><a href="#03）使用-javah-jni-HelloJNI-生成扩展名为-h-的头文件" class="headerlink" title="03）使用 javah -jni HelloJNI 生成扩展名为 h 的头文件"></a>03）使用 <code>javah -jni HelloJNI</code> 生成扩展名为 h 的头文件</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405261.png" alt="img"></p>
<blockquote>
<p>PS：Java 9 以后，javah 被弃用，取而代之的是使用 -h 选项来生成头文件，例如 <code>javac -h . ClassName.java</code>。</p>
</blockquote>
<p>执行完毕后，会在 HelloJNI.java 所在目录下生成一个名为 HelloJNI.h 的头文件。打开 HelloJNI.h 文件，可以看到如下代码。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405633.png" alt="img"></p>
<p>看不懂没关系，无所谓，直到它是自动生成的就好。</p>
<h5 id="04）使用-C-语言实现本地方法"><a href="#04）使用-C-语言实现本地方法" class="headerlink" title="04）使用 C 语言实现本地方法"></a>04）使用 C 语言实现本地方法</h5><p>创建一个 C 文件 HelloJNI.c，实现本地方法 sayHello。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="keyword">include</span> <span class="string">&quot;HelloJNI.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL <span class="title function_">Java_HelloJNI_helloJNI</span><span class="params">(JNIEnv *env, jobject obj)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, JNI!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里需要引入 JNI 头文件，并且实现的方法名称需要与在 Java 中声明的名称一致（<code>HelloJNI_helloJNI</code> HelloJNI 类的 helloJNI 方法）。</p>
<h5 id="05）编写编译脚本-compile-shopen-in-new-window"><a href="#05）编写编译脚本-compile-shopen-in-new-window" class="headerlink" title="05）编写编译脚本 compile.shopen in new window"></a>05）编写编译脚本 <a target="_blank" rel="noopener" href="http://compile.sh/">compile.shopen in new window</a></h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 编译 HelloJNI.c 文件</span></span><br><span class="line">gcc -I<span class="string">&quot;<span class="variable">$JAVA_HOME</span>/include&quot;</span> -I<span class="string">&quot;<span class="variable">$JAVA_HOME</span>/include/darwin&quot;</span> -shared -o libhello.dylib HelloJNI.c</span><br><span class="line"></span><br><span class="line"><span class="comment">## 把生成的 libhello.dylib 文件拷贝到当前目录</span></span><br><span class="line"><span class="built_in">cp</span> libhello.dylib .</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li><code>$JAVA_HOME</code> 是 JDK 的安装路径，需要根据实际情况修改。</li>
<li>在 macOS 上，动态链接库（hello）的后缀是 .dylib，而不是 Linux 上的 .so。</li>
</ul>
<p>这里的 -I 选项是为了告诉编译器头文件的位置，<code>$JAVA_HOME</code> 是 Java 安装目录的路径。</p>
<h5 id="06）执行编译脚本"><a href="#06）执行编译脚本" class="headerlink" title="06）执行编译脚本"></a>06）执行编译脚本</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh compile.sh</span><br></pre></td></tr></table></figure>

<p>执行完毕后，会在当前目录下生成一个名为 libhello.dylib 的动态链接库。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405718.png" alt="img"></p>
<h5 id="07）运行-HelloJNI"><a href="#07）运行-HelloJNI" class="headerlink" title="07）运行 HelloJNI"></a>07）运行 HelloJNI</h5><p>执行<code>java HelloJNI</code>命令运行 HelloJNI，如果一切正常，就会在终端上输出 Hello, JNI!。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405797.png" alt="img"></p>
<h4 id="3、JNI-调用-C-的流程图"><a href="#3、JNI-调用-C-的流程图" class="headerlink" title="3、JNI 调用 C 的流程图"></a><strong>3、JNI 调用 C 的流程图</strong></h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405043.png" alt="img"></p>
<h4 id="4、native-关键字"><a href="#4、native-关键字" class="headerlink" title="4、native 关键字"></a><strong>4、native 关键字</strong></h4><p>native 用来修饰方法，用 native 声明的方法表示该方法的实现在外部定义，可以用任何语言去实现它，比如说 C&#x2F;C++。 简单地讲，一个 native Method 就是一个 Java 调用非 Java 代码的接口。</p>
<p>native 语法：</p>
<ul>
<li>①、修饰方法的位置必须在返回类型之前，和其余的方法控制符前后关系不受限制。</li>
<li>②、不能用 abstract 修饰，也没有方法体，也没有左右大括号。</li>
<li>③、返回值可以是任意类型</li>
</ul>
<h2 id="java的构造方法"><a href="#java的构造方法" class="headerlink" title="java的构造方法"></a>java的构造方法</h2><p>在之前我们一直提到过构造方法，那么什么是构造方法呢，这里来进行一个详细的介绍。</p>
<p>“在 Java 中，构造方法是一种特殊的方法，当一个类被实例化的时候，就会调用构造方法。只有在构造方法被调用的时候，对象才会被分配内存空间。每次使用 <code>new</code> 关键字创建对象的时候，构造方法至少会被调用一次。”</p>
<p>“如果你在一个类中没有看见构造方法，并不是因为构造方法不存在，而是被缺省了，编译器会给这个类提供一个默认的构造方法。就是说，Java 有两种类型的构造方法：<strong>无参构造方法和有参构造方法</strong>。”</p>
<h4 id="01、创建构造方法的规则"><a href="#01、创建构造方法的规则" class="headerlink" title="01、创建构造方法的规则"></a>01、创建构造方法的规则</h4><p>构造方法必须符合以下规则：</p>
<ul>
<li>构造方法的名字必须和类名一样；</li>
<li>构造方法没有返回类型，包括 void；</li>
<li>构造方法不能是抽象的（abstract）、静态的（static）、最终的（final）、同步的（synchronized）。</li>
</ul>
<p>简单解析一下最后一条规则。</p>
<ul>
<li>由于构造方法不能被子类继承，所以用 final 和 abstract 关键字修饰没有意义；</li>
<li>构造方法用于初始化一个对象，所以用 static 关键字修饰没有意义；</li>
<li>多个线程不会同时创建内存地址相同的同一个对象，所以用 synchronized 关键字修饰没有必要。</li>
</ul>
<p>构造方法的语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">class_name</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">class_name</span><span class="params">()</span>&#123;&#125;    <span class="comment">// 默认无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ciass_name</span><span class="params">([paramList])</span>&#123;&#125;    <span class="comment">// 定义有参数列表的构造方法</span></span><br><span class="line">    …</span><br><span class="line">    <span class="comment">// 类主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，如果用 void 声明构造方法的话，编译时不会报错，但 Java 会把这个所谓的“构造方法”当成普通方法来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Demo</span><span class="params">()</span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>void Demo()&#123;&#125;</code> 看起来很符合构造方法的写法（与类名相同），但其实只是一个不符合规范的普通方法，方法名的首字母使用了大写，方法体为空，它并不是默认的无参构造方法，可以通过反编译后的字节码验证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Demo</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>public Demo() &#123;&#125;</code> 才是真正的无参构造方法。</p>
<p>不过，可以使用访问权限修饰符（private、protected、public、default）来修饰构造方法，访问权限修饰符决定了构造方法的创建方式。</p>
<h4 id="02、默认构造方法"><a href="#02、默认构造方法" class="headerlink" title="02、默认构造方法"></a>02、默认构造方法</h4><p>如果一个构造方法中没有任何参数，那么它就是一个默认构造方法，也称为无参构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bike</span> &#123;</span><br><span class="line">    Bike()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一辆自行车被创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Bike</span> <span class="variable">bike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bike</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这个例子中，我们为 Bike 类中创建了一个无参的构造方法，它在我们创建对象的时候被调用。</p>
<p>程序输出结果如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一辆自行车被创建</span><br></pre></td></tr></table></figure>

<p>通常情况下，无参构造方法是可以缺省的，我们开发者并不需要显式的声明无参构造方法，把这项工作交给编译器就可以了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405172.png" alt="img"></p>
<p>默认构造方法的目的是什么？它为什么是一个空的啊？</p>
<p>默认构造方法的目的主要是为对象的字段提供默认值，看下面这个例子你就明白了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名 &quot;</span> + p.name + <span class="string">&quot; 年龄 &quot;</span> + p.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">姓名 null 年龄 0</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，默认构造方法初始化了 name 和 age 的值，name 是 String 类型，所以默认值为 null，age 是 int 类型，所以默认值为 0。如果没有默认构造方法的话，这项工作就无法完成了。</p>
<h4 id="3、有参构造方法"><a href="#3、有参构造方法" class="headerlink" title="3、有参构造方法"></a>3、有参构造方法</h4><p>有参数的构造方法被称为有参构造方法，参数可以有一个或多个。有参构造方法可以为不同的对象提供不同的值。当然，也可以提供相同的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParamConstructorPerson</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParamConstructorPerson</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名 &quot;</span> + name + <span class="string">&quot; 年龄 &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ParamConstructorPerson</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParamConstructorPerson</span>(<span class="string">&quot;xiaou&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        p1.out();</span><br><span class="line"></span><br><span class="line">        <span class="type">ParamConstructorPerson</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParamConstructorPerson</span>(<span class="string">&quot;xiaou2&quot;</span>,<span class="number">16</span>);</span><br><span class="line">        p2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，构造方法有两个参数（name 和 age），这样的话，我们在创建对象的时候就可以直接为 name 和 age 赋值了。</p>
<h4 id="04、重载构造方法"><a href="#04、重载构造方法" class="headerlink" title="04、重载构造方法"></a>04、重载构造方法</h4><p>在 Java 中，构造方法和方法类似，只不过没有返回类型。它也可以像方法一样被重载。构造方法的重载也很简单，只需要提供不同的参数列表即可。编译器会通过参数的数量来决定应该调用哪一个构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverloadingConstrutorPerson</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OverloadingConstrutorPerson</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">int</span> sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OverloadingConstrutorPerson</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名 &quot;</span> + name + <span class="string">&quot; 年龄 &quot;</span> + age + <span class="string">&quot; 性别 &quot;</span> + sex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OverloadingConstrutorPerson</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OverloadingConstrutorPerson</span>(<span class="string">&quot;王二&quot;</span>,<span class="number">18</span>, <span class="number">1</span>);</span><br><span class="line">        p1.out();</span><br><span class="line"></span><br><span class="line">        <span class="type">OverloadingConstrutorPerson</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OverloadingConstrutorPerson</span>(<span class="string">&quot;王三&quot;</span>,<span class="number">16</span>);</span><br><span class="line">        p2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建对象的时候，如果传递的是三个参数，那么就会调用 <code>OverloadingConstrutorPerson(String name, int age, int sex)</code> 这个构造方法；如果传递的是两个参数，那么就会调用 <code>OverloadingConstrutorPerson(String name, int age)</code> 这个构造方法。</p>
<h4 id="05、构造方法和方法的区别"><a href="#05、构造方法和方法的区别" class="headerlink" title="05、构造方法和方法的区别"></a>05、构造方法和方法的区别</h4><p>构造方法和方法之间的区别还是蛮多的，比如说下面这些：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405248.png" alt="img"></p>
<h4 id="06、复制对象"><a href="#06、复制对象" class="headerlink" title="06、复制对象"></a>06、复制对象</h4><p>复制一个对象可以通过下面三种方式完成：</p>
<ul>
<li>通过构造方法</li>
<li>通过对象的值</li>
<li>通过 Object 类的 <code>clone()</code> 方法</li>
</ul>
<h5 id="1）通过构造方法"><a href="#1）通过构造方法" class="headerlink" title="1）通过构造方法"></a>1）通过构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyConstrutorPerson</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CopyConstrutorPerson</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CopyConstrutorPerson</span><span class="params">(CopyConstrutorPerson person)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = person.name;</span><br><span class="line">        <span class="built_in">this</span>.age = person.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名 &quot;</span> + name + <span class="string">&quot; 年龄 &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CopyConstrutorPerson</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CopyConstrutorPerson</span>(<span class="string">&quot;王二&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        p1.out();</span><br><span class="line"></span><br><span class="line">        <span class="type">CopyConstrutorPerson</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CopyConstrutorPerson</span>(p1);</span><br><span class="line">        p2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，有一个参数为 CopyConstrutorPerson 的构造方法，可以把该参数的字段直接复制到新的对象中，这样的话，就可以在 new 关键字创建新对象的时候把之前的 p1 对象传递过去。</p>
<h5 id="2）通过对象的值"><a href="#2）通过对象的值" class="headerlink" title="2）通过对象的值"></a>2）通过对象的值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyValuePerson</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CopyValuePerson</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CopyValuePerson</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名 &quot;</span> + name + <span class="string">&quot; 年龄 &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CopyValuePerson</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CopyValuePerson</span>(<span class="string">&quot;王二&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        p1.out();</span><br><span class="line"></span><br><span class="line">        <span class="type">CopyValuePerson</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CopyValuePerson</span>();</span><br><span class="line">        p2.name = p1.name;</span><br><span class="line">        p2.age = p1.age;</span><br><span class="line">        </span><br><span class="line">        p2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式比较粗暴，直接拿 p1 的字段值复制给 p2 对象（<code>p2.name = p1.name</code>）。</p>
<h5 id="3）通过-Object-类的-clone-方法"><a href="#3）通过-Object-类的-clone-方法" class="headerlink" title="3）通过 Object 类的 clone() 方法"></a>3）通过 Object 类的 <code>clone()</code> 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClonePerson</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClonePerson</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名 &quot;</span> + name + <span class="string">&quot; 年龄 &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">ClonePerson</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClonePerson</span>(<span class="string">&quot;王二&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        p1.out();</span><br><span class="line"></span><br><span class="line">        <span class="type">ClonePerson</span> <span class="variable">p2</span> <span class="operator">=</span> (ClonePerson) p1.clone();</span><br><span class="line">        p2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>clone()</code> 方法复制对象的时候，ClonePerson 必须先实现 Cloneable 接口的 <code>clone()</code> 方法，然后再调用 <code>clone()</code> 方法（<code>ClonePerson p2 = (ClonePerson) p1.clone()</code>）。</p>
<h2 id="Java访问权限修饰符"><a href="#Java访问权限修饰符" class="headerlink" title="Java访问权限修饰符"></a>Java访问权限修饰符</h2><p>这个是我们掌握封装的核心知识。</p>
<p>考虑两个场景：</p>
<p>场景 1：工程师 A 编写了一个类 ClassA，但是工程师 A 并不希望 ClassA 被其他类都访问到，该如何处理呢？</p>
<p>场景 2：工程师 A 编写了一个类 ClassA，其中有两个方法 fun1、fun2，工程师只想让 fun1 对外可见，也就是说，如果别的工程师来调用 ClassA，只可以调用方法 fun1，该怎么处理呢？</p>
<p>此时，访问权限控制便可以起到作用了。</p>
<p>在 Java 中，提供了四种访问权限控制：</p>
<ul>
<li>默认访问权限（包访问权限）</li>
<li>public</li>
<li>private</li>
<li>protected</li>
</ul>
<p>类只可以用默认访问权限和 public 修饰。比如说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wanger</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wanger</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>但变量和方法则都可以修饰。</p>
<h4 id="1-修饰类"><a href="#1-修饰类" class="headerlink" title="1. 修饰类"></a>1. 修饰类</h4><ul>
<li>默认访问权限（包访问权限）：用来修饰类的话，表示该类只对同一个包中的其他类可见。</li>
<li>public：用来修饰类的话，表示该类对其他所有的类都可见。</li>
</ul>
<p>例 1：</p>
<p>Main.java:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tobetterjavaer.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String\[\] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">		System.out.println(people.getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>People.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tobetterjavaer.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;<span class="comment">//默认访问权限（包访问权限）</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">People</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码可以看出，修饰 People 类采用的是默认访问权限，而由于 People 类和 Main 类在同一个包中，因此 People 类对于 Main 类是可见的。</p>
<p>例子 2：</p>
<p>People.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tobetterjavaer.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;<span class="comment">//默认访问权限（包访问权限）</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">People</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 People 类和 Main 类不在同一个包中，会发生什么情况呢？</p>
<p>下面是 Main 类中的提示的错误：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405498.png" alt="img"></p>
<p>提示 Peolple 类在 Main 类中不可见。从这里就可以看出，如果用默认访问权限去修饰一个类，该类只对同一个包中的其他类可见，对于不同包中的类是不可见的。</p>
<p>正如上图的快速修正提示所示，将 People 类的默认访问权限更改为 public 的话，People 类对于 Main 类便可见了。</p>
<h4 id="2-修饰方法和变量"><a href="#2-修饰方法和变量" class="headerlink" title="2. 修饰方法和变量"></a>2. 修饰方法和变量</h4><ul>
<li>默认访问权限（包访问权限）：如果一个类的方法或变量被包访问权限修饰，也就意味着只能在同一个包中的其他类中显示地调用该类的方法或者变量，在不同包中的类中不能显式地调用该类的方法或变量。</li>
<li>private：如果一个类的方法或者变量被 private 修饰，那么这个类的方法或者变量只能在该类本身中被访问，在类外以及其他类中都不能显式的进行访问。</li>
<li>protected：如果一个类的方法或者变量被 protected 修饰，对于同一个包的类，这个类的方法或变量是可以被访问的。对于不同包的类，只有继承于该类的类才可以访问到该类的方法或者变量。</li>
<li>public：被 public 修饰的方法或者变量，在任何地方都是可见的。</li>
</ul>
<p>例 3：</p>
<p>Main.java 没有变化</p>
<p>People.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tobebetterjavaer.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">People</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	String <span class="title function_">getName</span><span class="params">()</span> &#123;    <span class="comment">//默认访问权限（包访问权限）</span></span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;   <span class="comment">//默认访问权限（包访问权限）</span></span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时在 Main 类是可以显示调用方法 getName 和 setName 的。</p>
<p>但是如果 People 类和 Main 类不在同一个包中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tobebetterjavaer.test2;    <span class="comment">//与Main类处于不同包中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">People</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	String <span class="title function_">getName</span><span class="params">()</span> &#123;    <span class="comment">//默认访问权限（包访问权限）</span></span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;   <span class="comment">//默认访问权限（包访问权限）</span></span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时在 Main 类中会提示错误：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405601.png" alt="img"></p>
<p>由此可以看出，如果用默认访问权限来修饰类的方法或者变量，则只能在同一个包的其他类中进行访问。</p>
<p>例 4:</p>
<p>People.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tobebetterjavaer.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">People</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时是可以在 Main 中显示调用方法 getName 和 setName 的。</p>
<p>如果 People 类和 Main 类处于不同包中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tobebetterjavaer.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">People</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>则会在 Main 中报错：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405713.png" alt="img"></p>
<p>如果在 com.cxh.test1 中定一个类 Man 继承 People，则可以在类 Man 中显示调用方法 getName 和 setName：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.tobebetterjavaer.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.tobebetterjavaer.test2.People;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">People</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充一些关于 Java 包和类文件的知识：</p>
<p>1）Java 中的包主要是为了防止类文件命名冲突以及方便进行代码组织和管理；</p>
<p>2）对于一个 Java 源代码文件，如果存在 public 类的话，只能有一个 public 类，且此时源代码文件的名称必须和 public 类的名称完全相同。</p>
<p>另外，如果还存在其他类，这些类在包外是不可见的。如果源代码文件没有 public 类，则源代码文件的名称可以随意命名。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405777.png" alt="image-20230616180412200"></p>
<p>简单的来说就是</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071405873.png" alt="image-20230616180421789"></p>
<h2 id="java初始代码块"><a href="#java初始代码块" class="headerlink" title="java初始代码块"></a>java初始代码块</h2><p>代码初始化块用于初始化一些成员变量</p>
<p>“可以直接通过‘&#x3D;’操作符对成员变量进行初始化，但通过代码初始化块可以做更多的事情，比如说打印出成员变量初始化后的值。”</p>
<p>我们来看下面的代码可以直接通过 <code>=</code> 操作符对成员变量进行初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bike</span>&#123;  </span><br><span class="line">    <span class="type">int</span> speed=<span class="number">100</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>那为什么还需要代码初始化块呢？“我们可以通过代码初始化块执行一个更复杂的操作，比如为集合填充值。来看下面这段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bike</span> &#123;</span><br><span class="line">    List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Bike</span>().list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>“如果只使用‘&#x3D;’操作符的话，是没办法完成集合初始化的，对吧？‘&#x3D;’ 后面只能 new 出集合，却没办法填充值，代码初始化就可以完成这项工作。”</p>
<p>再看下面的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    Car() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代码初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以发现输出的结果是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">代码初始化块</span><br><span class="line">构造方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从输出结果看上去，仿佛代码初始化块执行得更早，</p>
<p>对象在初始化的时候会先调用构造方法，这是毫无疑问的，只不过，构造方法在执行的时候会把代码初始化块放在构造方法中其他代码之前，所以，先看到了‘代码初始化块’，后看到了‘’构造方法’。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406181.png" alt="img"></p>
<p>对于代码初始化来说，它有三个规则。</p>
<ul>
<li>类实例化的时候执行代码初始化块；</li>
<li>实际上，代码初始化块是放在构造方法中执行的，只不过比较靠前；</li>
<li>代码初始化块里的执行顺序是从前到后的。</li>
</ul>
<p>这些规则不用死记硬背，大致了解一下就行了。我们继续来看下面这段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    A () &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    B() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代码初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面来看输出结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父类构造方法</span><br><span class="line">代码初始化块</span><br><span class="line">子类构造方法</span><br></pre></td></tr></table></figure>

<p>在默认情况下，子类的构造方法在执行的时候会主动去调用父类的构造方法。也就是说，其实是构造方法先执行的，再执行的代码初始化块。</p>
<p>“这个例子再次印证了之前的第二条规则：代码初始化块是放在构造方法中执行的，只不过比较靠前。</p>
<p>下面是一个 Java 示例代码，演示实例初始化块和静态初始化块的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">instanceVar</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态初始化块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行静态初始化块&quot;</span>);</span><br><span class="line">        staticVar = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例初始化块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行实例初始化块&quot;</span>);</span><br><span class="line">        instanceVar = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Example</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行main方法&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Example</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        <span class="type">Example</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;e1的静态变量：&quot;</span> + e1.staticVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;e1的实例变量：&quot;</span> + e1.instanceVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;e2的静态变量：&quot;</span> + e2.staticVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;e2的实例变量：&quot;</span> + e2.instanceVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个示例代码中，有一个静态变量 staticVar 和一个实例变量 instanceVar，以及一个静态初始化块和一个实例初始化块。在静态初始化块中，我们打印了一条消息并修改了静态变量的值；在实例初始化块中，我们也打印了一条消息并修改了实例变量的值。来看一下执行结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">执行静态初始化块</span><br><span class="line">执行main方法</span><br><span class="line">执行实例初始化块</span><br><span class="line">执行构造方法</span><br><span class="line">执行实例初始化块</span><br><span class="line">执行构造方法</span><br><span class="line">e1的静态变量：3</span><br><span class="line">e1的实例变量：4</span><br><span class="line">e2的静态变量：3</span><br><span class="line">e2的实例变量：4</span><br></pre></td></tr></table></figure>

<p>从输出结果可以看出，静态初始化块在类加载时执行，只会执行一次，并且优先于实例初始化块和构造方法的执行；实例初始化块在每次创建对象时执行，在构造方法之前执行。</p>
<h2 id="java抽象类"><a href="#java抽象类" class="headerlink" title="java抽象类"></a>java抽象类</h2><h4 id="01、定义抽象类"><a href="#01、定义抽象类" class="headerlink" title="01、定义抽象类"></a>01、定义抽象类</h4><p>定义抽象类的时候需要用到关键字 <code>abstract</code>，放在 <code>class</code> 关键字前，就像下面这样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPlayer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于抽象类的命名，《阿里的 Java 开发手册》上有强调，“抽象类命名要使用 Abstract 或 Base 开头”，这条规约还是值得遵守的，真正做到名如其意。</p>
<h4 id="02、抽象类的特征"><a href="#02、抽象类的特征" class="headerlink" title="02、抽象类的特征"></a>02、抽象类的特征</h4><p>抽象类是不能实例化的，尝试通过 <code>new</code> 关键字实例化的话，编译器会报错，提示“类是抽象的，不能实例化”。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406241.png" alt="img"></p>
<p>虽然抽象类不能实例化，但可以有子类。子类通过 <code>extends</code> 关键字来继承抽象类。就像下面这样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasketballPlayer</span> <span class="keyword">extends</span> <span class="title class_">AbstractPlayer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类定义了一个或多个抽象方法，那么这个类必须是抽象类。</p>
<p>当我们尝试在一个普通类中定义抽象方法的时候，编译器会有两处错误提示。第一处在类级别上，提示“这个类必须通过 <code>abstract</code> 关键字定义”，见下图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406381.png" alt="img"></p>
<p>第二处在尝试定义 abstract 的方法上，提示“抽象方法所在的类不是抽象的”，见下图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406580.png" alt="img"></p>
<p>抽象类中既可以定义抽象方法，也可以定义普通方法，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;运动员也要休息而不是挑战极限&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类派生的子类必须实现父类中定义的抽象方法。比如说，抽象类 AbstractPlayer 中定义了 <code>play()</code> 方法，子类 BasketballPlayer 中就必须实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasketballPlayer</span> <span class="keyword">extends</span> <span class="title class_">AbstractPlayer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是张伯伦，篮球场上得过 100 分&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有实现的话，编译器会提示“子类必须实现抽象方法”，见下图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406703.png" alt="img"></p>
<h4 id="03、抽象类的应用场景"><a href="#03、抽象类的应用场景" class="headerlink" title="03、抽象类的应用场景"></a>03、抽象类的应用场景</h4><h5 id="01）第一种场景"><a href="#01）第一种场景" class="headerlink" title="01）第一种场景"></a><strong>01）第一种场景</strong></h5><p>当我们希望一些通用的功能被多个子类复用的时候，就可以使用抽象类。比如说，AbstractPlayer 抽象类中有一个普通的方法 <code>sleep()</code>，表明所有运动员都需要休息，那么这个方法就可以被子类复用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;运动员也要休息而不是挑战极限&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类 BasketballPlayer 继承了 AbstractPlayer 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasketballPlayer</span> <span class="keyword">extends</span> <span class="title class_">AbstractPlayer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就拥有了 <code>sleep()</code> 方法。BasketballPlayer 的对象可以直接调用父类的 <code>sleep()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BasketballPlayer</span> <span class="variable">basketballPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasketballPlayer</span>();</span><br><span class="line">basketballPlayer.sleep();</span><br></pre></td></tr></table></figure>

<p>子类 FootballPlayer 继承了 AbstractPlayer 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FootballPlayer</span> <span class="keyword">extends</span> <span class="title class_">AbstractPlayer</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也拥有了 <code>sleep()</code> 方法，FootballPlayer 的对象也可以直接调用父类的 <code>sleep()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FootballPlayer</span> <span class="variable">footballPlayer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FootballPlayer</span>();</span><br><span class="line">footballPlayer.sleep();</span><br></pre></td></tr></table></figure>

<p>这样是不是就实现了代码的复用呢？</p>
<h5 id="02）第二种场景"><a href="#02）第二种场景" class="headerlink" title="02）第二种场景"></a><strong>02）第二种场景</strong></h5><p>当我们需要在抽象类中定义好 API，然后在子类中扩展实现的时候就可以使用抽象类。比如说，AbstractPlayer 抽象类中定义了一个抽象方法 <code>play()</code>，表明所有运动员都可以从事某项运动，但需要对应子类去扩展实现，表明篮球运动员打篮球，足球运动员踢足球。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPlayer</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BasketballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 <code>play()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasketballPlayer</span> <span class="keyword">extends</span> <span class="title class_">AbstractPlayer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是张伯伦，我篮球场上得过 100 分，&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FootballPlayer 继承了 AbstractPlayer 类，扩展实现了自己的 <code>play()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FootballPlayer</span> <span class="keyword">extends</span> <span class="title class_">AbstractPlayer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">play</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是C罗，我能接住任意高度的头球&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了进一步展示抽象类的特性，我们再来看一个具体的示例。</p>
<p>假设现在有一个文件，里面的内容非常简单，只有一个“Hello World”，现在需要有一个读取器将内容从文件中读取出来，最好能按照大写的方式，或者小写的方式来读。</p>
<p>这时候，最好定义一个抽象类 BaseFileReader：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类，定义了一个读取文件的基础框架，其中 mapFileLine 是一个抽象方法，具体实现需要由子类来完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseFileReader</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Path filePath; <span class="comment">// 定义一个 protected 的 Path 对象，表示读取的文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，传入读取的文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath 读取的文件路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">BaseFileReader</span><span class="params">(Path filePath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取文件的方法，返回一个字符串列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字符串列表，表示文件的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException 如果文件读取出错，抛出该异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> Files.lines(filePath) <span class="comment">// 使用 Files 类的 lines 方法，读取文件的每一行</span></span><br><span class="line">                .map(<span class="built_in">this</span>::mapFileLine) <span class="comment">// 对每一行应用 mapFileLine 方法，将其转化为指定的格式</span></span><br><span class="line">                .collect(Collectors.toList()); <span class="comment">// 将处理后的每一行收集到一个字符串列表中，返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法，子类需要实现该方法，将文件中的每一行转化为指定的格式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> line 文件中的每一行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 转化后的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title function_">mapFileLine</span><span class="params">(String line)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>filePath 为文件路径，使用 protected 修饰，表明该成员变量可以在需要时被子类访问到。</li>
<li><code>readFile()</code> 方法用来读取文件，方法体里面调用了抽象方法 <code>mapFileLine()</code>——需要子类来扩展实现大小写的不同读取方式。</li>
</ul>
<p>在我看来，BaseFileReader 类设计的就非常合理，并且易于扩展，子类只需要专注于具体的大小写实现方式就可以了。</p>
<p>小写的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LowercaseFileReader</span> <span class="keyword">extends</span> <span class="title class_">BaseFileReader</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">LowercaseFileReader</span><span class="params">(Path filePath)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">mapFileLine</span><span class="params">(String line)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> line.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大写的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UppercaseFileReader</span> <span class="keyword">extends</span> <span class="title class_">BaseFileReader</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">UppercaseFileReader</span><span class="params">(Path filePath)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">mapFileLine</span><span class="params">(String line)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> line.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从文件里面一行一行读取内容的代码被子类复用了。与此同时，子类只需要专注于自己该做的工作，LowercaseFileReader 以小写的方式读取文件内容，UppercaseFileReader 以大写的方式读取文件内容。</p>
<p>来看一下测试类 FileReaderTest：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileReaderTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> URISyntaxException, IOException &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">location</span> <span class="operator">=</span> FileReaderTest.class.getClassLoader().getResource(<span class="string">&quot;helloworld.txt&quot;</span>);</span><br><span class="line">        <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(location.toURI());</span><br><span class="line">        <span class="type">BaseFileReader</span> <span class="variable">lowercaseFileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LowercaseFileReader</span>(path);</span><br><span class="line">        <span class="type">BaseFileReader</span> <span class="variable">uppercaseFileReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UppercaseFileReader</span>(path);</span><br><span class="line">        System.out.println(lowercaseFileReader.readFile());</span><br><span class="line">        System.out.println(uppercaseFileReader.readFile());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在项目的 resource 目录下建一个文本文件，名字叫 helloworld.txt，里面的内容就是“Hello World”。文件的具体位置如下图所示，我用的集成开发环境是 Intellij IDEA。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406840.png" alt="img"></p>
<p>在 resource 目录下的文件可以通过 <code>ClassLoader.getResource()</code> 的方式获取到 URI 路径，然后就可以取到文本内容了。</p>
<p>输出结果如下所示：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[hello world]</span><br><span class="line">[HELLO WORLD]</span><br></pre></td></tr></table></figure>

<h4 id="04、抽象类总结"><a href="#04、抽象类总结" class="headerlink" title="04、抽象类总结"></a>04、抽象类总结</h4><p>好了，对于抽象类我们简单总结一下：</p>
<ul>
<li>1、抽象类不能被实例化。</li>
<li>2、抽象类应该至少有一个抽象方法，否则它没有任何意义。</li>
<li>3、抽象类中的抽象方法没有方法体。</li>
<li>4、抽象类的子类必须给出父类中的抽象方法的具体实现，除非该子类也是抽象类。</li>
</ul>
<h2 id="java接口"><a href="#java接口" class="headerlink" title="java接口"></a>java接口</h2><p>在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现，这样，多态就能发挥出威力。</p>
<p>如果一个抽象类没有字段，所有方法全部都是抽象方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就可以把该抽象类改写为接口：<code>interface</code>。</p>
<p>在Java中，使用<code>interface</code>可以声明一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个<code>interface</code>，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Student implements Person, Hello &#123; // 实现了两个interface</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>注意区分术语：</p>
<p>Java的接口特指<code>interface</code>的定义，表示一个接口类型和一组方法签名，而编程接口泛指接口规范，如方法签名，数据格式，网络协议等。</p>
<p>抽象类和接口的对比如下：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">abstract class</th>
<th align="left">interface</th>
</tr>
</thead>
<tbody><tr>
<td align="left">继承</td>
<td align="left">只能extends一个class</td>
<td align="left">可以implements多个interface</td>
</tr>
<tr>
<td align="left">字段</td>
<td align="left">可以定义实例字段</td>
<td align="left">不能定义实例字段</td>
</tr>
<tr>
<td align="left">抽象方法</td>
<td align="left">可以定义抽象方法</td>
<td align="left">可以定义抽象方法</td>
</tr>
<tr>
<td align="left">非抽象方法</td>
<td align="left">可以定义非抽象方法</td>
<td align="left">可以定义default方法</td>
</tr>
</tbody></table>
<h4 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h4><p>一个<code>interface</code>可以继承自另一个<code>interface</code>。<code>interface</code>继承自<code>interface</code>使用<code>extends</code>，它相当于扩展了接口的方法。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Hello &#123;</span><br><span class="line">    void hello();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Person extends Hello &#123;</span><br><span class="line">    void run();</span><br><span class="line">    String getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，<code>Person</code>接口继承自<code>Hello</code>接口，因此，<code>Person</code>接口现在实际上有3个抽象方法签名，其中一个来自继承的<code>Hello</code>接口。</p>
<h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p>合理设计<code>interface</code>和<code>abstract class</code>的继承关系，可以充分复用代码。一般来说，公共逻辑适合放在<code>abstract class</code>中，具体逻辑放到各个子类，而接口层次代表抽象程度。可以参考Java的集合类定义的一组接口、抽象类以及具体子类的继承关系：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────┐</span><br><span class="line">│   Iterable    │</span><br><span class="line">└───────────────┘</span><br><span class="line">        ▲                ┌───────────────────┐</span><br><span class="line">        │                │      Object       │</span><br><span class="line">┌───────────────┐        └───────────────────┘</span><br><span class="line">│  Collection   │                  ▲</span><br><span class="line">└───────────────┘                  │</span><br><span class="line">        ▲     ▲          ┌───────────────────┐</span><br><span class="line">        │     └──────────│AbstractCollection │</span><br><span class="line">┌───────────────┐        └───────────────────┘</span><br><span class="line">│     List      │                  ▲</span><br><span class="line">└───────────────┘                  │</span><br><span class="line">              ▲          ┌───────────────────┐</span><br><span class="line">              └──────────│   AbstractList    │</span><br><span class="line">                         └───────────────────┘</span><br><span class="line">                                ▲     ▲</span><br><span class="line">                                │     │</span><br><span class="line">                                │     │</span><br><span class="line">                     ┌────────────┐ ┌────────────┐</span><br><span class="line">                     │ ArrayList  │ │ LinkedList │</span><br><span class="line">                     └────────────┘ └────────────┘</span><br></pre></td></tr></table></figure>

<p>在使用的时候，实例化的对象永远只能是某个具体的子类，但总是通过接口去引用它，因为接口比抽象类更抽象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(); <span class="comment">// 用List接口引用具体子类的实例</span></span><br><span class="line"><span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> list; <span class="comment">// 向上转型为Collection接口</span></span><br><span class="line"><span class="type">Iterable</span> <span class="variable">it</span> <span class="operator">=</span> coll; <span class="comment">// 向上转型为Iterable接口</span></span><br></pre></td></tr></table></figure>

<p>说了这么多，让我们来看看接口对我们的用途</p>
<h4 id="01、定义接口"><a href="#01、定义接口" class="headerlink" title="01、定义接口"></a>01、定义接口</h4><p>接口通过 interface 关键字来定义，它可以包含一些常量和方法，来看下面这个示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Electronic</span> &#123;</span><br><span class="line">    <span class="comment">// 常量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">LED</span> <span class="operator">=</span> <span class="string">&quot;LED&quot;</span>;</span><br><span class="line"><span class="comment">// 抽象方法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getElectricityUse</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEnergyEfficient</span><span class="params">(String electtronicType)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> electtronicType.equals(LED);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认方法</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">printDescription</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;电子&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>来看一下这段代码反编译后的字节码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Electronic</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getElectricityUse</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEnergyEfficient</span><span class="params">(String electtronicType)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> electtronicType.equals(<span class="string">&quot;LED&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printDescription</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\u7535\u5B50&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LED</span> <span class="operator">=</span> <span class="string">&quot;LED&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发现没？接口中定义的所有变量或者方法，都会自动添加上 <code>public</code> 关键字。</p>
<p>接下来，我来一一解释下 Electronic 接口中的核心知识点。</p>
<p><strong>1）接口中定义的变量会在编译的时候自动加上 <code>public static final</code> 修饰符</strong>（注意看一下反编译后的字节码），也就是说上例中的 LED 变量其实就是一个常量。</p>
<p>Java 官方文档上有这样的声明：</p>
<blockquote>
<p>Every field declaration in the body of an interface is implicitly public, static, and final.</p>
</blockquote>
<p>换句话说，接口可以用来作为常量类使用，还能省略掉 <code>public static final</code>，看似不错的一种选择，对吧？</p>
<p>不过，这种选择并不可取。因为接口的本意是对方法进行抽象，而常量接口会对子类中的变量造成命名空间上的“污染”。</p>
<p><strong>2）没有使用 <code>private</code>、<code>default</code> 或者 <code>static</code> 关键字修饰的方法是隐式抽象的</strong>，在编译的时候会自动加上 <code>public abstract</code> 修饰符。也就是说上例中的 <code>getElectricityUse()</code> 其实是一个抽象方法，没有方法体——这是定义接口的本意。</p>
<p><strong>3）从 Java 8 开始，接口中允许有静态方法</strong>，比如说上例中的 <code>isEnergyEfficient()</code> 方法。</p>
<p>静态方法无法由（实现了该接口的）类的对象调用，它只能通过接口名来调用，比如说 <code>Electronic.isEnergyEfficient(&quot;LED&quot;)</code>。</p>
<p>接口中定义静态方法的目的是为了提供一种简单的机制，使我们不必创建对象就能调用方法，从而提高接口的竞争力。</p>
<p><strong>4）接口中允许定义 <code>default</code> 方法</strong>也是从 Java 8 开始的，比如说上例中的 <code>printDescription()</code> 方法，它始终由一个代码块组成，为实现该接口而不覆盖该方法的类提供默认实现。既然要提供默认实现，就要有方法体，换句话说，默认方法后面不能直接使用“;”号来结束——编译器会报错。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406045.png" alt="img"></p>
<p>“为什么要在接口中定义默认方法呢？”</p>
<p>允许在接口中定义默认方法的理由很充分，因为一个接口可能有多个实现类，这些类就必须实现接口中定义的抽象类，否则编译器就会报错。假如我们需要在所有的实现类中追加某个具体的方法，在没有 <code>default</code> 方法的帮助下，我们就必须挨个对实现类进行修改。</p>
<p>由之前的例子我们就可以得出下面这些结论：</p>
<ul>
<li>接口中允许定义变量</li>
<li>接口中允许定义抽象方法</li>
<li>接口中允许定义静态方法（Java 8 之后）</li>
<li>接口中允许定义默认方法（Java 8 之后）</li>
</ul>
<p>除此之外，我们还应该知道：</p>
<p><strong>1）接口不允许直接实例化</strong>，否则编译器会报错。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406096.png" alt="img"></p>
<p>需要定义一个类去实现接口，见下例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> <span class="keyword">implements</span> <span class="title class_">Electronic</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getElectricityUse</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再实例化。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Electronic e = new Computer();</span><br></pre></td></tr></table></figure>

<p><strong>2）接口可以是空的</strong>，既可以不定义变量，也可以不定义方法。最典型的例子就是 Serializable 接口，在 <code>java.io</code> 包下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Serializable 接口用来为序列化的具体实现提供一个标记，也就是说，只要某个类实现了 Serializable 接口，那么它就可以用来序列化了。</p>
<p><strong>3）不要在定义接口的时候使用 final 关键字</strong>，否则会报编译错误，因为接口就是为了让子类实现的，而 final 阻止了这种行为。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406145.png" alt="img"></p>
<p><strong>4）接口的抽象方法不能是 private、protected 或者 final</strong>，否则编译器都会报错。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406432.png" alt="img"></p>
<p><strong>5）接口的变量是隐式 <code>public static final</code>（常量）</strong>，所以其值无法改变。</p>
<h4 id="02、接口的作用"><a href="#02、接口的作用" class="headerlink" title="02、接口的作用"></a>02、接口的作用</h4><p><strong>第一，使某些实现类具有我们想要的功能</strong>，比如说，实现了 Cloneable 接口的类具有拷贝的功能，实现了 Comparable 或者 Comparator 的类具有比较功能。</p>
<p>Cloneable 和 Serializable 一样，都属于标记型接口，它们内部都是空的。实现了 Cloneable 接口的类可以使用 <code>Object.clone()</code> 方法，否则会抛出 CloneNotSupportedException。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneableTest</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">CloneableTest</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CloneableTest</span>();</span><br><span class="line">        <span class="type">CloneableTest</span> <span class="variable">c2</span> <span class="operator">=</span> (CloneableTest) c1.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>运行后没有报错。现在把 <code>implements Cloneable</code> 去掉。</p>
<p>运行后抛出 CloneNotSupportedException：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.CloneNotSupportedException: com.cmower.baeldung.interface1.CloneableTest</span><br><span class="line">	at java.base/java.lang.Object.clone(Native Method)</span><br><span class="line">	at com.cmower.baeldung.interface1.CloneableTest.clone(CloneableTest.java:<span class="number">6</span>)</span><br><span class="line">	at com.cmower.baeldung.interface1.CloneableTest.main(CloneableTest.java:<span class="number">11</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>第二，Java 原则上只支持单一继承，但通过接口可以实现多重继承的目的</strong>。</p>
<p>如果有两个类共同继承（extends）一个父类，那么父类的方法就会被两个子类重写。然后，如果有一个新类同时继承了这两个子类，那么在调用重写方法的时候，编译器就不能识别要调用哪个类的方法了。这也正是著名的菱形问题，见下图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406493.png" alt="img"></p>
<p>简单解释下，ClassC 同时继承了 ClassA 和 ClassB，ClassC 的对象在调用 ClassA 和 ClassB 中重写的方法时，就不知道该调用 ClassA 的方法，还是 ClassB 的方法。</p>
<p>接口没有这方面的困扰。来定义两个接口，Fly 接口会飞，Run 接口会跑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Fly</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Run</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后让 Pig 类同时实现这两个接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Pig</span> <span class="keyword">implements</span> <span class="title class_">Fly</span>,Run&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;会飞的猪&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;会跑的猪&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在某种形式上，接口实现了多重继承的目的：现实世界里，猪的确只会跑，但在雷军的眼里，站在风口的猪就会飞，这就需要赋予这只猪更多的能力，通过抽象类是无法实现的，只能通过接口。</p>
<p><strong>第三，实现多态</strong>。</p>
<p>什么是多态呢？通俗的理解，就是同一个事件发生在不同的对象上会产生不同的结果，鼠标左键点击窗口上的 X 号可以关闭窗口，点击超链接却可以打开新的网页。</p>
<p>多态可以通过继承（<code>extends</code>）的关系实现，也可以通过接口的形式实现。</p>
<p>Shape 接口表示一个形状。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Circle 类实现了 Shape 接口，并重写了 <code>name()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;圆&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Square 类也实现了 Shape 接口，并重写了 <code>name()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;正方形&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后来看测试类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Shape&gt; shapes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">Shape</span> <span class="variable">circleShape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line"><span class="type">Shape</span> <span class="variable">squareShape</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line"></span><br><span class="line">shapes.add(circleShape);</span><br><span class="line">shapes.add(squareShape);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Shape shape : shapes) &#123;</span><br><span class="line">    System.out.println(shape.name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就实现了多态，变量 circleShape、squareShape 的引用类型都是 Shape，但执行 <code>shape.name()</code> 方法的时候，Java 虚拟机知道该去调用 Circle 的 <code>name()</code> 方法还是 Square 的 <code>name()</code> 方法。</p>
<p>说一下多态存在的 3 个前提：</p>
<ul>
<li>1、要有继承关系，比如说 Circle 和 Square 都实现了 Shape 接口。</li>
<li>2、子类要重写父类的方法，Circle 和 Square 都重写了 <code>name()</code> 方法。</li>
<li>3、父类引用指向子类对象，circleShape 和 squareShape 的类型都为 Shape，但前者指向的是 Circle 对象，后者指向的是 Square 对象。</li>
</ul>
<p>然后，我们来看一下测试结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">圆</span><br><span class="line">正方形</span><br></pre></td></tr></table></figure>

<p>也就意味着，尽管在 for 循环中，shape 的类型都为 Shape，但在调用 <code>name()</code> 方法的时候，它知道 Circle 对象应该调用 Circle 类的 <code>name()</code> 方法，Square 对象应该调用 Square 类的 <code>name()</code> 方法。</p>
<h4 id="03、接口的三种模式"><a href="#03、接口的三种模式" class="headerlink" title="03、接口的三种模式"></a>03、接口的三种模式</h4><p><strong>在编程领域，好的设计模式能够让我们的代码事半功倍</strong>。在使用接口的时候，经常会用到三种模式，分别是策略模式、适配器模式和工厂模式。</p>
<h5 id="1）策略模式"><a href="#1）策略模式" class="headerlink" title="1）策略模式"></a>1）策略模式</h5><p>策略模式的思想是，针对一组算法，将每一种算法封装到具有共同接口的实现类中，接口的设计者可以在不影响调用者的情况下对算法做出改变。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口：教练</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Coach</span> &#123;</span><br><span class="line">    <span class="comment">// 方法：防守</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">defend</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 何塞·穆里尼奥</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hesai</span> <span class="keyword">implements</span> <span class="title class_">Coach</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defend</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防守赢得冠军&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 德普·瓜迪奥拉</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Guatu</span> <span class="keyword">implements</span> <span class="title class_">Coach</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defend</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进攻就是最好的防守&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// 参数为接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">defend</span><span class="params">(Coach coach)</span> &#123;</span><br><span class="line">        coach.defend();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 为同一个方法传递不同的对象</span></span><br><span class="line">        defend(<span class="keyword">new</span> <span class="title class_">Hesai</span>());</span><br><span class="line">        defend(<span class="keyword">new</span> <span class="title class_">Guatu</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Demo.defend()</code> 方法可以接受不同风格的 Coach，并根据所传递的参数对象的不同而产生不同的行为，这被称为“策略模式”。</p>
<h5 id="2）适配器模式"><a href="#2）适配器模式" class="headerlink" title="2）适配器模式"></a>2）适配器模式</h5><p>适配器模式的思想是，针对调用者的需求对原有的接口进行转接。生活当中最常见的适配器就是HDMI（英语：<code>High Definition Multimedia Interface</code>，中文：高清多媒体接口）线，可以同时发送音频和视频信号。适配器模式的示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Coach</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">defend</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类实现接口，并置空方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AdapterCoach</span> <span class="keyword">implements</span> <span class="title class_">Coach</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defend</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新类继承适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hesai</span> <span class="keyword">extends</span> <span class="title class_">AdapterCoach</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defend</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防守赢得冠军&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Coach</span> <span class="variable">coach</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hesai</span>();</span><br><span class="line">        coach.defend();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Coach 接口中定义了两个方法（<code>defend()</code> 和 <code>attack()</code>），如果类直接实现该接口的话，就需要对两个方法进行实现。</p>
<p>如果我们只需要对其中一个方法进行实现的话，就可以使用一个抽象类作为中间件，即适配器（AdapterCoach），用这个抽象类实现接口，并对抽象类中的方法置空（方法体只有一对花括号），这时候，新类就可以绕过接口，继承抽象类，我们就可以只对需要的方法进行覆盖，而不是接口中的所有方法。</p>
<p>简单的来看一个案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a13;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">metho1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">metho2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">metho3</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">metho4</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">metho5</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">metho6</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">metho7</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比如有这样一个接口，里面有非常多的接口。</p>
<p>之后写一个类实现这个接口的时候。</p>
<p>必须要重写其中的所有的方法。非常的麻烦。</p>
<p>如果你只想用metho5，那就没有办法了吗？</p>
<p>实际上是有的。</p>
<p>我们用一个中间的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> <span class="keyword">implements</span> <span class="title class_">Inter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">metho1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">metho2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">metho3</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">metho4</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">metho5</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">metho6</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">metho7</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让外界调用她，所以把她设置成抽象的。</p>
<p>之后我们直接继承这个类。需要重写哪一个方法就重写哪一个就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a13;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interlmpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span>&#123;</span><br><span class="line">    <span class="comment">//需要什么方法重写就可以了</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">metho5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.metho5();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406554.png" alt="image-20230616222707040"></p>
<h5 id="3）工厂模式"><a href="#3）工厂模式" class="headerlink" title="3）工厂模式"></a>3）工厂模式</h5><p>所谓的工厂模式理解起来也不难，就是什么工厂生产什么，比如说宝马工厂生产宝马，奔驰工厂生产奔驰，A 级学院毕业 A 级教练，C 级学院毕业 C 级教练。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 教练</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Coach</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">command</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 教练学院</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CoachFactory</span> &#123;</span><br><span class="line">    Coach <span class="title function_">createCoach</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A级教练</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ACoach</span> <span class="keyword">implements</span> <span class="title class_">Coach</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">command</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是A级证书教练&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A级教练学院</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ACoachFactory</span> <span class="keyword">implements</span> <span class="title class_">CoachFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coach <span class="title function_">createCoach</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ACoach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C级教练</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCoach</span> <span class="keyword">implements</span> <span class="title class_">Coach</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">command</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是C级证书教练&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C级教练学院</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CCoachFactory</span> <span class="keyword">implements</span> <span class="title class_">CoachFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Coach <span class="title function_">createCoach</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CCoach</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">create</span><span class="params">(CoachFactory factory)</span> &#123;</span><br><span class="line">        factory.createCoach().command();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 对于一支球队来说，需要什么样的教练就去找什么样的学院</span></span><br><span class="line">        <span class="comment">// 学院会介绍球队对应水平的教练。</span></span><br><span class="line">        create(<span class="keyword">new</span> <span class="title class_">ACoachFactory</span>());</span><br><span class="line">        create(<span class="keyword">new</span> <span class="title class_">CCoachFactory</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个接口，一个是 Coach（教练），可以 <code>command()</code>（指挥球队）；另外一个是 CoachFactory（教练学院），能 <code>createCoach()</code>（教出一名优秀的教练）。然后 ACoach 类实现 Coach 接口，ACoachFactory 类实现 CoachFactory 接口；CCoach 类实现 Coach 接口，CCoachFactory 类实现 CoachFactory 接口。当需要 A 级教练时，就去找 A 级教练学院；当需要 C 级教练时，就去找 C 级教练学院。</p>
<p>依次类推，我们还可以用 BCoach 类实现 Coach 接口，BCoachFactory 类实现 CoachFactory 接口，从而不断地丰富教练的梯队。</p>
<h4 id="04、抽象类和接口的区别"><a href="#04、抽象类和接口的区别" class="headerlink" title="04、抽象类和接口的区别"></a>04、抽象类和接口的区别</h4><p>简单总结一下抽象类和接口的区别。</p>
<p>在 Java 中，通过关键字 <code>abstract</code> 定义的类叫做抽象类。Java 是一门面向对象的语言，因此所有的对象都是通过类来描述的；但反过来，并不是所有的类都是用来描述对象的，抽象类就是其中的一种。</p>
<p>以下示例展示了一个简单的抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 个人认为，一名教练必须攻守兼备</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coach</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">defend</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，有抽象方法的类被称为抽象类，也就意味着抽象类中还能有不是抽象方法的方法。这样的类就不能算作纯粹的接口，尽管它也可以提供接口的功能——只能说抽象类是普通类与接口之间的一种中庸之道。</p>
<p><strong>接口（英文：Interface），在 Java 中是一个抽象类型，是抽象方法的集合</strong>；接口通过关键字 <code>interface</code> 来定义。接口与抽象类的不同之处在于：</p>
<ul>
<li>1、抽象类可以有方法体的方法，但接口没有（Java 8 以前）。</li>
<li>2、接口中的成员变量隐式为 <code>static final</code>，但抽象类不是的。</li>
<li>3、一个类可以实现多个接口，但只能继承一个抽象类。</li>
</ul>
<p>以下示例展示了一个简单的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隐式的abstract</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Coach</span> &#123;</span><br><span class="line">	<span class="comment">// 隐式的public</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">defend</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">attack</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接口是隐式抽象的，所以声明时没有必要使用 <code>abstract</code> 关键字；</li>
<li>接口的每个方法都是隐式抽象的，所以同样不需要使用 <code>abstract</code> 关键字；</li>
<li>接口中的方法都是隐式 <code>public</code> 的。</li>
</ul>
<h5 id="1）语法层面上"><a href="#1）语法层面上" class="headerlink" title="1）语法层面上"></a>1）语法层面上</h5><ul>
<li>抽象类可以提供成员方法的实现细节，而接口中只能存在 public abstract 方法；</li>
<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的；</li>
<li>接口中不能含有静态代码块，而抽象类可以有静态代码块；</li>
<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
</ul>
<h5 id="2）设计层面上"><a href="#2）设计层面上" class="headerlink" title="2）设计层面上"></a>2）设计层面上</h5><p>抽象类是对一种事物的抽象，即对类抽象，继承抽象类的子类和抽象类本身是一种 <code>is-a</code> 的关系。而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。</p>
<p>举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类 Airplane，将鸟设计为一个类 Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。</p>
<p>此时可以将 飞行 设计为一个接口 Fly，包含方法 fly()，然后 Airplane 和 Bird 分别根据自己的需要实现 Fly 这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承 Airplane 即可，对于鸟也是类似的，不同种类的鸟直接继承 Bird 类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p>
<p>接口是对类的某种行为的一种抽象，接口和类之间并没有很强的关联关系，举个例子来说，所有的类都可以实现 <code>Serializable</code> 接口，从而具有序列化的功能，但不能说所有的类和 Serializable 之间是 <code>is-a</code> 的关系。</p>
<p>抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过 ppt 里面的模板，如果用模板 A 设计了 ppt B 和 ppt C，ppt B 和 ppt C 公共的部分就是模板 A 了，如果它们的公共部分需要改动，则只需要改动模板 A 就可以了，不需要重新对 ppt B 和 ppt C 进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>
<p>简单的来说，接口就是一个规范。也是在以后多人协作创作项目的时候所使用的。</p>
<p>这个和抽象非常的类似。那他们之间有什么区别的呢。</p>
<p>简单的来说，接口是多继承的。</p>
<p>而抽象是单继承的。所以，接口就是一种规则。</p>
<p>下面我们来写一个案例，来巩固这个操作</p>
<h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406746.png" alt="image-20230616222313161"></p>
<p>首先我们话一个图帮助我们来理解</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406859.png" alt="image-20230616222323833"></p>
<p>之后开始我们的代码实现吧。</p>
<p>先看父类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a12;</span><br><span class="line"><span class="comment">//因为创建人对象是没有意义的，所以就把她写成一个抽象的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span>  <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> age</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后再看接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a12;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 〈功能概述〉&lt;br&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>:Lenovo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2022/12/23 16:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">English</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">speakEnglish</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后再看子类。</p>
<p>先是俩个定义了抽象的子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coach</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Coach</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Coach</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Sporter</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sporter</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Sporter</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后是她们的子类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasketballCoach</span> <span class="keyword">extends</span> <span class="title class_">Coach</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;篮球教练在教如何打篮球&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BasketballCoach</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BasketballCoach</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseketballSprot</span> <span class="keyword">extends</span> <span class="title class_">Sporter</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;篮球运动员在学习如何打篮球&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseketballSprot</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BaseketballSprot</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PingPangCoach</span> <span class="keyword">extends</span> <span class="title class_">Coach</span> <span class="keyword">implements</span> <span class="title class_">English</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;乒乓球教练在教如何打乒乓球&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speakEnglish</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;乒乓球教练学习说英语&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PingPangCoach</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PingPangCoach</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PingPangSport</span> <span class="keyword">extends</span> <span class="title class_">Sporter</span> <span class="keyword">implements</span> <span class="title class_">English</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speakEnglish</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;乒乓球运动员在说英语&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;乒乓球运动员在学习如何打乒乓球&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PingPangSport</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PingPangSport</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后是我们的test类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 面向对象进阶.a12;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        PingPangCoach ppc=<span class="keyword">new</span> <span class="title class_">PingPangCoach</span>(<span class="string">&quot;你好&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        ppc.speakEnglish();</span><br><span class="line">        ppc.teach();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406957.png" alt="image-20230616222514213"></p>
<p>在接口中，可以定义<code>default</code>方法。例如，把<code>Person</code>接口的<code>run()</code>方法改为<code>default</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Xiao Ming&quot;</span>);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; run&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现类可以不必覆写<code>default</code>方法。<code>default</code>方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
<p><code>default</code>方法和抽象类的普通方法是有所不同的。因为<code>interface</code>没有字段，<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p>
<h2 id="java内部类"><a href="#java内部类" class="headerlink" title="java内部类"></a>java内部类</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406141.png" alt="image-20230616222830270"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406211.png" alt="image-20230616222844663"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406333.png" alt="image-20230616222853446"></p>
<p>一般来说，内部类分为成员内部类、局部内部类、匿名内部类和静态内部类。”</p>
<h4 id="1）成员内部类"><a href="#1）成员内部类" class="headerlink" title="1）成员内部类"></a><strong>1）成员内部类</strong></h4><p>成员内部类是最常见的内部类，看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Wanger</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Wangxiaoer</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">81</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来内部类 Wangxiaoer 就好像 Wanger 的一个成员，成员内部类可以无限制访问外部类的所有成员属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wanger</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小u&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Wangxiaoer</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">81</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类可以随心所欲地访问外部类的成员，但外部类想要访问内部类的成员，就不那么容易了，必须先创建一个成员内部类的对象，再通过这个对象来访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wanger</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小u&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Wanger</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Wangxiaoer</span>().print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Wangxiaoer</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">81</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也就意味着，如果想要在静态方法中访问成员内部类的时候，就必须先得创建一个外部类的对象，因为内部类是依附于外部类的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wanger</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小u&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Wanger</span> <span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Wangxiaoer</span>().print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Wanger</span> <span class="variable">wanger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wanger</span>();</span><br><span class="line">        <span class="type">Wangxiaoer</span> <span class="variable">xiaoer</span> <span class="operator">=</span> wanger.<span class="keyword">new</span> <span class="title class_">Wangxiaoer</span>();</span><br><span class="line">        xiaoer.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Wangxiaoer</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">81</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">            System.out.println(money);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种创建内部类的方式在实际开发中并不常用，因为内部类和外部类紧紧地绑定在一起，使用起来非常不便。</p>
<h4 id="2）局部内部类"><a href="#2）局部内部类" class="headerlink" title="2）局部内部类"></a><strong>2）局部内部类</strong></h4><p>局部内部类是定义在一个方法或者一个作用域里面的类，所以局部内部类的生命周期仅限于作用域内。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wangsan</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Wangsan <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Wangxiaosan</span> <span class="keyword">extends</span> <span class="title class_">Wangsan</span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Wangxiaosan</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>局部内部类就好像一个局部变量一样，它是不能被权限修饰符修饰的，比如说 public、protected、private 和 static 等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406388.png" alt="img"></p>
<h4 id="3）匿名内部类"><a href="#3）匿名内部类" class="headerlink" title="3）匿名内部类"></a><strong>3）匿名内部类</strong></h4><p>匿名内部类是我们平常用得最多的，尤其是启动多线程的时候，会经常用到，并且 IDE 也会帮我们自动生成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类就好像一个方法的参数一样，用完就没了，以至于我们都不需要为它专门写一个构造方法，它的名字也是由系统自动命名的。仔细观察编译后的字节码文件也可以发现，匿名内部类连名字都不配拥有，哈哈，直接借用的外部类，然后 <code>$1</code> 就搞定了。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406486.png" alt="img"></p>
<p>匿名内部类是唯一一种没有构造方法的类。就上面的写法来说，匿名内部类也不允许我们为其编写构造方法，因为它就像是直接通过 new 关键字创建出来的一个对象。</p>
<p>匿名内部类的作用主要是用来继承其他类或者实现接口，并不需要增加额外的方法，方便对继承的方法进行实现或者重写。</p>
<h4 id="4）静态内部类"><a href="#4）静态内部类" class="headerlink" title="4）静态内部类"></a><strong>4）静态内部类</strong></h4><p>静态内部类和成员内部类类似，只是多了一个 static 关键字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wangsi</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> money;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Wangxxiaosi</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Wangxxiaosi</span> <span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 static 关键字的存在，静态内部类是不允许访问外部类中非 static 的变量和方法的，这一点也非常好理解：你一个静态的内部类访问我非静态的成员变量干嘛？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406795.png" alt="img"></p>
<p>在《Think in java》中有这样一句话：</p>
<blockquote>
<p>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。</p>
</blockquote>
<p>在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。</p>
<p>使用内部类还能够为我们带来如下特性：</p>
<ul>
<li>1、内部类可以使用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。</li>
<li>2、在单个外部类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。</li>
<li>3、创建内部类对象的时刻并不依赖于外部类对象的创建。</li>
<li>4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。</li>
<li>5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。</li>
</ul>
<h2 id="java关键字this和super"><a href="#java关键字this和super" class="headerlink" title="java关键字this和super"></a>java关键字this和super</h2><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this 关键字有很多种用法，其中最常用的一个是，它可以作为引用变量，指向当前对象。</p>
<p>除此之外， this 关键字还可以完成以下工作。</p>
<ul>
<li>调用当前类的方法；</li>
<li><code>this()</code> 可以调用当前类的构造方法；</li>
<li>this 可以作为参数在方法中传递；</li>
<li>this 可以作为参数在构造方法中传递；</li>
<li>this 可以作为方法的返回值，返回当前类的对象</li>
</ul>
<h4 id="01、-指向当前对象"><a href="#01、-指向当前对象" class="headerlink" title="01、 指向当前对象"></a>01、 指向当前对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WithoutThisStudent</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    WithoutThisStudent(String name, <span class="type">int</span> age) &#123;</span><br><span class="line">        name = name;</span><br><span class="line">        age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot; &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WithoutThisStudent</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WithoutThisStudent</span>(<span class="string">&quot;xiaou&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">WithoutThisStudent</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WithoutThisStudent</span>(<span class="string">&quot;xiaou&quot;</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        s1.out();</span><br><span class="line">        s2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，构造方法的参数名和实例变量名相同，由于没有使用 this 关键字，所以无法为实例变量赋值。</p>
<p>下面来看输出的结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> <span class="number">0</span></span><br><span class="line"><span class="literal">null</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>从结果中可以看得出来，尽管创建对象的时候传递了参数，但实例变量并没有赋值。这是因为如果构造方法中没有使用 this 关键字的话，name 和 age 指向的并不是实例变量而是参数本身。</p>
<p>所以当我们在构造函数中，加上this，就可以了。</p>
<p>这次，实例变量有值了，在构造方法中，<code>this.xxx</code> 指向的就是实例变量，而不再是参数本身了。”我慢吞吞地说着，“当然了，如果参数名和实例变量名不同的话，就不必使用 this 关键字，但我建议使用 this 关键字，这样的代码更有意义。</p>
<h4 id="02、调用当前类的方法"><a href="#02、调用当前类的方法" class="headerlink" title="02、调用当前类的方法"></a>02、调用当前类的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvokeCurrentClassMethod</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokeCurrentClassMethod</span>().method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们来看这个代码，可以发现并没有this这个关键字，但是在我们的反编译字节码文件中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvokeCurrentClassMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">InvokeCurrentClassMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.method1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">InvokeCurrentClassMethod</span>()).method1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>出现了this</p>
<p>我们可以在一个类中使用 this 关键字来调用另外一个方法，如果没有使用的话，编译器会自动帮我们加上。“在源代码中，<code>method2()</code> 在调用 <code>method1()</code> 的时候并没有使用 this 关键字，但通过反编译后的字节码可以看得到</p>
<h4 id="03、调用当前类的构造方法"><a href="#03、调用当前类的构造方法" class="headerlink" title="03、调用当前类的构造方法"></a>03、调用当前类的构造方法</h4><p>“再来看下面这段代码。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvokeConstrutor</span> &#123;</span><br><span class="line">    InvokeConstrutor() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InvokeConstrutor(<span class="type">int</span> count) &#123;</span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InvokeConstrutor</span> <span class="variable">invokeConstrutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokeConstrutor</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“在有参构造方法 <code>InvokeConstrutor(int count)</code> 中，使用了 <code>this()</code> 来调用无参构造方法 <code>InvokeConstrutor()</code></p>
<p><code>this()</code> 可用于调用当前类的构造方法——构造方法可以重用了。”</p>
<p>“来看一下输出结果。”</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>同样的也可以在无参构造方法中使用 <code>this()</code> 并传递参数来调用有参构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvokeParamConstrutor</span> &#123;</span><br><span class="line">    InvokeParamConstrutor() &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InvokeParamConstrutor(<span class="type">int</span> count) &#123;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">InvokeParamConstrutor</span> <span class="variable">invokeConstrutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokeParamConstrutor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面再来看一个输出结果</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>“不过，需要注意的是，<code>this()</code> 必须放在构造方法的第一行，否则就报错了。”</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406854.png" alt="img"></p>
<h4 id="04、作为参数在方法中传递"><a href="#04、作为参数在方法中传递" class="headerlink" title="04、作为参数在方法中传递"></a>04、作为参数在方法中传递</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisAsParam</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(ThisAsParam p)</span> &#123;</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        method1(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThisAsParam</span> <span class="variable">thisAsParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThisAsParam</span>();</span><br><span class="line">        System.out.println(thisAsParam);</span><br><span class="line">        thisAsParam.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看上面的这个代码，“<code>this</code> 关键字可以作为参数在方法中传递，此时，它指向的是当前类的对象。</p>
<p>再看一下输出结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.itwanger.twentyseven.ThisAsParam@<span class="number">77459877</span></span><br><span class="line">com.itwanger.twentyseven.ThisAsParam@<span class="number">77459877</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>“<code>method2()</code> 调用了 <code>method1()</code>，并传递了参数 this，<code>method1()</code> 中打印了当前对象的字符串。 <code>main()</code> 方法中打印了 thisAsParam 对象的字符串。从输出结果中可以看得出来，两者是同一个对象。”</p>
<h4 id="05、作为参数在构造方法中传递"><a href="#05、作为参数在构造方法中传递" class="headerlink" title="05、作为参数在构造方法中传递"></a>05、作为参数在构造方法中传递</h4><p>“继续来看代码。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisAsConstrutorParam</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    ThisAsConstrutorParam() &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>(<span class="built_in">this</span>);</span><br><span class="line">        data.out();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThisAsConstrutorParam</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    ThisAsConstrutorParam param;</span><br><span class="line">    Data(ThisAsConstrutorParam param) &#123;</span><br><span class="line">        <span class="built_in">this</span>.param = param;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(param.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“在构造方法 <code>ThisAsConstrutorParam()</code> 中，我们使用 this 关键字作为参数传递给了 Data 对象，它其实指向的就是 <code>new ThisAsConstrutorParam()</code> 这个对象。”</p>
<p>“<code>this</code> 关键字也可以作为参数在构造方法中传递，它指向的是当前类的对象。当我们需要在多个类中使用一个对象的时候，这非常有用。”</p>
<p>“来看一下输出结果。”</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>

<h4 id="06、作为方法的返回值"><a href="#06、作为方法的返回值" class="headerlink" title="06、作为方法的返回值"></a>06、作为方法的返回值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThisAsMethodResult</span> &#123;</span><br><span class="line">    ThisAsMethodResult <span class="title function_">getThisAsMethodResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ThisAsMethodResult</span>().getThisAsMethodResult().out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>“<code>getThisAsMethodResult()</code> 方法返回了 this 关键字，指向的就是 <code>new ThisAsMethodResult()</code> 这个对象，所以可以紧接着调用 <code>out()</code> 方法——达到了链式调用的目的，这也是 this 关键字非常经典的一种用法。”</p>
<p>“来看一下输出结果。”</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure>

<h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>“super 关键字的用法主要有三种。”</p>
<ul>
<li>指向父类对象；</li>
<li>调用父类的方法；</li>
<li><code>super()</code> 可以调用父类的构造方法。</li>
</ul>
<p>其实和 this 有些相似，只不过用意不大相同,每当创建一个子类对象的时候，也会隐式的创建父类对象，由 super 关键字引用</p>
<p>如果父类和子类拥有同样名称的字段，super 关键字可以用来访问父类的同名字段</p>
<p>例如如下的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferParentField</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Dog</span>().printColor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> <span class="string">&quot;白色&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">color</span> <span class="operator">=</span> <span class="string">&quot;黑色&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">printColor</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(color);</span><br><span class="line">        System.out.println(<span class="built_in">super</span>.color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>“父类 Animal 中有一个名为 color 的字段，子类 Dog 中也有一个名为 color 的字段，子类的 <code>printColor()</code> 方法中，通过 super 关键字可以访问父类的 color。”</p>
<p>“来看一下输出结果。”</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">黑色</span><br><span class="line">白色</span><br></pre></td></tr></table></figure>

<p>“当子类和父类的方法名相同时，可以使用 super 关键字来调用父类的方法。换句话说，super 关键字可以用于方法重写时访问到父类的方法。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferParentMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Dog</span>().work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汪汪汪...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.eat();</span><br><span class="line">        bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>父类 Animal 和子类 Dog 中都有一个名为 <code>eat()</code> 的方法，通过 <code>super.eat()</code> 可以访问到父类的 <code>eat()</code> 方法</p>
<p>再看这个代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferParentConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    Animal()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物来了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    Dog() &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗来了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>“子类 Dog 的构造方法中，第一行代码为 <code>super()</code>，它就是用来调用父类的构造方法的。”</p>
<p>“来看一下输出结果。”</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">动物来了</span><br><span class="line">狗狗来了</span><br></pre></td></tr></table></figure>

<p>“当然了，在默认情况下，<code>super()</code> 是可以省略的，编译器会主动去调用父类的构造方法。也就是说，子类即使不使用 <code>super()</code> 主动调用父类的构造方法，父类的构造方法仍然会先执行。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferParentConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    Animal()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物来了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    Dog() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗狗来了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“输出结果和之前一样。”</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">动物来了</span><br><span class="line">狗狗来了</span><br></pre></td></tr></table></figure>

<p>“<code>super()</code> 也可以用来调用父类的有参构造方法，这样可以提高代码的可重用性。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Person(<span class="type">int</span> id, String name) &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Emp</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">float</span> salary;</span><br><span class="line"></span><br><span class="line">    Emp(<span class="type">int</span> id, String name, <span class="type">float</span> salary) &#123;</span><br><span class="line">        <span class="built_in">super</span>(id, name);</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(id + <span class="string">&quot; &quot;</span> + name + <span class="string">&quot; &quot;</span> + salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallParentParamConstrutor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="number">1</span>, <span class="string">&quot;xiaou&quot;</span>, <span class="number">20000f</span>).display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“Emp 类继承了 Person 类，也就继承了 id 和 name 字段，当在 Emp 中新增了 salary 字段后，构造方法中就可以使用 <code>super(id, name)</code> 来调用父类的有参构造方法。”</p>
<p>“来看一下输出结果。”</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 xiaou 20000.0</span><br></pre></td></tr></table></figure>

<h2 id="java-Static关键字"><a href="#java-Static关键字" class="headerlink" title="java Static关键字"></a>java Static关键字</h2><p>“static 是 Java 中比较难以理解的一个关键字，也是各大公司的面试官最喜欢问到的一个知识点之一。”既然是面试重点，那可得好好学习下。</p>
<p>“static 关键字的作用可以用一句话来描述：‘<strong>方便在没有创建对象的情况下进行调用</strong>，包括变量和方法’。也就是说，只要类被加载了，就可以通过类名进行访问。</p>
<h4 id="01、静态变量"><a href="#01、静态变量" class="headerlink" title="01、静态变量"></a>01、静态变量</h4><p>“如果在声明变量的时候使用了 static 关键字，那么这个变量就被称为静态变量。静态变量只在类加载的时候获取一次内存空间，这使得静态变量很节省内存空间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">String</span> <span class="variable">school</span> <span class="operator">=</span> <span class="string">&quot;郑州大学&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设郑州大学录取了一万名新生，那么在创建一万个 Student 对象的时候，所有的字段（name、age 和 school）都会获取到一块内存。学生的姓名和年纪不尽相同，但都属于郑州大学，如果每创建一个对象，school 这个字段都要占用一块内存的话，就很浪费，对吧？</p>
<p>“因此，最好将 school 这个字段设置为 static，这样就只会占用一块内存，而不是一万块。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">school</span> <span class="operator">=</span> <span class="string">&quot;郑州大学&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;xiaou&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;xiaou&quot;</span>, <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中我们定义的别的变量都在堆内存，但是只有static定义的是再我们的你静态区域里。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Counter() &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">        <span class="type">Counter</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“我们创建一个成员变量 count，并且在构造函数中让它自增。因为成员变量会在创建对象的时候获取内存，因此每一个对象都会有一个 count 的副本， count 的值并不会随着对象的增多而递增。”</p>
<p>我们来看他的结果</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>每创建一个 Counter 对象，count 的值就从 0 自增到 1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticCounter</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    StaticCounter() &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">StaticCounter</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticCounter</span>();</span><br><span class="line">        <span class="type">StaticCounter</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticCounter</span>();</span><br><span class="line">        <span class="type">StaticCounter</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticCounter</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“来看一下输出结果。”</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>“简单解释一下哈，由于静态变量只会获取一次内存空间，所以任何对象对它的修改都会得到保留，所以每创建一个对象，count 的值就会加 1，所以最终的结果是 3”</p>
<p>“另外，需要注意的是，由于静态变量属于一个类，所以不要通过对象引用来访问，而应该直接通过类名来访问，否则编译器会发出警告。”</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406909.png" alt="img"></p>
<h4 id="02、静态方法"><a href="#02、静态方法" class="headerlink" title="02、静态方法"></a>02、静态方法</h4><p>“静态方法有以下这些特征。”</p>
<ul>
<li>静态方法属于这个类而不是这个类的对象；</li>
<li>调用静态方法的时候不需要创建这个类的对象；</li>
<li>静态方法可以访问静态变量。</li>
</ul>
<p>“来，继续上代码”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticMethodStudent</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">school</span> <span class="operator">=</span> <span class="string">&quot;郑州大学&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StaticMethodStudent</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">()</span> &#123;</span><br><span class="line">        school = <span class="string">&quot;河南大学&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">out</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; &quot;</span> + age + <span class="string">&quot; &quot;</span> + school);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        StaticMethodStudent.change();</span><br><span class="line">        </span><br><span class="line">        <span class="type">StaticMethodStudent</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticMethodStudent</span>(<span class="string">&quot;xiaou&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="type">StaticMethodStudent</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticMethodStudent</span>(<span class="string">&quot;xiaou&quot;</span>, <span class="number">16</span>);</span><br><span class="line">        </span><br><span class="line">        s1.out();</span><br><span class="line">        s2.out();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“<code>change()</code> 方法就是一个静态方法，所以它可以直接访问静态变量 school，把它的值更改为河南大学；并且，可以通过类名直接调用 <code>change()</code> 方法，就像 <code>StaticMethodStudent.change()</code> 这样。”</p>
<p>“来看一下程序的输出结果吧。”</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xiaou 18 河南大学</span><br><span class="line">xiaou 16 河南大学</span><br></pre></td></tr></table></figure>

<p>“需要注意的是，静态方法不能访问非静态变量和调用非静态方法。我稍微改动一下代码，编译器就会报错。”</p>
<p>“先是在静态方法中访问非静态变量，编译器不允许。”</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406980.png" alt="img"></p>
<p>“然后在静态方法中访问非静态方法，编译器同样不允许。”</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406041.png" alt="img"></p>
<p>为什么 main 方法是静态的？</p>
<p>“如果 main 方法不是静态的，就意味着 Java 虚拟机在执行的时候需要先创建一个对象才能调用 main 方法，而 main 方法作为程序的入口，创建一个额外的对象显得非常多余。”</p>
<p>“java.lang.Math 类的几乎所有方法都是静态的，可以直接通过类名来调用，不需要创建类的对象。”</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406482.png" alt="img"></p>
<h4 id="03、静态代码块"><a href="#03、静态代码块" class="headerlink" title="03、静态代码块"></a>03、静态代码块</h4><p>“就像下面这串代码。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticBlock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“静态代码块通常用来初始化一些静态变量，它会优先于 <code>main()</code> 方法执行。”</p>
<p>“来看一下程序的输出结果吧。”</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">静态代码块</span><br><span class="line">main 方法</span><br></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticBlockNoMain</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块，没有 main&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“在命令行中执行 <code>java StaticBlockNoMain</code> 的时候，会抛出 NoClassDefFoundError 的错误。”</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202308071406556.png" alt="img"></p>
<h4 id="04、静态内部类"><a href="#04、静态内部类" class="headerlink" title="04、静态内部类"></a>04、静态内部类</h4><p>“常见的内部类有四种，成员内部类、局部内部类、匿名内部类和静态内部类，限于篇幅原因，前三种不在我们本次的讨论范围之内，以后有机会再细说。”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>“第一次加载 Singleton 类时并不会初始化 instance，只有第一次调用 <code>getInstance()</code> 方法时 Java 虚拟机才开始加载 SingletonHolder 并初始化 instance，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。不过，创建单例更优雅的一种方式是使用枚举，以后再讲给你听。”</p>
<p>“需要注意的是。第一，静态内部类不能访问外部类的所有成员变量；第二，静态内部类可以访问外部类的所有静态变量，包括私有静态变量。第三，外部类不能声明为 static。”</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">小u</div><div class="post-copyright__author_desc">热爱可抵岁月漫长</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2023/10/01/codenotes/Java/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2023/10/01/codenotes/Java/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/')">java面向对象</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816229.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300816224.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2023/10/01/codenotes/Java/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=java面向对象&amp;url=http://example.com/2023/10/01/codenotes/Java/java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/java/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>java<span class="tagsPageCount">12</span></a><a class="post-meta__box__tags" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>面向对象<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/10/01/codenotes/Java/spring6/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Spring6</div></div></a></div><div class="next-post pull-right"><a href="/2023/10/01/codenotes/Java/JDK%E6%96%B0%E7%89%B9%E6%80%A7/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">JDK9~JDK17新特性</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/10/01/codenotes/Java/JDK%E6%96%B0%E7%89%B9%E6%80%A7/" title="JDK9~JDK17新特性"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">JDK9~JDK17新特性</div></div></a></div><div><a href="/2023/10/01/codenotes/Java/java%E5%9F%BA%E7%A1%80/" title="java基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">java基础</div></div></a></div><div><a href="/2023/10/01/codenotes/Java/spring6/" title="Spring6"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">Spring6</div></div></a></div><div><a href="/2023/10/01/codenotes/other/clean-code/" title="《代码整洁之道》"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">《代码整洁之道》</div></div></a></div><div><a href="/2023/10/01/codenotes/other/effective-coding/" title="《Effective Coding——阿里巴巴 Java 开发手册》"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">《Effective Coding——阿里巴巴 Java 开发手册》</div></div></a></div><div><a href="/2023/10/01/projects/zatan/8/1/" title="JavaBean和封装之间的关系"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-01</div><div class="title">JavaBean和封装之间的关系</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://xiaou-1305448902.cos.ap-nanjing.myqcloud.com/img/202309300844043.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" ait="status"/></div></div><div class="author-info__description">Java,java,springboot,mysql,redis,教程,git,软件,编程,开发,互联网,Java 基础,Java 教程,Java程序员进阶之路,Java 入门,Vue,前端,算法</div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎来看我的博客 博客主地址：http://blog.xiaou61.top/  备用地址：https://newblog.guoyaxue.top/</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">什么是面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="toc-number">2.0.1.</span> <span class="toc-text">什么是面向过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-1"><span class="toc-number">2.0.2.</span> <span class="toc-text">什么是面向对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.1.</span> <span class="toc-text">new一个对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.2.</span> <span class="toc-text">初始化对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%EF%BC%9A%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E3%80%82"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">第一种：通过对象的引用变量。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%EF%BC%9A%E9%80%9A%E8%BF%87%E6%96%B9%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">第二种：通过方法初始化。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D%EF%BC%9A%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82"><span class="toc-number">3.2.0.3.</span> <span class="toc-text">第三种：通过构造方法初始化。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.3.</span> <span class="toc-text">关于对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E6%8A%BD%E8%B1%A1%E7%9A%84%E5%8E%86%E7%A8%8B"><span class="toc-number">3.3.0.1.</span> <span class="toc-text">1）抽象的历程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E5%AF%B9%E8%B1%A1%E5%85%B7%E6%9C%89%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.3.0.2.</span> <span class="toc-text">2）对象具有接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.3.0.3.</span> <span class="toc-text">3）访问权限修饰符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%EF%BC%89%E7%BB%84%E5%90%88"><span class="toc-number">3.3.0.4.</span> <span class="toc-text">4）组合</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81"><span class="toc-number">4.</span> <span class="toc-text">面向对象三大基本特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85-Encapsulation"><span class="toc-number">4.1.</span> <span class="toc-text">封装(Encapsulation)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-Inheritance"><span class="toc-number">4.2.</span> <span class="toc-text">继承(Inheritance)]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BB%A7%E6%89%BF"><span class="toc-number">4.2.1.</span> <span class="toc-text">单继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">4.2.2.</span> <span class="toc-text">多继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">4.2.3.</span> <span class="toc-text">如何实现继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#extends-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">extends 关键字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#implements-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.2.3.2.</span> <span class="toc-text">implements 关键字</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">4.2.4.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81-Polymorphism"><span class="toc-number">4.3.</span> <span class="toc-text">多态(Polymorphism)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#01%E3%80%81%E5%A4%9A%E6%80%81%E4%B8%8E%E5%90%8E%E6%9C%9F%E7%BB%91%E5%AE%9A"><span class="toc-number">4.3.0.1.</span> <span class="toc-text">01、多态与后期绑定</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#02%E3%80%81%E5%A4%9A%E6%80%81%E4%B8%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.0.2.</span> <span class="toc-text">02、多态与构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#03%E3%80%81%E5%A4%9A%E6%80%81%E4%B8%8E%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">4.3.0.3.</span> <span class="toc-text">03、多态与向下转型</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%94%E5%A4%A7%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">5.</span> <span class="toc-text">面向对象的五大基本原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%EF%BC%88single-responsibility-principle%EF%BC%89"><span class="toc-number">5.0.1.</span> <span class="toc-text">单一职责原（single-responsibility-principle）)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%94%BE%E5%B0%81%E9%97%AD%E5%8E%9F%E5%88%99%EF%BC%88Open-Closed-principle"><span class="toc-number">5.0.2.</span> <span class="toc-text">开放封闭原则（Open-Closed principle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%88Liskov-Substitution-Principle"><span class="toc-number">5.0.3.</span> <span class="toc-text">里氏替换原则（Liskov-Substitution Principle]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99%EF%BC%88Dependecy-Inversion-Principle%EF%BC%89"><span class="toc-number">5.0.4.</span> <span class="toc-text">依赖倒置原则（Dependecy-Inversion Principle）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99%EF%BC%88Interface-Segregation-Principle%EF%BC%89"><span class="toc-number">5.0.5.</span> <span class="toc-text">接口隔离原则（Interface-Segregation Principle）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">6.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84%E5%8C%85"><span class="toc-number">7.</span> <span class="toc-text">java中的包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">7.0.1.</span> <span class="toc-text">包的作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%8C%85"><span class="toc-number">7.0.2.</span> <span class="toc-text">导入包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">7.0.3.</span> <span class="toc-text">包的最佳实践</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">8.</span> <span class="toc-text">java中的变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#01%E3%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">8.0.1.</span> <span class="toc-text">01、局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#02%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">8.0.2.</span> <span class="toc-text">02、成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#03%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">8.0.3.</span> <span class="toc-text">03、静态变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#04%E3%80%81%E5%B8%B8%E9%87%8F"><span class="toc-number">8.0.4.</span> <span class="toc-text">04、常量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">java中的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#01%E3%80%81Java%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">9.0.1.</span> <span class="toc-text">01、Java中的方法是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#02%E3%80%81%E5%A6%82%E4%BD%95%E5%A3%B0%E6%98%8E%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">9.0.2.</span> <span class="toc-text">02、如何声明方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#03%E3%80%81%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">9.0.3.</span> <span class="toc-text">03、方法有哪几种？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E9%A2%84%E5%85%88%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="toc-number">9.0.3.1.</span> <span class="toc-text">1）预先定义方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="toc-number">9.0.3.2.</span> <span class="toc-text">2）用户自定义方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#04%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">9.0.4.</span> <span class="toc-text">04、什么是实例方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#05%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">9.0.5.</span> <span class="toc-text">05、什么是静态方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#06%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">9.0.6.</span> <span class="toc-text">06、什么是抽象方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#07%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD"><span class="toc-number">9.0.7.</span> <span class="toc-text">07、方法重写与重载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#javq%E5%AE%9E%E7%8E%B0%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E6%80%A7"><span class="toc-number">10.</span> <span class="toc-text">javq实现平台无关性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E6%80%A7"><span class="toc-number">10.0.1.</span> <span class="toc-text">什么是平台无关性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E6%80%A7%E5%A5%BD%E5%A4%84"><span class="toc-number">10.0.1.1.</span> <span class="toc-text">平台无关性好处</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E5%8F%B0%E6%97%A0%E5%85%B3%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.0.2.</span> <span class="toc-text">平台无关性的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%9F%BA%E7%A1%80"><span class="toc-number">10.0.2.1.</span> <span class="toc-text">编译原理基础</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E7%A0%81"><span class="toc-number">10.0.2.2.</span> <span class="toc-text">字节码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83"><span class="toc-number">10.0.2.3.</span> <span class="toc-text">Java语言规范</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">10.0.3.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E6%97%A0%E5%85%B3%E6%80%A7"><span class="toc-number">10.0.4.</span> <span class="toc-text">语言无关性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">11.</span> <span class="toc-text">Java可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-native%E6%96%B9%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">java native方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81JNI%EF%BC%9AJava-Native-Interface"><span class="toc-number">12.0.1.</span> <span class="toc-text">1、JNI：Java Native Interface</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E7%94%A8-C-%E8%AF%AD%E8%A8%80%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95"><span class="toc-number">12.0.2.</span> <span class="toc-text">2、用 C 语言编写程序本地方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#01%EF%BC%89%E7%BC%96%E5%86%99%E5%B8%A6%E6%9C%89-native-%E6%96%B9%E6%B3%95%E7%9A%84-Java-%E7%B1%BB-HelloJNI-java"><span class="toc-number">12.0.2.1.</span> <span class="toc-text">01）编写带有 native 方法的 Java 类 HelloJNI.java</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#02%EF%BC%89%E7%BC%96%E8%AF%91-HelloJNI-java"><span class="toc-number">12.0.2.2.</span> <span class="toc-text">02）编译 HelloJNI.java</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#03%EF%BC%89%E4%BD%BF%E7%94%A8-javah-jni-HelloJNI-%E7%94%9F%E6%88%90%E6%89%A9%E5%B1%95%E5%90%8D%E4%B8%BA-h-%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">12.0.2.3.</span> <span class="toc-text">03）使用 javah -jni HelloJNI 生成扩展名为 h 的头文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#04%EF%BC%89%E4%BD%BF%E7%94%A8-C-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95"><span class="toc-number">12.0.2.4.</span> <span class="toc-text">04）使用 C 语言实现本地方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#05%EF%BC%89%E7%BC%96%E5%86%99%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC-compile-shopen-in-new-window"><span class="toc-number">12.0.2.5.</span> <span class="toc-text">05）编写编译脚本 compile.shopen in new window</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#06%EF%BC%89%E6%89%A7%E8%A1%8C%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC"><span class="toc-number">12.0.2.6.</span> <span class="toc-text">06）执行编译脚本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#07%EF%BC%89%E8%BF%90%E8%A1%8C-HelloJNI"><span class="toc-number">12.0.2.7.</span> <span class="toc-text">07）运行 HelloJNI</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81JNI-%E8%B0%83%E7%94%A8-C-%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">12.0.3.</span> <span class="toc-text">3、JNI 调用 C 的流程图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81native-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">12.0.4.</span> <span class="toc-text">4、native 关键字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">java的构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#01%E3%80%81%E5%88%9B%E5%BB%BA%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">13.0.1.</span> <span class="toc-text">01、创建构造方法的规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#02%E3%80%81%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">13.0.2.</span> <span class="toc-text">02、默认构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">13.0.3.</span> <span class="toc-text">3、有参构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#04%E3%80%81%E9%87%8D%E8%BD%BD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">13.0.4.</span> <span class="toc-text">04、重载构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#05%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.0.5.</span> <span class="toc-text">05、构造方法和方法的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#06%E3%80%81%E5%A4%8D%E5%88%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.0.6.</span> <span class="toc-text">06、复制对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E9%80%9A%E8%BF%87%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">13.0.6.1.</span> <span class="toc-text">1）通过构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%80%BC"><span class="toc-number">13.0.6.2.</span> <span class="toc-text">2）通过对象的值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E9%80%9A%E8%BF%87-Object-%E7%B1%BB%E7%9A%84-clone-%E6%96%B9%E6%B3%95"><span class="toc-number">13.0.6.3.</span> <span class="toc-text">3）通过 Object 类的 clone() 方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">14.</span> <span class="toc-text">Java访问权限修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-number">14.0.1.</span> <span class="toc-text">1. 修饰类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95%E5%92%8C%E5%8F%98%E9%87%8F"><span class="toc-number">14.0.2.</span> <span class="toc-text">2. 修饰方法和变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%88%9D%E5%A7%8B%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">15.</span> <span class="toc-text">java初始代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">16.</span> <span class="toc-text">java抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#01%E3%80%81%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">16.0.1.</span> <span class="toc-text">01、定义抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#02%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">16.0.2.</span> <span class="toc-text">02、抽象类的特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#03%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">16.0.3.</span> <span class="toc-text">03、抽象类的应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#01%EF%BC%89%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%9C%BA%E6%99%AF"><span class="toc-number">16.0.3.1.</span> <span class="toc-text">01）第一种场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#02%EF%BC%89%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%9C%BA%E6%99%AF"><span class="toc-number">16.0.3.2.</span> <span class="toc-text">02）第二种场景</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#04%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%80%BB%E7%BB%93"><span class="toc-number">16.0.4.</span> <span class="toc-text">04、抽象类总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E6%8E%A5%E5%8F%A3"><span class="toc-number">17.</span> <span class="toc-text">java接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-number">17.0.1.</span> <span class="toc-text">术语</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF"><span class="toc-number">17.0.2.</span> <span class="toc-text">接口继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">17.0.3.</span> <span class="toc-text">继承关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#01%E3%80%81%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3"><span class="toc-number">17.0.4.</span> <span class="toc-text">01、定义接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#02%E3%80%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">17.0.5.</span> <span class="toc-text">02、接口的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#03%E3%80%81%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">17.0.6.</span> <span class="toc-text">03、接口的三种模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">17.0.6.1.</span> <span class="toc-text">1）策略模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">17.0.6.2.</span> <span class="toc-text">2）适配器模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%EF%BC%89%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">17.0.6.3.</span> <span class="toc-text">3）工厂模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#04%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">17.0.7.</span> <span class="toc-text">04、抽象类和接口的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%89%E8%AF%AD%E6%B3%95%E5%B1%82%E9%9D%A2%E4%B8%8A"><span class="toc-number">17.0.7.1.</span> <span class="toc-text">1）语法层面上</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%EF%BC%89%E8%AE%BE%E8%AE%A1%E5%B1%82%E9%9D%A2%E4%B8%8A"><span class="toc-number">17.0.7.2.</span> <span class="toc-text">2）设计层面上</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-number">18.</span> <span class="toc-text">案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#default%E6%96%B9%E6%B3%95"><span class="toc-number">19.</span> <span class="toc-text">default方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">20.</span> <span class="toc-text">java内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">20.0.1.</span> <span class="toc-text">1）成员内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">20.0.2.</span> <span class="toc-text">2）局部内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">20.0.3.</span> <span class="toc-text">3）匿名内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">20.0.4.</span> <span class="toc-text">4）静态内部类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java%E5%85%B3%E9%94%AE%E5%AD%97this%E5%92%8Csuper"><span class="toc-number">21.</span> <span class="toc-text">java关键字this和super</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-number">21.1.</span> <span class="toc-text">this</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#01%E3%80%81-%E6%8C%87%E5%90%91%E5%BD%93%E5%89%8D%E5%AF%B9%E8%B1%A1"><span class="toc-number">21.1.1.</span> <span class="toc-text">01、 指向当前对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#02%E3%80%81%E8%B0%83%E7%94%A8%E5%BD%93%E5%89%8D%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">21.1.2.</span> <span class="toc-text">02、调用当前类的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#03%E3%80%81%E8%B0%83%E7%94%A8%E5%BD%93%E5%89%8D%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">21.1.3.</span> <span class="toc-text">03、调用当前类的构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#04%E3%80%81%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BC%A0%E9%80%92"><span class="toc-number">21.1.4.</span> <span class="toc-text">04、作为参数在方法中传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#05%E3%80%81%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E5%9C%A8%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BC%A0%E9%80%92"><span class="toc-number">21.1.5.</span> <span class="toc-text">05、作为参数在构造方法中传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#06%E3%80%81%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">21.1.6.</span> <span class="toc-text">06、作为方法的返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super"><span class="toc-number">21.2.</span> <span class="toc-text">super</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-Static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">22.</span> <span class="toc-text">java Static关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#01%E3%80%81%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">22.0.1.</span> <span class="toc-text">01、静态变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#02%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">22.0.2.</span> <span class="toc-text">02、静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#03%E3%80%81%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">22.0.3.</span> <span class="toc-text">03、静态代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#04%E3%80%81%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">22.0.4.</span> <span class="toc-text">04、静态内部类</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/27/" title="再见 MyBatis-Plus ！">再见 MyBatis-Plus ！</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/26/" title="“人尽皆知”的单例模式">“人尽皆知”的单例模式</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/29/" title="阿里的同事，写的代码真 TMD 优雅！">阿里的同事，写的代码真 TMD 优雅！</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/28/" title="别再用 BeanUtils 了，这款 PO VO DTO 转换神器不香么？">别再用 BeanUtils 了，这款 PO VO DTO 转换神器不香么？</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/08/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%94%B6%E8%97%8F/30/" title="MyBatis过时了吗？">MyBatis过时了吗？</a><time datetime="2023-10-08T12:28:14.000Z" title="Created 2023-10-08 20:28:14">2023-10-08</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2023 By <a class="footer-bar-link" href="/" title="小u" target="_blank">小u</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">Articles</div><div class="length-num">238</div></a><a href="/tags/" title="tag"><div class="headline">Tags</div><div class="length-num">39</div></a><a href="/categories/" title="category"><div class="headline">Categories</div><div class="length-num">50</div></a></div><span class="sidebar-menu-item-title">Function</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="Display Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>Display Mode</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://mydocs.guoyaxue.top/" title="旧版博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="旧版博客"/><span class="back-menu-item-text">旧版博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://pan.xiaou61.top/#/" title="免费网盘"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="免费网盘"/><span class="back-menu-item-text">免费网盘</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://cloud.xiaou61.top/" title="云盘(自用)"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="云盘(自用)"/><span class="back-menu-item-text">云盘(自用)</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://wpzc.xiaou61.top/" title="云盘转存"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="云盘转存"/><span class="back-menu-item-text">云盘转存</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://love.xiaou61.top/#/" title="关于我们(My girlFriend)"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="关于我们(My girlFriend)"/><span class="back-menu-item-text">关于我们(My girlFriend)</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">娱乐项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="http://fxq.xiaou61.top/#/" title="飞行棋"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="飞行棋"/><span class="back-menu-item-text">飞行棋</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/game/sqnwmai803/" title="谁去拿外卖"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="谁去拿外卖"/><span class="back-menu-item-text">谁去拿外卖</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/desktop.html" title="win12网页版"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blogutil-1305448902.cos-website.ap-nanjing.myqcloud.com/win12kymain/win12-main/icon/logo.svg" alt="win12网页版"/><span class="back-menu-item-text">win12网页版</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="http://game.xiaou61.top/" title="在线游戏"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="在线游戏"/><span class="back-menu-item-text">在线游戏</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 开往</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" target="_blank" rel="noopener" href="https://www.travellings.cn/go.html"><span> 开往</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>3</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>1</sup></a><a href="/tags/JVM/" style="font-size: 0.88rem;">JVM<sup>22</sup></a><a href="/tags/Nginx/" style="font-size: 0.88rem;">Nginx<sup>1</sup></a><a href="/tags/Spring/" style="font-size: 0.88rem;">Spring<sup>1</sup></a><a href="/tags/Ts/" style="font-size: 0.88rem;">Ts<sup>1</sup></a><a href="/tags/TypeScript/" style="font-size: 0.88rem;">TypeScript<sup>1</sup></a><a href="/tags/WebApi/" style="font-size: 0.88rem;">WebApi<sup>1</sup></a><a href="/tags/coder1v5/" style="font-size: 0.88rem;">coder1v5<sup>2</sup></a><a href="/tags/css/" style="font-size: 0.88rem;">css<sup>3</sup></a><a href="/tags/java/" style="font-size: 0.88rem;">java<sup>12</sup></a><a href="/tags/javaSE/" style="font-size: 0.88rem;">javaSE<sup>3</sup></a><a href="/tags/javaWeb/" style="font-size: 0.88rem;">javaWeb<sup>2</sup></a><a href="/tags/js%E9%80%86%E5%90%91/" style="font-size: 0.88rem;">js逆向<sup>1</sup></a><a href="/tags/leetcode/" style="font-size: 0.88rem;">leetcode<sup>3</sup></a><a href="/tags/python/" style="font-size: 0.88rem;">python<sup>8</sup></a><a href="/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/" style="font-size: 0.88rem;">书籍推荐<sup>2</sup></a><a href="/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%90%AC%E8%BF%90/" style="font-size: 0.88rem;">公众号搬运<sup>35</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 0.88rem;">前端<sup>10</sup></a><a href="/tags/%E5%8A%9E%E5%85%AC/" style="font-size: 0.88rem;">办公<sup>1</sup></a><a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 0.88rem;">后端<sup>8</sup></a><a href="/tags/%E5%A4%A9%E6%B6%AF%E8%AE%BA%E5%9D%9B/" style="font-size: 0.88rem;">天涯论坛<sup>1</sup></a><a href="/tags/%E5%AF%BC%E8%88%AA/" style="font-size: 0.88rem;">导航<sup>1</sup></a><a href="/tags/%E5%B0%B1%E4%B8%9A/" style="font-size: 0.88rem;">就业<sup>16</sup></a><a href="/tags/%E5%BE%AE%E4%BF%A1/" style="font-size: 0.88rem;">微信<sup>1</sup></a><a href="/tags/%E6%8A%80%E6%9C%AF%E6%9D%82%E8%B0%88/" style="font-size: 0.88rem;">技术杂谈<sup>51</sup></a><a href="/tags/%E6%8E%98%E9%87%91/" style="font-size: 0.88rem;">掘金<sup>14</sup></a><a href="/tags/%E6%9D%82%E9%A1%B9/" style="font-size: 0.88rem;">杂项<sup>1</sup></a><a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 0.88rem;">测试<sup>1</sup></a><a href="/tags/%E6%B8%A1%E4%B8%80%E5%A4%A7%E5%B8%88%E8%AF%BE/" style="font-size: 0.88rem;">渡一大师课<sup>3</sup></a><a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 0.88rem;">爬虫<sup>1</sup></a><a href="/tags/%E7%9B%AE%E5%BD%95/" style="font-size: 0.88rem;">目录<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>4</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 0.88rem;">虚拟机<sup>12</sup></a><a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.88rem;">设计模式<sup>6</sup></a><a href="/tags/%E8%B7%AF%E9%A3%9E%E5%AD%A6%E9%99%A2/" style="font-size: 0.88rem;">路飞学院<sup>3</sup></a><a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 0.88rem;">面向对象<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>51</sup></a><a href="/tags/%E9%A3%9E%E8%A1%8C%E6%A3%8B/" style="font-size: 0.88rem;">飞行棋<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="7409599794" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>